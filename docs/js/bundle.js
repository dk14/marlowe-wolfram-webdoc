/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@noble/hashes/_assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/_assert.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports["default"] = assert;
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/_sha2.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/_sha2.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA2 = void 0;
const _assert_js_1 = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/_assert.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;
//# sourceMappingURL=_sha2.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/crypto.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/crypto.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/ripemd160.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/ripemd160.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "./node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha1.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha1.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha1 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "./node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// SHA1 was cryptographically broken.
// It is still widely used in legacy apps. Don't use it for a new protocol.
// RFC 3174
const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Initial state
const IV = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA1_W = new Uint32Array(80);
class SHA1 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = Chi(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = Maj(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = rotl(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        SHA1_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
exports.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
//# sourceMappingURL=sha1.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha256.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "./node_modules/@noble/hashes/_sha2.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/crypto.js");
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");

var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require2.inspect;

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ "./node_modules/es6-object-assign/index.js").assign);
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require.inspect;

var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');


/***/ }),

/***/ "./node_modules/bigi/lib/bigi.js":
/*!***************************************!*\
  !*** ./node_modules/bigi/lib/bigi.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// (public) Constructor
function BigInteger(a, b, c) {
  if (!(this instanceof BigInteger))
    return new BigInteger(a, b, c)

  if (a != null) {
    if ("number" == typeof a) this.fromNumber(a, b, c)
    else if (b == null && "string" != typeof a) this.fromString(a, 256)
    else this.fromString(a, b)
  }
}

var proto = BigInteger.prototype

// duck-typed isBigInteger
proto.__bigi = (__webpack_require__(/*! ../package.json */ "./node_modules/bigi/package.json").version)
BigInteger.isBigInteger = function (obj, check_ver) {
  return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
}

// Bits per digit
var dbits

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c
    c = Math.floor(v / 0x4000000)
    w[j++] = v & 0x3ffffff
  }
  return c
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
    xh = x >> 15
  while (--n >= 0) {
    var l = this[i] & 0x7fff
    var h = this[i++] >> 15
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30)
    w[j++] = l & 0x3fffffff
  }
  return c
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
    xh = x >> 14
  while (--n >= 0) {
    var l = this[i] & 0x3fff
    var h = this[i++] >> 14
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c
    c = (l >> 28) + (m >> 14) + xh * h
    w[j++] = l & 0xfffffff
  }
  return c
}

// wtf?
BigInteger.prototype.am = am1
dbits = 26

BigInteger.prototype.DB = dbits
BigInteger.prototype.DM = ((1 << dbits) - 1)
var DV = BigInteger.prototype.DV = (1 << dbits)

var BI_FP = 52
BigInteger.prototype.FV = Math.pow(2, BI_FP)
BigInteger.prototype.F1 = BI_FP - dbits
BigInteger.prototype.F2 = 2 * dbits - BI_FP

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
var BI_RC = new Array()
var rr, vv
rr = "0".charCodeAt(0)
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv
rr = "a".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv
rr = "A".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv

function int2char(n) {
  return BI_RM.charAt(n)
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)]
  return (c == null) ? -1 : c
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i]
  r.t = this.t
  r.s = this.s
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1
  this.s = (x < 0) ? -1 : 0
  if (x > 0) this[0] = x
  else if (x < -1) this[0] = x + DV
  else this.t = 0
}

// return bigint initialized to value
function nbv(i) {
  var r = new BigInteger()
  r.fromInt(i)
  return r
}

// (protected) set from string and radix
function bnpFromString(s, b) {
  var self = this

  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else {
    self.fromRadix(s, b)
    return
  }
  self.t = 0
  self.s = 0
  var i = s.length,
    mi = false,
    sh = 0
  while (--i >= 0) {
    var x = (k == 8) ? s[i] & 0xff : intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true
      continue
    }
    mi = false
    if (sh == 0)
      self[self.t++] = x
    else if (sh + k > self.DB) {
      self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh
      self[self.t++] = (x >> (self.DB - sh))
    } else
      self[self.t - 1] |= x << sh
    sh += k
    if (sh >= self.DB) sh -= self.DB
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    self.s = -1
    if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh
  }
  self.clamp()
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s & this.DM
  while (this.t > 0 && this[this.t - 1] == c)--this.t
}

// (public) return string representation in given radix
function bnToString(b) {
  var self = this
  if (self.s < 0) return "-" + self.negate()
    .toString(b)
  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else return self.toRadix(b)
  var km = (1 << k) - 1,
    d, m = false,
    r = "",
    i = self.t
  var p = self.DB - (i * self.DB) % k
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) > 0) {
      m = true
      r = int2char(d)
    }
    while (i >= 0) {
      if (p < k) {
        d = (self[i] & ((1 << p) - 1)) << (k - p)
        d |= self[--i] >> (p += self.DB - k)
      } else {
        d = (self[i] >> (p -= k)) & km
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if (d > 0) m = true
      if (m) r += int2char(d)
    }
  }
  return m ? r : "0"
}

// (public) -this
function bnNegate() {
  var r = new BigInteger()
  BigInteger.ZERO.subTo(this, r)
  return r
}

// (public) |this|
function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s - a.s
  if (r != 0) return r
  var i = this.t
  r = i - a.t
  if (r != 0) return (this.s < 0) ? -r : r
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0) return r
  return 0
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1,
    t
  if ((t = x >>> 16) != 0) {
    x = t
    r += 16
  }
  if ((t = x >> 8) != 0) {
    x = t
    r += 8
  }
  if ((t = x >> 4) != 0) {
    x = t
    r += 4
  }
  if ((t = x >> 2) != 0) {
    x = t
    r += 2
  }
  if ((t = x >> 1) != 0) {
    x = t
    r += 1
  }
  return r
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if (this.t <= 0) return 0
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

// (public) return the number of bytes in "this"
function bnByteLength() {
  return this.bitLength() >> 3
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
  var i
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i]
  for (i = n - 1; i >= 0; --i) r[i] = 0
  r.t = this.t + n
  r.s = this.s
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i]
  r.t = Math.max(this.t - n, 0)
  r.s = this.s
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
  var self = this
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << cbs) - 1
  var ds = Math.floor(n / self.DB),
    c = (self.s << bs) & self.DM,
    i
  for (i = self.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (self[i] >> cbs) | c
    c = (self[i] & bm) << bs
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0
  r[ds] = c
  r.t = self.t + ds + 1
  r.s = self.s
  r.clamp()
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
  var self = this
  r.s = self.s
  var ds = Math.floor(n / self.DB)
  if (ds >= self.t) {
    r.t = 0
    return
  }
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << bs) - 1
  r[0] = self[ds] >> bs
  for (var i = ds + 1; i < self.t; ++i) {
    r[i - ds - 1] |= (self[i] & bm) << cbs
    r[i - ds] = self[i] >> bs
  }
  if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs
  r.t = self.t - ds
  r.clamp()
}

// (protected) r = this - a
function bnpSubTo(a, r) {
  var self = this
  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] - a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c -= a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c -= a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c -= a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c < -1) r[i++] = self.DV + c
  else if (c > 0) r[i++] = c
  r.t = i
  r.clamp()
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
  var x = this.abs(),
    y = a.abs()
  var i = x.t
  r.t = i + y.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)
  r.s = 0
  r.clamp()
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs()
  var i = r.t = 2 * x.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1)
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV
      r[i + x.t + 1] = 1
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)
  r.s = 0
  r.clamp()
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
  var self = this
  var pm = m.abs()
  if (pm.t <= 0) return
  var pt = self.abs()
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0)
    if (r != null) self.copyTo(r)
    return
  }
  if (r == null) r = new BigInteger()
  var y = new BigInteger(),
    ts = self.s,
    ms = m.s
  var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
  if (nsh > 0) {
    pm.lShiftTo(nsh, y)
    pt.lShiftTo(nsh, r)
  } else {
    pm.copyTo(y)
    pt.copyTo(r)
  }
  var ys = y.t
  var y0 = y[ys - 1]
  if (y0 == 0) return
  var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0)
  var d1 = self.FV / yt,
    d2 = (1 << self.F1) / yt,
    e = 1 << self.F2
  var i = r.t,
    j = i - ys,
    t = (q == null) ? new BigInteger() : q
  y.dlShiftTo(j, t)
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1
    r.subTo(t, r)
  }
  BigInteger.ONE.dlShiftTo(ys, t)
  t.subTo(y, y); // "negative" y so we can replace sub with am later
  while (y.t < ys) y[y.t++] = 0
  while (--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2)
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
      y.dlShiftTo(j, t)
      r.subTo(t, r)
      while (r[i] < --qd) r.subTo(t, r)
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q)
    if (ts != ms) BigInteger.ZERO.subTo(q, q)
  }
  r.t = ys
  r.clamp()
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
  if (ts < 0) BigInteger.ZERO.subTo(r, r)
}

// (public) this mod a
function bnMod(a) {
  var r = new BigInteger()
  this.abs()
    .divRemTo(a, null, r)
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r)
  return r
}

// Modular reduction using "classic" algorithm
function Classic(m) {
  this.m = m
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m)
  else return x
}

function cRevert(x) {
  return x
}

function cReduce(x) {
  x.divRemTo(this.m, null, x)
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

function cSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

Classic.prototype.convert = cConvert
Classic.prototype.revert = cRevert
Classic.prototype.reduce = cReduce
Classic.prototype.mulTo = cMulTo
Classic.prototype.sqrTo = cSqrTo

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if (this.t < 1) return 0
  var x = this[0]
  if ((x & 1) == 0) return 0
  var y = x & 3; // y == 1/x mod 2^2
  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y > 0) ? this.DV - y : -y
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m
  this.mp = m.invDigit()
  this.mpl = this.mp & 0x7fff
  this.mph = this.mp >> 15
  this.um = (1 << (m.DB - 15)) - 1
  this.mt2 = 2 * m.t
}

// xR mod m
function montConvert(x) {
  var r = new BigInteger()
  x.abs()
    .dlShiftTo(this.m.t, r)
  r.divRemTo(this.m, null, r)
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)
  return r
}

// x/R mod m
function montRevert(x) {
  var r = new BigInteger()
  x.copyTo(r)
  this.reduce(r)
  return r
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0
  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i] & 0x7fff
    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM
    // use am to combine the multiply-shift-add into one call
    j = i + this.m.t
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t)
    // propagate carry
    while (x[j] >= x.DV) {
      x[j] -= x.DV
      x[++j]++
    }
  }
  x.clamp()
  x.drShiftTo(this.m.t, x)
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x)
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Montgomery.prototype.convert = montConvert
Montgomery.prototype.revert = montRevert
Montgomery.prototype.reduce = montReduce
Montgomery.prototype.mulTo = montMulTo
Montgomery.prototype.sqrTo = montSqrTo

// (protected) true iff this is even
function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE
  var r = new BigInteger(),
    r2 = new BigInteger(),
    g = z.convert(this),
    i = nbits(e) - 1
  g.copyTo(r)
  while (--i >= 0) {
    z.sqrTo(r, r2)
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r)
    else {
      var t = r
      r = r2
      r2 = t
    }
  }
  return z.revert(r)
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
  var z
  if (e < 256 || m.isEven()) z = new Classic(m)
  else z = new Montgomery(m)
  return this.exp(e, z)
}

// protected
proto.copyTo = bnpCopyTo
proto.fromInt = bnpFromInt
proto.fromString = bnpFromString
proto.clamp = bnpClamp
proto.dlShiftTo = bnpDLShiftTo
proto.drShiftTo = bnpDRShiftTo
proto.lShiftTo = bnpLShiftTo
proto.rShiftTo = bnpRShiftTo
proto.subTo = bnpSubTo
proto.multiplyTo = bnpMultiplyTo
proto.squareTo = bnpSquareTo
proto.divRemTo = bnpDivRemTo
proto.invDigit = bnpInvDigit
proto.isEven = bnpIsEven
proto.exp = bnpExp

// public
proto.toString = bnToString
proto.negate = bnNegate
proto.abs = bnAbs
proto.compareTo = bnCompareTo
proto.bitLength = bnBitLength
proto.byteLength = bnByteLength
proto.mod = bnMod
proto.modPowInt = bnModPowInt

// (public)
function bnClone() {
  var r = new BigInteger()
  this.copyTo(r)
  return r
}

// (public) return value as integer
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV
    else if (this.t == 0) return -1
  } else if (this.t == 1) return this[0]
  else if (this.t == 0) return 0
  // assumes 16 < DB < 32
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

// (public) return value as byte
function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r))
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if (this.s < 0) return -1
  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0
  else return 1
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if (b == null) b = 10
  if (this.signum() == 0 || b < 2 || b > 36) return "0"
  var cs = this.chunkSize(b)
  var a = Math.pow(b, cs)
  var d = nbv(a),
    y = new BigInteger(),
    z = new BigInteger(),
    r = ""
  this.divRemTo(d, y, z)
  while (y.signum() > 0) {
    r = (a + z.intValue())
      .toString(b)
      .substr(1) + r
    y.divRemTo(d, y, z)
  }
  return z.intValue()
    .toString(b) + r
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
  var self = this
  self.fromInt(0)
  if (b == null) b = 10
  var cs = self.chunkSize(b)
  var d = Math.pow(b, cs),
    mi = false,
    j = 0,
    w = 0
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-" && self.signum() == 0) mi = true
      continue
    }
    w = b * w + x
    if (++j >= cs) {
      self.dMultiply(d)
      self.dAddOffset(w, 0)
      j = 0
      w = 0
    }
  }
  if (j > 0) {
    self.dMultiply(Math.pow(b, j))
    self.dAddOffset(w, 0)
  }
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
  var self = this
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) self.fromInt(1)
    else {
      self.fromNumber(a, c)
      if (!self.testBit(a - 1)) // force MSB set
        self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self)
      if (self.isEven()) self.dAddOffset(1, 0); // force odd
      while (!self.isProbablePrime(b)) {
        self.dAddOffset(2, 0)
        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
      t = a & 7
    x.length = (a >> 3) + 1
    b.nextBytes(x)
    if (t > 0) x[0] &= ((1 << t) - 1)
    else x[0] = 0
    self.fromString(x, 256)
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var self = this
  var i = self.t,
    r = new Array()
  r[0] = self.s
  var p = self.DB - (i * self.DB) % 8,
    d, k = 0
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
      r[k++] = d | (self.s << (self.DB - p))
    while (i >= 0) {
      if (p < 8) {
        d = (self[i] & ((1 << p) - 1)) << (8 - p)
        d |= self[--i] >> (p += self.DB - 8)
      } else {
        d = (self[i] >> (p -= 8)) & 0xff
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if ((d & 0x80) != 0) d |= -256
      if (k === 0 && (self.s & 0x80) != (d & 0x80))++k
      if (k > 0 || d != self.s) r[k++] = d
    }
  }
  return r
}

function bnEquals(a) {
  return (this.compareTo(a) == 0)
}

function bnMin(a) {
  return (this.compareTo(a) < 0) ? this : a
}

function bnMax(a) {
  return (this.compareTo(a) > 0) ? this : a
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
  var self = this
  var i, f, m = Math.min(a.t, self.t)
  for (i = 0; i < m; ++i) r[i] = op(self[i], a[i])
  if (a.t < self.t) {
    f = a.s & self.DM
    for (i = m; i < self.t; ++i) r[i] = op(self[i], f)
    r.t = self.t
  } else {
    f = self.s & self.DM
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i])
    r.t = a.t
  }
  r.s = op(self.s, a.s)
  r.clamp()
}

// (public) this & a
function op_and(x, y) {
  return x & y
}

function bnAnd(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_and, r)
  return r
}

// (public) this | a
function op_or(x, y) {
  return x | y
}

function bnOr(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_or, r)
  return r
}

// (public) this ^ a
function op_xor(x, y) {
  return x ^ y
}

function bnXor(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_xor, r)
  return r
}

// (public) this & ~a
function op_andnot(x, y) {
  return x & ~y
}

function bnAndNot(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_andnot, r)
  return r
}

// (public) ~this
function bnNot() {
  var r = new BigInteger()
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i]
  r.t = this.t
  r.s = ~this.s
  return r
}

// (public) this << n
function bnShiftLeft(n) {
  var r = new BigInteger()
  if (n < 0) this.rShiftTo(-n, r)
  else this.lShiftTo(n, r)
  return r
}

// (public) this >> n
function bnShiftRight(n) {
  var r = new BigInteger()
  if (n < 0) this.lShiftTo(-n, r)
  else this.rShiftTo(n, r)
  return r
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if (x == 0) return -1
  var r = 0
  if ((x & 0xffff) == 0) {
    x >>= 16
    r += 16
  }
  if ((x & 0xff) == 0) {
    x >>= 8
    r += 8
  }
  if ((x & 0xf) == 0) {
    x >>= 4
    r += 4
  }
  if ((x & 3) == 0) {
    x >>= 2
    r += 2
  }
  if ((x & 1) == 0)++r
  return r
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i])
  if (this.s < 0) return this.t * this.DB
  return -1
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0
  while (x != 0) {
    x &= x - 1
    ++r
  }
  return r
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0,
    x = this.s & this.DM
  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x)
  return r
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n / this.DB)
  if (j >= this.t) return (this.s != 0)
  return ((this[j] & (1 << (n % this.DB))) != 0)
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n)
  this.bitwiseTo(r, op, r)
  return r
}

// (public) this | (1<<n)
function bnSetBit(n) {
  return this.changeBit(n, op_or)
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
  return this.changeBit(n, op_andnot)
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
  return this.changeBit(n, op_xor)
}

// (protected) r = this + a
function bnpAddTo(a, r) {
  var self = this

  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] + a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c += a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c += a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c > 0) r[i++] = c
  else if (c < -1) r[i++] = self.DV + c
  r.t = i
  r.clamp()
}

// (public) this + a
function bnAdd(a) {
  var r = new BigInteger()
  this.addTo(a, r)
  return r
}

// (public) this - a
function bnSubtract(a) {
  var r = new BigInteger()
  this.subTo(a, r)
  return r
}

// (public) this * a
function bnMultiply(a) {
  var r = new BigInteger()
  this.multiplyTo(a, r)
  return r
}

// (public) this^2
function bnSquare() {
  var r = new BigInteger()
  this.squareTo(r)
  return r
}

// (public) this / a
function bnDivide(a) {
  var r = new BigInteger()
  this.divRemTo(a, r, null)
  return r
}

// (public) this % a
function bnRemainder(a) {
  var r = new BigInteger()
  this.divRemTo(a, null, r)
  return r
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = new BigInteger(),
    r = new BigInteger()
  this.divRemTo(a, q, r)
  return new Array(q, r)
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t)
  ++this.t
  this.clamp()
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
  if (n == 0) return
  while (this.t <= w) this[this.t++] = 0
  this[w] += n
  while (this[w] >= this.DV) {
    this[w] -= this.DV
    if (++w >= this.t) this[this.t++] = 0
    ++this[w]
  }
}

// A "null" reducer
function NullExp() {}

function nNop(x) {
  return x
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r)
}

function nSqrTo(x, r) {
  x.squareTo(r)
}

NullExp.prototype.convert = nNop
NullExp.prototype.revert = nNop
NullExp.prototype.mulTo = nMulTo
NullExp.prototype.sqrTo = nSqrTo

// (public) this^e
function bnPow(e) {
  return this.exp(e, new NullExp())
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n)
  r.s = 0; // assumes a,this >= 0
  r.t = i
  while (i > 0) r[--i] = 0
  var j
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t)
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i)
  r.clamp()
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
  --n
  var i = r.t = this.t + a.t - n
  r.s = 0; // assumes a,this >= 0
  while (--i >= 0) r[i] = 0
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n)
  r.clamp()
  r.drShiftTo(1, r)
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = new BigInteger()
  this.q3 = new BigInteger()
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2)
  this.mu = this.r2.divide(m)
  this.m = m
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m)
  else if (x.compareTo(this.m) < 0) return x
  else {
    var r = new BigInteger()
    x.copyTo(r)
    this.reduce(r)
    return r
  }
}

function barrettRevert(x) {
  return x
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  var self = this
  x.drShiftTo(self.m.t - 1, self.r2)
  if (x.t > self.m.t + 1) {
    x.t = self.m.t + 1
    x.clamp()
  }
  self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3)
  self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2)
  while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1)
  x.subTo(self.r2, x)
  while (x.compareTo(self.m) >= 0) x.subTo(self.m, x)
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Barrett.prototype.convert = barrettConvert
Barrett.prototype.revert = barrettRevert
Barrett.prototype.reduce = barrettReduce
Barrett.prototype.mulTo = barrettMulTo
Barrett.prototype.sqrTo = barrettSqrTo

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
  var i = e.bitLength(),
    k, r = nbv(1),
    z
  if (i <= 0) return r
  else if (i < 18) k = 1
  else if (i < 48) k = 3
  else if (i < 144) k = 4
  else if (i < 768) k = 5
  else k = 6
  if (i < 8)
    z = new Classic(m)
  else if (m.isEven())
    z = new Barrett(m)
  else
    z = new Montgomery(m)

  // precomputation
  var g = new Array(),
    n = 3,
    k1 = k - 1,
    km = (1 << k) - 1
  g[1] = z.convert(this)
  if (k > 1) {
    var g2 = new BigInteger()
    z.sqrTo(g[1], g2)
    while (n <= km) {
      g[n] = new BigInteger()
      z.mulTo(g2, g[n - 2], g[n])
      n += 2
    }
  }

  var j = e.t - 1,
    w, is1 = true,
    r2 = new BigInteger(),
    t
  i = nbits(e[j]) - 1
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i)
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1)
    }

    n = k
    while ((w & 1) == 0) {
      w >>= 1
      --n
    }
    if ((i -= n) < 0) {
      i += this.DB
      --j
    }
    if (is1) { // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r)
      is1 = false
    } else {
      while (n > 1) {
        z.sqrTo(r, r2)
        z.sqrTo(r2, r)
        n -= 2
      }
      if (n > 0) z.sqrTo(r, r2)
      else {
        t = r
        r = r2
        r2 = t
      }
      z.mulTo(r2, g[w], r)
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2)
      t = r
      r = r2
      r2 = t
      if (--i < 0) {
        i = this.DB - 1
        --j
      }
    }
  }
  return z.revert(r)
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s < 0) ? this.negate() : this.clone()
  var y = (a.s < 0) ? a.negate() : a.clone()
  if (x.compareTo(y) < 0) {
    var t = x
    x = y
    y = t
  }
  var i = x.getLowestSetBit(),
    g = y.getLowestSetBit()
  if (g < 0) return x
  if (i < g) g = i
  if (g > 0) {
    x.rShiftTo(g, x)
    y.rShiftTo(g, y)
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x)
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y)
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x)
      x.rShiftTo(1, x)
    } else {
      y.subTo(x, y)
      y.rShiftTo(1, y)
    }
  }
  if (g > 0) y.lShiftTo(g, y)
  return y
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if (n <= 0) return 0
  var d = this.DV % n,
    r = (this.s < 0) ? n - 1 : 0
  if (this.t > 0)
    if (d == 0) r = this[0] % n
    else
      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n
  return r
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven()
  if (this.signum() === 0) throw new Error('division by zero')
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO
  var u = m.clone(),
    v = this.clone()
  var a = nbv(1),
    b = nbv(0),
    c = nbv(0),
    d = nbv(1)
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u)
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a)
          b.subTo(m, b)
        }
        a.rShiftTo(1, a)
      } else if (!b.isEven()) b.subTo(m, b)
      b.rShiftTo(1, b)
    }
    while (v.isEven()) {
      v.rShiftTo(1, v)
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c)
          d.subTo(m, d)
        }
        c.rShiftTo(1, c)
      } else if (!d.isEven()) d.subTo(m, d)
      d.rShiftTo(1, d)
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u)
      if (ac) a.subTo(c, a)
      b.subTo(d, b)
    } else {
      v.subTo(u, v)
      if (ac) c.subTo(a, c)
      d.subTo(b, d)
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO
  while (d.compareTo(m) >= 0) d.subTo(m, d)
  while (d.signum() < 0) d.addTo(m, d)
  return d
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
  157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
  331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
  509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
  709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
  919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
]

var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs()
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true
    return false
  }
  if (x.isEven()) return false
  i = 1
  while (i < lowprimes.length) {
    var m = lowprimes[i],
      j = i + 1
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]
    m = x.modInt(m)
    while (i < j) if (m % lowprimes[i++] == 0) return false
  }
  return x.millerRabin(t)
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE)
  var k = n1.getLowestSetBit()
  if (k <= 0) return false
  var r = n1.shiftRight(k)
  t = (t + 1) >> 1
  if (t > lowprimes.length) t = lowprimes.length
  var a = new BigInteger(null)
  var j, bases = []
  for (var i = 0; i < t; ++i) {
    for (;;) {
      j = lowprimes[Math.floor(Math.random() * lowprimes.length)]
      if (bases.indexOf(j) == -1) break
    }
    bases.push(j)
    a.fromInt(j)
    var y = a.modPow(r, this)
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this)
        if (y.compareTo(BigInteger.ONE) == 0) return false
      }
      if (y.compareTo(n1) != 0) return false
    }
  }
  return true
}

// protected
proto.chunkSize = bnpChunkSize
proto.toRadix = bnpToRadix
proto.fromRadix = bnpFromRadix
proto.fromNumber = bnpFromNumber
proto.bitwiseTo = bnpBitwiseTo
proto.changeBit = bnpChangeBit
proto.addTo = bnpAddTo
proto.dMultiply = bnpDMultiply
proto.dAddOffset = bnpDAddOffset
proto.multiplyLowerTo = bnpMultiplyLowerTo
proto.multiplyUpperTo = bnpMultiplyUpperTo
proto.modInt = bnpModInt
proto.millerRabin = bnpMillerRabin

// public
proto.clone = bnClone
proto.intValue = bnIntValue
proto.byteValue = bnByteValue
proto.shortValue = bnShortValue
proto.signum = bnSigNum
proto.toByteArray = bnToByteArray
proto.equals = bnEquals
proto.min = bnMin
proto.max = bnMax
proto.and = bnAnd
proto.or = bnOr
proto.xor = bnXor
proto.andNot = bnAndNot
proto.not = bnNot
proto.shiftLeft = bnShiftLeft
proto.shiftRight = bnShiftRight
proto.getLowestSetBit = bnGetLowestSetBit
proto.bitCount = bnBitCount
proto.testBit = bnTestBit
proto.setBit = bnSetBit
proto.clearBit = bnClearBit
proto.flipBit = bnFlipBit
proto.add = bnAdd
proto.subtract = bnSubtract
proto.multiply = bnMultiply
proto.divide = bnDivide
proto.remainder = bnRemainder
proto.divideAndRemainder = bnDivideAndRemainder
proto.modPow = bnModPow
proto.modInverse = bnModInverse
proto.pow = bnPow
proto.gcd = bnGCD
proto.isProbablePrime = bnIsProbablePrime

// JSBN-specific extension
proto.square = bnSquare

// constants
BigInteger.ZERO = nbv(0)
BigInteger.ONE = nbv(1)
BigInteger.valueOf = nbv

module.exports = BigInteger


/***/ }),

/***/ "./node_modules/bigi/lib/convert.js":
/*!******************************************!*\
  !*** ./node_modules/bigi/lib/convert.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
// FIXME: Kind of a weird way to throw exceptions, consider removing
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
var BigInteger = __webpack_require__(/*! ./bigi */ "./node_modules/bigi/lib/bigi.js")

/**
 * Turns a byte array into a big integer.
 *
 * This function will interpret a byte array as a big integer in big
 * endian notation.
 */
BigInteger.fromByteArrayUnsigned = function(byteArray) {
  // BigInteger expects a DER integer conformant byte array
  if (byteArray[0] & 0x80) {
    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(byteArray)
}

/**
 * Returns a byte array representation of the big integer.
 *
 * This returns the absolute of the contained value in big endian
 * form. A value of zero results in an empty array.
 */
BigInteger.prototype.toByteArrayUnsigned = function() {
  var byteArray = this.toByteArray()
  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray
}

BigInteger.fromDERInteger = function(byteArray) {
  return new BigInteger(byteArray)
}

/*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray

BigInteger.fromBuffer = function(buffer) {
  // BigInteger expects a DER integer conformant byte array
  if (buffer[0] & 0x80) {
    var byteArray = Array.prototype.slice.call(buffer)

    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(buffer)
}

BigInteger.fromHex = function(hex) {
  if (hex === '') return BigInteger.ZERO

  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')
  assert.equal(hex.length % 2, 0, 'Incomplete hex')
  return new BigInteger(hex, 16)
}

BigInteger.prototype.toBuffer = function(size) {
  var byteArray = this.toByteArrayUnsigned()
  var zeros = []

  var padding = size - byteArray.length
  while (zeros.length < padding) zeros.push(0)

  return new Buffer(zeros.concat(byteArray))
}

BigInteger.prototype.toHex = function(size) {
  return this.toBuffer(size).toString('hex')
}


/***/ }),

/***/ "./node_modules/bigi/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/bigi/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BigInteger = __webpack_require__(/*! ./bigi */ "./node_modules/bigi/lib/bigi.js")

//addons
__webpack_require__(/*! ./convert */ "./node_modules/bigi/lib/convert.js")

module.exports = BigInteger

/***/ }),

/***/ "./node_modules/bip-schnorr/src/check.js":
/*!***********************************************!*\
  !*** ./node_modules/bip-schnorr/src/check.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');

const one = BigInteger.ONE;
const n = curve.n;
const p = curve.p;

function checkBuffer(name, buf, len, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!Buffer.isBuffer(buf)) {
    throw new Error(name + idxStr + ' must be a Buffer');
  }
  if (buf.length !== len) {
    throw new Error(name + idxStr + ' must be ' + len + ' bytes long');
  }
}

function checkArray(name, arr) {
  if (!arr || !arr.length) {
    throw new Error(name + ' must be an array with one or more elements');
  }
}

function checkPubKeyArr(pubKeys) {
  checkArray('pubKeys', pubKeys);
  for (let i = 0; i < pubKeys.length; i++) {
    checkBuffer('pubKey', pubKeys[i], 32, i);
  }
}

function checkMessageArr(messages) {
  checkArray('messages', messages);
  for (let i = 0; i < messages.length; i++) {
    checkBuffer('message', messages[i], 32, i);
  }
}

function checkSignatureArr(signatures) {
  checkArray('signatures', signatures);
  for (let i = 0; i < signatures.length; i++) {
    checkBuffer('signature', signatures[i], 64, i);
  }
}

function checkNonceArr(nonces) {
  checkArray('nonces', nonces);
  for (let i = 0; i < nonces.length; i++) {
    checkBuffer('nonce', nonces[i], 32, i);
  }
}

function checkPrivateKey(privateKey, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!BigInteger.isBigInteger(privateKey) && !(typeof privateKey == 'string')) {
    throw new Error('privateKey' + idxStr + ' must be a BigInteger or valid hex string');
  }

  if (typeof(privateKey) == 'string') {
    if (privateKey.match(/[^a-f^A-F^0-9]+/)) {
      throw new Error('privateKey must be a BigInteger or valid hex string');
    }

    checkRange('privateKey', BigInteger.fromHex(privateKey));
    return
  }

  checkRange('privateKey', privateKey);
}

function checkSignParams(privateKey, message) {
  checkPrivateKey(privateKey);
  checkBuffer('message', message, 32);
}

function checkVerifyParams(pubKey, message, signature) {
  checkBuffer('pubKey', pubKey, 32);
  checkBuffer('message', message, 32);
  checkBuffer('signature', signature, 64);
}

function checkBatchVerifyParams(pubKeys, messages, signatures) {
  checkPubKeyArr(pubKeys);
  checkMessageArr(messages);
  checkSignatureArr(signatures);
  if (pubKeys.length !== messages.length || messages.length !== signatures.length) {
    throw new Error('all parameters must be an array with the same length')
  }
}

function checkSessionParams(sessionId, privateKey, message, pubKeyCombined, ell) {
  checkSignParams(privateKey, message);
  checkBuffer('sessionId', sessionId, 32);
  checkBuffer('pubKeyCombined', pubKeyCombined, 32);
  checkBuffer('ell', ell, 32);
}

function checkRange(name, scalar) {
  if (scalar.compareTo(one) < 0 || scalar.compareTo(n.subtract(one)) > 0) {
    throw new Error(name + ' must be an integer in the range 1..n-1')
  }
}

function checkSignatureInput(r, s) {
  if (r.compareTo(p) >= 0) {
    throw new Error('r is larger than or equal to field size');
  }
  if (s.compareTo(n) >= 0) {
    throw new Error('s is larger than or equal to curve order');
  }
}

function checkPointExists(pubKeyEven, P) {
  if (P.curve.isInfinity(P)) {
    throw new Error('point is at infinity');
  }
  const pEven = P.affineY.isEven();
  if (pubKeyEven !== pEven) {
    throw new Error('point does not exist');
  }
}

function checkAux(aux) {
  if (aux.length !== 32) {
    throw new Error('aux must be 32 bytes');
  }
}

module.exports = {
  checkSessionParams,
  checkSignParams,
  checkVerifyParams,
  checkBatchVerifyParams,
  checkRange,
  checkSignatureInput,
  checkPointExists,
  checkPubKeyArr,
  checkArray,
  checkNonceArr,
  checkAux,
};


/***/ }),

/***/ "./node_modules/bip-schnorr/src/convert.js":
/*!*************************************************!*\
  !*** ./node_modules/bip-schnorr/src/convert.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const sha256 = __webpack_require__(/*! js-sha256 */ "./node_modules/js-sha256/src/sha256.js");

function bufferToInt(buffer) {
  return BigInteger.fromBuffer(buffer);
}

function intToBuffer(bigInteger) {
  return bigInteger.toBuffer(32);
}

function hash(buffer) {
  return Buffer.from(sha256.create().update(buffer).array());
}

module.exports = {
  bufferToInt,
  intToBuffer,
  hash,
};


/***/ }),

/***/ "./node_modules/bip-schnorr/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/bip-schnorr/src/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const schnorr = __webpack_require__(/*! ./schnorr */ "./node_modules/bip-schnorr/src/schnorr.js");
schnorr.check = __webpack_require__(/*! ./check */ "./node_modules/bip-schnorr/src/check.js");
schnorr.convert = __webpack_require__(/*! ./convert */ "./node_modules/bip-schnorr/src/convert.js");
schnorr.math = __webpack_require__(/*! ./math */ "./node_modules/bip-schnorr/src/math.js");
schnorr.muSig = __webpack_require__(/*! ./mu-sig */ "./node_modules/bip-schnorr/src/mu-sig.js");
schnorr.taproot = __webpack_require__(/*! ./taproot */ "./node_modules/bip-schnorr/src/taproot.js");

module.exports = schnorr;


/***/ }),

/***/ "./node_modules/bip-schnorr/src/math.js":
/*!**********************************************!*\
  !*** ./node_modules/bip-schnorr/src/math.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
const curve = ecurve.getCurveByName('secp256k1');
const check = __webpack_require__(/*! ./check */ "./node_modules/bip-schnorr/src/check.js");
const convert = __webpack_require__(/*! ./convert */ "./node_modules/bip-schnorr/src/convert.js");

const concat = Buffer.concat;
const G = curve.G;
const p = curve.p;
const n = curve.n;
const zero = BigInteger.ZERO;
const one = BigInteger.ONE;
const two = BigInteger.valueOf(2);
const three = BigInteger.valueOf(3);
const four = BigInteger.valueOf(4);
const seven = BigInteger.valueOf(7);

function deterministicGetK0(privateKey, publicKey, message) {
  check.checkSignParams(privateKey, message);

  const h = taggedHash('BIP0340/nonce', concat([convert.intToBuffer(privateKey), publicKey, message]));
  const i = convert.bufferToInt(h);
  return i.mod(n);
}

function isEven(pubKey) {
  return pubKey.affineY.mod(two).equals(zero);
}

function getEvenKey(pubKey, privateKey) {
  if (isEven(pubKey)) {
    return privateKey.clone();
  }

  return n.subtract(privateKey);
}

function getE(Rx, Px, m) {
  const hash = taggedHash('BIP0340/challenge', concat([Rx, Px, m]));
  return convert.bufferToInt(hash).mod(n);
}

function getR(s, e, P) {
  const sG = G.multiply(s);
  const eP = P.multiply(e);
  return sG.add(eP.negate());
}

function taggedHash(tag, msg) {
  const tagHash = convert.hash(tag);
  return convert.hash(concat([tagHash, tagHash, Buffer.from(msg)]));
}

function liftX(Px) {
  const x = convert.bufferToInt(Px);

  const c = x.pow(three).add(seven).mod(p);
  const y = c.modPow(p.add(one).divide(four), p);
  if (c.compareTo(y.modPow(two, p)) !== 0) {
    throw new Error('c is not equal to y^2');
  }
  let P = ecurve.Point.fromAffine(curve, x, y);
  if (!isEven(P)) {
    P = ecurve.Point.fromAffine(curve, x, p.subtract(y));
  }

  check.checkPointExists(true, P);
  return P;
}

function randomA() {
  let a = null;
  for (; ;) {
    a = convert.bufferToInt(Buffer.from(randomBytes(32)));
    try {
      check.checkRange('a', a);
      return a;
    } catch (e) {
      // out of range, generate another one
    }
  }
}

module.exports = {
  deterministicGetK0,
  isEven,
  getEvenKey,
  getE,
  getR,
  taggedHash,
  liftX,
  randomA,
};


/***/ }),

/***/ "./node_modules/bip-schnorr/src/mu-sig.js":
/*!************************************************!*\
  !*** ./node_modules/bip-schnorr/src/mu-sig.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');
const math = __webpack_require__(/*! ./math */ "./node_modules/bip-schnorr/src/math.js");
const check = __webpack_require__(/*! ./check */ "./node_modules/bip-schnorr/src/check.js");
const convert = __webpack_require__(/*! ./convert */ "./node_modules/bip-schnorr/src/convert.js");

const concat = Buffer.concat;
const G = curve.G;
const n = curve.n;
const MUSIG_TAG = convert.hash(Buffer.from('MuSig coefficient'));

// Computes ell = SHA256(pubKeys[0], ..., pubKeys[pubKeys.length-1]) with
// pubKeys serialized in compressed form.
function computeEll(pubKeys) {
  check.checkPubKeyArr(pubKeys);
  return convert.hash(concat(pubKeys))
}

function computeCoefficient(ell, idx) {
  const idxBuf = Buffer.alloc(4);
  idxBuf.writeUInt32LE(idx);
  const data = concat([MUSIG_TAG, MUSIG_TAG, ell, idxBuf]);
  return convert.bufferToInt(convert.hash(data)).mod(n);
}

function pubKeyCombine(pubKeys, pubKeyHash) {
  const ell = pubKeyHash || computeEll(pubKeys);
  let X = null;
  for (let i = 0; i < pubKeys.length; i++) {
    const Xi = math.liftX(pubKeys[i]);
    const coefficient = computeCoefficient(ell, i);
    const summand = Xi.multiply(coefficient);
    if (X === null) {
      X = summand;
    } else {
      X = X.add(summand);
    }
  }
  return X;
}

function sessionInitialize(sessionId, privateKey, message, pubKeyCombined, pkParity, ell, idx) {
  check.checkSessionParams(sessionId, privateKey, message, pubKeyCombined, ell);

  const session = {
    sessionId,
    message,
    pubKeyCombined,
    pkParity,
    ell,
    idx,
  };

  const coefficient = computeCoefficient(ell, idx);
  session.secretKey = privateKey.multiply(coefficient).mod(n);
  session.ownKeyParity = math.isEven(G.multiply(privateKey));
  if (session.pkParity !== session.ownKeyParity) {
    session.secretKey = n.subtract(session.secretKey);
  }

  const nonceData = concat([sessionId, message, session.pubKeyCombined, convert.intToBuffer(privateKey)]);
  session.secretNonce = convert.bufferToInt(convert.hash(nonceData));
  check.checkRange('secretNonce', session.secretNonce);
  const R = G.multiply(session.secretNonce);
  session.nonce = convert.intToBuffer(R.affineX);
  session.nonceParity = math.isEven(R);
  session.commitment = convert.hash(session.nonce);
  return session;
}

function sessionNonceCombine(session, nonces) {
  check.checkNonceArr(nonces);
  let R = math.liftX(nonces[0]);
  for (let i = 1; i < nonces.length; i++) {
    R = R.add(math.liftX(nonces[i]));
  }
  session.combinedNonceParity = math.isEven(R);
  return convert.intToBuffer(R.affineX);
}

function partialSign(session, message, nonceCombined, pubKeyCombined) {
  const e = math.getE(nonceCombined, pubKeyCombined, message);
  const sk = session.secretKey;
  let k = session.secretNonce;
  if (session.nonceParity !== session.combinedNonceParity) {
    k = n.subtract(k);
  }
  return sk.multiply(e).add(k).mod(n);
}

function partialSigVerify(session, partialSig, nonceCombined, idx, pubKey, nonce) {
  let e = math.getE(nonceCombined, session.pubKeyCombined, session.message);
  const coefficient = computeCoefficient(session.ell, idx);
  const Pj = math.liftX(pubKey);
  const Ri = math.liftX(nonce);

  if (!session.pkParity) {
    e = n.subtract(e);
  }

  let RP = math.getR(partialSig, e.multiply(coefficient).mod(n), Pj);
  if (session.combinedNonceParity) {
    RP = RP.negate();
  }
  const sum = RP.add(Ri);
  if (!sum.curve.isInfinity(sum)) {
    throw new Error('partial signature verification failed');
  }
}

function partialSigCombine(nonceCombined, partialSigs) {
  const R = math.liftX(nonceCombined);
  check.checkArray('partialSigs', partialSigs);
  const Rx = convert.intToBuffer(R.affineX);
  let s = partialSigs[0];
  for (let i = 1; i < partialSigs.length; i++) {
    s = s.add(partialSigs[i]).mod(n);
  }
  return concat([Rx, convert.intToBuffer(s)]);
}

module.exports = {
  computeEll,
  computeCoefficient,
  pubKeyCombine,
  sessionInitialize,
  sessionNonceCombine,
  partialSign,
  partialSigVerify,
  partialSigCombine,
};


/***/ }),

/***/ "./node_modules/bip-schnorr/src/schnorr.js":
/*!*************************************************!*\
  !*** ./node_modules/bip-schnorr/src/schnorr.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');
const math = __webpack_require__(/*! ./math */ "./node_modules/bip-schnorr/src/math.js");
const check = __webpack_require__(/*! ./check */ "./node_modules/bip-schnorr/src/check.js");
const convert = __webpack_require__(/*! ./convert */ "./node_modules/bip-schnorr/src/convert.js");

const concat = Buffer.concat;
const G = curve.G;
const p = curve.p;
const n = curve.n;
const zero = BigInteger.ZERO;

function sign(privateKey, message, aux) {
  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#signing
  check.checkSignParams(privateKey, message);
  privateKey = typeof (privateKey) == 'string' ? BigInteger.fromHex(privateKey) : privateKey;

  const P = G.multiply(privateKey);
  const Px = convert.intToBuffer(P.affineX);

  const d = math.getEvenKey(P, privateKey);
  let kPrime
  if (aux) {
    check.checkAux(aux);

    const t = convert.intToBuffer(d.xor(convert.bufferToInt(math.taggedHash('BIP0340/aux', aux))));
    const rand = math.taggedHash('BIP0340/nonce', concat([t, Px, message]))
    kPrime = convert.bufferToInt(rand).mod(n);
  } else {
    kPrime = math.deterministicGetK0(d, Px, message);
  }

  if (kPrime.signum() === 0) {
    throw new Error('kPrime is zero');
  }

  const R = G.multiply(kPrime);
  const k = math.getEvenKey(R, kPrime);
  const Rx = convert.intToBuffer(R.affineX);
  const e = math.getE(Rx, Px, message);
  return concat([Rx, convert.intToBuffer(k.add(e.multiply(d)).mod(n))]);
}

function verify(pubKey, message, signature) {
  check.checkVerifyParams(pubKey, message, signature);

  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#verification
  const P = math.liftX(pubKey);
  const Px = convert.intToBuffer(P.affineX);
  const r = convert.bufferToInt(signature.slice(0, 32));
  const s = convert.bufferToInt(signature.slice(32, 64));
  check.checkSignatureInput(r, s);
  const e = math.getE(convert.intToBuffer(r), Px, message);
  const R = math.getR(s, e, P);
  if (R.curve.isInfinity(R) || !math.isEven(R) || !R.affineX.equals(r)) {
    throw new Error('signature verification failed');
  }
}

function batchVerify(pubKeys, messages, signatures) {
  check.checkBatchVerifyParams(pubKeys, messages, signatures);

  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Batch_Verification
  let leftSide = zero;
  let rightSide = null;
  for (let i = 0; i < pubKeys.length; i++) {
    const P = math.liftX(pubKeys[i]);
    const Px = convert.intToBuffer(P.affineX);
    const r = convert.bufferToInt(signatures[i].slice(0, 32));
    const s = convert.bufferToInt(signatures[i].slice(32, 64));
    check.checkSignatureInput(r, s);
    const e = math.getE(convert.intToBuffer(r), Px, messages[i]);
    const R = math.liftX(signatures[i].slice(0, 32));

    if (i === 0) {
      leftSide = leftSide.add(s);
      rightSide = R;
      rightSide = rightSide.add(P.multiply(e));
    } else {
      const a = math.randomA();
      leftSide = leftSide.add(a.multiply(s));
      rightSide = rightSide.add(R.multiply(a));
      rightSide = rightSide.add(P.multiply(a.multiply(e)));
    }
  }

  if (!G.multiply(leftSide).equals(rightSide)) {
    throw new Error('signature verification failed');
  }
}

module.exports = {
  sign,
  verify,
  batchVerify,
};


/***/ }),

/***/ "./node_modules/bip-schnorr/src/taproot.js":
/*!*************************************************!*\
  !*** ./node_modules/bip-schnorr/src/taproot.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');
const math = __webpack_require__(/*! ./math */ "./node_modules/bip-schnorr/src/math.js");
const convert = __webpack_require__(/*! ./convert */ "./node_modules/bip-schnorr/src/convert.js");

const concat = Buffer.concat;
const G = curve.G;

function taprootConstruct(pubKey, merkleRoot) {
  // If the spending conditions do not require a script path, the output key should commit to an unspendable script path
  // instead of having no script path. This can be achieved by computing the output key point as
  // Q = P + int(hashTapTweak(bytes(P)))G.
  // https://en.bitcoin.it/wiki/BIP_0341#cite_note-22
  if (!merkleRoot || merkleRoot.length === 0) {
    merkleRoot = Buffer.alloc(0, 0);
  }
  const Px = convert.intToBuffer(pubKey.affineX);
  const P = math.liftX(Px);
  const tweak = convert.bufferToInt(math.taggedHash('TapTweak', concat([Px, merkleRoot])));
  const Q = P.add(G.multiply(tweak));
  return convert.intToBuffer(Q.affineX);
}

module.exports = {
  taprootConstruct,
};


/***/ }),

/***/ "./node_modules/bip174/src/lib/combiner/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bip174/src/lib/combiner/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parser_1 = __webpack_require__(/*! ../parser */ "./node_modules/bip174/src/lib/parser/index.js");
function combine(psbts) {
  const self = psbts[0];
  const selfKeyVals = parser_1.psbtToKeyVals(self);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error('Combine: Nothing to combine');
  const selfTx = getTx(self);
  if (selfTx === undefined) {
    throw new Error('Combine: Self missing transaction');
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (
      otherTx === undefined ||
      !otherTx.toBuffer().equals(selfTx.toBuffer())
    ) {
      throw new Error(
        'Combine: One of the Psbts does not have the same transaction.',
      );
    }
    const otherKeyVals = parser_1.psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals,
      ),
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach((inputSet, idx) =>
      inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx],
        ),
      ),
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach((outputSet, idx) =>
      outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx],
        ),
      ),
    );
  }
  return parser_1.psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals,
  });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return key => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = new Set();
  keyVals.forEach(keyVal => {
    const hex = keyVal.key.toString('hex');
    if (set.has(hex))
      throw new Error('Combine: KeyValue Map keys should be unique');
    set.add(hex);
  });
  return set;
}


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/global/globalXpub.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/global/globalXpub.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
const range = n => [...Array(n).keys()];
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      'Decode Error: could not decode globalXpub with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.value.length / 4) % 1 !== 0) {
    throw new Error(
      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: 'm',
  };
  for (const i of range(keyVal.value.length / 4 - 1)) {
    const val = keyVal.value.readUInt32LE(i * 4 + 4);
    const isHard = !!(val & 0x80000000);
    const idx = val & 0x7fffffff;
    data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
  }
  return data;
}
exports.decode = decode;
function encode(data) {
  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
  const key = Buffer.concat([head, data.extendedPubkey]);
  const splitPath = data.path.split('/');
  const value = Buffer.allocUnsafe(splitPath.length * 4);
  data.masterFingerprint.copy(value, 0);
  let offset = 4;
  splitPath.slice(1).forEach(level => {
    const isHard = level.slice(-1) === "'";
    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 0x80000000;
    value.writeUInt32LE(num, offset);
    offset += 4;
  });
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected =
  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';
function check(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return (
    Buffer.isBuffer(epk) &&
    epk.length === 78 &&
    [2, 3].indexOf(epk[45]) > -1 &&
    Buffer.isBuffer(mfp) &&
    mfp.length === 4 &&
    typeof p === 'string' &&
    !!p.match(/^m(\/\d+'?)*$/)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.extendedPubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/global/unsignedTx.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/global/unsignedTx.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer(),
  };
}
exports.encode = encode;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
const globalXpub = __webpack_require__(/*! ./global/globalXpub */ "./node_modules/bip174/src/lib/converter/global/globalXpub.js");
const unsignedTx = __webpack_require__(/*! ./global/unsignedTx */ "./node_modules/bip174/src/lib/converter/global/unsignedTx.js");
const finalScriptSig = __webpack_require__(/*! ./input/finalScriptSig */ "./node_modules/bip174/src/lib/converter/input/finalScriptSig.js");
const finalScriptWitness = __webpack_require__(/*! ./input/finalScriptWitness */ "./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js");
const nonWitnessUtxo = __webpack_require__(/*! ./input/nonWitnessUtxo */ "./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js");
const partialSig = __webpack_require__(/*! ./input/partialSig */ "./node_modules/bip174/src/lib/converter/input/partialSig.js");
const porCommitment = __webpack_require__(/*! ./input/porCommitment */ "./node_modules/bip174/src/lib/converter/input/porCommitment.js");
const sighashType = __webpack_require__(/*! ./input/sighashType */ "./node_modules/bip174/src/lib/converter/input/sighashType.js");
const tapKeySig = __webpack_require__(/*! ./input/tapKeySig */ "./node_modules/bip174/src/lib/converter/input/tapKeySig.js");
const tapLeafScript = __webpack_require__(/*! ./input/tapLeafScript */ "./node_modules/bip174/src/lib/converter/input/tapLeafScript.js");
const tapMerkleRoot = __webpack_require__(/*! ./input/tapMerkleRoot */ "./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js");
const tapScriptSig = __webpack_require__(/*! ./input/tapScriptSig */ "./node_modules/bip174/src/lib/converter/input/tapScriptSig.js");
const witnessUtxo = __webpack_require__(/*! ./input/witnessUtxo */ "./node_modules/bip174/src/lib/converter/input/witnessUtxo.js");
const tapTree = __webpack_require__(/*! ./output/tapTree */ "./node_modules/bip174/src/lib/converter/output/tapTree.js");
const bip32Derivation = __webpack_require__(/*! ./shared/bip32Derivation */ "./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js");
const checkPubkey = __webpack_require__(/*! ./shared/checkPubkey */ "./node_modules/bip174/src/lib/converter/shared/checkPubkey.js");
const redeemScript = __webpack_require__(/*! ./shared/redeemScript */ "./node_modules/bip174/src/lib/converter/shared/redeemScript.js");
const tapBip32Derivation = __webpack_require__(/*! ./shared/tapBip32Derivation */ "./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js");
const tapInternalKey = __webpack_require__(/*! ./shared/tapInternalKey */ "./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js");
const witnessScript = __webpack_require__(/*! ./shared/witnessScript */ "./node_modules/bip174/src/lib/converter/shared/witnessScript.js");
const globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([]),
};
exports.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.InputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.InputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.InputTypes.PARTIAL_SIG,
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.InputTypes.TAP_INTERNAL_KEY,
  ),
  tapMerkleRoot,
};
exports.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.OutputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.OutputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
  ),
};
exports.outputs = outputs;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/finalScriptSig.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/finalScriptSig.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      'Decode Error: could not decode finalScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      'Decode Error: could not decode finalScriptWitness with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData && !!newData && currentData.finalScriptWitness === undefined
  );
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/partialSig.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/partialSig.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
    throw new Error(
      'Decode Error: could not decode partialSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (
    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
    ![2, 3, 4].includes(keyVal.key[1])
  ) {
    throw new Error(
      'Decode Error: partialSig has invalid pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(pSig) {
  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer.concat([head, pSig.pubkey]),
    value: pSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.signature) &&
    [33, 65].includes(data.pubkey.length) &&
    [2, 3, 4].includes(data.pubkey[0]) &&
    isDerSigWithSighash(data.signature)
  );
}
exports.check = check;
function isDerSigWithSighash(buf) {
  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.pubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/porCommitment.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/porCommitment.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
    throw new Error(
      'Decode Error: could not decode porCommitment with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.toString('utf8');
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: Buffer.from(data, 'utf8'),
  };
}
exports.encode = encode;
exports.expected = 'string';
function check(data) {
  return typeof data === 'string';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/sighashType.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/sighashType.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
    throw new Error(
      'Decode Error: could not decode sighashType with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.readUInt32LE(0);
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
  const value = Buffer.allocUnsafe(4);
  value.writeUInt32LE(data, 0);
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected = 'number';
function check(data) {
  return typeof data === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapKeySig.js":
/*!******************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapKeySig.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapKeySig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error(
      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapLeafScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapLeafScript.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      'Decode Error: could not decode tapLeafScript with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      'Decode Error: tapLeafScript has invalid control block in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
    throw new Error(
      'Decode Error: tapLeafScript bad leaf version in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const script = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script, leafVersion };
}
exports.decode = decode;
function encode(tScript) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Buffer.from([tScript.leafVersion]);
  return {
    key: Buffer.concat([head, tScript.controlBlock]),
    value: Buffer.concat([tScript.script, verBuf]),
  };
}
exports.encode = encode;
exports.expected =
  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.controlBlock) &&
    (data.controlBlock.length - 1) % 32 === 0 &&
    (data.controlBlock[0] & 0xfe) === data.leafVersion &&
    Buffer.isBuffer(data.script)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.controlBlock.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapMerkleRoot with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && data.length === 32;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapScriptSig.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapScriptSig.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      'Decode Error: could not decode tapScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid signature in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(tSig) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.leafHash) &&
    Buffer.isBuffer(data.signature) &&
    data.pubkey.length === 32 &&
    data.leafHash.length === 32 &&
    (data.signature.length === 64 || data.signature.length === 65)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString =
    item.pubkey.toString('hex') + item.leafHash.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(
      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),
    ).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/witnessUtxo.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/witnessUtxo.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
const tools_1 = __webpack_require__(/*! ../tools */ "./node_modules/bip174/src/lib/converter/tools.js");
const varuint = __webpack_require__(/*! ../varint */ "./node_modules/bip174/src/lib/converter/varint.js");
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode witnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const value = tools_1.readUInt64LE(keyVal.value, 0);
  let _offset = 8;
  const scriptLen = varuint.decode(keyVal.value, _offset);
  _offset += varuint.encodingLength(scriptLen);
  const script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  return {
    script,
    value,
  };
}
exports.decode = decode;
function encode(data) {
  const { script, value } = data;
  const varintLen = varuint.encodingLength(script.length);
  const result = Buffer.allocUnsafe(8 + varintLen + script.length);
  tools_1.writeUInt64LE(result, value, 0);
  varuint.encode(script.length, result, 8);
  script.copy(result, 8 + varintLen);
  return {
    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
    value: result,
  };
}
exports.encode = encode;
exports.expected = '{ script: Buffer; value: number; }';
function check(data) {
  return Buffer.isBuffer(data.script) && typeof data.value === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/output/tapTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/output/tapTree.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(/*! ../../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
const varuint = __webpack_require__(/*! ../varint */ "./node_modules/bip174/src/lib/converter/varint.js");
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapTree with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  let _offset = 0;
  const data = [];
  while (_offset < keyVal.value.length) {
    const depth = keyVal.value[_offset++];
    const leafVersion = keyVal.value[_offset++];
    const scriptLen = varuint.decode(keyVal.value, _offset);
    _offset += varuint.encodingLength(scriptLen);
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen),
    });
    _offset += scriptLen;
  }
  return { leaves: data };
}
exports.decode = decode;
function encode(tree) {
  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map(tapLeaf => [
      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
      varuint.encode(tapLeaf.script.length),
      tapLeaf.script,
    ]),
  );
  return {
    key,
    value: Buffer.concat(bufs),
  };
}
exports.encode = encode;
exports.expected =
  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';
function check(data) {
  return (
    Array.isArray(data.leaves) &&
    data.leaves.every(
      tapLeaf =>
        tapLeaf.depth >= 0 &&
        tapLeaf.depth <= 128 &&
        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&
        Buffer.isBuffer(tapLeaf.script),
    )
  );
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const range = n => [...Array(n).keys()];
const isValidDERKey = pubkey =>
  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||
  (pubkey.length === 65 && 4 === pubkey[0]);
function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode bip32Derivation with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: 'm',
    };
    for (const i of range(keyVal.value.length / 4 - 1)) {
      const val = keyVal.value.readUInt32LE(i * 4 + 4);
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  function encode(data) {
    const head = Buffer.from([TYPE_BYTE]);
    const key = Buffer.concat([head, data.pubkey]);
    const splitPath = data.path.split('/');
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      value.writeUInt32LE(num, offset);
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  const expected =
    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
  function check(data) {
    return (
      Buffer.isBuffer(data.pubkey) &&
      Buffer.isBuffer(data.masterFingerprint) &&
      typeof data.path === 'string' &&
      isValidPubkey(data.pubkey) &&
      data.masterFingerprint.length === 4
    );
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/checkPubkey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/checkPubkey.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (
        !(pubkey.length === 33 || pubkey.length === 65) ||
        ![2, 3, 4].includes(pubkey[0])
      ) {
        throw new Error(
          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
        );
      }
    }
    return pubkey;
  }
}
exports.makeChecker = makeChecker;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/redeemScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/redeemScript.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode redeemScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const varuint = __webpack_require__(/*! ../varint */ "./node_modules/bip174/src/lib/converter/varint.js");
const bip32Derivation = __webpack_require__(/*! ./bip32Derivation */ "./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js");
const isValidBIP340Key = pubkey => pubkey.length === 32;
function makeConverter(TYPE_BYTE) {
  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
  function decode(keyVal) {
    const nHashes = varuint.decode(keyVal.value);
    const nHashesLen = varuint.encodingLength(nHashes);
    const base = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + nHashes * 32),
    });
    const leafHashes = new Array(nHashes);
    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return Object.assign({}, base, { leafHashes });
  }
  function encode(data) {
    const base = parent.encode(data);
    const nHashesLen = varuint.encodingLength(data.leafHashes.length);
    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
    varuint.encode(data.leafHashes.length, nHashesBuf);
    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
    return Object.assign({}, base, { value });
  }
  const expected =
    '{ ' +
    'masterFingerprint: Buffer; ' +
    'pubkey: Buffer; ' +
    'path: string; ' +
    'leafHashes: Buffer[]; ' +
    '}';
  function check(data) {
    return (
      Array.isArray(data.leafHashes) &&
      data.leafHashes.every(
        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,
      ) &&
      parent.check(data)
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray: parent.canAddToArray,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js":
/*!************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        'Decode Error: could not decode tapInternalKey with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',
      );
    }
    return keyVal.value;
  }
  function encode(value) {
    const key = Buffer.from([TYPE_BYTE]);
    return { key, value };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data) && data.length === 32;
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.tapInternalKey === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/witnessScript.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/witnessScript.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode witnessScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.witnessScript === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/tools.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/tools.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const varuint = __webpack_require__(/*! ./varint */ "./node_modules/bip174/src/lib/converter/varint.js");
exports.range = n => [...Array(n).keys()];
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Buffer.from([0]));
  return Buffer.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = varuint.encodingLength(keyLen);
  const valVarIntLen = varuint.encodingLength(valLen);
  const buffer = Buffer.allocUnsafe(
    keyVarIntLen + keyLen + valVarIntLen + valLen,
  );
  varuint.encode(keyLen, buffer, 0);
  keyVal.key.copy(buffer, keyVarIntLen);
  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}
exports.keyValToBuffer = keyValToBuffer;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;


/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/varint.js":
/*!*********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/varint.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Number.MAX_SAFE_INTEGER
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
    throw new RangeError('value out of range');
}
function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  // 8 bit
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, { bytes: 1 });
    // 16 bit
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, { bytes: 3 });
    // 32 bit
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, { bytes: 5 });
    // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
    Object.assign(encode, { bytes: 9 });
  }
  return buffer;
}
exports.encode = encode;
function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  const first = buffer.readUInt8(offset);
  // 8 bit
  if (first < 0xfd) {
    Object.assign(decode, { bytes: 1 });
    return first;
    // 16 bit
  } else if (first === 0xfd) {
    Object.assign(decode, { bytes: 3 });
    return buffer.readUInt16LE(offset + 1);
    // 32 bit
  } else if (first === 0xfe) {
    Object.assign(decode, { bytes: 5 });
    return buffer.readUInt32LE(offset + 1);
    // 64 bit
  } else {
    Object.assign(decode, { bytes: 9 });
    const lo = buffer.readUInt32LE(offset + 1);
    const hi = buffer.readUInt32LE(offset + 5);
    const _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
}
exports.decode = decode;
function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd
    ? 1
    : _number <= 0xffff
    ? 3
    : _number <= 0xffffffff
    ? 5
    : 9;
}
exports.encodingLength = encodingLength;


/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/fromBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/fromBuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const convert = __webpack_require__(/*! ../converter */ "./node_modules/bip174/src/lib/converter/index.js");
const tools_1 = __webpack_require__(/*! ../converter/tools */ "./node_modules/bip174/src/lib/converter/tools.js");
const varuint = __webpack_require__(/*! ../converter/varint */ "./node_modules/bip174/src/lib/converter/varint.js");
const typeFields_1 = __webpack_require__(/*! ../typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
function psbtFromBuffer(buffer, txGetter) {
  let offset = 0;
  function varSlice() {
    const keyLen = varuint.decode(buffer, offset);
    offset += varuint.encodingLength(keyLen);
    const key = buffer.slice(offset, offset + keyLen);
    offset += keyLen;
    return key;
  }
  function readUInt32BE() {
    const num = buffer.readUInt32BE(offset);
    offset += 4;
    return num;
  }
  function readUInt8() {
    const num = buffer.readUInt8(offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value,
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error('Format Error: Unexpected End of PSBT');
    }
    const isEnd = buffer.readUInt8(offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 0x70736274) {
    throw new Error('Format Error: Invalid Magic Number');
  }
  if (readUInt8() !== 0xff) {
    throw new Error(
      'Format Error: Magic Number must be followed by 0xff separator',
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = keyVal.key.toString('hex');
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        'Format Error: Keys must be unique for global keymap: key ' + hexKey,
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
  }
  const unsignedTx = txGetter(unsignedTxMaps[0].value);
  // Get input and output counts to loop the respective fields
  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each input: ' +
            'input index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each output: ' +
            'output index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals,
  });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (!keyBuf.equals(Buffer.from([keyNum]))) {
    throw new Error(
      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    );
  }
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(
  unsignedTx,
  { globalMapKeyVals, inputKeyVals, outputKeyVals },
) {
  // That was easy :-)
  const globalMap = {
    unsignedTx,
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    // If a globalMap item needs pubkey, uncomment
    // const pubkey = convert.globals.checkPubkey(keyVal);
    switch (keyVal.key[0]) {
      case typeFields_1.GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer(
          'global',
          keyVal.key,
          typeFields_1.GlobalTypes.UNSIGNED_TX,
        );
        if (txCount > 0) {
          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
        }
        txCount++;
        break;
      case typeFields_1.GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === undefined) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
        break;
      default:
        // This will allow inclusion during serialization.
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  // Get input and output counts to loop the respective fields
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs = [];
  const outputs = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      convert.inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.NON_WITNESS_UTXO,
          );
          if (input.nonWitnessUtxo !== undefined) {
            throw new Error(
              'Format Error: Input has multiple NON_WITNESS_UTXO',
            );
          }
          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_UTXO,
          );
          if (input.witnessUtxo !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_UTXO');
          }
          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.PARTIAL_SIG:
          if (input.partialSig === undefined) {
            input.partialSig = [];
          }
          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.SIGHASH_TYPE:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.SIGHASH_TYPE,
          );
          if (input.sighashType !== undefined) {
            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
          }
          input.sighashType = convert.inputs.sighashType.decode(keyVal);
          break;
        case typeFields_1.InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.REDEEM_SCRIPT,
          );
          if (input.redeemScript !== undefined) {
            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
          }
          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_SCRIPT,
          );
          if (input.witnessScript !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
          }
          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === undefined) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            convert.inputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTSIG,
          );
          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
          );
          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
            keyVal,
          );
          break;
        case typeFields_1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.POR_COMMITMENT,
          );
          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_KEY_SIG,
          );
          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
          if (input.tapScriptSig === undefined) {
            input.tapScriptSig = [];
          }
          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
          if (input.tapLeafScript === undefined) {
            input.tapLeafScript = [];
          }
          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
          if (input.tapBip32Derivation === undefined) {
            input.tapBip32Derivation = [];
          }
          input.tapBip32Derivation.push(
            convert.inputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_INTERNAL_KEY,
          );
          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_MERKLE_ROOT,
          );
          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
          break;
        default:
          // This will allow inclusion during serialization.
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      convert.outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.REDEEM_SCRIPT,
          );
          if (output.redeemScript !== undefined) {
            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
          }
          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.WITNESS_SCRIPT,
          );
          if (output.witnessScript !== undefined) {
            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
          }
          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === undefined) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            convert.outputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
          );
          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_TREE,
          );
          output.tapTree = convert.outputs.tapTree.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
          if (output.tapBip32Derivation === undefined) {
            output.tapBip32Derivation = [];
          }
          output.tapBip32Derivation.push(
            convert.outputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs.push(output);
  }
  return { globalMap, inputs, outputs };
}
exports.psbtFromKeyVals = psbtFromKeyVals;


/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(/*! ./fromBuffer */ "./node_modules/bip174/src/lib/parser/fromBuffer.js"));
__export(__webpack_require__(/*! ./toBuffer */ "./node_modules/bip174/src/lib/parser/toBuffer.js"));


/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/toBuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/toBuffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const convert = __webpack_require__(/*! ../converter */ "./node_modules/bip174/src/lib/converter/index.js");
const tools_1 = __webpack_require__(/*! ../converter/tools */ "./node_modules/bip174/src/lib/converter/tools.js");
function psbtToBuffer({ globalMap, inputs, outputs }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs,
    outputs,
  });
  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = keyVals =>
    keyVals.length === 0
      ? [Buffer.from([0])]
      : keyVals.map(tools_1.keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = Buffer.allocUnsafe(5);
  header.writeUIntBE(0x70736274ff, 0, 5);
  return Buffer.concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers),
  );
}
exports.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (a, b) => {
  return a.key.compare(b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === 'unknownKeyVals') return result;
    // We are checking for undefined anyways. So ignore TS error
    // @ts-ignore
    const converter = converterFactory[key];
    if (converter === undefined) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter.encode,
    );
    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
    keyHexes.forEach(hex => {
      if (keyHexSet.has(hex))
        throw new Error('Serialize Error: Duplicate key: ' + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  // Get other keyVals that have not yet been gotten
  const otherKeyVals = keyValMap.unknownKeyVals
    ? keyValMap.unknownKeyVals.filter(keyVal => {
        return !keyHexSet.has(keyVal.key.toString('hex'));
      })
    : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs, outputs }) {
  // First parse the global keyVals
  // Get any extra keyvals to pass along
  return {
    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
  };
}
exports.psbtToKeyVals = psbtToKeyVals;


/***/ }),

/***/ "./node_modules/bip174/src/lib/psbt.js":
/*!*********************************************!*\
  !*** ./node_modules/bip174/src/lib/psbt.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const combiner_1 = __webpack_require__(/*! ./combiner */ "./node_modules/bip174/src/lib/combiner/index.js");
const parser_1 = __webpack_require__(/*! ./parser */ "./node_modules/bip174/src/lib/parser/index.js");
const typeFields_1 = __webpack_require__(/*! ./typeFields */ "./node_modules/bip174/src/lib/typeFields.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/bip174/src/lib/utils.js");
class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx,
    };
  }
  static fromBase64(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromHex(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromBuffer(buffer, txFromBuffer) {
    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer = this.toBuffer();
    return buffer.toString('base64');
  }
  toHex() {
    const buffer = this.toBuffer();
    return buffer.toString('hex');
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    utils_1.updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    utils_1.checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.GlobalTypes),
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.checkHasKey(
      keyVal,
      input.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.InputTypes),
    );
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.checkHasKey(
      keyVal,
      output.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.OutputTypes),
    );
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(inputIndex, keyVal),
    );
    utils_1.addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(outputIndex, keyVal),
    );
    utils_1.addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (
        ![
          'witnessUtxo',
          'nonWitnessUtxo',
          'finalScriptSig',
          'finalScriptWitness',
          'unknownKeyVals',
        ].includes(key)
      ) {
        // @ts-ignore
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    // Combine this with those.
    // Return self for chaining.
    const result = combiner_1.combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
}
exports.Psbt = Psbt;


/***/ }),

/***/ "./node_modules/bip174/src/lib/typeFields.js":
/*!***************************************************!*\
  !*** ./node_modules/bip174/src/lib/typeFields.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var GlobalTypes;
(function(GlobalTypes) {
  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
var InputTypes;
(function(InputTypes) {
  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';
  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';
  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';
  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =
    'TAP_BIP32_DERIVATION';
  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';
  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';
})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
exports.INPUT_TYPE_NAMES = [
  'nonWitnessUtxo',
  'witnessUtxo',
  'partialSig',
  'sighashType',
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'finalScriptSig',
  'finalScriptWitness',
  'porCommitment',
  'tapKeySig',
  'tapScriptSig',
  'tapLeafScript',
  'tapBip32Derivation',
  'tapInternalKey',
  'tapMerkleRoot',
];
var OutputTypes;
(function(OutputTypes) {
  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';
  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';
  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =
    'TAP_BIP32_DERIVATION';
})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
exports.OUTPUT_TYPE_NAMES = [
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'tapInternalKey',
  'tapTree',
  'tapBip32Derivation',
];


/***/ }),

/***/ "./node_modules/bip174/src/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/bip174/src/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const converter = __webpack_require__(/*! ./converter */ "./node_modules/bip174/src/lib/converter/index.js");
function checkForInput(inputs, inputIndex) {
  const input = inputs[inputIndex];
  if (input === undefined) throw new Error(`No input #${inputIndex}`);
  return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === undefined) throw new Error(`No output #${outputIndex}`);
  return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`,
    );
  }
  if (
    keyVals &&
    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
  ) {
    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
  }
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach(val => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`,
    );
  }
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ` +
      `${expected} and got ${JSON.stringify(data)}`,
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      // @ts-ignore
      const data = updateData[name];
      // @ts-ignore
      const { canAdd, canAddToArray, check, expected } =
        // @ts-ignore
        converter[typeName + 's'][name] || {};
      const isArray = !!canAddToArray;
      // If unknown data. ignore and do not add
      if (check) {
        if (isArray) {
          if (
            !Array.isArray(data) ||
            // @ts-ignore
            (mainData[name] && !Array.isArray(mainData[name]))
          ) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          // @ts-ignore
          const arr = mainData[name] || [];
          const dupeCheckSet = new Set();
          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
            throw new Error('Can not add duplicate data to array');
          }
          // @ts-ignore
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          // @ts-ignore
          mainData[name] = data;
        }
      }
    }
  };
}
exports.updateGlobal = updateMaker('global');
exports.updateInput = updateMaker('input');
exports.updateOutput = updateMaker('output');
function addInputAttributes(inputs, data) {
  const index = inputs.length - 1;
  const input = checkForInput(inputs, index);
  exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
  const index = outputs.length - 1;
  const output = checkForOutput(outputs, index);
  exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Version: Invalid Transaction');
  }
  txBuf.writeUInt32LE(version, 0);
  return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Locktime: Invalid Transaction');
  }
  txBuf.writeUInt32LE(locktime, txBuf.length - 4);
  return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/address.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/address.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toOutputScript =
  exports.fromOutputScript =
  exports.toBech32 =
  exports.toBase58Check =
  exports.fromBech32 =
  exports.fromBase58Check =
    void 0;
const networks = __webpack_require__(/*! ./networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const payments = __webpack_require__(/*! ./payments */ "./node_modules/bitcoinjs-lib/src/payments/index.js");
const bscript = __webpack_require__(/*! ./script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js");
const bs58check = __webpack_require__(/*! bs58check */ "./node_modules/bs58check/index.js");
const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 2;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
const FUTURE_SEGWIT_VERSION_WARNING =
  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +
  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +
  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +
  'then decide when it is safe to use which version of segwit.';
function _toFutureSegwitAddress(output, network) {
  const data = output.slice(2);
  if (
    data.length < FUTURE_SEGWIT_MIN_SIZE ||
    data.length > FUTURE_SEGWIT_MAX_SIZE
  )
    throw new TypeError('Invalid program length for segwit address');
  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (
    version < FUTURE_SEGWIT_MIN_VERSION ||
    version > FUTURE_SEGWIT_MAX_VERSION
  )
    throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length)
    throw new TypeError('Invalid script for segwit address');
  console.warn(FUTURE_SEGWIT_VERSION_WARNING);
  return toBech32(data, version, network.bech32);
}
function fromBase58Check(address) {
  const payload = Buffer.from(bs58check.decode(address));
  // TODO: 4.0.0, move to "toOutputScript"
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  const version = payload.readUint8(0);
  const hash = payload.slice(1);
  return { version, hash };
}
exports.fromBase58Check = fromBase58Check;
function fromBech32(address) {
  let result;
  let version;
  try {
    result = bech32_1.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = bech32_1.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  const data = bech32_1.bech32.fromWords(result.words.slice(1));
  return {
    version,
    prefix: result.prefix,
    data: Buffer.from(data),
  };
}
exports.fromBech32 = fromBech32;
function toBase58Check(hash, version) {
  (0, types_1.typeforce)(
    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
    arguments,
  );
  const payload = Buffer.allocUnsafe(21);
  payload.writeUInt8(version, 0);
  hash.copy(payload, 1);
  return bs58check.encode(payload);
}
exports.toBase58Check = toBase58Check;
function toBech32(data, version, prefix) {
  const words = bech32_1.bech32.toWords(data);
  words.unshift(version);
  return version === 0
    ? bech32_1.bech32.encode(prefix, words)
    : bech32_1.bech32m.encode(prefix, words);
}
exports.toBech32 = toBech32;
function fromOutputScript(output, network) {
  // TODO: Network
  network = network || networks.bitcoin;
  try {
    return payments.p2pkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2sh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wpkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wsh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2tr({ output, network }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(bscript.toASM(output) + ' has no matching Address');
}
exports.fromOutputScript = fromOutputScript;
function toOutputScript(address, network) {
  network = network || networks.bitcoin;
  let decodeBase58;
  let decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash)
      return payments.p2pkh({ hash: decodeBase58.hash }).output;
    if (decodeBase58.version === network.scriptHash)
      return payments.p2sh({ hash: decodeBase58.hash }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {}
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32)
        throw new Error(address + ' has an invalid prefix');
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20)
          return payments.p2wpkh({ hash: decodeBech32.data }).output;
        if (decodeBech32.data.length === 32)
          return payments.p2wsh({ hash: decodeBech32.data }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32)
          return payments.p2tr({ pubkey: decodeBech32.data }).output;
      } else if (
        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE
      ) {
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return bscript.compile([
          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
          decodeBech32.data,
        ]);
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}
exports.toOutputScript = toOutputScript;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/bip66.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/bip66.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = exports.check = void 0;
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  const lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  const lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    return false;
  return true;
}
exports.check = check;
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2)
    throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  const lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  const lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
    throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    throw new Error('S value excessively padded');
  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR),
  };
}
exports.decode = decode;
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode(r, s) {
  const lenR = r.length;
  const lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
    throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
    throw new Error('S value excessively padded');
  const signature = Buffer.allocUnsafe(6 + lenR + lenS);
  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
exports.encode = encode;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/block.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/block.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Block = void 0;
const bufferutils_1 = __webpack_require__(/*! ./bufferutils */ "./node_modules/bitcoinjs-lib/src/bufferutils.js");
const bcrypto = __webpack_require__(/*! ./crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const merkle_1 = __webpack_require__(/*! ./merkle */ "./node_modules/bitcoinjs-lib/src/merkle.js");
const transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/bitcoinjs-lib/src/transaction.js");
const types = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const { typeforce } = types;
const errorMerkleNoTxes = new TypeError(
  'Cannot compute merkle root for zero transactions',
);
const errorWitnessNotSegwit = new TypeError(
  'Cannot compute witness commit for non-segwit block',
);
class Block {
  constructor() {
    this.version = 1;
    this.prevHash = undefined;
    this.merkleRoot = undefined;
    this.timestamp = 0;
    this.witnessCommit = undefined;
    this.bits = 0;
    this.nonce = 0;
    this.transactions = undefined;
  }
  static fromBuffer(buffer) {
    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const block = new Block();
    block.version = bufferReader.readInt32();
    block.prevHash = bufferReader.readSlice(32);
    block.merkleRoot = bufferReader.readSlice(32);
    block.timestamp = bufferReader.readUInt32();
    block.bits = bufferReader.readUInt32();
    block.nonce = bufferReader.readUInt32();
    if (buffer.length === 80) return block;
    const readTransaction = () => {
      const tx = transaction_1.Transaction.fromBuffer(
        bufferReader.buffer.slice(bufferReader.offset),
        true,
      );
      bufferReader.offset += tx.byteLength();
      return tx;
    };
    const nTransactions = bufferReader.readVarInt();
    block.transactions = [];
    for (let i = 0; i < nTransactions; ++i) {
      const tx = readTransaction();
      block.transactions.push(tx);
    }
    const witnessCommit = block.getWitnessCommit();
    // This Block contains a witness commit
    if (witnessCommit) block.witnessCommit = witnessCommit;
    return block;
  }
  static fromHex(hex) {
    return Block.fromBuffer(Buffer.from(hex, 'hex'));
  }
  static calculateTarget(bits) {
    const exponent = ((bits & 0xff000000) >> 24) - 3;
    const mantissa = bits & 0x007fffff;
    const target = Buffer.alloc(32, 0);
    target.writeUIntBE(mantissa, 29 - exponent, 3);
    return target;
  }
  static calculateMerkleRoot(transactions, forWitness) {
    typeforce([{ getHash: types.Function }], transactions);
    if (transactions.length === 0) throw errorMerkleNoTxes;
    if (forWitness && !txesHaveWitnessCommit(transactions))
      throw errorWitnessNotSegwit;
    const hashes = transactions.map(transaction =>
      transaction.getHash(forWitness),
    );
    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
    return forWitness
      ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),
        )
      : rootHash;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    // The merkle root for the witness data is in an OP_RETURN output.
    // There is no rule for the index of the output, so use filter to find it.
    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
    // If multiple commits are found, the output with highest index is assumed.
    const witnessCommits = this.transactions[0].outs
      .filter(out =>
        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),
      )
      .map(out => out.script.slice(6, 38));
    if (witnessCommits.length === 0) return null;
    // Use the commit with the highest output (should only be one though)
    const result = witnessCommits[witnessCommits.length - 1];
    if (!(result instanceof Buffer && result.length === 32)) return null;
    return result;
  }
  hasWitnessCommit() {
    if (
      this.witnessCommit instanceof Buffer &&
      this.witnessCommit.length === 32
    )
      return true;
    if (this.getWitnessCommit() !== null) return true;
    return false;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const base = this.byteLength(false, false);
    const total = this.byteLength(false, true);
    return base * 3 + total;
  }
  byteLength(headersOnly, allowWitness = true) {
    if (headersOnly || !this.transactions) return 80;
    return (
      80 +
      bufferutils_1.varuint.encodingLength(this.transactions.length) +
      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)
    );
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(true));
  }
  getId() {
    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');
  }
  getUTCDate() {
    const date = new Date(0); // epoch
    date.setUTCSeconds(this.timestamp);
    return date;
  }
  // TODO: buffer, offset compatibility
  toBuffer(headersOnly) {
    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
    const bufferWriter = new bufferutils_1.BufferWriter(buffer);
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(this.prevHash);
    bufferWriter.writeSlice(this.merkleRoot);
    bufferWriter.writeUInt32(this.timestamp);
    bufferWriter.writeUInt32(this.bits);
    bufferWriter.writeUInt32(this.nonce);
    if (headersOnly || !this.transactions) return buffer;
    bufferutils_1.varuint.encode(
      this.transactions.length,
      buffer,
      bufferWriter.offset,
    );
    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
    this.transactions.forEach(tx => {
      const txSize = tx.byteLength(); // TODO: extract from toBuffer?
      tx.toBuffer(buffer, bufferWriter.offset);
      bufferWriter.offset += txSize;
    });
    return buffer;
  }
  toHex(headersOnly) {
    return this.toBuffer(headersOnly).toString('hex');
  }
  checkTxRoots() {
    // If the Block has segwit transactions but no witness commit,
    // there's no way it can be valid, so fail the check.
    const hasWitnessCommit = this.hasWitnessCommit();
    if (!hasWitnessCommit && this.hasWitness()) return false;
    return (
      this.__checkMerkleRoot() &&
      (hasWitnessCommit ? this.__checkWitnessCommit() : true)
    );
  }
  checkProofOfWork() {
    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
    const target = Block.calculateTarget(this.bits);
    return hash.compare(target) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(actualMerkleRoot) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const actualWitnessCommit = Block.calculateMerkleRoot(
      this.transactions,
      true,
    );
    return this.witnessCommit.compare(actualWitnessCommit) === 0;
  }
}
exports.Block = Block;
function txesHaveWitnessCommit(transactions) {
  return (
    transactions instanceof Array &&
    transactions[0] &&
    transactions[0].ins &&
    transactions[0].ins instanceof Array &&
    transactions[0].ins[0] &&
    transactions[0].ins[0].witness &&
    transactions[0].ins[0].witness instanceof Array &&
    transactions[0].ins[0].witness.length > 0
  );
}
function anyTxHasWitness(transactions) {
  return (
    transactions instanceof Array &&
    transactions.some(
      tx =>
        typeof tx === 'object' &&
        tx.ins instanceof Array &&
        tx.ins.some(
          input =>
            typeof input === 'object' &&
            input.witness instanceof Array &&
            input.witness.length > 0,
        ),
    )
  );
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/bufferutils.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/bufferutils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferReader =
  exports.BufferWriter =
  exports.cloneBuffer =
  exports.reverseBuffer =
  exports.writeUInt64LE =
  exports.readUInt64LE =
  exports.varuint =
    void 0;
const types = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const { typeforce } = types;
const varuint = __webpack_require__(/*! varuint-bitcoin */ "./node_modules/varuint-bitcoin/index.js");
exports.varuint = varuint;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
  const clone = Buffer.allocUnsafe(buffer.length);
  buffer.copy(clone);
  return clone;
}
exports.cloneBuffer = cloneBuffer;
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */
class BufferWriter {
  static withCapacity(size) {
    return new BufferWriter(Buffer.alloc(size));
  }
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  writeUInt8(i) {
    this.offset = this.buffer.writeUInt8(i, this.offset);
  }
  writeInt32(i) {
    this.offset = this.buffer.writeInt32LE(i, this.offset);
  }
  writeUInt32(i) {
    this.offset = this.buffer.writeUInt32LE(i, this.offset);
  }
  writeUInt64(i) {
    this.offset = writeUInt64LE(this.buffer, i, this.offset);
  }
  writeVarInt(i) {
    varuint.encode(i, this.buffer, this.offset);
    this.offset += varuint.encode.bytes;
  }
  writeSlice(slice) {
    if (this.buffer.length < this.offset + slice.length) {
      throw new Error('Cannot write slice out of bounds');
    }
    this.offset += slice.copy(this.buffer, this.offset);
  }
  writeVarSlice(slice) {
    this.writeVarInt(slice.length);
    this.writeSlice(slice);
  }
  writeVector(vector) {
    this.writeVarInt(vector.length);
    vector.forEach(buf => this.writeVarSlice(buf));
  }
  end() {
    if (this.buffer.length === this.offset) {
      return this.buffer;
    }
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */
class BufferReader {
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  readUInt8() {
    const result = this.buffer.readUInt8(this.offset);
    this.offset++;
    return result;
  }
  readInt32() {
    const result = this.buffer.readInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt32() {
    const result = this.buffer.readUInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt64() {
    const result = readUInt64LE(this.buffer, this.offset);
    this.offset += 8;
    return result;
  }
  readVarInt() {
    const vi = varuint.decode(this.buffer, this.offset);
    this.offset += varuint.decode.bytes;
    return vi;
  }
  readSlice(n) {
    if (this.buffer.length < this.offset + n) {
      throw new Error('Cannot read slice out of bounds');
    }
    const result = this.buffer.slice(this.offset, this.offset + n);
    this.offset += n;
    return result;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const count = this.readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
    return vector;
  }
}
exports.BufferReader = BufferReader;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taggedHash =
  exports.TAGGED_HASH_PREFIXES =
  exports.TAGS =
  exports.hash256 =
  exports.hash160 =
  exports.sha256 =
  exports.sha1 =
  exports.ripemd160 =
    void 0;
const ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "./node_modules/@noble/hashes/ripemd160.js");
const sha1_1 = __webpack_require__(/*! @noble/hashes/sha1 */ "./node_modules/@noble/hashes/sha1.js");
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/sha256.js");
function ripemd160(buffer) {
  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
}
exports.sha1 = sha1;
function sha256(buffer) {
  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
}
exports.sha256 = sha256;
function hash160(buffer) {
  return Buffer.from(
    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash160 = hash160;
function hash256(buffer) {
  return Buffer.from(
    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash256 = hash256;
exports.TAGS = [
  'BIP0340/challenge',
  'BIP0340/aux',
  'BIP0340/nonce',
  'TapLeaf',
  'TapBranch',
  'TapSighash',
  'TapTweak',
  'KeyAgg list',
  'KeyAgg coefficient',
];
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
exports.TAGGED_HASH_PREFIXES = {
  'BIP0340/challenge': Buffer.from([
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
  ]),
  'BIP0340/aux': Buffer.from([
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
  ]),
  'BIP0340/nonce': Buffer.from([
    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,
    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,
    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,
    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,
  ]),
  TapLeaf: Buffer.from([
    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,
    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,
    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,
    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,
  ]),
  TapBranch: Buffer.from([
    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,
    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,
    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,
    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,
  ]),
  TapSighash: Buffer.from([
    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,
    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,
    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,
    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,
  ]),
  TapTweak: Buffer.from([
    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,
    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,
    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,
    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,
  ]),
  'KeyAgg list': Buffer.from([
    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,
    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,
    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,
    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,
  ]),
  'KeyAgg coefficient': Buffer.from([
    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,
    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,
    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,
    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,
  ]),
};
function taggedHash(prefix, data) {
  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
}
exports.taggedHash = taggedHash;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/ecc_lib.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/ecc_lib.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEccLib = exports.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(eccLib) {
  if (!eccLib) {
    // allow clearing the library
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    // new instance, verify it
    verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
exports.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',
    );
  return _ECCLIB_CACHE.eccLib;
}
exports.getEccLib = getEccLib;
const h = hex => Buffer.from(hex, 'hex');
function verifyEcc(ecc) {
  assert(typeof ecc.isXOnlyPoint === 'function');
  assert(
    ecc.isXOnlyPoint(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000001'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    ),
  );
  assert(typeof ecc.xOnlyPointAddTweak === 'function');
  tweakAddVectors.forEach(t => {
    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}
const tweakAddVectors = [
  {
    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
    parity: -1,
    result: null,
  },
  {
    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
    parity: 1,
    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',
  },
  {
    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
    parity: 0,
    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',
  },
];


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initEccLib =
  exports.Transaction =
  exports.opcodes =
  exports.Psbt =
  exports.Block =
  exports.script =
  exports.payments =
  exports.networks =
  exports.crypto =
  exports.address =
    void 0;
const address = __webpack_require__(/*! ./address */ "./node_modules/bitcoinjs-lib/src/address.js");
exports.address = address;
const crypto = __webpack_require__(/*! ./crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
exports.crypto = crypto;
const networks = __webpack_require__(/*! ./networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
exports.networks = networks;
const payments = __webpack_require__(/*! ./payments */ "./node_modules/bitcoinjs-lib/src/payments/index.js");
exports.payments = payments;
const script = __webpack_require__(/*! ./script */ "./node_modules/bitcoinjs-lib/src/script.js");
exports.script = script;
var block_1 = __webpack_require__(/*! ./block */ "./node_modules/bitcoinjs-lib/src/block.js");
Object.defineProperty(exports, "Block", ({
  enumerable: true,
  get: function () {
    return block_1.Block;
  },
}));
var psbt_1 = __webpack_require__(/*! ./psbt */ "./node_modules/bitcoinjs-lib/src/psbt.js");
Object.defineProperty(exports, "Psbt", ({
  enumerable: true,
  get: function () {
    return psbt_1.Psbt;
  },
}));
var ops_1 = __webpack_require__(/*! ./ops */ "./node_modules/bitcoinjs-lib/src/ops.js");
Object.defineProperty(exports, "opcodes", ({
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
}));
var transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/bitcoinjs-lib/src/transaction.js");
Object.defineProperty(exports, "Transaction", ({
  enumerable: true,
  get: function () {
    return transaction_1.Transaction;
  },
}));
var ecc_lib_1 = __webpack_require__(/*! ./ecc_lib */ "./node_modules/bitcoinjs-lib/src/ecc_lib.js");
Object.defineProperty(exports, "initEccLib", ({
  enumerable: true,
  get: function () {
    return ecc_lib_1.initEccLib;
  },
}));


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/merkle.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/merkle.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fastMerkleRoot = void 0;
function fastMerkleRoot(values, digestFn) {
  if (!Array.isArray(values)) throw TypeError('Expected values Array');
  if (typeof digestFn !== 'function')
    throw TypeError('Expected digest Function');
  let length = values.length;
  const results = values.concat();
  while (length > 1) {
    let j = 0;
    for (let i = 0; i < length; i += 2, ++j) {
      const left = results[i];
      const right = i + 1 === length ? left : results[i + 1];
      const data = Buffer.concat([left, right]);
      results[j] = digestFn(data);
    }
    length = j;
  }
  return results[0];
}
exports.fastMerkleRoot = fastMerkleRoot;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/networks.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/networks.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testnet = exports.regtest = exports.bitcoin = void 0;
exports.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};
exports.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/ops.js":
/*!***********************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/ops.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REVERSE_OPS = exports.OPS = void 0;
const OPS = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255,
};
exports.OPS = OPS;
const REVERSE_OPS = {};
exports.REVERSE_OPS = REVERSE_OPS;
for (const op of Object.keys(OPS)) {
  const code = OPS[op];
  REVERSE_OPS[code] = op;
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/bip341.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/bip341.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tweakKey =
  exports.tapTweakHash =
  exports.tapleafHash =
  exports.findScriptPath =
  exports.toHashTree =
  exports.rootHashFromPath =
  exports.MAX_TAPTREE_DEPTH =
  exports.LEAF_VERSION_TAPSCRIPT =
    void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ "./node_modules/bitcoinjs-lib/src/ecc_lib.js");
const bcrypto = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const bufferutils_1 = __webpack_require__(/*! ../bufferutils */ "./node_modules/bitcoinjs-lib/src/bufferutils.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
exports.LEAF_VERSION_TAPSCRIPT = 0xc0;
exports.MAX_TAPTREE_DEPTH = 128;
const isHashBranch = ht => 'left' in ht && 'right' in ht;
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
    );
  const m = (controlBlock.length - 33) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (kj.compare(ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
exports.rootHashFromPath = rootHashFromPath;
/**
 * Build a hash tree of merkle nodes from the scripts binary tree.
 * @param scriptTree - the tree of scripts to pairwise hash.
 */
function toHashTree(scriptTree) {
  if ((0, types_1.isTapleaf)(scriptTree))
    return { hash: tapleafHash(scriptTree) };
  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes.sort((a, b) => a.hash.compare(b.hash));
  const [left, right] = hashes;
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left,
    right,
  };
}
exports.toHashTree = toHashTree;
/**
 * Given a HashTree, finds the path from a particular hash to the root.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - array of sibling hashes, from leaf (inclusive) to root
 * (exclusive) needed to prove inclusion of the specified hash. undefined if no
 * path is found
 */
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    const leftPath = findScriptPath(node.left, hash);
    if (leftPath !== undefined) return [...leftPath, node.right.hash];
    const rightPath = findScriptPath(node.right, hash);
    if (rightPath !== undefined) return [...rightPath, node.left.hash];
  } else if (node.hash.equals(hash)) {
    return [];
  }
  return undefined;
}
exports.findScriptPath = findScriptPath;
function tapleafHash(leaf) {
  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
  return bcrypto.taggedHash(
    'TapLeaf',
    buffer_1.Buffer.concat([
      buffer_1.Buffer.from([version]),
      serializeScript(leaf.output),
    ]),
  );
}
exports.tapleafHash = tapleafHash;
function tapTweakHash(pubKey, h) {
  return bcrypto.taggedHash(
    'TapTweak',
    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),
  );
}
exports.tapTweakHash = tapTweakHash;
function tweakKey(pubKey, h) {
  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
  if (pubKey.length !== 32) return null;
  if (h && h.length !== 32) return null;
  const tweakHash = tapTweakHash(pubKey, h);
  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: buffer_1.Buffer.from(res.xOnlyPubkey),
  };
}
exports.tweakKey = tweakKey;
function tapBranchHash(a, b) {
  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));
}
function serializeScript(s) {
  const varintLen = bufferutils_1.varuint.encodingLength(s.length);
  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better
  bufferutils_1.varuint.encode(s.length, buffer);
  return buffer_1.Buffer.concat([buffer, s]);
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/embed.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/embed.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2data = void 0;
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// output: OP_RETURN ...
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      data: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'embed', network };
  lazy.prop(o, 'output', () => {
    if (!a.data) return;
    return bscript.compile([OPS.OP_RETURN].concat(a.data));
  });
  lazy.prop(o, 'data', () => {
    if (!a.output) return;
    return bscript.decompile(a.output).slice(1);
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      const chunks = bscript.decompile(a.output);
      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
      if (!chunks.slice(1).every(types_1.typeforce.Buffer))
        throw new TypeError('Output is invalid');
      if (a.data && !stacksEqual(a.data, o.data))
        throw new TypeError('Data mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2data = p2data;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2tr =
  exports.p2wsh =
  exports.p2wpkh =
  exports.p2sh =
  exports.p2pkh =
  exports.p2pk =
  exports.p2ms =
  exports.embed =
    void 0;
const embed_1 = __webpack_require__(/*! ./embed */ "./node_modules/bitcoinjs-lib/src/payments/embed.js");
Object.defineProperty(exports, "embed", ({
  enumerable: true,
  get: function () {
    return embed_1.p2data;
  },
}));
const p2ms_1 = __webpack_require__(/*! ./p2ms */ "./node_modules/bitcoinjs-lib/src/payments/p2ms.js");
Object.defineProperty(exports, "p2ms", ({
  enumerable: true,
  get: function () {
    return p2ms_1.p2ms;
  },
}));
const p2pk_1 = __webpack_require__(/*! ./p2pk */ "./node_modules/bitcoinjs-lib/src/payments/p2pk.js");
Object.defineProperty(exports, "p2pk", ({
  enumerable: true,
  get: function () {
    return p2pk_1.p2pk;
  },
}));
const p2pkh_1 = __webpack_require__(/*! ./p2pkh */ "./node_modules/bitcoinjs-lib/src/payments/p2pkh.js");
Object.defineProperty(exports, "p2pkh", ({
  enumerable: true,
  get: function () {
    return p2pkh_1.p2pkh;
  },
}));
const p2sh_1 = __webpack_require__(/*! ./p2sh */ "./node_modules/bitcoinjs-lib/src/payments/p2sh.js");
Object.defineProperty(exports, "p2sh", ({
  enumerable: true,
  get: function () {
    return p2sh_1.p2sh;
  },
}));
const p2wpkh_1 = __webpack_require__(/*! ./p2wpkh */ "./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js");
Object.defineProperty(exports, "p2wpkh", ({
  enumerable: true,
  get: function () {
    return p2wpkh_1.p2wpkh;
  },
}));
const p2wsh_1 = __webpack_require__(/*! ./p2wsh */ "./node_modules/bitcoinjs-lib/src/payments/p2wsh.js");
Object.defineProperty(exports, "p2wsh", ({
  enumerable: true,
  get: function () {
    return p2wsh_1.p2wsh;
  },
}));
const p2tr_1 = __webpack_require__(/*! ./p2tr */ "./node_modules/bitcoinjs-lib/src/payments/p2tr.js");
Object.defineProperty(exports, "p2tr", ({
  enumerable: true,
  get: function () {
    return p2tr_1.p2tr;
  },
}));
// TODO
// witness commitment


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/lazy.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/lazy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.value = exports.prop = void 0;
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get() {
      const _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true,
      });
    },
  });
}
exports.prop = prop;
function value(f) {
  let _value;
  return () => {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}
exports.value = value;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2ms.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2ms.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2ms = void 0;
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const OPS = bscript.OPS;
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
function p2ms(a, opts) {
  if (
    !a.input &&
    !a.output &&
    !(a.pubkeys && a.m !== undefined) &&
    !a.signatures
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  function isAcceptableSignature(x) {
    return (
      bscript.isCanonicalScriptSignature(x) ||
      (opts.allowIncomplete && x === OPS.OP_0) !== undefined
    );
  }
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      m: types_1.typeforce.maybe(types_1.typeforce.Number),
      n: types_1.typeforce.maybe(types_1.typeforce.Number),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkeys: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.isPoint),
      ),
      signatures: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(isAcceptableSignature),
      ),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { network };
  let chunks = [];
  let decoded = false;
  function decode(output) {
    if (decoded) return;
    decoded = true;
    chunks = bscript.decompile(output);
    o.m = chunks[0] - OP_INT_BASE;
    o.n = chunks[chunks.length - 2] - OP_INT_BASE;
    o.pubkeys = chunks.slice(1, -2);
  }
  lazy.prop(o, 'output', () => {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return bscript.compile(
      [].concat(
        OP_INT_BASE + a.m,
        a.pubkeys,
        OP_INT_BASE + o.n,
        OPS.OP_CHECKMULTISIG,
      ),
    );
  });
  lazy.prop(o, 'm', () => {
    if (!o.output) return;
    decode(o.output);
    return o.m;
  });
  lazy.prop(o, 'n', () => {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  lazy.prop(o, 'pubkeys', () => {
    if (!a.output) return;
    decode(a.output);
    return o.pubkeys;
  });
  lazy.prop(o, 'signatures', () => {
    if (!a.input) return;
    return bscript.decompile(a.input).slice(1);
  });
  lazy.prop(o, 'input', () => {
    if (!a.signatures) return;
    return bscript.compile([OPS.OP_0].concat(a.signatures));
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'name', () => {
    if (!o.m || !o.n) return;
    return `p2ms(${o.m} of ${o.n})`;
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      decode(a.output);
      if (!types_1.typeforce.Number(chunks[0]))
        throw new TypeError('Output is invalid');
      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
        throw new TypeError('Output is invalid');
      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
        throw new TypeError('Output is invalid');
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
        throw new TypeError('Output is invalid');
      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))
        throw new TypeError('Output is invalid');
      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
        throw new TypeError('Pubkeys mismatch');
    }
    if (a.pubkeys) {
      if (a.n !== undefined && a.n !== a.pubkeys.length)
        throw new TypeError('Pubkey count mismatch');
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
    }
    if (a.signatures) {
      if (a.signatures.length < o.m)
        throw new TypeError('Not enough signatures provided');
      if (a.signatures.length > o.m)
        throw new TypeError('Too many signatures provided');
    }
    if (a.input) {
      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
      if (
        o.signatures.length === 0 ||
        !o.signatures.every(isAcceptableSignature)
      )
        throw new TypeError('Input has invalid signature(s)');
      if (a.signatures && !stacksEqual(a.signatures, o.signatures))
        throw new TypeError('Signature mismatch');
      if (a.m !== undefined && a.m !== a.signatures.length)
        throw new TypeError('Signature count mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2ms = p2ms;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pk.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pk.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2pk = void 0;
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const OPS = bscript.OPS;
// input: {signature}
// output: {pubKey} OP_CHECKSIG
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pk', network };
  lazy.prop(o, 'output', () => {
    if (!a.pubkey) return;
    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.signature) return;
    return bscript.compile([a.signature]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
        throw new TypeError('Output is invalid');
      if (!(0, types_1.isPoint)(o.pubkey))
        throw new TypeError('Output pubkey is invalid');
      if (a.pubkey && !a.pubkey.equals(o.pubkey))
        throw new TypeError('Pubkey mismatch');
    }
    if (a.signature) {
      if (a.input && !a.input.equals(o.input))
        throw new TypeError('Signature mismatch');
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(o.signature))
        throw new TypeError('Input has invalid signature');
    }
  }
  return Object.assign(o, a);
}
exports.p2pk = p2pk;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pkh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pkh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2pkh = void 0;
const bcrypto = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const bs58check = __webpack_require__(/*! bs58check */ "./node_modules/bs58check/index.js");
const OPS = bscript.OPS;
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(network.pubKeyHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([
      OPS.OP_DUP,
      OPS.OP_HASH160,
      o.hash,
      OPS.OP_EQUALVERIFY,
      OPS.OP_CHECKSIG,
    ]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.input) return;
    return _chunks()[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return bscript.compile([a.signature, a.pubkey]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 25 ||
        a.output[0] !== OPS.OP_DUP ||
        a.output[1] !== OPS.OP_HASH160 ||
        a.output[2] !== 0x14 ||
        a.output[23] !== OPS.OP_EQUALVERIFY ||
        a.output[24] !== OPS.OP_CHECKSIG
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
    }
    if (a.input) {
      const chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(chunks[0]))
        throw new TypeError('Input has invalid signature');
      if (!(0, types_1.isPoint)(chunks[1]))
        throw new TypeError('Input has invalid pubkey');
      if (a.signature && !a.signature.equals(chunks[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(chunks[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(chunks[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2pkh = p2pkh;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2sh.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2sh.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2sh = void 0;
const bcrypto = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const bs58check = __webpack_require__(/*! bs58check */ "./node_modules/bs58check/index.js");
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
      redeem: types_1.typeforce.maybe({
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const _redeem = lazy.value(() => {
    const chunks = _chunks();
    const lastChunk = chunks[chunks.length - 1];
    return {
      network,
      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
      input: bscript.compile(chunks.slice(0, -1)),
      witness: a.witness || [],
    };
  });
  // output dependents
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(o.network.scriptHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    // in order of least effort
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  // input dependents
  lazy.prop(o, 'redeem', () => {
    if (!a.input) return;
    return _redeem();
  });
  lazy.prop(o, 'input', () => {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return bscript.compile(
      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
    );
  });
  lazy.prop(o, 'witness', () => {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 23 ||
        a.output[0] !== OPS.OP_HASH160 ||
        a.output[1] !== 0x14 ||
        a.output[22] !== OPS.OP_EQUAL
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    // inlined to prevent 'no-inner-declarations' failing
    const checkRedeem = redeem => {
      // is the redeem output empty/invalid?
      if (redeem.output) {
        const decompile = bscript.decompile(redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output too short');
        if (redeem.output.byteLength > 520)
          throw new TypeError(
            'Redeem.output unspendable if larger than 520 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.hash160(redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (redeem.input) {
        const hasInput = redeem.input.length > 0;
        const hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness)
          throw new TypeError('Input and witness provided');
        if (hasInput) {
          const richunks = bscript.decompile(redeem.input);
          if (!bscript.isPushOnly(richunks))
            throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      const chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!Buffer.isBuffer(_redeem().output))
        throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      if (a.input) {
        const redeem = _redeem();
        if (a.redeem.output && !a.redeem.output.equals(redeem.output))
          throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && !a.redeem.input.equals(redeem.input))
          throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (
        a.redeem &&
        a.redeem.witness &&
        !stacksEqual(a.redeem.witness, a.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2sh = p2sh;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2tr.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2tr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2tr = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ "./node_modules/bitcoinjs-lib/src/ecc_lib.js");
const bip341_1 = __webpack_require__(/*! ./bip341 */ "./node_modules/bitcoinjs-lib/src/payments/bip341.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js");
const OPS = bscript.OPS;
const TAPROOT_WITNESS_VERSION = 0x01;
const ANNEX_PREFIX = 0x50;
function p2tr(a, opts) {
  if (
    !a.address &&
    !a.output &&
    !a.pubkey &&
    !a.internalPubkey &&
    !(a.witness && a.witness.length > 1)
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      signature: types_1.typeforce.maybe(
        types_1.typeforce.anyOf(
          types_1.typeforce.BufferN(64),
          types_1.typeforce.BufferN(65),
        ),
      ),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
      redeem: types_1.typeforce.maybe({
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32m.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32m.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: buffer_1.Buffer.from(data),
    };
  });
  // remove annex if present, ignored by taproot
  const _witness = lazy.value(() => {
    if (!a.witness || !a.witness.length) return;
    if (
      a.witness.length >= 2 &&
      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX
    ) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  const _hashTree = lazy.value(() => {
    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
    if (a.hash) return { hash: a.hash };
    return;
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2tr', network };
  lazy.prop(o, 'address', () => {
    if (!o.pubkey) return;
    const words = bech32_1.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return bech32_1.bech32m.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    const hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    const w = _witness();
    if (w && w.length > 1) {
      const controlBlock = w[w.length - 1];
      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
      const script = w[w.length - 2];
      const leafHash = (0, bip341_1.tapleafHash)({
        output: script,
        version: leafVersion,
      });
      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
    }
    return null;
  });
  lazy.prop(o, 'output', () => {
    if (!o.pubkey) return;
    return bscript.compile([OPS.OP_1, o.pubkey]);
  });
  lazy.prop(o, 'redeemVersion', () => {
    if (a.redeemVersion) return a.redeemVersion;
    if (
      a.redeem &&
      a.redeem.redeemVersion !== undefined &&
      a.redeem.redeemVersion !== null
    ) {
      return a.redeem.redeemVersion;
    }
    return bip341_1.LEAF_VERSION_TAPSCRIPT;
  });
  lazy.prop(o, 'redeem', () => {
    const witness = _witness(); // witness without annex
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion:
        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,
    };
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  lazy.prop(o, 'internalPubkey', () => {
    if (a.internalPubkey) return a.internalPubkey;
    const witness = _witness();
    if (witness && witness.length > 1)
      return witness[witness.length - 1].slice(1, 33);
  });
  lazy.prop(o, 'signature', () => {
    if (a.signature) return a.signature;
    const witness = _witness(); // witness without annex
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  lazy.prop(o, 'witness', () => {
    if (a.witness) return a.witness;
    const hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
      if (!path) return;
      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      const controlBock = buffer_1.Buffer.concat(
        [
          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
          a.internalPubkey,
        ].concat(path),
      );
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  // extended validation
  if (opts.validate) {
    let pubkey = buffer_1.Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== TAPROOT_WITNESS_VERSION)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.pubkey;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_1 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
        throw new TypeError('Pubkey mismatch');
      else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
        throw new TypeError('Invalid pubkey for p2tr');
    }
    const hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');
    }
    if (a.redeem && a.redeem.output && hashTree) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
        throw new TypeError('Redeem script not in tree');
    }
    const witness = _witness();
    // compare the provided redeem data with the one computed from witness
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
          throw new TypeError('Redeem.redeemVersion and witness mismatch');
      }
      if (a.redeem.output) {
        if (bscript.decompile(a.redeem.output).length === 0)
          throw new TypeError('Redeem.output is invalid');
        // output redeem is constructed from the witness
        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
          throw new TypeError('Redeem.output and witness mismatch');
      }
      if (a.redeem.witness) {
        if (
          o.redeem.witness &&
          !stacksEqual(a.redeem.witness, o.redeem.witness)
        )
          throw new TypeError('Redeem.witness and witness mismatch');
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        // key spending
        if (a.signature && !a.signature.equals(witness[0]))
          throw new TypeError('Signature mismatch');
      } else {
        // script path spending
        const controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
          );
        if ((controlBlock.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${controlBlock.length} is incorrect!`,
          );
        const m = (controlBlock.length - 33) / 32;
        if (m > 128)
          throw new TypeError(
            `The script path is too long. Got ${m}, expected max 128.`,
          );
        const internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
          throw new TypeError('Internal pubkey mismatch');
        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
          throw new TypeError('Invalid internalPubkey for p2tr witness');
        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
        const script = witness[witness.length - 2];
        const leafHash = (0, bip341_1.tapleafHash)({
          output: script,
          version: leafVersion,
        });
        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
        if (!outputKey)
          // todo: needs test data
          throw new TypeError('Invalid outputKey for p2tr witness');
        if (pubkey.length && !pubkey.equals(outputKey.x))
          throw new TypeError('Pubkey mismatch for p2tr witness');
        if (outputKey.parity !== (controlBlock[0] & 1))
          throw new Error('Incorrect parity');
      }
    }
  }
  return Object.assign(o, a);
}
exports.p2tr = p2tr;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2wpkh = void 0;
const bcrypto = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js");
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2wpkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.witness) return;
    return a.witness[0];
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 20)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 22 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x14
      )
        throw new TypeError('Output is invalid');
      if (hash.length > 0 && !hash.equals(a.output.slice(2)))
        throw new TypeError('Hash mismatch');
      else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
        throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!bscript.isCanonicalScriptSignature(a.witness[0]))
        throw new TypeError('Witness has invalid signature');
      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
        throw new TypeError('Witness has invalid pubkey');
      if (a.signature && !a.signature.equals(a.witness[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(a.witness[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(a.witness[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wsh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wsh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2wsh = void 0;
const bcrypto = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const lazy = __webpack_require__(/*! ./lazy */ "./node_modules/bitcoinjs-lib/src/payments/lazy.js");
const bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js");
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
function chunkHasUncompressedPubkey(chunk) {
  if (
    Buffer.isBuffer(chunk) &&
    chunk.length === 65 &&
    chunk[0] === 0x04 &&
    (0, types_1.isPoint)(chunk)
  ) {
    return true;
  } else {
    return false;
  }
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      redeem: types_1.typeforce.maybe({
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const _rchunks = lazy.value(() => {
    return bscript.decompile(a.redeem.input);
  });
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'redeem', () => {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER,
      witness: a.witness.slice(0, -1),
    };
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    // transform redeem input to witness stack?
    if (
      a.redeem &&
      a.redeem.input &&
      a.redeem.input.length > 0 &&
      a.redeem.output &&
      a.redeem.output.length > 0
    ) {
      const stack = bscript.toStack(_rchunks());
      // assign, and blank the existing input
      o.redeem = Object.assign({ witness: stack }, a.redeem);
      o.redeem.input = EMPTY_BUFFER;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2wsh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      // is there two redeem sources?
      if (
        a.redeem.input &&
        a.redeem.input.length > 0 &&
        a.redeem.witness &&
        a.redeem.witness.length > 0
      )
        throw new TypeError('Ambiguous witness source');
      // is the redeem output non-empty/valid?
      if (a.redeem.output) {
        const decompile = bscript.decompile(a.redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output is invalid');
        if (a.redeem.output.byteLength > 3600)
          throw new TypeError(
            'Redeem.output unspendable if larger than 3600 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.sha256(a.redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
        throw new TypeError('Non push-only scriptSig');
      if (
        a.witness &&
        a.redeem.witness &&
        !stacksEqual(a.witness, a.redeem.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
      if (
        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||
        (a.redeem.output &&
          (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey,
          ))
      ) {
        throw new TypeError(
          'redeem.input or redeem.output contains uncompressed pubkey',
        );
      }
    }
    if (a.witness && a.witness.length > 0) {
      const wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
        throw new TypeError('Witness and redeem.output mismatch');
      if (
        a.witness.some(chunkHasUncompressedPubkey) ||
        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)
      )
        throw new TypeError('Witness contains uncompressed pubkey');
    }
  }
  return Object.assign(o, a);
}
exports.p2wsh = p2wsh;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt.js":
/*!************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Psbt = void 0;
const bip174_1 = __webpack_require__(/*! bip174 */ "./node_modules/bip174/src/lib/psbt.js");
const varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ "./node_modules/bip174/src/lib/converter/varint.js");
const utils_1 = __webpack_require__(/*! bip174/src/lib/utils */ "./node_modules/bip174/src/lib/utils.js");
const address_1 = __webpack_require__(/*! ./address */ "./node_modules/bitcoinjs-lib/src/address.js");
const bufferutils_1 = __webpack_require__(/*! ./bufferutils */ "./node_modules/bitcoinjs-lib/src/bufferutils.js");
const networks_1 = __webpack_require__(/*! ./networks */ "./node_modules/bitcoinjs-lib/src/networks.js");
const payments = __webpack_require__(/*! ./payments */ "./node_modules/bitcoinjs-lib/src/payments/index.js");
const bip341_1 = __webpack_require__(/*! ./payments/bip341 */ "./node_modules/bitcoinjs-lib/src/payments/bip341.js");
const bscript = __webpack_require__(/*! ./script */ "./node_modules/bitcoinjs-lib/src/script.js");
const transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/bitcoinjs-lib/src/transaction.js");
const bip371_1 = __webpack_require__(/*! ./psbt/bip371 */ "./node_modules/bitcoinjs-lib/src/psbt/bip371.js");
const psbtutils_1 = __webpack_require__(/*! ./psbt/psbtutils */ "./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js");
/**
 * These are the default arguments for a Psbt instance.
 */
const DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5000, // satoshi per byte
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
class Psbt {
  static fromBase64(data, opts = {}) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
    return psbt;
  }
  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = data;
    // set defaults
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecesor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false,
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    // Make data hidden when enumerating
    const dpew = (obj, attr, enumerable, writable) =>
      Object.defineProperty(obj, attr, {
        enumerable,
        writable,
      });
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map(input => ({
      hash: (0, bufferutils_1.cloneBuffer)(input.hash),
      index: input.index,
      sequence: input.sequence,
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map(output => {
      let address;
      try {
        address = (0, address_1.fromOutputScript)(
          output.script,
          this.opts.network,
        );
      } catch (_) {}
      return {
        script: (0, bufferutils_1.cloneBuffer)(output.script),
        value: output.value,
        address,
      };
    });
  }
  combine(...those) {
    this.data.combine(...those.map(o => o.data));
    return this;
  }
  clone() {
    // TODO: more efficient cloning
    const res = Psbt.fromBuffer(this.data.toBuffer());
    res.opts = JSON.parse(JSON.stringify(this.opts));
    return res;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
    this.opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, 'setVersion');
    const c = this.__CACHE;
    c.__TX.version = version;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, 'setLocktime');
    const c = this.__CACHE;
    c.__TX.locktime = locktime;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
    const c = this.__CACHE;
    if (c.__TX.ins.length <= inputIndex) {
      throw new Error('Input index too high');
    }
    c.__TX.ins[inputIndex].sequence = sequence;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addInputs(inputDatas) {
    inputDatas.forEach(inputData => this.addInput(inputData));
    return this;
  }
  addInput(inputData) {
    if (
      arguments.length > 1 ||
      !inputData ||
      inputData.hash === undefined ||
      inputData.index === undefined
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addInput. ` +
          `Requires single object with at least [hash] and [index]`,
      );
    }
    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');
    checkInputsForPartialSig(this.data.inputs, 'addInput');
    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
    const c = this.__CACHE;
    this.data.addInput(inputData);
    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
    checkTxInputCache(c, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, input, inputIndex);
    }
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addOutputs(outputDatas) {
    outputDatas.forEach(outputData => this.addOutput(outputData));
    return this;
  }
  addOutput(outputData) {
    if (
      arguments.length > 1 ||
      !outputData ||
      outputData.value === undefined ||
      (outputData.address === undefined && outputData.script === undefined)
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addOutput. ` +
          `Requires single object with at least [script or address] and [value]`,
      );
    }
    checkInputsForPartialSig(this.data.inputs, 'addOutput');
    const { address } = outputData;
    if (typeof address === 'string') {
      const { network } = this.opts;
      const script = (0, address_1.toOutputScript)(address, network);
      outputData = Object.assign(outputData, { script });
    }
    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');
    const c = this.__CACHE;
    this.data.addOutput(outputData);
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  extractTransaction(disableFeeCheck) {
    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
    const c = this.__CACHE;
    if (!disableFeeCheck) {
      checkFees(this, c, this.opts);
    }
    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
    const tx = c.__TX.clone();
    inputFinalizeGetAmts(this.data.inputs, tx, c, true);
    return tx;
  }
  getFeeRate() {
    return getTxCacheValue(
      '__FEE_RATE',
      'fee rate',
      this.data.inputs,
      this.__CACHE,
    );
  }
  getFee() {
    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        undefined,
        finalScriptsFunc,
      );
    return this._finalizeInput(inputIndex, input, finalScriptsFunc);
  }
  finalizeTaprootInput(
    inputIndex,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        tapLeafHashToFinalize,
        finalScriptsFunc,
      );
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
      inputIndex,
      input,
      this.__CACHE,
    );
    if (!script) throw new Error(`No script found for input #${inputIndex}`);
    checkPartialSigSighashes(input);
    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
      inputIndex,
      input,
      script,
      isSegwit,
      isP2SH,
      isP2WSH,
    );
    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
    if (finalScriptWitness)
      this.data.updateInput(inputIndex, { finalScriptWitness });
    if (!finalScriptSig && !finalScriptWitness)
      throw new Error(`Unknown error finalizing input #${inputIndex}`);
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  _finalizeTaprootInput(
    inputIndex,
    input,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    if (!input.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,
      );
    // Check key spend first. Increased privacy and reduced block space.
    if (input.tapKeySig) {
      const payment = payments.p2tr({
        output: input.witnessUtxo.script,
        signature: input.tapKeySig,
      });
      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    } else {
      const { finalScriptWitness } = finalScriptsFunc(
        inputIndex,
        input,
        tapLeafHashToFinalize,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    }
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  getInputType(inputIndex) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
    const result = getMeaningfulScript(
      script,
      inputIndex,
      'input',
      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
      input.witnessScript ||
        redeemFromFinalWitnessScript(input.finalScriptWitness),
    );
    const type = result.type === 'raw' ? '' : result.type + '-';
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
  }
  inputHasHDKey(inputIndex, root) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)
    );
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
  }
  outputHasHDKey(outputIndex, root) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)
    );
  }
  validateSignaturesOfAllInputs(validator) {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    const results = range(this.data.inputs.length).map(idx =>
      this.validateSignaturesOfInput(idx, validator),
    );
    return results.reduce((final, res) => res === true && final, true);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if ((0, bip371_1.isTaprootInput)(input))
      return this.validateSignaturesOfTaprootInput(
        inputIndex,
        validator,
        pubkey,
      );
    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
  }
  _validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = (input || {}).partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    const mySigs = pubkey
      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
      : partialSig;
    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const sig = bscript.signature.decode(pSig.signature);
      const { hash, script } =
        sighashCache !== sig.hashType
          ? getHashForSig(
              inputIndex,
              Object.assign({}, input, { sighashType: sig.hashType }),
              this.__CACHE,
              true,
            )
          : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script;
      checkScriptForPubkey(pSig.pubkey, script, 'verify');
      results.push(validator(pSig.pubkey, hash, sig.signature));
    }
    return results.every(res => res === true);
  }
  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const tapKeySig = (input || {}).tapKeySig;
    const tapScriptSig = (input || {}).tapScriptSig;
    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
    const allHashses = pubkey
      ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE,
        )
      : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE,
        );
    if (!allHashses.length) throw new Error('No signatures for this pubkey');
    const tapKeyHash = allHashses.find(h => !h.leafHash);
    let validationResultCount = 0;
    if (tapKeySig && tapKeyHash) {
      const isValidTapkeySig = validator(
        tapKeyHash.pubkey,
        tapKeyHash.hash,
        trimTaprootSig(tapKeySig),
      );
      if (!isValidTapkeySig) return false;
      validationResultCount++;
    }
    if (tapScriptSig) {
      for (const tapSig of tapScriptSig) {
        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));
        if (tapSigHash) {
          const isValidTapScriptSig = validator(
            tapSig.pubkey,
            tapSigHash.hash,
            trimTaprootSig(tapSig.signature),
          );
          if (!isValidTapScriptSig) return false;
          validationResultCount++;
        }
      }
    }
    return validationResultCount > 0;
  }
  signAllInputsHD(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsHDAsync(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const results = [];
      const promises = [];
      for (const i of range(this.data.inputs.length)) {
        promises.push(
          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInputHD(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  signInputHDAsync(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      const promises = signers.map(signer =>
        this.signInputAsync(inputIndex, signer, sighashTypes),
      );
      return Promise.all(promises)
        .then(() => {
          resolve();
        })
        .catch(reject);
    });
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    // TODO: Add a pubkey/pubkeyhash cache to each input
    // as input information is added, then eventually
    // optimize this method.
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsAsync(keyPair, sighashTypes) {
    return new Promise((resolve, reject) => {
      if (!keyPair || !keyPair.publicKey)
        return reject(new Error('Need Signer to sign input'));
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      const results = [];
      const promises = [];
      for (const [i] of this.data.inputs.entries()) {
        promises.push(
          this.signInputAsync(i, keyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input)) {
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        undefined,
        sighashTypes,
      );
    }
    return this._signInput(inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        tapLeafHashToSign,
        sighashTypes,
      );
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  _signInput(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    const partialSig = [
      {
        pubkey: keyPair.publicKey,
        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
      },
    ];
    this.data.updateInput(inputIndex, { partialSig });
    return this;
  }
  _signTaprootInput(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    const tapKeySig = hashesForSig
      .filter(h => !h.leafHash)
      .map(h =>
        (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
      )[0];
    const tapScriptSig = hashesForSig
      .filter(h => !!h.leafHash)
      .map(h => ({
        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
        signature: (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
        leafHash: h.leafHash,
      }));
    if (tapKeySig) {
      this.data.updateInput(inputIndex, { tapKeySig });
    }
    if (tapScriptSig.length) {
      this.data.updateInput(inputIndex, { tapScriptSig });
    }
    return this;
  }
  signInputAsync(inputIndex, keyPair, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          undefined,
          sighashTypes,
        );
      return this._signInputAsync(inputIndex, keyPair, sighashTypes);
    });
  }
  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes,
        );
      throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    });
  }
  _signInputAsync(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    return Promise.resolve(keyPair.sign(hash)).then(signature => {
      const partialSig = [
        {
          pubkey: keyPair.publicKey,
          signature: bscript.signature.encode(signature, sighashType),
        },
      ];
      this.data.updateInput(inputIndex, { partialSig });
    });
  }
  async _signTaprootInputAsync(
    inputIndex,
    input,
    keyPair,
    tapLeafHash,
    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHash,
      sighashTypes,
    );
    const signaturePromises = [];
    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];
    if (tapKeyHash) {
      const tapKeySigPromise = Promise.resolve(
        keyPair.signSchnorr(tapKeyHash.hash),
      ).then(sig => {
        return {
          tapKeySig: (0, bip371_1.serializeTaprootSignature)(
            sig,
            input.sighashType,
          ),
        };
      });
      signaturePromises.push(tapKeySigPromise);
    }
    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);
    if (tapScriptHashes.length) {
      const tapScriptSigPromises = tapScriptHashes.map(tsh => {
        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
          signature => {
            const tapScriptSig = [
              {
                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                signature: (0, bip371_1.serializeTaprootSignature)(
                  signature,
                  input.sighashType,
                ),
                leafHash: tsh.leafHash,
              },
            ];
            return { tapScriptSig };
          },
        );
      });
      signaturePromises.push(...tapScriptSigPromises);
    }
    return Promise.all(signaturePromises).then(results => {
      results.forEach(v => this.data.updateInput(inputIndex, v));
    });
  }
  checkTaprootHashesForSig(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes,
  ) {
    if (typeof keyPair.signSchnorr !== 'function')
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,
      );
    const hashesForSig = getTaprootHashesForSig(
      inputIndex,
      input,
      this.data.inputs,
      keyPair.publicKey,
      this.__CACHE,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(
        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
          'hex',
        )}`,
      );
    return hashesForSig;
  }
  toBuffer() {
    checkCache(this.__CACHE);
    return this.data.toBuffer();
  }
  toHex() {
    checkCache(this.__CACHE);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.__CACHE);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
    (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[inputIndex],
      updateData,
      'updateInput',
    );
    this.data.updateInput(inputIndex, updateData);
    if (updateData.nonWitnessUtxo) {
      addNonWitnessTxCache(
        this.__CACHE,
        this.data.inputs[inputIndex],
        inputIndex,
      );
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    (0, bip371_1.checkTaprootOutputFields)(
      outputData,
      updateData,
      'updateOutput',
    );
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
}
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
const transactionFromBuffer = buffer => new PsbtTransaction(buffer);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */
class PsbtTransaction {
  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true,
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length,
    };
  }
  addInput(input) {
    if (
      input.hash === undefined ||
      input.index === undefined ||
      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
      typeof input.index !== 'number'
    ) {
      throw new Error('Error adding input.');
    }
    const hash =
      typeof input.hash === 'string'
        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))
        : input.hash;
    this.tx.addInput(hash, input.index, input.sequence);
  }
  addOutput(output) {
    if (
      output.script === undefined ||
      output.value === undefined ||
      !Buffer.isBuffer(output.script) ||
      typeof output.value !== 'number'
    ) {
      throw new Error('Error adding output.');
    }
    this.tx.addOutput(output.script, output.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      const p2ms = payments.p2ms({ output: script });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys
      .map(pkey => {
        const pubkey = compressPubkey(pkey);
        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
      })
      .filter(v => !!v);
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return d => {
    if (!d.masterFingerprint.equals(root.fingerprint)) return false;
    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (
    typeof num !== 'number' ||
    num !== Math.floor(num) ||
    num > 0xffffffff ||
    num < 0
  ) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  const vsize = cache.__EXTRACTED_TX.virtualSize();
  const satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error(
      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
        `fees, which is ${feeRate} satoshi per byte for a transaction ` +
        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
        `pass true to the first arg of extractTransaction.`,
    );
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(input => {
    const throws = (0, bip371_1.isTaprootInput)(input)
      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)
      : (0, psbtutils_1.checkInputForSig)(input, action);
    if (throws)
      throw new Error('Can not modify transaction, signatures exist.');
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  const { partialSig, sighashType } = input;
  partialSig.forEach(pSig => {
    const { hashType } = bscript.signature.decode(pSig.signature);
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
    throw new Error(
      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
    );
  }
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every(
    input =>
      input.script &&
      input.script.length === 0 &&
      input.witness &&
      input.witness.length === 0,
  );
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(input => {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  const key =
    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +
    ':' +
    input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript },
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error(
        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,
      );
    }
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
const checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  'Witness script',
);
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${name}`);
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  let tx;
  let mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;
  else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  const scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType))
    throw new Error(`Can not finalize input #${inputIndex}`);
  return prepareFinalScripts(
    script,
    scriptType,
    input.partialSig,
    isSegwit,
    isP2SH,
    isP2WSH,
  );
}
function prepareFinalScripts(
  script,
  scriptType,
  partialSig,
  isSegwit,
  isP2SH,
  isP2WSH,
) {
  let finalScriptSig;
  let finalScriptWitness;
  // Wow, the payments API is very handy
  const payment = getPayment(script, scriptType, partialSig);
  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        p2wsh.witness,
      );
    } else {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig,
    finalScriptWitness,
  };
}
function getHashAndSighashType(
  inputs,
  inputIndex,
  pubkey,
  cache,
  sighashTypes,
) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  const { hash, sighashType, script } = getHashForSig(
    inputIndex,
    input,
    cache,
    false,
    sighashTypes,
  );
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash,
    sighashType,
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  let hash;
  let prevout;
  if (input.nonWitnessUtxo) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const prevoutHash = unsignedTx.ins[inputIndex].hash;
    const utxoHash = nonWitnessUtxoTx.getHash();
    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error(
        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
      );
    }
    const prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  const { meaningfulScript, type } = getMeaningfulScript(
    prevout.script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      meaningfulScript,
      prevout.value,
      sighashType,
    );
  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
    // P2WPKH uses the P2PKH template for prevoutScript when signing
    const signingScript = payments.p2pkh({
      hash: meaningfulScript.slice(2),
    }).output;
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      signingScript,
      prevout.value,
      sighashType,
    );
  } else {
    // non-segwit
    if (
      input.nonWitnessUtxo === undefined &&
      cache.__UNSAFE_SIGN_NONSEGWIT === false
    )
      throw new Error(
        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
          `${meaningfulScript.toString('hex')}`,
      );
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
      console.warn(
        'Warning: Signing non-segwit inputs without the full parent transaction ' +
          'means there is a chance that a miner could feed you incorrect information ' +
          "to trick you into paying large fees. This behavior is the same as Psbt's predecesor " +
          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +
          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +
          'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' +
          '*********************',
      );
    hash = unsignedTx.hashForSignature(
      inputIndex,
      meaningfulScript,
      sighashType,
    );
  }
  return {
    script: meaningfulScript,
    sighashType,
    hash,
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  const allPublicKeys = [];
  if (input.tapInternalKey) {
    const key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);
    allPublicKeys.push(...tapScriptPubkeys);
  }
  const allHashes = allPublicKeys.map(pubicKey =>
    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),
  );
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : signature.subarray(0, 64);
}
function getTaprootHashesForSig(
  inputIndex,
  input,
  inputs,
  pubkey,
  cache,
  tapLeafHashToSign,
  allowedSighashTypes,
) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  const prevOuts = inputs.map((i, index) =>
    getScriptAndAmountFromUtxo(index, i, cache),
  );
  const signingScripts = prevOuts.map(o => o.script);
  const values = prevOuts.map(o => o.value);
  const hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    const outputKey =
      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
      const tapKeyHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        sighashType,
      );
      hashes.push({ pubkey, hash: tapKeyHash });
    }
  }
  const tapLeafHashes = (input.tapLeafScript || [])
    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))
    .map(tapLeaf => {
      const hash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
      });
      return Object.assign({ hash }, tapLeaf);
    })
    .filter(
      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),
    )
    .map(tapLeaf => {
      const tapScriptHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        transaction_1.Transaction.SIGHASH_DEFAULT,
        tapLeaf.hash,
      );
      return {
        pubkey,
        hash: tapScriptHash,
        leafHash: tapLeaf.hash,
      };
    });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    const str = sighashTypeToString(sighashType);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the ` +
        `sighashTypes array of whitelisted types. Sighash type: ${str}`,
    );
  }
}
function getPayment(script, scriptType, partialSig) {
  let payment;
  switch (scriptType) {
    case 'multisig':
      const sigs = getSortedSigs(script, partialSig);
      payment = payments.p2ms({
        output: script,
        signatures: sigs,
      });
      break;
    case 'pubkey':
      payment = payments.p2pk({
        output: script,
        signature: partialSig[0].signature,
      });
      break;
    case 'pubkeyhash':
      payment = payments.p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
    case 'witnesspubkeyhash':
      payment = payments.p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  const unsignedTx = cache.__TX;
  const res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false,
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
        cache,
        input,
        inputIndex,
      );
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  const myDerivations = input.bip32Derivation
    .map(bipDv => {
      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
        return bipDv;
      } else {
        return;
      }
    })
    .filter(v => !!v);
  if (myDerivations.length === 0) {
    throw new Error(
      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
    );
  }
  const signers = myDerivations.map(bipDv => {
    const node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  const p2ms = payments.p2ms({ output: script });
  // for each pubkey in order of p2ms script
  return p2ms.pubkeys
    .map(pk => {
      // filter partialSig array by pubkey being equal
      return (
        partialSig.filter(ps => {
          return ps.pubkey.equals(pk);
        })[0] || {}
      ).signature;
      // Any pubkey without a match will return undefined
      // this last filter removes all the undefined items in the array.
    })
    .filter(v => !!v);
}
function scriptWitnessToWitnessStack(buffer) {
  let offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    const vi = varuint.decode(buffer, offset);
    offset += varuint.decode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  let text =
    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
      ? 'SIGHASH_ANYONECANPAY | '
      : '';
  const sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  const self = cache;
  const selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get() {
      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        const newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    },
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  let inputAmount = 0;
  inputs.forEach((input, idx) => {
    if (mustFinalize && input.finalScriptSig)
      tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(
        input.finalScriptWitness,
      );
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      const vout = tx.ins[idx].index;
      const out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
  const fee = inputAmount - outputAmount;
  if (fee < 0) {
    throw new Error('Outputs are spending more than Inputs');
  }
  const bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value,
    };
  } else if (input.nonWitnessUtxo !== undefined) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return { script: o.script, value: o.value };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  const script = getScriptFromUtxo(inputIndex, input, cache);
  const { meaningfulScript } = getMeaningfulScript(
    script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  const script = cache.__TX.outs[outputIndex].script;
  const { meaningfulScript } = getMeaningfulScript(
    script,
    outputIndex,
    'output',
    output.redeemScript,
    output.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  const decomp = bscript.decompile(finalScript);
  if (!decomp) return;
  const lastItem = decomp[decomp.length - 1];
  if (
    !Buffer.isBuffer(lastItem) ||
    isPubkeyLike(lastItem) ||
    isSigLike(lastItem)
  )
    return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  const decomp = scriptWitnessToWitnessStack(finalScript);
  const lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function isPubkeyLike(buf) {
  return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(
  script,
  index,
  ioType,
  redeemScript,
  witnessScript,
) {
  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
  const isP2SHP2WSH =
    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
  if (isP2SH && redeemScript === undefined)
    throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)
    throw new Error(
      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',
    );
  let meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH
      ? 'p2sh-p2wsh'
      : isP2SH
      ? 'p2sh'
      : isP2WSH
      ? 'p2wsh'
      : 'raw',
  };
}
function checkInvalidP2WSH(script) {
  if (
    (0, psbtutils_1.isP2WPKH)(script) ||
    (0, psbtutils_1.isP2SHScript)(script)
  ) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function classifyScript(script) {
  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';
  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';
  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';
  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return [...Array(n).keys()];
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt/bip371.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt/bip371.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkTaprootInputForSigs =
  exports.tapTreeFromList =
  exports.tapTreeToList =
  exports.tweakInternalPubKey =
  exports.checkTaprootOutputFields =
  exports.checkTaprootInputFields =
  exports.isTaprootOutput =
  exports.isTaprootInput =
  exports.serializeTaprootSignature =
  exports.tapScriptFinalizer =
  exports.toXOnly =
    void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/bitcoinjs-lib/src/types.js");
const transaction_1 = __webpack_require__(/*! ../transaction */ "./node_modules/bitcoinjs-lib/src/transaction.js");
const psbtutils_1 = __webpack_require__(/*! ./psbtutils */ "./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js");
const bip341_1 = __webpack_require__(/*! ../payments/bip341 */ "./node_modules/bitcoinjs-lib/src/payments/bip341.js");
const payments_1 = __webpack_require__(/*! ../payments */ "./node_modules/bitcoinjs-lib/src/payments/index.js");
const psbtutils_2 = __webpack_require__(/*! ./psbtutils */ "./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js");
const toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));
exports.toXOnly = toXOnly;
/**
 * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.
 * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.
 * @param inputIndex the position of the PSBT input.
 * @param input the PSBT input.
 * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash
 *                              and will try to build the finalScriptWitness.
 * @returns the finalScriptWitness or throws an exception if no tapleaf found.
 */
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  const tapLeaf = findTapLeafToFinalize(
    input,
    inputIndex,
    tapLeafHashToFinalize,
  );
  try {
    const sigs = sortSignatures(input, tapLeaf);
    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),
    };
  } catch (err) {
    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
  }
}
exports.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(sig, sighashType) {
  const sighashTypeByte = sighashType
    ? Buffer.from([sighashType])
    : Buffer.from([]);
  return Buffer.concat([sig, sighashTypeByte]);
}
exports.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(input) {
  return (
    input &&
    !!(
      input.tapInternalKey ||
      input.tapMerkleRoot ||
      (input.tapLeafScript && input.tapLeafScript.length) ||
      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))
    )
  );
}
exports.isTaprootInput = isTaprootInput;
function isTaprootOutput(output, script) {
  return (
    output &&
    !!(
      output.tapInternalKey ||
      output.tapTree ||
      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
      (script && (0, psbtutils_1.isP2TR)(script))
    )
  );
}
exports.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
exports.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
exports.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
  const tapInternalKey =
    newOutputData.tapInternalKey || outputData.tapInternalKey;
  const tapTree = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    const { script: scriptPubkey } = outputData;
    const script = getTaprootScripPubkey(tapInternalKey, tapTree);
    if (scriptPubkey && !scriptPubkey.equals(script))
      throw new Error('Error adding output. Script or address missmatch.');
  }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
  const { output } = (0, payments_1.p2tr)({
    internalPubkey: tapInternalKey,
    scriptTree,
  });
  return output;
}
function tweakInternalPubKey(inputIndex, input) {
  const tapInternalKey = input.tapInternalKey;
  const outputKey =
    tapInternalKey &&
    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
  if (!outputKey)
    throw new Error(
      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${
        tapInternalKey && tapInternalKey.toString('hex')
      }`,
    );
  return outputKey.x;
}
exports.tweakInternalPubKey = tweakInternalPubKey;
/**
 * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @param tree the binary tap tree
 * @returns a list of BIP 371 tapleaves
 */
function tapTreeToList(tree) {
  if (!(0, types_1.isTaptree)(tree))
    throw new Error(
      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',
    );
  return _tapTreeToList(tree);
}
exports.tapTreeToList = tapTreeToList;
/**
 * Convert a BIP371 TapLeaf list to a TapTree (binary).
 * @param leaves a list of tapleaves where each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed
 */
function tapTreeFromList(leaves = []) {
  if (leaves.length === 1 && leaves[0].depth === 0)
    return {
      output: leaves[0].script,
      version: leaves[0].leafVersion,
    };
  return instertLeavesInTree(leaves);
}
exports.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(input, action) {
  const sigs = extractTaprootSigs(input);
  return sigs.some(sig =>
    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),
  );
}
exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(signature) {
  return {
    signature: signature.slice(0, 64),
    hashType:
      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,
  };
}
function extractTaprootSigs(input) {
  const sigs = [];
  if (input.tapKeySig) sigs.push(input.tapKeySig);
  if (input.tapScriptSig)
    sigs.push(...input.tapScriptSig.map(s => s.signature));
  if (!sigs.length) {
    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
    if (finalTapKeySig) sigs.push(finalTapKeySig);
  }
  return sigs;
}
function getTapKeySigFromWithness(finalScriptWitness) {
  if (!finalScriptWitness) return;
  const witness = finalScriptWitness.slice(2);
  // todo: add schnorr signature validation
  if (witness.length === 64 || witness.length === 65) return witness;
}
function _tapTreeToList(tree, leaves = [], depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (!tree) return [];
  if ((0, types_1.isTapleaf)(tree)) {
    leaves.push({
      depth,
      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
      script: tree.output,
    });
    return leaves;
  }
  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
  return leaves;
}
function instertLeavesInTree(leaves) {
  let tree;
  for (const leaf of leaves) {
    tree = instertLeafInTree(leaf, tree);
    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
  }
  return tree;
}
function instertLeafInTree(leaf, tree, depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (leaf.depth === depth) {
    if (!tree)
      return {
        output: leaf.script,
        version: leaf.leafVersion,
      };
    return;
  }
  if ((0, types_1.isTapleaf)(tree)) return;
  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide) return [leftSide, tree && tree[1]];
  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide) return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootInput(newInputData) &&
    hasNonTaprootFields(newInputData); // todo: bad? use !===
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootOutput(newInputData) &&
    hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
  if (newInputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    if (!newLeafsInTree || !oldLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  } else if (inputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, inputData.tapMerkleRoot),
    );
    if (!newLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  }
}
function isTapLeafInTree(tapLeaf, merkleRoot) {
  if (!merkleRoot) return true;
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  const rootHash = (0, bip341_1.rootHashFromPath)(
    tapLeaf.controlBlock,
    leafHash,
  );
  return rootHash.equals(merkleRoot);
}
function sortSignatures(input, tapLeaf) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  return (input.tapScriptSig || [])
    .filter(tss => tss.leafHash.equals(leafHash))
    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))
    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
    .map(t => t.signature);
}
function addPubkeyPositionInScript(script, tss) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
        tss.pubkey,
        script,
      ),
    },
    tss,
  );
}
/**
 * Find tapleaf by hash, or get the signed tapleaf with the shortest path.
 */
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  if (!input.tapScriptSig || !input.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,
    );
  const tapLeaf = (input.tapLeafScript || [])
    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
    .find(leaf =>
      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),
    );
  if (!tapLeaf)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,
    );
  return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: leaf.script,
    version: leaf.leafVersion,
  });
  const whiteListedHash = !hash || hash.equals(leafHash);
  return (
    whiteListedHash &&
    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined
  );
}
function hasNonTaprootFields(io) {
  return (
    io &&
    !!(
      io.redeemScript ||
      io.witnessScript ||
      (io.bip32Derivation && io.bip32Derivation.length)
    )
  );
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureBlocksAction =
  exports.checkInputForSig =
  exports.pubkeyInScript =
  exports.pubkeyPositionInScript =
  exports.witnessStackToScriptWitness =
  exports.isP2TR =
  exports.isP2SHScript =
  exports.isP2WSHScript =
  exports.isP2WPKH =
  exports.isP2PKH =
  exports.isP2PK =
  exports.isP2MS =
    void 0;
const varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ "./node_modules/bip174/src/lib/converter/varint.js");
const bscript = __webpack_require__(/*! ../script */ "./node_modules/bitcoinjs-lib/src/script.js");
const transaction_1 = __webpack_require__(/*! ../transaction */ "./node_modules/bitcoinjs-lib/src/transaction.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const payments = __webpack_require__(/*! ../payments */ "./node_modules/bitcoinjs-lib/src/payments/index.js");
function isPaymentFactory(payment) {
  return script => {
    try {
      payment({ output: script });
      return true;
    } catch (err) {
      return false;
    }
  };
}
exports.isP2MS = isPaymentFactory(payments.p2ms);
exports.isP2PK = isPaymentFactory(payments.p2pk);
exports.isP2PKH = isPaymentFactory(payments.p2pkh);
exports.isP2WPKH = isPaymentFactory(payments.p2wpkh);
exports.isP2WSHScript = isPaymentFactory(payments.p2wsh);
exports.isP2SHScript = isPaymentFactory(payments.p2sh);
exports.isP2TR = isPaymentFactory(payments.p2tr);
function witnessStackToScriptWitness(witness) {
  let buffer = Buffer.allocUnsafe(0);
  function writeSlice(slice) {
    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
  }
  function writeVarInt(i) {
    const currentLen = buffer.length;
    const varintLen = varuint.encodingLength(i);
    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(pubkey, script) {
  const pubkeyHash = (0, crypto_1.hash160)(pubkey);
  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?
  const decompiled = bscript.decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.findIndex(element => {
    if (typeof element === 'number') return false;
    return (
      element.equals(pubkey) ||
      element.equals(pubkeyHash) ||
      element.equals(pubkeyXOnly)
    );
  });
}
exports.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(pubkey, script) {
  return pubkeyPositionInScript(pubkey, script) !== -1;
}
exports.pubkeyInScript = pubkeyInScript;
function checkInputForSig(input, action) {
  const pSigs = extractPartialSigs(input);
  return pSigs.some(pSig =>
    signatureBlocksAction(pSig, bscript.signature.decode, action),
  );
}
exports.checkInputForSig = checkInputForSig;
function signatureBlocksAction(signature, signatureDecodeFn, action) {
  const { hashType } = signatureDecodeFn(signature);
  const whitelist = [];
  const isAnyoneCanPay =
    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay) whitelist.push('addInput');
  const hashMod = hashType & 0x1f;
  switch (hashMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
    case transaction_1.Transaction.SIGHASH_NONE:
      whitelist.push('addOutput');
      whitelist.push('setInputSequence');
      break;
  }
  if (whitelist.indexOf(action) === -1) {
    return true;
  }
  return false;
}
exports.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(input) {
  let pSigs = [];
  if ((input.partialSig || []).length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness) return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = input.partialSig;
  }
  return pSigs.map(p => p.signature);
}
function getPsigsFromInputFinalScripts(input) {
  const scriptItems = !input.finalScriptSig
    ? []
    : bscript.decompile(input.finalScriptSig) || [];
  const witnessItems = !input.finalScriptWitness
    ? []
    : bscript.decompile(input.finalScriptWitness) || [];
  return scriptItems
    .concat(witnessItems)
    .filter(item => {
      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
    })
    .map(sig => ({ signature: sig }));
}


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/push_data.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/push_data.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = exports.encode = exports.encodingLength = void 0;
const ops_1 = __webpack_require__(/*! ./ops */ "./node_modules/bitcoinjs-lib/src/ops.js");
function encodingLength(i) {
  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
exports.encodingLength = encodingLength;
function encode(buffer, num, offset) {
  const size = encodingLength(num);
  // ~6 bit
  if (size === 1) {
    buffer.writeUInt8(num, offset);
    // 8 bit
  } else if (size === 2) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
    buffer.writeUInt8(num, offset + 1);
    // 16 bit
  } else if (size === 3) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
    buffer.writeUInt16LE(num, offset + 1);
    // 32 bit
  } else {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
    buffer.writeUInt32LE(num, offset + 1);
  }
  return size;
}
exports.encode = encode;
function decode(buffer, offset) {
  const opcode = buffer.readUInt8(offset);
  let num;
  let size;
  // ~6 bit
  if (opcode < ops_1.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
    // 8 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = buffer.readUInt8(offset + 1);
    size = 2;
    // 16 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = buffer.readUInt16LE(offset + 1);
    size = 3;
    // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = buffer.readUInt32LE(offset + 1);
    size = 5;
  }
  return {
    opcode,
    number: num,
    size,
  };
}
exports.decode = decode;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signature =
  exports.number =
  exports.isCanonicalScriptSignature =
  exports.isDefinedHashType =
  exports.isCanonicalPubKey =
  exports.toStack =
  exports.fromASM =
  exports.toASM =
  exports.decompile =
  exports.compile =
  exports.countNonPushOnlyOPs =
  exports.isPushOnly =
  exports.OPS =
    void 0;
const bip66 = __webpack_require__(/*! ./bip66 */ "./node_modules/bitcoinjs-lib/src/bip66.js");
const ops_1 = __webpack_require__(/*! ./ops */ "./node_modules/bitcoinjs-lib/src/ops.js");
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
}));
const pushdata = __webpack_require__(/*! ./push_data */ "./node_modules/bitcoinjs-lib/src/push_data.js");
const scriptNumber = __webpack_require__(/*! ./script_number */ "./node_modules/bitcoinjs-lib/src/script_number.js");
const scriptSignature = __webpack_require__(/*! ./script_signature */ "./node_modules/bitcoinjs-lib/src/script_signature.js");
const types = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const { typeforce } = types;
const OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
  return (
    types.Number(value) &&
    (value === ops_1.OPS.OP_0 ||
      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||
      value === ops_1.OPS.OP_1NEGATE)
  );
}
function isPushOnlyChunk(value) {
  return types.Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
  return types.Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
function asMinimalOP(buffer) {
  if (buffer.length === 0) return ops_1.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
  return types.Array(buf);
}
function singleChunkIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function compile(chunks) {
  // TODO: remove me
  if (chunksIsBuffer(chunks)) return chunks;
  typeforce(types.Array, chunks);
  const bufferSize = chunks.reduce((accum, chunk) => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + pushdata.encodingLength(chunk.length) + chunk.length;
    }
    // opcode
    return accum + 1;
  }, 0.0);
  const buffer = Buffer.allocUnsafe(bufferSize);
  let offset = 0;
  chunks.forEach(chunk => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      const opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        buffer.writeUInt8(opcode, offset);
        offset += 1;
        return;
      }
      offset += pushdata.encode(buffer, chunk.length, offset);
      chunk.copy(buffer, offset);
      offset += chunk.length;
      // opcode
    } else {
      buffer.writeUInt8(chunk, offset);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
exports.compile = compile;
function decompile(buffer) {
  // TODO: remove me
  if (chunksIsArray(buffer)) return buffer;
  typeforce(types.Buffer, buffer);
  const chunks = [];
  let i = 0;
  while (i < buffer.length) {
    const opcode = buffer[i];
    // data chunk
    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
      const d = pushdata.decode(buffer, i);
      // did reading a pushDataInt fail?
      if (d === null) return null;
      i += d.size;
      // attempt to read too much data?
      if (i + d.number > buffer.length) return null;
      const data = buffer.slice(i, i + d.number);
      i += d.number;
      // decompile minimally
      const op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
      // opcode
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
exports.decompile = decompile;
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  return chunks
    .map(chunk => {
      // data?
      if (singleChunkIsBuffer(chunk)) {
        const op = asMinimalOP(chunk);
        if (op === undefined) return chunk.toString('hex');
        chunk = op;
      }
      // opcode!
      return ops_1.REVERSE_OPS[chunk];
    })
    .join(' ');
}
exports.toASM = toASM;
function fromASM(asm) {
  typeforce(types.String, asm);
  return compile(
    asm.split(' ').map(chunkStr => {
      // opcode?
      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];
      typeforce(types.Hex, chunkStr);
      // data!
      return Buffer.from(chunkStr, 'hex');
    }),
  );
}
exports.fromASM = fromASM;
function toStack(chunks) {
  chunks = decompile(chunks);
  typeforce(isPushOnly, chunks);
  return chunks.map(op => {
    if (singleChunkIsBuffer(op)) return op;
    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
    return scriptNumber.encode(op - OP_INT_BASE);
  });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
  return types.isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & ~0x80;
  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
  if (!Buffer.isBuffer(buffer)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return bip66.check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
exports.number = scriptNumber;
exports.signature = scriptSignature;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_number.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_number.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  const length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
        throw new Error('Non-minimally encoded script number');
    }
  }
  // 40-bit
  if (length === 5) {
    const a = buffer.readUInt32LE(0);
    const b = buffer.readUInt8(4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  // 32-bit / 24-bit / 16-bit / 8-bit
  let result = 0;
  for (let i = 0; i < length; ++i) {
    result |= buffer[i] << (8 * i);
  }
  if (buffer[length - 1] & 0x80)
    return -(result & ~(0x80 << (8 * (length - 1))));
  return result;
}
exports.decode = decode;
function scriptNumSize(i) {
  return i > 0x7fffffff
    ? 5
    : i > 0x7fffff
    ? 4
    : i > 0x7fff
    ? 3
    : i > 0x7f
    ? 2
    : i > 0x00
    ? 1
    : 0;
}
function encode(_number) {
  let value = Math.abs(_number);
  const size = scriptNumSize(value);
  const buffer = Buffer.allocUnsafe(size);
  const negative = _number < 0;
  for (let i = 0; i < size; ++i) {
    buffer.writeUInt8(value & 0xff, i);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}
exports.encode = encode;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_signature.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_signature.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
const bip66 = __webpack_require__(/*! ./bip66 */ "./node_modules/bitcoinjs-lib/src/bip66.js");
const types = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const { typeforce } = types;
const ZERO = Buffer.alloc(1, 0);
function toDER(x) {
  let i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
  return x;
}
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  const buffer = Buffer.alloc(32, 0);
  const bstart = Math.max(0, 32 - x.length);
  x.copy(buffer, bstart);
  return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
function decode(buffer) {
  const hashType = buffer.readUInt8(buffer.length - 1);
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const decoded = bip66.decode(buffer.slice(0, -1));
  const r = fromDER(decoded.r);
  const s = fromDER(decoded.s);
  const signature = Buffer.concat([r, s], 64);
  return { signature, hashType };
}
exports.decode = decode;
function encode(signature, hashType) {
  typeforce(
    {
      signature: types.BufferN(64),
      hashType: types.UInt8,
    },
    { signature, hashType },
  );
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const hashTypeBuffer = Buffer.allocUnsafe(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  const r = toDER(signature.slice(0, 32));
  const s = toDER(signature.slice(32, 64));
  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
}
exports.encode = encode;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/transaction.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/transaction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = void 0;
const bufferutils_1 = __webpack_require__(/*! ./bufferutils */ "./node_modules/bitcoinjs-lib/src/bufferutils.js");
const bcrypto = __webpack_require__(/*! ./crypto */ "./node_modules/bitcoinjs-lib/src/crypto.js");
const bscript = __webpack_require__(/*! ./script */ "./node_modules/bitcoinjs-lib/src/script.js");
const script_1 = __webpack_require__(/*! ./script */ "./node_modules/bitcoinjs-lib/src/script.js");
const types = __webpack_require__(/*! ./types */ "./node_modules/bitcoinjs-lib/src/types.js");
const { typeforce } = types;
function varSliceSize(someScript) {
  const length = someScript.length;
  return bufferutils_1.varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
  const length = someVector.length;
  return (
    bufferutils_1.varuint.encodingLength(length) +
    someVector.reduce((sum, witness) => {
      return sum + varSliceSize(witness);
    }, 0)
  );
}
const EMPTY_BUFFER = Buffer.allocUnsafe(0);
const EMPTY_WITNESS = [];
const ZERO = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex',
);
const ONE = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000001',
  'hex',
);
const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
const BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX,
};
function isOutput(out) {
  return out.value !== undefined;
}
class Transaction {
  constructor() {
    this.version = 1;
    this.locktime = 0;
    this.ins = [];
    this.outs = [];
  }
  static fromBuffer(buffer, _NO_STRICT) {
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const tx = new Transaction();
    tx.version = bufferReader.readInt32();
    const marker = bufferReader.readUInt8();
    const flag = bufferReader.readUInt8();
    let hasWitnesses = false;
    if (
      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
      flag === Transaction.ADVANCED_TRANSACTION_FLAG
    ) {
      hasWitnesses = true;
    } else {
      bufferReader.offset -= 2;
    }
    const vinLen = bufferReader.readVarInt();
    for (let i = 0; i < vinLen; ++i) {
      tx.ins.push({
        hash: bufferReader.readSlice(32),
        index: bufferReader.readUInt32(),
        script: bufferReader.readVarSlice(),
        sequence: bufferReader.readUInt32(),
        witness: EMPTY_WITNESS,
      });
    }
    const voutLen = bufferReader.readVarInt();
    for (let i = 0; i < voutLen; ++i) {
      tx.outs.push({
        value: bufferReader.readUInt64(),
        script: bufferReader.readVarSlice(),
      });
    }
    if (hasWitnesses) {
      for (let i = 0; i < vinLen; ++i) {
        tx.ins[i].witness = bufferReader.readVector();
      }
      // was this pointless?
      if (!tx.hasWitnesses())
        throw new Error('Transaction has superfluous witness data');
    }
    tx.locktime = bufferReader.readUInt32();
    if (_NO_STRICT) return tx;
    if (bufferReader.offset !== buffer.length)
      throw new Error('Transaction has unexpected data');
    return tx;
  }
  static fromHex(hex) {
    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
  }
  static isCoinbaseHash(buffer) {
    typeforce(types.Hash256bit, buffer);
    for (let i = 0; i < 32; ++i) {
      if (buffer[i] !== 0) return false;
    }
    return true;
  }
  isCoinbase() {
    return (
      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
    );
  }
  addInput(hash, index, sequence, scriptSig) {
    typeforce(
      types.tuple(
        types.Hash256bit,
        types.UInt32,
        types.maybe(types.UInt32),
        types.maybe(types.Buffer),
      ),
      arguments,
    );
    if (types.Null(sequence)) {
      sequence = Transaction.DEFAULT_SEQUENCE;
    }
    // Add the input and return the input's index
    return (
      this.ins.push({
        hash,
        index,
        script: scriptSig || EMPTY_BUFFER,
        sequence: sequence,
        witness: EMPTY_WITNESS,
      }) - 1
    );
  }
  addOutput(scriptPubKey, value) {
    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
    // Add the output and return the output's index
    return (
      this.outs.push({
        script: scriptPubKey,
        value,
      }) - 1
    );
  }
  hasWitnesses() {
    return this.ins.some(x => {
      return x.witness.length !== 0;
    });
  }
  weight() {
    const base = this.byteLength(false);
    const total = this.byteLength(true);
    return base * 3 + total;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(_ALLOW_WITNESS = true) {
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    return (
      (hasWitnesses ? 10 : 8) +
      bufferutils_1.varuint.encodingLength(this.ins.length) +
      bufferutils_1.varuint.encodingLength(this.outs.length) +
      this.ins.reduce((sum, input) => {
        return sum + 40 + varSliceSize(input.script);
      }, 0) +
      this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0) +
      (hasWitnesses
        ? this.ins.reduce((sum, input) => {
            return sum + vectorSize(input.witness);
          }, 0)
        : 0)
    );
  }
  clone() {
    const newTx = new Transaction();
    newTx.version = this.version;
    newTx.locktime = this.locktime;
    newTx.ins = this.ins.map(txIn => {
      return {
        hash: txIn.hash,
        index: txIn.index,
        script: txIn.script,
        sequence: txIn.sequence,
        witness: txIn.witness,
      };
    });
    newTx.outs = this.outs.map(txOut => {
      return {
        script: txOut.script,
        value: txOut.value,
      };
    });
    return newTx;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(inIndex, prevOutScript, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
      arguments,
    );
    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
    if (inIndex >= this.ins.length) return ONE;
    // ignore OP_CODESEPARATOR
    const ourScript = bscript.compile(
      bscript.decompile(prevOutScript).filter(x => {
        return x !== script_1.OPS.OP_CODESEPARATOR;
      }),
    );
    const txTmp = this.clone();
    // SIGHASH_NONE: ignore all outputs? (wildcard payee)
    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
      txTmp.outs = [];
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, i) => {
        if (i === inIndex) return;
        input.sequence = 0;
      });
      // SIGHASH_SINGLE: ignore all outputs, except at the same index?
    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
      if (inIndex >= this.outs.length) return ONE;
      // truncate outputs after
      txTmp.outs.length = inIndex + 1;
      // "blank" outputs before
      for (let i = 0; i < inIndex; i++) {
        txTmp.outs[i] = BLANK_OUTPUT;
      }
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, y) => {
        if (y === inIndex) return;
        input.sequence = 0;
      });
    }
    // SIGHASH_ANYONECANPAY: ignore inputs entirely?
    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
      txTmp.ins = [txTmp.ins[inIndex]];
      txTmp.ins[0].script = ourScript;
      // SIGHASH_ALL: only ignore input scripts
    } else {
      // "blank" others input scripts
      txTmp.ins.forEach(input => {
        input.script = EMPTY_BUFFER;
      });
      txTmp.ins[inIndex].script = ourScript;
    }
    // serialize and hash
    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
    buffer.writeInt32LE(hashType, buffer.length - 4);
    txTmp.__toBuffer(buffer, 0, false);
    return bcrypto.hash256(buffer);
  }
  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
    typeforce(
      types.tuple(
        types.UInt32,
        typeforce.arrayOf(types.Buffer),
        typeforce.arrayOf(types.Satoshi),
        types.UInt32,
      ),
      arguments,
    );
    if (
      values.length !== this.ins.length ||
      prevOutScripts.length !== this.ins.length
    ) {
      throw new Error('Must supply prevout script and value for all inputs');
    }
    const outputType =
      hashType === Transaction.SIGHASH_DEFAULT
        ? Transaction.SIGHASH_ALL
        : hashType & Transaction.SIGHASH_OUTPUT_MASK;
    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
    const isNone = outputType === Transaction.SIGHASH_NONE;
    const isSingle = outputType === Transaction.SIGHASH_SINGLE;
    let hashPrevouts = EMPTY_BUFFER;
    let hashAmounts = EMPTY_BUFFER;
    let hashScriptPubKeys = EMPTY_BUFFER;
    let hashSequences = EMPTY_BUFFER;
    let hashOutputs = EMPTY_BUFFER;
    if (!isAnyoneCanPay) {
      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        36 * this.ins.length,
      );
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 * this.ins.length,
      );
      values.forEach(value => bufferWriter.writeUInt64(value));
      hashAmounts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),
      );
      prevOutScripts.forEach(prevOutScript =>
        bufferWriter.writeVarSlice(prevOutScript),
      );
      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        4 * this.ins.length,
      );
      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));
      hashSequences = bcrypto.sha256(bufferWriter.end());
    }
    if (!(isNone || isSingle)) {
      const txOutsSize = this.outs
        .map(output => 8 + varSliceSize(output.script))
        .reduce((a, b) => a + b);
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    } else if (isSingle && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 + varSliceSize(output.script),
      );
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    }
    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
    // Length calculation from:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14
    // With extension from:
    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation
    const sigMsgSize =
      174 -
      (isAnyoneCanPay ? 49 : 0) -
      (isNone ? 32 : 0) +
      (annex ? 32 : 0) +
      (leafHash ? 37 : 0);
    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
    sigMsgWriter.writeUInt8(hashType);
    // Transaction
    sigMsgWriter.writeInt32(this.version);
    sigMsgWriter.writeUInt32(this.locktime);
    sigMsgWriter.writeSlice(hashPrevouts);
    sigMsgWriter.writeSlice(hashAmounts);
    sigMsgWriter.writeSlice(hashScriptPubKeys);
    sigMsgWriter.writeSlice(hashSequences);
    if (!(isNone || isSingle)) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // Input
    sigMsgWriter.writeUInt8(spendType);
    if (isAnyoneCanPay) {
      const input = this.ins[inIndex];
      sigMsgWriter.writeSlice(input.hash);
      sigMsgWriter.writeUInt32(input.index);
      sigMsgWriter.writeUInt64(values[inIndex]);
      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
      sigMsgWriter.writeUInt32(input.sequence);
    } else {
      sigMsgWriter.writeUInt32(inIndex);
    }
    if (annex) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        varSliceSize(annex),
      );
      bufferWriter.writeVarSlice(annex);
      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
    }
    // Output
    if (isSingle) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // BIP342 extension
    if (leafHash) {
      sigMsgWriter.writeSlice(leafHash);
      sigMsgWriter.writeUInt8(0);
      sigMsgWriter.writeUInt32(0xffffffff);
    }
    // Extra zero byte because:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19
    return bcrypto.taggedHash(
      'TapSighash',
      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),
    );
  }
  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
      arguments,
    );
    let tbuffer = Buffer.from([]);
    let bufferWriter;
    let hashOutputs = ZERO;
    let hashPrevouts = ZERO;
    let hashSequence = ZERO;
    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.hash256(tbuffer);
    }
    if (
      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeUInt32(txIn.sequence);
      });
      hashSequence = bcrypto.hash256(tbuffer);
    }
    if (
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      const txOutsSize = this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0);
      tbuffer = Buffer.allocUnsafe(txOutsSize);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.hash256(tbuffer);
    } else if (
      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
      inIndex < this.outs.length
    ) {
      const output = this.outs[inIndex];
      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.hash256(tbuffer);
    }
    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
    const input = this.ins[inIndex];
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(hashPrevouts);
    bufferWriter.writeSlice(hashSequence);
    bufferWriter.writeSlice(input.hash);
    bufferWriter.writeUInt32(input.index);
    bufferWriter.writeVarSlice(prevOutScript);
    bufferWriter.writeUInt64(value);
    bufferWriter.writeUInt32(input.sequence);
    bufferWriter.writeSlice(hashOutputs);
    bufferWriter.writeUInt32(this.locktime);
    bufferWriter.writeUInt32(hashType);
    return bcrypto.hash256(tbuffer);
  }
  getHash(forWitness) {
    // wtxid for coinbase is always 32 bytes of 0x00
    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
  }
  getId() {
    // transaction hash's are displayed in reverse order
    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
      'hex',
    );
  }
  toBuffer(buffer, initialOffset) {
    return this.__toBuffer(buffer, initialOffset, true);
  }
  toHex() {
    return this.toBuffer(undefined, undefined).toString('hex');
  }
  setInputScript(index, scriptSig) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.ins[index].script = scriptSig;
  }
  setWitness(index, witness) {
    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
    this.ins[index].witness = witness;
  }
  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
    const bufferWriter = new bufferutils_1.BufferWriter(
      buffer,
      initialOffset || 0,
    );
    bufferWriter.writeInt32(this.version);
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    if (hasWitnesses) {
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
    }
    bufferWriter.writeVarInt(this.ins.length);
    this.ins.forEach(txIn => {
      bufferWriter.writeSlice(txIn.hash);
      bufferWriter.writeUInt32(txIn.index);
      bufferWriter.writeVarSlice(txIn.script);
      bufferWriter.writeUInt32(txIn.sequence);
    });
    bufferWriter.writeVarInt(this.outs.length);
    this.outs.forEach(txOut => {
      if (isOutput(txOut)) {
        bufferWriter.writeUInt64(txOut.value);
      } else {
        bufferWriter.writeSlice(txOut.valueBuffer);
      }
      bufferWriter.writeVarSlice(txOut.script);
    });
    if (hasWitnesses) {
      this.ins.forEach(input => {
        bufferWriter.writeVector(input.witness);
      });
    }
    bufferWriter.writeUInt32(this.locktime);
    // avoid slicing unless necessary
    if (initialOffset !== undefined)
      return buffer.slice(initialOffset, bufferWriter.offset);
    return buffer;
  }
}
exports.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;


/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/types.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneOf =
  exports.Null =
  exports.BufferN =
  exports.Function =
  exports.UInt32 =
  exports.UInt8 =
  exports.tuple =
  exports.maybe =
  exports.Hex =
  exports.Buffer =
  exports.String =
  exports.Boolean =
  exports.Array =
  exports.Number =
  exports.Hash256bit =
  exports.Hash160bit =
  exports.Buffer256bit =
  exports.isTaptree =
  exports.isTapleaf =
  exports.TAPLEAF_VERSION_MASK =
  exports.Network =
  exports.ECPoint =
  exports.Satoshi =
  exports.Signer =
  exports.BIP32Path =
  exports.UInt31 =
  exports.isPoint =
  exports.typeforce =
    void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
exports.typeforce = __webpack_require__(/*! typeforce */ "./node_modules/typeforce/index.js");
const ZERO32 = buffer_1.Buffer.alloc(32, 0);
const EC_P = buffer_1.Buffer.from(
  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
  'hex',
);
function isPoint(p) {
  if (!buffer_1.Buffer.isBuffer(p)) return false;
  if (p.length < 33) return false;
  const t = p[0];
  const x = p.slice(1, 33);
  if (x.compare(ZERO32) === 0) return false;
  if (x.compare(EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  const y = p.slice(33);
  if (y.compare(ZERO32) === 0) return false;
  if (y.compare(EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.isPoint = isPoint;
const UINT31_MAX = Math.pow(2, 31) - 1;
function UInt31(value) {
  return exports.typeforce.UInt32(value) && value <= UINT31_MAX;
}
exports.UInt31 = UInt31;
function BIP32Path(value) {
  return (
    exports.typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
  );
}
exports.BIP32Path = BIP32Path;
BIP32Path.toJSON = () => {
  return 'BIP32 derivation path';
};
function Signer(obj) {
  return (
    (exports.typeforce.Buffer(obj.publicKey) ||
      typeof obj.getPublicKey === 'function') &&
    typeof obj.sign === 'function'
  );
}
exports.Signer = Signer;
const SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
}
exports.Satoshi = Satoshi;
// external dependent types
exports.ECPoint = exports.typeforce.quacksLike('Point');
// exposed, external API
exports.Network = exports.typeforce.compile({
  messagePrefix: exports.typeforce.oneOf(
    exports.typeforce.Buffer,
    exports.typeforce.String,
  ),
  bip32: {
    public: exports.typeforce.UInt32,
    private: exports.typeforce.UInt32,
  },
  pubKeyHash: exports.typeforce.UInt8,
  scriptHash: exports.typeforce.UInt8,
  wif: exports.typeforce.UInt8,
});
exports.TAPLEAF_VERSION_MASK = 0xfe;
function isTapleaf(o) {
  if (!o || !('output' in o)) return false;
  if (!buffer_1.Buffer.isBuffer(o.output)) return false;
  if (o.version !== undefined)
    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
exports.isTapleaf = isTapleaf;
function isTaptree(scriptTree) {
  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every(t => isTaptree(t));
}
exports.isTaptree = isTaptree;
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Hash160bit = exports.typeforce.BufferN(20);
exports.Hash256bit = exports.typeforce.BufferN(32);
exports.Number = exports.typeforce.Number;
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean;
exports.String = exports.typeforce.String;
exports.Buffer = exports.typeforce.Buffer;
exports.Hex = exports.typeforce.Hex;
exports.maybe = exports.typeforce.maybe;
exports.tuple = exports.typeforce.tuple;
exports.UInt8 = exports.typeforce.UInt8;
exports.UInt32 = exports.typeforce.UInt32;
exports.Function = exports.typeforce.Function;
exports.BufferN = exports.typeforce.BufferN;
exports.Null = exports.typeforce.Null;
exports.oneOf = exports.typeforce.oneOf;


/***/ }),

/***/ "./node_modules/bs58/index.js":
/*!************************************!*\
  !*** ./node_modules/bs58/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const basex = __webpack_require__(/*! base-x */ "./node_modules/base-x/src/index.js")
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),

/***/ "./node_modules/bs58check/base.js":
/*!****************************************!*\
  !*** ./node_modules/bs58check/base.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var base58 = __webpack_require__(/*! bs58 */ "./node_modules/bs58/index.js")

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var payloadU8 = Uint8Array.from(payload)
    var checksum = checksumFn(payloadU8)
    var length = payloadU8.length + 4
    var both = new Uint8Array(length)
    both.set(payloadU8, 0)
    both.set(checksum.subarray(0, 4), payloadU8.length)
    return base58.encode(both, length)
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}


/***/ }),

/***/ "./node_modules/bs58check/index.js":
/*!*****************************************!*\
  !*** ./node_modules/bs58check/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var { sha256 } = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/sha256.js")
var bs58checkBase = __webpack_require__(/*! ./base */ "./node_modules/bs58check/base.js")

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  return sha256(sha256(buffer))
}

module.exports = bs58checkBase(sha256x2)


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/darkreader/darkreader.js":
/*!***********************************************!*\
  !*** ./node_modules/darkreader/darkreader.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/**
 * Dark Reader v4.9.58
 * https://darkreader.org/
 */

(function (global, factory) {
     true
        ? factory(exports)
        : 0;
})(this, function (exports) {
    "use strict";

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function () {
        __assign =
            Object.assign ||
            function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P
                ? value
                : new P(function (resolve) {
                      resolve(value);
                  });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected);
            }
            step(
                (generator = generator.apply(thisArg, _arguments || [])).next()
            );
        });
    }

    function __generator(thisArg, body) {
        var _ = {
                label: 0,
                sent: function () {
                    if (t[0] & 1) throw t[1];
                    return t[1];
                },
                trys: [],
                ops: []
            },
            f,
            y,
            t,
            g;
        return (
            (g = {next: verb(0), throw: verb(1), return: verb(2)}),
            typeof Symbol === "function" &&
                (g[Symbol.iterator] = function () {
                    return this;
                }),
            g
        );
        function verb(n) {
            return function (v) {
                return step([n, v]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (
                        ((f = 1),
                        y &&
                            (t =
                                op[0] & 2
                                    ? y["return"]
                                    : op[0]
                                    ? y["throw"] ||
                                      ((t = y["return"]) && t.call(y), 0)
                                    : y.next) &&
                            !(t = t.call(y, op[1])).done)
                    )
                        return t;
                    if (((y = 0), t)) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return {value: op[1], done: false};
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (
                                !((t = _.trys),
                                (t = t.length > 0 && t[t.length - 1])) &&
                                (op[0] === 6 || op[0] === 2)
                            ) {
                                _ = 0;
                                continue;
                            }
                            if (
                                op[0] === 3 &&
                                (!t || (op[1] > t[0] && op[1] < t[3]))
                            ) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2]) _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) {
                    op = [6, e];
                    y = 0;
                } finally {
                    f = t = 0;
                }
            if (op[0] & 5) throw op[1];
            return {value: op[0] ? op[1] : void 0, done: true};
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator,
            m = s && o[s],
            i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length) o = void 0;
                    return {value: o && o[i++], done: !o};
                }
            };
        throw new TypeError(
            s ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
            r,
            ar = [],
            e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        } catch (error) {
            e = {error: error};
        } finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            } finally {
                if (e) throw e.error;
            }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var MessageType;
    (function (MessageType) {
        MessageType["UI_GET_DATA"] = "ui-get-data";
        MessageType["UI_SUBSCRIBE_TO_CHANGES"] = "ui-subscribe-to-changes";
        MessageType["UI_UNSUBSCRIBE_FROM_CHANGES"] =
            "ui-unsubscribe-from-changes";
        MessageType["UI_CHANGE_SETTINGS"] = "ui-change-settings";
        MessageType["UI_SET_THEME"] = "ui-set-theme";
        MessageType["UI_SET_SHORTCUT"] = "ui-set-shortcut";
        MessageType["UI_TOGGLE_ACTIVE_TAB"] = "ui-toggle-active-tab";
        MessageType["UI_MARK_NEWS_AS_READ"] = "ui-mark-news-as-read";
        MessageType["UI_MARK_NEWS_AS_DISPLAYED"] = "ui-mark-news-as-displayed";
        MessageType["UI_LOAD_CONFIG"] = "ui-load-config";
        MessageType["UI_APPLY_DEV_DYNAMIC_THEME_FIXES"] =
            "ui-apply-dev-dynamic-theme-fixes";
        MessageType["UI_RESET_DEV_DYNAMIC_THEME_FIXES"] =
            "ui-reset-dev-dynamic-theme-fixes";
        MessageType["UI_APPLY_DEV_INVERSION_FIXES"] =
            "ui-apply-dev-inversion-fixes";
        MessageType["UI_RESET_DEV_INVERSION_FIXES"] =
            "ui-reset-dev-inversion-fixes";
        MessageType["UI_APPLY_DEV_STATIC_THEMES"] =
            "ui-apply-dev-static-themes";
        MessageType["UI_RESET_DEV_STATIC_THEMES"] =
            "ui-reset-dev-static-themes";
        MessageType["UI_SAVE_FILE"] = "ui-save-file";
        MessageType["UI_REQUEST_EXPORT_CSS"] = "ui-request-export-css";
        MessageType["UI_COLOR_SCHEME_CHANGE"] = "ui-color-scheme-change";
        MessageType["BG_CHANGES"] = "bg-changes";
        MessageType["BG_ADD_CSS_FILTER"] = "bg-add-css-filter";
        MessageType["BG_ADD_STATIC_THEME"] = "bg-add-static-theme";
        MessageType["BG_ADD_SVG_FILTER"] = "bg-add-svg-filter";
        MessageType["BG_ADD_DYNAMIC_THEME"] = "bg-add-dynamic-theme";
        MessageType["BG_EXPORT_CSS"] = "bg-export-css";
        MessageType["BG_UNSUPPORTED_SENDER"] = "bg-unsupported-sender";
        MessageType["BG_CLEAN_UP"] = "bg-clean-up";
        MessageType["BG_RELOAD"] = "bg-reload";
        MessageType["BG_FETCH_RESPONSE"] = "bg-fetch-response";
        MessageType["BG_UI_UPDATE"] = "bg-ui-update";
        MessageType["BG_CSS_UPDATE"] = "bg-css-update";
        MessageType["CS_COLOR_SCHEME_CHANGE"] = "cs-color-scheme-change";
        MessageType["CS_FRAME_CONNECT"] = "cs-frame-connect";
        MessageType["CS_FRAME_FORGET"] = "cs-frame-forget";
        MessageType["CS_FRAME_FREEZE"] = "cs-frame-freeze";
        MessageType["CS_FRAME_RESUME"] = "cs-frame-resume";
        MessageType["CS_EXPORT_CSS_RESPONSE"] = "cs-export-css-response";
        MessageType["CS_FETCH"] = "cs-fetch";
        MessageType["CS_DARK_THEME_DETECTED"] = "cs-dark-theme-detected";
        MessageType["CS_DARK_THEME_NOT_DETECTED"] =
            "cs-dark-theme-not-detected";
        MessageType["CS_LOG"] = "cs-log";
    })(MessageType || (MessageType = {}));

    var isNavigatorDefined = typeof navigator !== "undefined";
    var userAgent = isNavigatorDefined
        ? navigator.userAgentData &&
          Array.isArray(navigator.userAgentData.brands)
            ? navigator.userAgentData.brands
                  .map(function (brand) {
                      return ""
                          .concat(brand.brand.toLowerCase(), " ")
                          .concat(brand.version);
                  })
                  .join(" ")
            : navigator.userAgent.toLowerCase()
        : "some useragent";
    var platform = isNavigatorDefined
        ? navigator.userAgentData &&
          typeof navigator.userAgentData.platform === "string"
            ? navigator.userAgentData.platform.toLowerCase()
            : navigator.platform.toLowerCase()
        : "some platform";
    var isChromium =
        userAgent.includes("chrome") || userAgent.includes("chromium");
    var isThunderbird = userAgent.includes("thunderbird");
    var isFirefox =
        userAgent.includes("firefox") ||
        userAgent.includes("librewolf") ||
        isThunderbird;
    userAgent.includes("vivaldi");
    userAgent.includes("yabrowser");
    userAgent.includes("opr") || userAgent.includes("opera");
    userAgent.includes("edg");
    var isSafari = userAgent.includes("safari") && !isChromium;
    var isWindows = platform.startsWith("win");
    var isMacOS = platform.startsWith("mac");
    isNavigatorDefined && navigator.userAgentData
        ? navigator.userAgentData.mobile
        : userAgent.includes("mobile");
    var isShadowDomSupported = typeof ShadowRoot === "function";
    var isMatchMediaChangeEventListenerSupported =
        typeof MediaQueryList === "function" &&
        typeof MediaQueryList.prototype.addEventListener === "function";
    (function () {
        var m = userAgent.match(/chrom(?:e|ium)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
            return m[1];
        }
        return "";
    })();
    (function () {
        var m = userAgent.match(/(?:firefox|librewolf)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
            return m[1];
        }
        return "";
    })();
    var isDefinedSelectorSupported = (function () {
        try {
            document.querySelector(":defined");
            return true;
        } catch (err) {
            return false;
        }
    })();
    var isCSSColorSchemePropSupported = (function () {
        if (typeof document === "undefined") {
            return false;
        }
        var el = document.createElement("div");
        el.setAttribute("style", "color-scheme: dark");
        return el.style && el.style.colorScheme === "dark";
    })();

    function getOKResponse(url, mimeType, origin) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        return [
                            4,
                            fetch(url, {
                                cache: "force-cache",
                                credentials: "omit",
                                referrer: origin
                            })
                        ];
                    case 1:
                        response = _a.sent();
                        if (
                            isFirefox &&
                            mimeType === "text/css" &&
                            url.startsWith("moz-extension://") &&
                            url.endsWith(".css")
                        ) {
                            return [2, response];
                        }
                        if (
                            mimeType &&
                            !response.headers
                                .get("Content-Type")
                                .startsWith(mimeType)
                        ) {
                            throw new Error(
                                "Mime type mismatch when loading ".concat(url)
                            );
                        }
                        if (!response.ok) {
                            throw new Error(
                                "Unable to load "
                                    .concat(url, " ")
                                    .concat(response.status, " ")
                                    .concat(response.statusText)
                            );
                        }
                        return [2, response];
                }
            });
        });
    }
    function loadAsDataURL(url, mimeType) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        return [4, getOKResponse(url, mimeType)];
                    case 1:
                        response = _a.sent();
                        return [4, readResponseAsDataURL(response)];
                    case 2:
                        return [2, _a.sent()];
                }
            });
        });
    }
    function readResponseAsDataURL(response) {
        return __awaiter(this, void 0, void 0, function () {
            var blob, dataURL;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        return [4, response.blob()];
                    case 1:
                        blob = _a.sent();
                        return [
                            4,
                            new Promise(function (resolve) {
                                var reader = new FileReader();
                                reader.onloadend = function () {
                                    return resolve(reader.result);
                                };
                                reader.readAsDataURL(blob);
                            })
                        ];
                    case 2:
                        dataURL = _a.sent();
                        return [2, dataURL];
                }
            });
        });
    }

    var throwCORSError = function (url) {
        return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [
                    2,
                    Promise.reject(
                        new Error(
                            [
                                "Embedded Dark Reader cannot access a cross-origin resource",
                                url,
                                "Overview your URLs and CORS policies or use",
                                "`DarkReader.setFetchMethod(fetch: (url) => Promise<Response>))`.",
                                "See if using `DarkReader.setFetchMethod(window.fetch)`",
                                "before `DarkReader.enable()` works."
                            ].join(" ")
                        )
                    )
                ];
            });
        });
    };
    var fetcher = throwCORSError;
    function setFetchMethod$1(fetch) {
        if (fetch) {
            fetcher = fetch;
        } else {
            fetcher = throwCORSError;
        }
    }
    function callFetchMethod(url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        return [4, fetcher(url)];
                    case 1:
                        return [2, _a.sent()];
                }
            });
        });
    }

    if (!window.chrome) {
        window.chrome = {};
    }
    if (!chrome.runtime) {
        chrome.runtime = {};
    }
    var messageListeners = new Set();
    function sendMessage() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var id_1, _a, url, responseType, response, text_1, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(args[0] && args[0].type === MessageType.CS_FETCH))
                            return [3, 8];
                        id_1 = args[0].id;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 7, , 8]);
                        (_a = args[0].data),
                            (url = _a.url),
                            (responseType = _a.responseType);
                        return [4, callFetchMethod(url)];
                    case 2:
                        response = _b.sent();
                        if (!(responseType === "data-url")) return [3, 4];
                        return [4, readResponseAsDataURL(response)];
                    case 3:
                        text_1 = _b.sent();
                        return [3, 6];
                    case 4:
                        return [4, response.text()];
                    case 5:
                        text_1 = _b.sent();
                        _b.label = 6;
                    case 6:
                        messageListeners.forEach(function (cb) {
                            return cb({
                                type: MessageType.BG_FETCH_RESPONSE,
                                data: text_1,
                                error: null,
                                id: id_1
                            });
                        });
                        return [3, 8];
                    case 7:
                        error_1 = _b.sent();
                        console.error(error_1);
                        messageListeners.forEach(function (cb) {
                            return cb({
                                type: MessageType.BG_FETCH_RESPONSE,
                                data: null,
                                error: error_1,
                                id: id_1
                            });
                        });
                        return [3, 8];
                    case 8:
                        return [2];
                }
            });
        });
    }
    function addMessageListener(callback) {
        messageListeners.add(callback);
    }
    if (typeof chrome.runtime.sendMessage === "function") {
        var nativeSendMessage_1 = chrome.runtime.sendMessage;
        chrome.runtime.sendMessage = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            sendMessage.apply(void 0, __spreadArray([], __read(args), false));
            nativeSendMessage_1.apply(chrome.runtime, args);
        };
    } else {
        chrome.runtime.sendMessage = sendMessage;
    }
    if (!chrome.runtime.onMessage) {
        chrome.runtime.onMessage = {};
    }
    if (typeof chrome.runtime.onMessage.addListener === "function") {
        var nativeAddListener_1 = chrome.runtime.onMessage.addListener;
        chrome.runtime.onMessage.addListener = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            addMessageListener(args[0]);
            nativeAddListener_1.apply(chrome.runtime.onMessage, args);
        };
    } else {
        chrome.runtime.onMessage.addListener = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return addMessageListener(args[0]);
        };
    }

    var ThemeEngine;
    (function (ThemeEngine) {
        ThemeEngine["cssFilter"] = "cssFilter";
        ThemeEngine["svgFilter"] = "svgFilter";
        ThemeEngine["staticTheme"] = "staticTheme";
        ThemeEngine["dynamicTheme"] = "dynamicTheme";
    })(ThemeEngine || (ThemeEngine = {}));

    var AutomationMode;
    (function (AutomationMode) {
        AutomationMode["NONE"] = "";
        AutomationMode["TIME"] = "time";
        AutomationMode["SYSTEM"] = "system";
        AutomationMode["LOCATION"] = "location";
    })(AutomationMode || (AutomationMode = {}));

    var DEFAULT_COLORS = {
        darkScheme: {
            background: "#181a1b",
            text: "#e8e6e3"
        },
        lightScheme: {
            background: "#dcdad7",
            text: "#181a1b"
        }
    };
    var DEFAULT_THEME = {
        mode: 1,
        brightness: 100,
        contrast: 100,
        grayscale: 0,
        sepia: 0,
        useFont: false,
        fontFamily: isMacOS
            ? "Helvetica Neue"
            : isWindows
            ? "Segoe UI"
            : "Open Sans",
        textStroke: 0,
        engine: ThemeEngine.dynamicTheme,
        stylesheet: "",
        darkSchemeBackgroundColor: DEFAULT_COLORS.darkScheme.background,
        darkSchemeTextColor: DEFAULT_COLORS.darkScheme.text,
        lightSchemeBackgroundColor: DEFAULT_COLORS.lightScheme.background,
        lightSchemeTextColor: DEFAULT_COLORS.lightScheme.text,
        scrollbarColor: isMacOS ? "" : "auto",
        selectionColor: "auto",
        styleSystemControls: !isCSSColorSchemePropSupported,
        lightColorScheme: "Default",
        darkColorScheme: "Default",
        immediateModify: false
    };
    ({
        enabled: true,
        fetchNews: true,
        theme: DEFAULT_THEME,
        presets: [],
        customThemes: [],
        siteList: [],
        siteListEnabled: [],
        applyToListedOnly: false,
        changeBrowserTheme: false,
        syncSettings: true,
        syncSitesFixes: false,
        automation: {
            enabled: false,
            mode: AutomationMode.NONE,
            behavior: "OnOff"
        },
        time: {
            activation: "18:00",
            deactivation: "9:00"
        },
        location: {
            latitude: null,
            longitude: null
        },
        previewNewDesign: false,
        enableForPDF: true,
        enableForProtectedPages: false,
        enableContextMenus: false,
        detectDarkTheme: false
    });

    function isArrayLike(items) {
        return items.length != null;
    }
    function forEach(items, iterator) {
        var e_1, _a;
        if (isArrayLike(items)) {
            for (var i = 0, len = items.length; i < len; i++) {
                iterator(items[i]);
            }
        } else {
            try {
                for (
                    var items_1 = __values(items), items_1_1 = items_1.next();
                    !items_1_1.done;
                    items_1_1 = items_1.next()
                ) {
                    var item = items_1_1.value;
                    iterator(item);
                }
            } catch (e_1_1) {
                e_1 = {error: e_1_1};
            } finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return))
                        _a.call(items_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
        }
    }
    function push(array, addition) {
        forEach(addition, function (a) {
            return array.push(a);
        });
    }
    function toArray(items) {
        var results = [];
        for (var i = 0, len = items.length; i < len; i++) {
            results.push(items[i]);
        }
        return results;
    }

    function logInfo() {}
    function logWarn() {}

    function throttle(callback) {
        var pending = false;
        var frameId = null;
        var lastArgs;
        var throttled = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            if (frameId) {
                pending = true;
            } else {
                callback.apply(
                    void 0,
                    __spreadArray([], __read(lastArgs), false)
                );
                frameId = requestAnimationFrame(function () {
                    frameId = null;
                    if (pending) {
                        callback.apply(
                            void 0,
                            __spreadArray([], __read(lastArgs), false)
                        );
                        pending = false;
                    }
                });
            }
        };
        var cancel = function () {
            cancelAnimationFrame(frameId);
            pending = false;
            frameId = null;
        };
        return Object.assign(throttled, {cancel: cancel});
    }
    function createAsyncTasksQueue() {
        var tasks = [];
        var frameId = null;
        function runTasks() {
            var task;
            while ((task = tasks.shift())) {
                task();
            }
            frameId = null;
        }
        function add(task) {
            tasks.push(task);
            if (!frameId) {
                frameId = requestAnimationFrame(runTasks);
            }
        }
        function cancel() {
            tasks.splice(0);
            cancelAnimationFrame(frameId);
            frameId = null;
        }
        return {add: add, cancel: cancel};
    }

    function getDuration(time) {
        var duration = 0;
        if (time.seconds) {
            duration += time.seconds * 1000;
        }
        if (time.minutes) {
            duration += time.minutes * 60 * 1000;
        }
        if (time.hours) {
            duration += time.hours * 60 * 60 * 1000;
        }
        if (time.days) {
            duration += time.days * 24 * 60 * 60 * 1000;
        }
        return duration;
    }

    function removeNode(node) {
        node && node.parentNode && node.parentNode.removeChild(node);
    }
    function watchForNodePosition(node, mode, onRestore) {
        if (onRestore === void 0) {
            onRestore = Function.prototype;
        }
        var MAX_ATTEMPTS_COUNT = 10;
        var RETRY_TIMEOUT = getDuration({seconds: 2});
        var ATTEMPTS_INTERVAL = getDuration({seconds: 10});
        var prevSibling = node.previousSibling;
        var parent = node.parentNode;
        if (!parent) {
            throw new Error(
                "Unable to watch for node position: parent element not found"
            );
        }
        if (mode === "prev-sibling" && !prevSibling) {
            throw new Error(
                "Unable to watch for node position: there is no previous sibling"
            );
        }
        var attempts = 0;
        var start = null;
        var timeoutId = null;
        var restore = throttle(function () {
            if (timeoutId) {
                return;
            }
            attempts++;
            var now = Date.now();
            if (start == null) {
                start = now;
            } else if (attempts >= MAX_ATTEMPTS_COUNT) {
                if (now - start < ATTEMPTS_INTERVAL) {
                    timeoutId = setTimeout(function () {
                        start = null;
                        attempts = 0;
                        timeoutId = null;
                        restore();
                    }, RETRY_TIMEOUT);
                    return;
                }
                start = now;
                attempts = 1;
            }
            if (mode === "parent") {
                if (prevSibling && prevSibling.parentNode !== parent) {
                    stop();
                    return;
                }
            }
            if (mode === "prev-sibling") {
                if (prevSibling.parentNode == null) {
                    stop();
                    return;
                }
                if (prevSibling.parentNode !== parent) {
                    updateParent(prevSibling.parentNode);
                }
            }
            parent.insertBefore(
                node,
                prevSibling ? prevSibling.nextSibling : parent.firstChild
            );
            observer.takeRecords();
            onRestore && onRestore();
        });
        var observer = new MutationObserver(function () {
            if (
                (mode === "parent" && node.parentNode !== parent) ||
                (mode === "prev-sibling" &&
                    node.previousSibling !== prevSibling)
            ) {
                restore();
            }
        });
        var run = function () {
            observer.observe(parent, {childList: true});
        };
        var stop = function () {
            clearTimeout(timeoutId);
            observer.disconnect();
            restore.cancel();
        };
        var skip = function () {
            observer.takeRecords();
        };
        var updateParent = function (parentNode) {
            parent = parentNode;
            stop();
            run();
        };
        run();
        return {run: run, stop: stop, skip: skip};
    }
    function iterateShadowHosts(root, iterator) {
        if (root == null) {
            return;
        }
        var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
            acceptNode: function (node) {
                return node.shadowRoot == null
                    ? NodeFilter.FILTER_SKIP
                    : NodeFilter.FILTER_ACCEPT;
            }
        });
        for (
            var node = root.shadowRoot ? walker.currentNode : walker.nextNode();
            node != null;
            node = walker.nextNode()
        ) {
            if (node.classList.contains("surfingkeys_hints_host")) {
                continue;
            }
            iterator(node);
            iterateShadowHosts(node.shadowRoot, iterator);
        }
    }
    var isDOMReady = function () {
        return (
            document.readyState === "complete" ||
            document.readyState === "interactive"
        );
    };
    function setIsDOMReady(newFunc) {
        isDOMReady = newFunc;
    }
    var readyStateListeners = new Set();
    function addDOMReadyListener(listener) {
        isDOMReady() ? listener() : readyStateListeners.add(listener);
    }
    function removeDOMReadyListener(listener) {
        readyStateListeners.delete(listener);
    }
    function isReadyStateComplete() {
        return document.readyState === "complete";
    }
    var readyStateCompleteListeners = new Set();
    function addReadyStateCompleteListener(listener) {
        isReadyStateComplete()
            ? listener()
            : readyStateCompleteListeners.add(listener);
    }
    function cleanReadyStateCompleteListeners() {
        readyStateCompleteListeners.clear();
    }
    if (!isDOMReady()) {
        var onReadyStateChange_1 = function () {
            if (isDOMReady()) {
                readyStateListeners.forEach(function (listener) {
                    return listener();
                });
                readyStateListeners.clear();
                if (isReadyStateComplete()) {
                    document.removeEventListener(
                        "readystatechange",
                        onReadyStateChange_1
                    );
                    readyStateCompleteListeners.forEach(function (listener) {
                        return listener();
                    });
                    readyStateCompleteListeners.clear();
                }
            }
        };
        document.addEventListener("readystatechange", onReadyStateChange_1);
    }
    var HUGE_MUTATIONS_COUNT = 1000;
    function isHugeMutation(mutations) {
        if (mutations.length > HUGE_MUTATIONS_COUNT) {
            return true;
        }
        var addedNodesCount = 0;
        for (var i = 0; i < mutations.length; i++) {
            addedNodesCount += mutations[i].addedNodes.length;
            if (addedNodesCount > HUGE_MUTATIONS_COUNT) {
                return true;
            }
        }
        return false;
    }
    function getElementsTreeOperations(mutations) {
        var additions = new Set();
        var deletions = new Set();
        var moves = new Set();
        mutations.forEach(function (m) {
            forEach(m.addedNodes, function (n) {
                if (n instanceof Element && n.isConnected) {
                    additions.add(n);
                }
            });
            forEach(m.removedNodes, function (n) {
                if (n instanceof Element) {
                    if (n.isConnected) {
                        moves.add(n);
                        additions.delete(n);
                    } else {
                        deletions.add(n);
                    }
                }
            });
        });
        var duplicateAdditions = [];
        var duplicateDeletions = [];
        additions.forEach(function (node) {
            if (additions.has(node.parentElement)) {
                duplicateAdditions.push(node);
            }
        });
        deletions.forEach(function (node) {
            if (deletions.has(node.parentElement)) {
                duplicateDeletions.push(node);
            }
        });
        duplicateAdditions.forEach(function (node) {
            return additions.delete(node);
        });
        duplicateDeletions.forEach(function (node) {
            return deletions.delete(node);
        });
        return {additions: additions, moves: moves, deletions: deletions};
    }
    var optimizedTreeObservers = new Map();
    var optimizedTreeCallbacks = new WeakMap();
    function createOptimizedTreeObserver(root, callbacks) {
        var observer;
        var observerCallbacks;
        var domReadyListener;
        if (optimizedTreeObservers.has(root)) {
            observer = optimizedTreeObservers.get(root);
            observerCallbacks = optimizedTreeCallbacks.get(observer);
        } else {
            var hadHugeMutationsBefore_1 = false;
            var subscribedForReadyState_1 = false;
            observer = new MutationObserver(function (mutations) {
                if (isHugeMutation(mutations)) {
                    if (!hadHugeMutationsBefore_1 || isDOMReady()) {
                        observerCallbacks.forEach(function (_a) {
                            var onHugeMutations = _a.onHugeMutations;
                            return onHugeMutations(root);
                        });
                    } else if (!subscribedForReadyState_1) {
                        domReadyListener = function () {
                            return observerCallbacks.forEach(function (_a) {
                                var onHugeMutations = _a.onHugeMutations;
                                return onHugeMutations(root);
                            });
                        };
                        addDOMReadyListener(domReadyListener);
                        subscribedForReadyState_1 = true;
                    }
                    hadHugeMutationsBefore_1 = true;
                } else {
                    var elementsOperations_1 =
                        getElementsTreeOperations(mutations);
                    observerCallbacks.forEach(function (_a) {
                        var onMinorMutations = _a.onMinorMutations;
                        return onMinorMutations(elementsOperations_1);
                    });
                }
            });
            observer.observe(root, {childList: true, subtree: true});
            optimizedTreeObservers.set(root, observer);
            observerCallbacks = new Set();
            optimizedTreeCallbacks.set(observer, observerCallbacks);
        }
        observerCallbacks.add(callbacks);
        return {
            disconnect: function () {
                observerCallbacks.delete(callbacks);
                if (domReadyListener) {
                    removeDOMReadyListener(domReadyListener);
                }
                if (observerCallbacks.size === 0) {
                    observer.disconnect();
                    optimizedTreeCallbacks.delete(observer);
                    optimizedTreeObservers.delete(root);
                }
            }
        };
    }

    var anchor;
    var parsedURLCache = new Map();
    function fixBaseURL($url) {
        if (!anchor) {
            anchor = document.createElement("a");
        }
        anchor.href = $url;
        return anchor.href;
    }
    function parseURL($url, $base) {
        if ($base === void 0) {
            $base = null;
        }
        var key = "".concat($url).concat($base ? ";".concat($base) : "");
        if (parsedURLCache.has(key)) {
            return parsedURLCache.get(key);
        }
        if ($base) {
            var parsedURL_1 = new URL($url, fixBaseURL($base));
            parsedURLCache.set(key, parsedURL_1);
            return parsedURL_1;
        }
        var parsedURL = new URL(fixBaseURL($url));
        parsedURLCache.set($url, parsedURL);
        return parsedURL;
    }
    function getAbsoluteURL($base, $relative) {
        if ($relative.match(/^data\\?\:/)) {
            return $relative;
        }
        if (/^\/\//.test($relative)) {
            return "".concat(location.protocol).concat($relative);
        }
        var b = parseURL($base);
        var a = parseURL($relative, b.href);
        return a.href;
    }
    function isRelativeHrefOnAbsolutePath(href) {
        if (href.startsWith("data:")) {
            return true;
        }
        var url = parseURL(href);
        if (url.protocol !== location.protocol) {
            return false;
        }
        if (url.hostname !== location.hostname) {
            return false;
        }
        if (url.port !== location.port) {
            return false;
        }
        return url.pathname === location.pathname;
    }

    function iterateCSSRules(rules, iterate, onMediaRuleError) {
        forEach(rules, function (rule) {
            if (rule.selectorText) {
                iterate(rule);
            } else if (rule.href) {
                try {
                    iterateCSSRules(
                        rule.styleSheet.cssRules,
                        iterate,
                        onMediaRuleError
                    );
                } catch (err) {
                    logInfo("Found a non-loaded link.");
                    onMediaRuleError && onMediaRuleError();
                }
            } else if (rule.media) {
                var media = Array.from(rule.media);
                var isScreenOrAllOrQuery = media.some(function (m) {
                    return (
                        m.startsWith("screen") ||
                        m.startsWith("all") ||
                        m.startsWith("(")
                    );
                });
                var isPrintOrSpeech = media.some(function (m) {
                    return m.startsWith("print") || m.startsWith("speech");
                });
                if (isScreenOrAllOrQuery || !isPrintOrSpeech) {
                    iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
                }
            } else if (rule.conditionText) {
                if (CSS.supports(rule.conditionText)) {
                    iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
                }
            } else {
                logWarn("CSSRule type not supported", rule);
            }
        });
    }
    var shorthandVarDependantProperties = [
        "background",
        "border",
        "border-color",
        "border-bottom",
        "border-left",
        "border-right",
        "border-top",
        "outline",
        "outline-color"
    ];
    var shorthandVarDepPropRegexps = isSafari
        ? shorthandVarDependantProperties.map(function (prop) {
              var regexp = new RegExp("".concat(prop, ":\\s*(.*?)\\s*;"));
              return [prop, regexp];
          })
        : null;
    function iterateCSSDeclarations(style, iterate) {
        forEach(style, function (property) {
            var value = style.getPropertyValue(property).trim();
            if (!value) {
                return;
            }
            iterate(property, value);
        });
        var cssText = style.cssText;
        if (cssText.includes("var(")) {
            if (isSafari) {
                shorthandVarDepPropRegexps.forEach(function (_a) {
                    var _b = __read(_a, 2),
                        prop = _b[0],
                        regexp = _b[1];
                    var match = cssText.match(regexp);
                    if (match && match[1]) {
                        var val = match[1].trim();
                        iterate(prop, val);
                    }
                });
            } else {
                shorthandVarDependantProperties.forEach(function (prop) {
                    var val = style.getPropertyValue(prop);
                    if (val && val.includes("var(")) {
                        iterate(prop, val);
                    }
                });
            }
        }
    }
    var cssURLRegex = /url\((('.*?')|(".*?")|([^\)]*?))\)/g;
    var cssImportRegex =
        /@import\s*(url\()?(('.+?')|(".+?")|([^\)]*?))\)? ?(screen)?;?/gi;
    function getCSSURLValue(cssURL) {
        return cssURL
            .trim()
            .replace(/[\n\r\\]+/g, "")
            .replace(/^url\((.*)\)$/, "$1")
            .trim()
            .replace(/^"(.*)"$/, "$1")
            .replace(/^'(.*)'$/, "$1")
            .replace(/(?:\\(.))/g, "$1");
    }
    function getCSSBaseBath(url) {
        var cssURL = parseURL(url);
        return ""
            .concat(cssURL.origin)
            .concat(
                cssURL.pathname
                    .replace(/\?.*$/, "")
                    .replace(/(\/)([^\/]+)$/i, "$1")
            );
    }
    function replaceCSSRelativeURLsWithAbsolute($css, cssBasePath) {
        return $css.replace(cssURLRegex, function (match) {
            var pathValue = getCSSURLValue(match);
            try {
                return "url('".concat(
                    getAbsoluteURL(cssBasePath, pathValue),
                    "')"
                );
            } catch (err) {
                return match;
            }
        });
    }
    var cssCommentsRegex = /\/\*[\s\S]*?\*\//g;
    function removeCSSComments($css) {
        return $css.replace(cssCommentsRegex, "");
    }
    var fontFaceRegex = /@font-face\s*{[^}]*}/g;
    function replaceCSSFontFace($css) {
        return $css.replace(fontFaceRegex, "");
    }

    function evalMath(expression) {
        var rpnStack = [];
        var workingStack = [];
        var lastToken;
        for (var i = 0, len = expression.length; i < len; i++) {
            var token = expression[i];
            if (!token || token === " ") {
                continue;
            }
            if (operators.has(token)) {
                var op = operators.get(token);
                while (workingStack.length) {
                    var currentOp = operators.get(workingStack[0]);
                    if (!currentOp) {
                        break;
                    }
                    if (op.lessOrEqualThan(currentOp)) {
                        rpnStack.push(workingStack.shift());
                    } else {
                        break;
                    }
                }
                workingStack.unshift(token);
            } else if (!lastToken || operators.has(lastToken)) {
                rpnStack.push(token);
            } else {
                rpnStack[rpnStack.length - 1] += token;
            }
            lastToken = token;
        }
        rpnStack.push.apply(
            rpnStack,
            __spreadArray([], __read(workingStack), false)
        );
        var stack = [];
        for (var i = 0, len = rpnStack.length; i < len; i++) {
            var op = operators.get(rpnStack[i]);
            if (op) {
                var args = stack.splice(0, 2);
                stack.push(op.exec(args[1], args[0]));
            } else {
                stack.unshift(parseFloat(rpnStack[i]));
            }
        }
        return stack[0];
    }
    var Operator = (function () {
        function Operator(precedence, method) {
            this.precendce = precedence;
            this.execMethod = method;
        }
        Operator.prototype.exec = function (left, right) {
            return this.execMethod(left, right);
        };
        Operator.prototype.lessOrEqualThan = function (op) {
            return this.precendce <= op.precendce;
        };
        return Operator;
    })();
    var operators = new Map([
        [
            "+",
            new Operator(1, function (left, right) {
                return left + right;
            })
        ],
        [
            "-",
            new Operator(1, function (left, right) {
                return left - right;
            })
        ],
        [
            "*",
            new Operator(2, function (left, right) {
                return left * right;
            })
        ],
        [
            "/",
            new Operator(2, function (left, right) {
                return left / right;
            })
        ]
    ]);

    function getMatches(regex, input, group) {
        if (group === void 0) {
            group = 0;
        }
        var matches = [];
        var m;
        while ((m = regex.exec(input))) {
            matches.push(m[group]);
        }
        return matches;
    }
    function formatCSS(text) {
        function trimLeft(text) {
            return text.replace(/^\s+/, "");
        }
        function getIndent(depth) {
            if (depth === 0) {
                return "";
            }
            return " ".repeat(4 * depth);
        }
        if (text.length < 50000) {
            var emptyRuleRegexp = /[^{}]+{\s*}/;
            while (emptyRuleRegexp.test(text)) {
                text = text.replace(emptyRuleRegexp, "");
            }
        }
        var css = text
            .replace(/\s{2,}/g, " ")
            .replace(/\{/g, "{\n")
            .replace(/\}/g, "\n}\n")
            .replace(/\;(?![^\(|\"]*(\)|\"))/g, ";\n")
            .replace(/\,(?![^\(|\"]*(\)|\"))/g, ",\n")
            .replace(/\n\s*\n/g, "\n")
            .split("\n");
        var depth = 0;
        var formatted = [];
        for (var x = 0, len = css.length; x < len; x++) {
            var line = "".concat(css[x], "\n");
            if (line.includes("{")) {
                formatted.push(getIndent(depth++) + trimLeft(line));
            } else if (line.includes("}")) {
                formatted.push(getIndent(--depth) + trimLeft(line));
            } else {
                formatted.push(getIndent(depth) + trimLeft(line));
            }
        }
        return formatted.join("").trim();
    }
    function getParenthesesRange(input, searchStartIndex) {
        if (searchStartIndex === void 0) {
            searchStartIndex = 0;
        }
        var length = input.length;
        var depth = 0;
        var firstOpenIndex = -1;
        for (var i = searchStartIndex; i < length; i++) {
            if (depth === 0) {
                var openIndex = input.indexOf("(", i);
                if (openIndex < 0) {
                    break;
                }
                firstOpenIndex = openIndex;
                depth++;
                i = openIndex;
            } else {
                var closingIndex = input.indexOf(")", i);
                if (closingIndex < 0) {
                    break;
                }
                var openIndex = input.indexOf("(", i);
                if (openIndex < 0 || closingIndex < openIndex) {
                    depth--;
                    if (depth === 0) {
                        return {start: firstOpenIndex, end: closingIndex + 1};
                    }
                    i = closingIndex;
                } else {
                    depth++;
                    i = openIndex;
                }
            }
        }
        return null;
    }

    var hslaParseCache = new Map();
    var rgbaParseCache = new Map();
    function parseColorWithCache($color) {
        $color = $color.trim();
        if (rgbaParseCache.has($color)) {
            return rgbaParseCache.get($color);
        }
        if ($color.includes("calc(")) {
            $color = lowerCalcExpression($color);
        }
        var color = parse($color);
        color && rgbaParseCache.set($color, color);
        return color;
    }
    function parseToHSLWithCache(color) {
        if (hslaParseCache.has(color)) {
            return hslaParseCache.get(color);
        }
        var rgb = parseColorWithCache(color);
        if (!rgb) {
            return null;
        }
        var hsl = rgbToHSL(rgb);
        hslaParseCache.set(color, hsl);
        return hsl;
    }
    function clearColorCache() {
        hslaParseCache.clear();
        rgbaParseCache.clear();
    }
    function hslToRGB(_a) {
        var h = _a.h,
            s = _a.s,
            l = _a.l,
            _b = _a.a,
            a = _b === void 0 ? 1 : _b;
        if (s === 0) {
            var _c = __read(
                    [l, l, l].map(function (x) {
                        return Math.round(x * 255);
                    }),
                    3
                ),
                r_1 = _c[0],
                b_1 = _c[1],
                g_1 = _c[2];
            return {r: r_1, g: g_1, b: b_1, a: a};
        }
        var c = (1 - Math.abs(2 * l - 1)) * s;
        var x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        var m = l - c / 2;
        var _d = __read(
                (h < 60
                    ? [c, x, 0]
                    : h < 120
                    ? [x, c, 0]
                    : h < 180
                    ? [0, c, x]
                    : h < 240
                    ? [0, x, c]
                    : h < 300
                    ? [x, 0, c]
                    : [c, 0, x]
                ).map(function (n) {
                    return Math.round((n + m) * 255);
                }),
                3
            ),
            r = _d[0],
            g = _d[1],
            b = _d[2];
        return {r: r, g: g, b: b, a: a};
    }
    function rgbToHSL(_a) {
        var r255 = _a.r,
            g255 = _a.g,
            b255 = _a.b,
            _b = _a.a,
            a = _b === void 0 ? 1 : _b;
        var r = r255 / 255;
        var g = g255 / 255;
        var b = b255 / 255;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var c = max - min;
        var l = (max + min) / 2;
        if (c === 0) {
            return {h: 0, s: 0, l: l, a: a};
        }
        var h =
            (max === r
                ? ((g - b) / c) % 6
                : max === g
                ? (b - r) / c + 2
                : (r - g) / c + 4) * 60;
        if (h < 0) {
            h += 360;
        }
        var s = c / (1 - Math.abs(2 * l - 1));
        return {h: h, s: s, l: l, a: a};
    }
    function toFixed(n, digits) {
        if (digits === void 0) {
            digits = 0;
        }
        var fixed = n.toFixed(digits);
        if (digits === 0) {
            return fixed;
        }
        var dot = fixed.indexOf(".");
        if (dot >= 0) {
            var zerosMatch = fixed.match(/0+$/);
            if (zerosMatch) {
                if (zerosMatch.index === dot + 1) {
                    return fixed.substring(0, dot);
                }
                return fixed.substring(0, zerosMatch.index);
            }
        }
        return fixed;
    }
    function rgbToString(rgb) {
        var r = rgb.r,
            g = rgb.g,
            b = rgb.b,
            a = rgb.a;
        if (a != null && a < 1) {
            return "rgba("
                .concat(toFixed(r), ", ")
                .concat(toFixed(g), ", ")
                .concat(toFixed(b), ", ")
                .concat(toFixed(a, 2), ")");
        }
        return "rgb("
            .concat(toFixed(r), ", ")
            .concat(toFixed(g), ", ")
            .concat(toFixed(b), ")");
    }
    function rgbToHexString(_a) {
        var r = _a.r,
            g = _a.g,
            b = _a.b,
            a = _a.a;
        return "#".concat(
            (a != null && a < 1 ? [r, g, b, Math.round(a * 255)] : [r, g, b])
                .map(function (x) {
                    return "".concat(x < 16 ? "0" : "").concat(x.toString(16));
                })
                .join("")
        );
    }
    function hslToString(hsl) {
        var h = hsl.h,
            s = hsl.s,
            l = hsl.l,
            a = hsl.a;
        if (a != null && a < 1) {
            return "hsla("
                .concat(toFixed(h), ", ")
                .concat(toFixed(s * 100), "%, ")
                .concat(toFixed(l * 100), "%, ")
                .concat(toFixed(a, 2), ")");
        }
        return "hsl("
            .concat(toFixed(h), ", ")
            .concat(toFixed(s * 100), "%, ")
            .concat(toFixed(l * 100), "%)");
    }
    var rgbMatch = /^rgba?\([^\(\)]+\)$/;
    var hslMatch = /^hsla?\([^\(\)]+\)$/;
    var hexMatch = /^#[0-9a-f]+$/i;
    function parse($color) {
        var c = $color.trim().toLowerCase();
        if (c.match(rgbMatch)) {
            return parseRGB(c);
        }
        if (c.match(hslMatch)) {
            return parseHSL(c);
        }
        if (c.match(hexMatch)) {
            return parseHex(c);
        }
        if (knownColors.has(c)) {
            return getColorByName(c);
        }
        if (systemColors.has(c)) {
            return getSystemColor(c);
        }
        if ($color === "transparent") {
            return {r: 0, g: 0, b: 0, a: 0};
        }
        return null;
    }
    function getNumbers($color) {
        var numbers = [];
        var prevPos = 0;
        var isMining = false;
        var startIndex = $color.indexOf("(");
        $color = $color.substring(startIndex + 1, $color.length - 1);
        for (var i = 0; i < $color.length; i++) {
            var c = $color[i];
            if ((c >= "0" && c <= "9") || c === "." || c === "+" || c === "-") {
                isMining = true;
            } else if (isMining && (c === " " || c === ",")) {
                numbers.push($color.substring(prevPos, i));
                isMining = false;
                prevPos = i + 1;
            } else if (!isMining) {
                prevPos = i + 1;
            }
        }
        if (isMining) {
            numbers.push($color.substring(prevPos, $color.length));
        }
        return numbers;
    }
    function getNumbersFromString(str, range, units) {
        var raw = getNumbers(str);
        var unitsList = Object.entries(units);
        var numbers = raw
            .map(function (r) {
                return r.trim();
            })
            .map(function (r, i) {
                var n;
                var unit = unitsList.find(function (_a) {
                    var _b = __read(_a, 1),
                        u = _b[0];
                    return r.endsWith(u);
                });
                if (unit) {
                    n =
                        (parseFloat(r.substring(0, r.length - unit[0].length)) /
                            unit[1]) *
                        range[i];
                } else {
                    n = parseFloat(r);
                }
                if (range[i] > 1) {
                    return Math.round(n);
                }
                return n;
            });
        return numbers;
    }
    var rgbRange = [255, 255, 255, 1];
    var rgbUnits = {"%": 100};
    function parseRGB($rgb) {
        var _a = __read(getNumbersFromString($rgb, rgbRange, rgbUnits), 4),
            r = _a[0],
            g = _a[1],
            b = _a[2],
            _b = _a[3],
            a = _b === void 0 ? 1 : _b;
        return {r: r, g: g, b: b, a: a};
    }
    var hslRange = [360, 1, 1, 1];
    var hslUnits = {"%": 100, "deg": 360, "rad": 2 * Math.PI, "turn": 1};
    function parseHSL($hsl) {
        var _a = __read(getNumbersFromString($hsl, hslRange, hslUnits), 4),
            h = _a[0],
            s = _a[1],
            l = _a[2],
            _b = _a[3],
            a = _b === void 0 ? 1 : _b;
        return hslToRGB({h: h, s: s, l: l, a: a});
    }
    function parseHex($hex) {
        var h = $hex.substring(1);
        switch (h.length) {
            case 3:
            case 4: {
                var _a = __read(
                        [0, 1, 2].map(function (i) {
                            return parseInt("".concat(h[i]).concat(h[i]), 16);
                        }),
                        3
                    ),
                    r = _a[0],
                    g = _a[1],
                    b = _a[2];
                var a =
                    h.length === 3
                        ? 1
                        : parseInt("".concat(h[3]).concat(h[3]), 16) / 255;
                return {r: r, g: g, b: b, a: a};
            }
            case 6:
            case 8: {
                var _b = __read(
                        [0, 2, 4].map(function (i) {
                            return parseInt(h.substring(i, i + 2), 16);
                        }),
                        3
                    ),
                    r = _b[0],
                    g = _b[1],
                    b = _b[2];
                var a =
                    h.length === 6 ? 1 : parseInt(h.substring(6, 8), 16) / 255;
                return {r: r, g: g, b: b, a: a};
            }
        }
        return null;
    }
    function getColorByName($color) {
        var n = knownColors.get($color);
        return {
            r: (n >> 16) & 255,
            g: (n >> 8) & 255,
            b: (n >> 0) & 255,
            a: 1
        };
    }
    function getSystemColor($color) {
        var n = systemColors.get($color);
        return {
            r: (n >> 16) & 255,
            g: (n >> 8) & 255,
            b: (n >> 0) & 255,
            a: 1
        };
    }
    function lowerCalcExpression(color) {
        var searchIndex = 0;
        var replaceBetweenIndices = function (start, end, replacement) {
            color =
                color.substring(0, start) + replacement + color.substring(end);
        };
        while ((searchIndex = color.indexOf("calc(")) !== -1) {
            var range = getParenthesesRange(color, searchIndex);
            if (!range) {
                break;
            }
            var slice = color.slice(range.start + 1, range.end - 1);
            var includesPercentage = slice.includes("%");
            slice = slice.split("%").join("");
            var output = Math.round(evalMath(slice));
            replaceBetweenIndices(
                range.start - 4,
                range.end,
                output + (includesPercentage ? "%" : "")
            );
        }
        return color;
    }
    var knownColors = new Map(
        Object.entries({
            aliceblue: 0xf0f8ff,
            antiquewhite: 0xfaebd7,
            aqua: 0x00ffff,
            aquamarine: 0x7fffd4,
            azure: 0xf0ffff,
            beige: 0xf5f5dc,
            bisque: 0xffe4c4,
            black: 0x000000,
            blanchedalmond: 0xffebcd,
            blue: 0x0000ff,
            blueviolet: 0x8a2be2,
            brown: 0xa52a2a,
            burlywood: 0xdeb887,
            cadetblue: 0x5f9ea0,
            chartreuse: 0x7fff00,
            chocolate: 0xd2691e,
            coral: 0xff7f50,
            cornflowerblue: 0x6495ed,
            cornsilk: 0xfff8dc,
            crimson: 0xdc143c,
            cyan: 0x00ffff,
            darkblue: 0x00008b,
            darkcyan: 0x008b8b,
            darkgoldenrod: 0xb8860b,
            darkgray: 0xa9a9a9,
            darkgrey: 0xa9a9a9,
            darkgreen: 0x006400,
            darkkhaki: 0xbdb76b,
            darkmagenta: 0x8b008b,
            darkolivegreen: 0x556b2f,
            darkorange: 0xff8c00,
            darkorchid: 0x9932cc,
            darkred: 0x8b0000,
            darksalmon: 0xe9967a,
            darkseagreen: 0x8fbc8f,
            darkslateblue: 0x483d8b,
            darkslategray: 0x2f4f4f,
            darkslategrey: 0x2f4f4f,
            darkturquoise: 0x00ced1,
            darkviolet: 0x9400d3,
            deeppink: 0xff1493,
            deepskyblue: 0x00bfff,
            dimgray: 0x696969,
            dimgrey: 0x696969,
            dodgerblue: 0x1e90ff,
            firebrick: 0xb22222,
            floralwhite: 0xfffaf0,
            forestgreen: 0x228b22,
            fuchsia: 0xff00ff,
            gainsboro: 0xdcdcdc,
            ghostwhite: 0xf8f8ff,
            gold: 0xffd700,
            goldenrod: 0xdaa520,
            gray: 0x808080,
            grey: 0x808080,
            green: 0x008000,
            greenyellow: 0xadff2f,
            honeydew: 0xf0fff0,
            hotpink: 0xff69b4,
            indianred: 0xcd5c5c,
            indigo: 0x4b0082,
            ivory: 0xfffff0,
            khaki: 0xf0e68c,
            lavender: 0xe6e6fa,
            lavenderblush: 0xfff0f5,
            lawngreen: 0x7cfc00,
            lemonchiffon: 0xfffacd,
            lightblue: 0xadd8e6,
            lightcoral: 0xf08080,
            lightcyan: 0xe0ffff,
            lightgoldenrodyellow: 0xfafad2,
            lightgray: 0xd3d3d3,
            lightgrey: 0xd3d3d3,
            lightgreen: 0x90ee90,
            lightpink: 0xffb6c1,
            lightsalmon: 0xffa07a,
            lightseagreen: 0x20b2aa,
            lightskyblue: 0x87cefa,
            lightslategray: 0x778899,
            lightslategrey: 0x778899,
            lightsteelblue: 0xb0c4de,
            lightyellow: 0xffffe0,
            lime: 0x00ff00,
            limegreen: 0x32cd32,
            linen: 0xfaf0e6,
            magenta: 0xff00ff,
            maroon: 0x800000,
            mediumaquamarine: 0x66cdaa,
            mediumblue: 0x0000cd,
            mediumorchid: 0xba55d3,
            mediumpurple: 0x9370db,
            mediumseagreen: 0x3cb371,
            mediumslateblue: 0x7b68ee,
            mediumspringgreen: 0x00fa9a,
            mediumturquoise: 0x48d1cc,
            mediumvioletred: 0xc71585,
            midnightblue: 0x191970,
            mintcream: 0xf5fffa,
            mistyrose: 0xffe4e1,
            moccasin: 0xffe4b5,
            navajowhite: 0xffdead,
            navy: 0x000080,
            oldlace: 0xfdf5e6,
            olive: 0x808000,
            olivedrab: 0x6b8e23,
            orange: 0xffa500,
            orangered: 0xff4500,
            orchid: 0xda70d6,
            palegoldenrod: 0xeee8aa,
            palegreen: 0x98fb98,
            paleturquoise: 0xafeeee,
            palevioletred: 0xdb7093,
            papayawhip: 0xffefd5,
            peachpuff: 0xffdab9,
            peru: 0xcd853f,
            pink: 0xffc0cb,
            plum: 0xdda0dd,
            powderblue: 0xb0e0e6,
            purple: 0x800080,
            rebeccapurple: 0x663399,
            red: 0xff0000,
            rosybrown: 0xbc8f8f,
            royalblue: 0x4169e1,
            saddlebrown: 0x8b4513,
            salmon: 0xfa8072,
            sandybrown: 0xf4a460,
            seagreen: 0x2e8b57,
            seashell: 0xfff5ee,
            sienna: 0xa0522d,
            silver: 0xc0c0c0,
            skyblue: 0x87ceeb,
            slateblue: 0x6a5acd,
            slategray: 0x708090,
            slategrey: 0x708090,
            snow: 0xfffafa,
            springgreen: 0x00ff7f,
            steelblue: 0x4682b4,
            tan: 0xd2b48c,
            teal: 0x008080,
            thistle: 0xd8bfd8,
            tomato: 0xff6347,
            turquoise: 0x40e0d0,
            violet: 0xee82ee,
            wheat: 0xf5deb3,
            white: 0xffffff,
            whitesmoke: 0xf5f5f5,
            yellow: 0xffff00,
            yellowgreen: 0x9acd32
        })
    );
    var systemColors = new Map(
        Object.entries({
            "ActiveBorder": 0x3b99fc,
            "ActiveCaption": 0x000000,
            "AppWorkspace": 0xaaaaaa,
            "Background": 0x6363ce,
            "ButtonFace": 0xffffff,
            "ButtonHighlight": 0xe9e9e9,
            "ButtonShadow": 0x9fa09f,
            "ButtonText": 0x000000,
            "CaptionText": 0x000000,
            "GrayText": 0x7f7f7f,
            "Highlight": 0xb2d7ff,
            "HighlightText": 0x000000,
            "InactiveBorder": 0xffffff,
            "InactiveCaption": 0xffffff,
            "InactiveCaptionText": 0x000000,
            "InfoBackground": 0xfbfcc5,
            "InfoText": 0x000000,
            "Menu": 0xf6f6f6,
            "MenuText": 0xffffff,
            "Scrollbar": 0xaaaaaa,
            "ThreeDDarkShadow": 0x000000,
            "ThreeDFace": 0xc0c0c0,
            "ThreeDHighlight": 0xffffff,
            "ThreeDLightShadow": 0xffffff,
            "ThreeDShadow": 0x000000,
            "Window": 0xececec,
            "WindowFrame": 0xaaaaaa,
            "WindowText": 0x000000,
            "-webkit-focus-ring-color": 0xe59700
        }).map(function (_a) {
            var _b = __read(_a, 2),
                key = _b[0],
                value = _b[1];
            return [key.toLowerCase(), value];
        })
    );
    function getSRGBLightness(r, g, b) {
        return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
    }

    function scale(x, inLow, inHigh, outLow, outHigh) {
        return ((x - inLow) * (outHigh - outLow)) / (inHigh - inLow) + outLow;
    }
    function clamp(x, min, max) {
        return Math.min(max, Math.max(min, x));
    }
    function multiplyMatrices(m1, m2) {
        var result = [];
        for (var i = 0, len = m1.length; i < len; i++) {
            result[i] = [];
            for (var j = 0, len2 = m2[0].length; j < len2; j++) {
                var sum = 0;
                for (var k = 0, len3 = m1[0].length; k < len3; k++) {
                    sum += m1[i][k] * m2[k][j];
                }
                result[i][j] = sum;
            }
        }
        return result;
    }

    function createFilterMatrix(config) {
        var m = Matrix.identity();
        if (config.sepia !== 0) {
            m = multiplyMatrices(m, Matrix.sepia(config.sepia / 100));
        }
        if (config.grayscale !== 0) {
            m = multiplyMatrices(m, Matrix.grayscale(config.grayscale / 100));
        }
        if (config.contrast !== 100) {
            m = multiplyMatrices(m, Matrix.contrast(config.contrast / 100));
        }
        if (config.brightness !== 100) {
            m = multiplyMatrices(m, Matrix.brightness(config.brightness / 100));
        }
        if (config.mode === 1) {
            m = multiplyMatrices(m, Matrix.invertNHue());
        }
        return m;
    }
    function applyColorMatrix(_a, matrix) {
        var _b = __read(_a, 3),
            r = _b[0],
            g = _b[1],
            b = _b[2];
        var rgb = [[r / 255], [g / 255], [b / 255], [1], [1]];
        var result = multiplyMatrices(matrix, rgb);
        return [0, 1, 2].map(function (i) {
            return clamp(Math.round(result[i][0] * 255), 0, 255);
        });
    }
    var Matrix = {
        identity: function () {
            return [
                [1, 0, 0, 0, 0],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        invertNHue: function () {
            return [
                [0.333, -0.667, -0.667, 0, 1],
                [-0.667, 0.333, -0.667, 0, 1],
                [-0.667, -0.667, 0.333, 0, 1],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        brightness: function (v) {
            return [
                [v, 0, 0, 0, 0],
                [0, v, 0, 0, 0],
                [0, 0, v, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        contrast: function (v) {
            var t = (1 - v) / 2;
            return [
                [v, 0, 0, 0, t],
                [0, v, 0, 0, t],
                [0, 0, v, 0, t],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        sepia: function (v) {
            return [
                [
                    0.393 + 0.607 * (1 - v),
                    0.769 - 0.769 * (1 - v),
                    0.189 - 0.189 * (1 - v),
                    0,
                    0
                ],
                [
                    0.349 - 0.349 * (1 - v),
                    0.686 + 0.314 * (1 - v),
                    0.168 - 0.168 * (1 - v),
                    0,
                    0
                ],
                [
                    0.272 - 0.272 * (1 - v),
                    0.534 - 0.534 * (1 - v),
                    0.131 + 0.869 * (1 - v),
                    0,
                    0
                ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        grayscale: function (v) {
            return [
                [
                    0.2126 + 0.7874 * (1 - v),
                    0.7152 - 0.7152 * (1 - v),
                    0.0722 - 0.0722 * (1 - v),
                    0,
                    0
                ],
                [
                    0.2126 - 0.2126 * (1 - v),
                    0.7152 + 0.2848 * (1 - v),
                    0.0722 - 0.0722 * (1 - v),
                    0,
                    0
                ],
                [
                    0.2126 - 0.2126 * (1 - v),
                    0.7152 - 0.7152 * (1 - v),
                    0.0722 + 0.9278 * (1 - v),
                    0,
                    0
                ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        }
    };

    function getBgPole(theme) {
        var isDarkScheme = theme.mode === 1;
        var prop = isDarkScheme
            ? "darkSchemeBackgroundColor"
            : "lightSchemeBackgroundColor";
        return theme[prop];
    }
    function getFgPole(theme) {
        var isDarkScheme = theme.mode === 1;
        var prop = isDarkScheme
            ? "darkSchemeTextColor"
            : "lightSchemeTextColor";
        return theme[prop];
    }
    var colorModificationCache = new Map();
    function clearColorModificationCache() {
        colorModificationCache.clear();
    }
    var rgbCacheKeys = ["r", "g", "b", "a"];
    var themeCacheKeys$1 = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
    ];
    function getCacheId(rgb, theme) {
        var resultId = "";
        rgbCacheKeys.forEach(function (key) {
            resultId += "".concat(rgb[key], ";");
        });
        themeCacheKeys$1.forEach(function (key) {
            resultId += "".concat(theme[key], ";");
        });
        return resultId;
    }
    function modifyColorWithCache(
        rgb,
        theme,
        modifyHSL,
        poleColor,
        anotherPoleColor
    ) {
        var fnCache;
        if (colorModificationCache.has(modifyHSL)) {
            fnCache = colorModificationCache.get(modifyHSL);
        } else {
            fnCache = new Map();
            colorModificationCache.set(modifyHSL, fnCache);
        }
        var id = getCacheId(rgb, theme);
        if (fnCache.has(id)) {
            return fnCache.get(id);
        }
        var hsl = rgbToHSL(rgb);
        var pole = poleColor == null ? null : parseToHSLWithCache(poleColor);
        var anotherPole =
            anotherPoleColor == null
                ? null
                : parseToHSLWithCache(anotherPoleColor);
        var modified = modifyHSL(hsl, pole, anotherPole);
        var _a = hslToRGB(modified),
            r = _a.r,
            g = _a.g,
            b = _a.b,
            a = _a.a;
        var matrix = createFilterMatrix(theme);
        var _b = __read(applyColorMatrix([r, g, b], matrix), 3),
            rf = _b[0],
            gf = _b[1],
            bf = _b[2];
        var color =
            a === 1
                ? rgbToHexString({r: rf, g: gf, b: bf})
                : rgbToString({r: rf, g: gf, b: bf, a: a});
        fnCache.set(id, color);
        return color;
    }
    function noopHSL(hsl) {
        return hsl;
    }
    function modifyColor(rgb, theme) {
        return modifyColorWithCache(rgb, theme, noopHSL);
    }
    function modifyLightSchemeColor(rgb, theme) {
        var poleBg = getBgPole(theme);
        var poleFg = getFgPole(theme);
        return modifyColorWithCache(
            rgb,
            theme,
            modifyLightModeHSL,
            poleFg,
            poleBg
        );
    }
    function modifyLightModeHSL(_a, poleFg, poleBg) {
        var h = _a.h,
            s = _a.s,
            l = _a.l,
            a = _a.a;
        var isDark = l < 0.5;
        var isNeutral;
        if (isDark) {
            isNeutral = l < 0.2 || s < 0.12;
        } else {
            var isBlue = h > 200 && h < 280;
            isNeutral = s < 0.24 || (l > 0.8 && isBlue);
        }
        var hx = h;
        var sx = l;
        if (isNeutral) {
            if (isDark) {
                hx = poleFg.h;
                sx = poleFg.s;
            } else {
                hx = poleBg.h;
                sx = poleBg.s;
            }
        }
        var lx = scale(l, 0, 1, poleFg.l, poleBg.l);
        return {h: hx, s: sx, l: lx, a: a};
    }
    var MAX_BG_LIGHTNESS = 0.4;
    function modifyBgHSL(_a, pole) {
        var h = _a.h,
            s = _a.s,
            l = _a.l,
            a = _a.a;
        var isDark = l < 0.5;
        var isBlue = h > 200 && h < 280;
        var isNeutral = s < 0.12 || (l > 0.8 && isBlue);
        if (isDark) {
            var lx_1 = scale(l, 0, 0.5, 0, MAX_BG_LIGHTNESS);
            if (isNeutral) {
                var hx_1 = pole.h;
                var sx = pole.s;
                return {h: hx_1, s: sx, l: lx_1, a: a};
            }
            return {h: h, s: s, l: lx_1, a: a};
        }
        var lx = scale(l, 0.5, 1, MAX_BG_LIGHTNESS, pole.l);
        if (isNeutral) {
            var hx_2 = pole.h;
            var sx = pole.s;
            return {h: hx_2, s: sx, l: lx, a: a};
        }
        var hx = h;
        var isYellow = h > 60 && h < 180;
        if (isYellow) {
            var isCloserToGreen = h > 120;
            if (isCloserToGreen) {
                hx = scale(h, 120, 180, 135, 180);
            } else {
                hx = scale(h, 60, 120, 60, 105);
            }
        }
        if (hx > 40 && hx < 80) {
            lx *= 0.75;
        }
        return {h: hx, s: s, l: lx, a: a};
    }
    function modifyBackgroundColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        var pole = getBgPole(theme);
        return modifyColorWithCache(
            rgb,
            __assign(__assign({}, theme), {mode: 0}),
            modifyBgHSL,
            pole
        );
    }
    var MIN_FG_LIGHTNESS = 0.55;
    function modifyBlueFgHue(hue) {
        return scale(hue, 205, 245, 205, 220);
    }
    function modifyFgHSL(_a, pole) {
        var h = _a.h,
            s = _a.s,
            l = _a.l,
            a = _a.a;
        var isLight = l > 0.5;
        var isNeutral = l < 0.2 || s < 0.24;
        var isBlue = !isNeutral && h > 205 && h < 245;
        if (isLight) {
            var lx_2 = scale(l, 0.5, 1, MIN_FG_LIGHTNESS, pole.l);
            if (isNeutral) {
                var hx_3 = pole.h;
                var sx = pole.s;
                return {h: hx_3, s: sx, l: lx_2, a: a};
            }
            var hx_4 = h;
            if (isBlue) {
                hx_4 = modifyBlueFgHue(h);
            }
            return {h: hx_4, s: s, l: lx_2, a: a};
        }
        if (isNeutral) {
            var hx_5 = pole.h;
            var sx = pole.s;
            var lx_3 = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
            return {h: hx_5, s: sx, l: lx_3, a: a};
        }
        var hx = h;
        var lx;
        if (isBlue) {
            hx = modifyBlueFgHue(h);
            lx = scale(l, 0, 0.5, pole.l, Math.min(1, MIN_FG_LIGHTNESS + 0.05));
        } else {
            lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
        }
        return {h: hx, s: s, l: lx, a: a};
    }
    function modifyForegroundColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        var pole = getFgPole(theme);
        return modifyColorWithCache(
            rgb,
            __assign(__assign({}, theme), {mode: 0}),
            modifyFgHSL,
            pole
        );
    }
    function modifyBorderHSL(_a, poleFg, poleBg) {
        var h = _a.h,
            s = _a.s,
            l = _a.l,
            a = _a.a;
        var isDark = l < 0.5;
        var isNeutral = l < 0.2 || s < 0.24;
        var hx = h;
        var sx = s;
        if (isNeutral) {
            if (isDark) {
                hx = poleFg.h;
                sx = poleFg.s;
            } else {
                hx = poleBg.h;
                sx = poleBg.s;
            }
        }
        var lx = scale(l, 0, 1, 0.5, 0.2);
        return {h: hx, s: sx, l: lx, a: a};
    }
    function modifyBorderColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        var poleFg = getFgPole(theme);
        var poleBg = getBgPole(theme);
        return modifyColorWithCache(
            rgb,
            __assign(__assign({}, theme), {mode: 0}),
            modifyBorderHSL,
            poleFg,
            poleBg
        );
    }
    function modifyShadowColor(rgb, filter) {
        return modifyBackgroundColor(rgb, filter);
    }
    function modifyGradientColor(rgb, filter) {
        return modifyBackgroundColor(rgb, filter);
    }

    function createTextStyle(config) {
        var lines = [];
        lines.push(
            '*:not(pre, pre *, code, .far, .fa, .glyphicon, [class*="vjs-"], .fab, .fa-github, .fas, .material-icons, .icofont, .typcn, mu, [class*="mu-"], .glyphicon, .icon) {'
        );
        if (config.useFont && config.fontFamily) {
            lines.push(
                "  font-family: ".concat(config.fontFamily, " !important;")
            );
        }
        if (config.textStroke > 0) {
            lines.push(
                "  -webkit-text-stroke: ".concat(
                    config.textStroke,
                    "px !important;"
                )
            );
            lines.push(
                "  text-stroke: ".concat(config.textStroke, "px !important;")
            );
        }
        lines.push("}");
        return lines.join("\n");
    }

    var FilterMode;
    (function (FilterMode) {
        FilterMode[(FilterMode["light"] = 0)] = "light";
        FilterMode[(FilterMode["dark"] = 1)] = "dark";
    })(FilterMode || (FilterMode = {}));
    function getCSSFilterValue(config) {
        var filters = [];
        if (config.mode === FilterMode.dark) {
            filters.push("invert(100%) hue-rotate(180deg)");
        }
        if (config.brightness !== 100) {
            filters.push("brightness(".concat(config.brightness, "%)"));
        }
        if (config.contrast !== 100) {
            filters.push("contrast(".concat(config.contrast, "%)"));
        }
        if (config.grayscale !== 0) {
            filters.push("grayscale(".concat(config.grayscale, "%)"));
        }
        if (config.sepia !== 0) {
            filters.push("sepia(".concat(config.sepia, "%)"));
        }
        if (filters.length === 0) {
            return null;
        }
        return filters.join(" ");
    }

    function toSVGMatrix(matrix) {
        return matrix
            .slice(0, 4)
            .map(function (m) {
                return m
                    .map(function (m) {
                        return m.toFixed(3);
                    })
                    .join(" ");
            })
            .join(" ");
    }
    function getSVGFilterMatrixValue(config) {
        return toSVGMatrix(createFilterMatrix(config));
    }

    var counter = 0;
    var resolvers$1 = new Map();
    var rejectors = new Map();
    function bgFetch(request) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [
                    2,
                    new Promise(function (resolve, reject) {
                        var id = ++counter;
                        resolvers$1.set(id, resolve);
                        rejectors.set(id, reject);
                        chrome.runtime.sendMessage({
                            type: MessageType.CS_FETCH,
                            data: request,
                            id: id
                        });
                    })
                ];
            });
        });
    }
    chrome.runtime.onMessage.addListener(function (_a) {
        var type = _a.type,
            data = _a.data,
            error = _a.error,
            id = _a.id;
        if (type === MessageType.BG_FETCH_RESPONSE) {
            var resolve = resolvers$1.get(id);
            var reject = rejectors.get(id);
            resolvers$1.delete(id);
            rejectors.delete(id);
            if (error) {
                reject && reject(error);
            } else {
                resolve && resolve(data);
            }
        }
    });

    var AsyncQueue = (function () {
        function AsyncQueue() {
            this.queue = [];
            this.timerId = null;
            this.frameDuration = 1000 / 60;
        }
        AsyncQueue.prototype.addToQueue = function (entry) {
            this.queue.push(entry);
            this.startQueue();
        };
        AsyncQueue.prototype.stopQueue = function () {
            if (this.timerId !== null) {
                cancelAnimationFrame(this.timerId);
                this.timerId = null;
            }
            this.queue = [];
        };
        AsyncQueue.prototype.startQueue = function () {
            var _this = this;
            if (this.timerId) {
                return;
            }
            this.timerId = requestAnimationFrame(function () {
                _this.timerId = null;
                var start = Date.now();
                var cb;
                while ((cb = _this.queue.shift())) {
                    cb();
                    if (Date.now() - start >= _this.frameDuration) {
                        _this.startQueue();
                        break;
                    }
                }
            });
        };
        return AsyncQueue;
    })();

    var imageManager = new AsyncQueue();
    function getImageDetails(url) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [
                    2,
                    new Promise(function (resolve, reject) {
                        return __awaiter(_this, void 0, void 0, function () {
                            var dataURL, error_1, image_1, error_2;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!url.startsWith("data:"))
                                            return [3, 1];
                                        dataURL = url;
                                        return [3, 4];
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4, getImageDataURL(url)];
                                    case 2:
                                        dataURL = _a.sent();
                                        return [3, 4];
                                    case 3:
                                        error_1 = _a.sent();
                                        reject(error_1);
                                        return [2];
                                    case 4:
                                        _a.trys.push([4, 6, , 7]);
                                        return [4, urlToImage(dataURL)];
                                    case 5:
                                        image_1 = _a.sent();
                                        imageManager.addToQueue(function () {
                                            resolve(
                                                __assign(
                                                    {
                                                        src: url,
                                                        dataURL: dataURL,
                                                        width: image_1.naturalWidth,
                                                        height: image_1.naturalHeight
                                                    },
                                                    analyzeImage(image_1)
                                                )
                                            );
                                        });
                                        return [3, 7];
                                    case 6:
                                        error_2 = _a.sent();
                                        reject(error_2);
                                        return [3, 7];
                                    case 7:
                                        return [2];
                                }
                            });
                        });
                    })
                ];
            });
        });
    }
    function getImageDataURL(url) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedURL;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parsedURL = new URL(url);
                        if (!(parsedURL.origin === location.origin))
                            return [3, 2];
                        return [4, loadAsDataURL(url)];
                    case 1:
                        return [2, _a.sent()];
                    case 2:
                        return [
                            4,
                            bgFetch({url: url, responseType: "data-url"})
                        ];
                    case 3:
                        return [2, _a.sent()];
                }
            });
        });
    }
    function urlToImage(url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [
                    2,
                    new Promise(function (resolve, reject) {
                        var image = new Image();
                        image.onload = function () {
                            return resolve(image);
                        };
                        image.onerror = function () {
                            return reject("Unable to load image ".concat(url));
                        };
                        image.src = url;
                    })
                ];
            });
        });
    }
    var MAX_ANALIZE_PIXELS_COUNT = 32 * 32;
    var canvas;
    var context;
    function createCanvas() {
        var maxWidth = MAX_ANALIZE_PIXELS_COUNT;
        var maxHeight = MAX_ANALIZE_PIXELS_COUNT;
        canvas = document.createElement("canvas");
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        context = canvas.getContext("2d");
        context.imageSmoothingEnabled = false;
    }
    function removeCanvas() {
        canvas = null;
        context = null;
    }
    var MAX_IMAGE_SIZE = 5 * 1024 * 1024;
    function analyzeImage(image) {
        if (!canvas) {
            createCanvas();
        }
        var naturalWidth = image.naturalWidth,
            naturalHeight = image.naturalHeight;
        if (naturalHeight === 0 || naturalWidth === 0) {
            logWarn("logWarn(Image is empty ".concat(image.currentSrc, ")"));
            return null;
        }
        var size = naturalWidth * naturalHeight * 4;
        if (size > MAX_IMAGE_SIZE) {
            return {
                isDark: false,
                isLight: false,
                isTransparent: false,
                isLarge: false,
                isTooLarge: true
            };
        }
        var naturalPixelsCount = naturalWidth * naturalHeight;
        var k = Math.min(
            1,
            Math.sqrt(MAX_ANALIZE_PIXELS_COUNT / naturalPixelsCount)
        );
        var width = Math.ceil(naturalWidth * k);
        var height = Math.ceil(naturalHeight * k);
        context.clearRect(0, 0, width, height);
        context.drawImage(
            image,
            0,
            0,
            naturalWidth,
            naturalHeight,
            0,
            0,
            width,
            height
        );
        var imageData = context.getImageData(0, 0, width, height);
        var d = imageData.data;
        var TRANSPARENT_ALPHA_THRESHOLD = 0.05;
        var DARK_LIGHTNESS_THRESHOLD = 0.4;
        var LIGHT_LIGHTNESS_THRESHOLD = 0.7;
        var transparentPixelsCount = 0;
        var darkPixelsCount = 0;
        var lightPixelsCount = 0;
        var i, x, y;
        var r, g, b, a;
        var l;
        for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
                i = 4 * (y * width + x);
                r = d[i + 0];
                g = d[i + 1];
                b = d[i + 2];
                a = d[i + 3];
                if (a / 255 < TRANSPARENT_ALPHA_THRESHOLD) {
                    transparentPixelsCount++;
                } else {
                    l = getSRGBLightness(r, g, b);
                    if (l < DARK_LIGHTNESS_THRESHOLD) {
                        darkPixelsCount++;
                    }
                    if (l > LIGHT_LIGHTNESS_THRESHOLD) {
                        lightPixelsCount++;
                    }
                }
            }
        }
        var totalPixelsCount = width * height;
        var opaquePixelsCount = totalPixelsCount - transparentPixelsCount;
        var DARK_IMAGE_THRESHOLD = 0.7;
        var LIGHT_IMAGE_THRESHOLD = 0.7;
        var TRANSPARENT_IMAGE_THRESHOLD = 0.1;
        var LARGE_IMAGE_PIXELS_COUNT = 800 * 600;
        return {
            isDark: darkPixelsCount / opaquePixelsCount >= DARK_IMAGE_THRESHOLD,
            isLight:
                lightPixelsCount / opaquePixelsCount >= LIGHT_IMAGE_THRESHOLD,
            isTransparent:
                transparentPixelsCount / totalPixelsCount >=
                TRANSPARENT_IMAGE_THRESHOLD,
            isLarge: naturalPixelsCount >= LARGE_IMAGE_PIXELS_COUNT,
            isTooLarge: false
        };
    }
    function getFilteredImageDataURL(_a, theme) {
        var dataURL = _a.dataURL,
            width = _a.width,
            height = _a.height;
        var matrix = getSVGFilterMatrixValue(theme);
        var svg = [
            '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="'
                .concat(width, '" height="')
                .concat(height, '">'),
            "<defs>",
            '<filter id="darkreader-image-filter">',
            '<feColorMatrix type="matrix" values="'.concat(matrix, '" />'),
            "</filter>",
            "</defs>",
            '<image width="'
                .concat(width, '" height="')
                .concat(
                    height,
                    '" filter="url(#darkreader-image-filter)" xlink:href="'
                )
                .concat(dataURL, '" />'),
            "</svg>"
        ].join("");
        return "data:image/svg+xml;base64,".concat(btoa(svg));
    }
    function cleanImageProcessingCache() {
        imageManager && imageManager.stopQueue();
        removeCanvas();
    }

    var gradientLength = "gradient".length;
    var conicGradient = "conic-";
    var conicGradientLength = conicGradient.length;
    var radialGradient = "radial-";
    var linearGradient = "linear-";
    function parseGradient(value) {
        var result = [];
        var index = 0;
        var startIndex = conicGradient.length;
        var _loop_1 = function () {
            var typeGradient;
            [linearGradient, radialGradient, conicGradient].find(function (
                possibleType
            ) {
                if (index - possibleType.length >= 0) {
                    var possibleGradient = value.substring(
                        index - possibleType.length,
                        index
                    );
                    if (possibleGradient === possibleType) {
                        if (
                            value.slice(
                                index - possibleType.length - 10,
                                index - possibleType.length - 1
                            ) === "repeating"
                        ) {
                            typeGradient = "repeating-".concat(
                                possibleType,
                                "gradient"
                            );
                            return true;
                        }
                        if (
                            value.slice(
                                index - possibleType.length - 8,
                                index - possibleType.length - 1
                            ) === "-webkit"
                        ) {
                            typeGradient = "-webkit-".concat(
                                possibleType,
                                "gradient"
                            );
                            return true;
                        }
                        typeGradient = "".concat(possibleType, "gradient");
                        return true;
                    }
                }
            });
            if (!typeGradient) {
                return "break";
            }
            var _a = getParenthesesRange(value, index + gradientLength),
                start = _a.start,
                end = _a.end;
            var match = value.substring(start + 1, end - 1);
            startIndex = end + 1 + conicGradientLength;
            result.push({
                typeGradient: typeGradient,
                match: match,
                offset: typeGradient.length + 2,
                index: index - typeGradient.length + gradientLength,
                hasComma: true
            });
        };
        while ((index = value.indexOf("gradient", startIndex)) !== -1) {
            var state_1 = _loop_1();
            if (state_1 === "break") break;
        }
        if (result.length) {
            result[result.length - 1].hasComma = false;
        }
        return result;
    }

    function getPriority(ruleStyle, property) {
        return Boolean(ruleStyle && ruleStyle.getPropertyPriority(property));
    }
    function getModifiableCSSDeclaration(
        property,
        value,
        rule,
        variablesStore,
        ignoreImageSelectors,
        isCancelled
    ) {
        if (property.startsWith("--")) {
            var modifier = getVariableModifier(
                variablesStore,
                property,
                value,
                rule,
                ignoreImageSelectors,
                isCancelled
            );
            if (modifier) {
                return {
                    property: property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (value.includes("var(")) {
            var modifier = getVariableDependantModifier(
                variablesStore,
                property,
                value
            );
            if (modifier) {
                return {
                    property: property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (property === "color-scheme") {
            return null;
        } else if (
            (property.includes("color") &&
                property !== "-webkit-print-color-adjust") ||
            property === "fill" ||
            property === "stroke" ||
            property === "stop-color"
        ) {
            var modifier = getColorModifier(property, value, rule);
            if (modifier) {
                return {
                    property: property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (
            property === "background-image" ||
            property === "list-style-image"
        ) {
            var modifier = getBgImageModifier(
                value,
                rule,
                ignoreImageSelectors,
                isCancelled
            );
            if (modifier) {
                return {
                    property: property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (property.includes("shadow")) {
            var modifier = getShadowModifier(value);
            if (modifier) {
                return {
                    property: property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        }
        return null;
    }
    function joinSelectors() {
        var selectors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selectors[_i] = arguments[_i];
        }
        return selectors.filter(Boolean).join(", ");
    }
    function getModifiedUserAgentStyle(theme, isIFrame, styleSystemControls) {
        var lines = [];
        if (!isIFrame) {
            lines.push("html {");
            lines.push(
                "    background-color: ".concat(
                    modifyBackgroundColor({r: 255, g: 255, b: 255}, theme),
                    " !important;"
                )
            );
            lines.push("}");
        }
        if (isCSSColorSchemePropSupported) {
            lines.push("html {");
            lines.push(
                "    color-scheme: ".concat(
                    theme.mode === 1 ? "dark" : "dark light",
                    " !important;"
                )
            );
            lines.push("}");
        }
        var bgSelectors = joinSelectors(
            isIFrame ? "" : "html, body",
            styleSystemControls ? "input, textarea, select, button, dialog" : ""
        );
        if (bgSelectors) {
            lines.push("".concat(bgSelectors, " {"));
            lines.push(
                "    background-color: ".concat(
                    modifyBackgroundColor({r: 255, g: 255, b: 255}, theme),
                    ";"
                )
            );
            lines.push("}");
        }
        lines.push(
            "".concat(
                joinSelectors(
                    "html, body",
                    styleSystemControls ? "input, textarea, select, button" : ""
                ),
                " {"
            )
        );
        lines.push(
            "    border-color: ".concat(
                modifyBorderColor({r: 76, g: 76, b: 76}, theme),
                ";"
            )
        );
        lines.push(
            "    color: ".concat(
                modifyForegroundColor({r: 0, g: 0, b: 0}, theme),
                ";"
            )
        );
        lines.push("}");
        lines.push("a {");
        lines.push(
            "    color: ".concat(
                modifyForegroundColor({r: 0, g: 64, b: 255}, theme),
                ";"
            )
        );
        lines.push("}");
        lines.push("table {");
        lines.push(
            "    border-color: ".concat(
                modifyBorderColor({r: 128, g: 128, b: 128}, theme),
                ";"
            )
        );
        lines.push("}");
        lines.push("::placeholder {");
        lines.push(
            "    color: ".concat(
                modifyForegroundColor({r: 169, g: 169, b: 169}, theme),
                ";"
            )
        );
        lines.push("}");
        lines.push("input:-webkit-autofill,");
        lines.push("textarea:-webkit-autofill,");
        lines.push("select:-webkit-autofill {");
        lines.push(
            "    background-color: ".concat(
                modifyBackgroundColor({r: 250, g: 255, b: 189}, theme),
                " !important;"
            )
        );
        lines.push(
            "    color: ".concat(
                modifyForegroundColor({r: 0, g: 0, b: 0}, theme),
                " !important;"
            )
        );
        lines.push("}");
        if (theme.scrollbarColor) {
            lines.push(getModifiedScrollbarStyle(theme));
        }
        if (theme.selectionColor) {
            lines.push(getModifiedSelectionStyle(theme));
        }
        return lines.join("\n");
    }
    function getSelectionColor(theme) {
        var backgroundColorSelection;
        var foregroundColorSelection;
        if (theme.selectionColor === "auto") {
            backgroundColorSelection = modifyBackgroundColor(
                {r: 0, g: 96, b: 212},
                __assign(__assign({}, theme), {grayscale: 0})
            );
            foregroundColorSelection = modifyForegroundColor(
                {r: 255, g: 255, b: 255},
                __assign(__assign({}, theme), {grayscale: 0})
            );
        } else {
            var rgb = parseColorWithCache(theme.selectionColor);
            var hsl = rgbToHSL(rgb);
            backgroundColorSelection = theme.selectionColor;
            if (hsl.l < 0.5) {
                foregroundColorSelection = "#FFF";
            } else {
                foregroundColorSelection = "#000";
            }
        }
        return {
            backgroundColorSelection: backgroundColorSelection,
            foregroundColorSelection: foregroundColorSelection
        };
    }
    function getModifiedSelectionStyle(theme) {
        var lines = [];
        var modifiedSelectionColor = getSelectionColor(theme);
        var backgroundColorSelection =
            modifiedSelectionColor.backgroundColorSelection;
        var foregroundColorSelection =
            modifiedSelectionColor.foregroundColorSelection;
        ["::selection", "::-moz-selection"].forEach(function (selection) {
            lines.push("".concat(selection, " {"));
            lines.push(
                "    background-color: ".concat(
                    backgroundColorSelection,
                    " !important;"
                )
            );
            lines.push(
                "    color: ".concat(foregroundColorSelection, " !important;")
            );
            lines.push("}");
        });
        return lines.join("\n");
    }
    function getModifiedScrollbarStyle(theme) {
        var lines = [];
        var colorTrack;
        var colorIcons;
        var colorThumb;
        var colorThumbHover;
        var colorThumbActive;
        var colorCorner;
        if (theme.scrollbarColor === "auto") {
            colorTrack = modifyBackgroundColor({r: 241, g: 241, b: 241}, theme);
            colorIcons = modifyForegroundColor({r: 96, g: 96, b: 96}, theme);
            colorThumb = modifyBackgroundColor({r: 176, g: 176, b: 176}, theme);
            colorThumbHover = modifyBackgroundColor(
                {r: 144, g: 144, b: 144},
                theme
            );
            colorThumbActive = modifyBackgroundColor(
                {r: 96, g: 96, b: 96},
                theme
            );
            colorCorner = modifyBackgroundColor(
                {r: 255, g: 255, b: 255},
                theme
            );
        } else {
            var rgb = parseColorWithCache(theme.scrollbarColor);
            var hsl_1 = rgbToHSL(rgb);
            var isLight = hsl_1.l > 0.5;
            var lighten = function (lighter) {
                return __assign(__assign({}, hsl_1), {
                    l: clamp(hsl_1.l + lighter, 0, 1)
                });
            };
            var darken = function (darker) {
                return __assign(__assign({}, hsl_1), {
                    l: clamp(hsl_1.l - darker, 0, 1)
                });
            };
            colorTrack = hslToString(darken(0.4));
            colorIcons = hslToString(isLight ? darken(0.4) : lighten(0.4));
            colorThumb = hslToString(hsl_1);
            colorThumbHover = hslToString(lighten(0.1));
            colorThumbActive = hslToString(lighten(0.2));
        }
        lines.push("::-webkit-scrollbar {");
        lines.push("    background-color: ".concat(colorTrack, ";"));
        lines.push("    color: ".concat(colorIcons, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb {");
        lines.push("    background-color: ".concat(colorThumb, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:hover {");
        lines.push("    background-color: ".concat(colorThumbHover, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:active {");
        lines.push("    background-color: ".concat(colorThumbActive, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-corner {");
        lines.push("    background-color: ".concat(colorCorner, ";"));
        lines.push("}");
        if (isFirefox) {
            lines.push("* {");
            lines.push(
                "    scrollbar-color: "
                    .concat(colorThumb, " ")
                    .concat(colorTrack, ";")
            );
            lines.push("}");
        }
        return lines.join("\n");
    }
    function getModifiedFallbackStyle(filter, _a) {
        var strict = _a.strict;
        var lines = [];
        var isMicrosoft = ["microsoft.com", "docs.microsoft.com"].includes(
            location.hostname
        );
        lines.push(
            "html, body, ".concat(
                strict
                    ? "body :not(iframe)".concat(
                          isMicrosoft
                              ? ':not(div[style^="position:absolute;top:0;left:-"]'
                              : ""
                      )
                    : "body > :not(iframe)",
                " {"
            )
        );
        lines.push(
            "    background-color: ".concat(
                modifyBackgroundColor({r: 255, g: 255, b: 255}, filter),
                " !important;"
            )
        );
        lines.push(
            "    border-color: ".concat(
                modifyBorderColor({r: 64, g: 64, b: 64}, filter),
                " !important;"
            )
        );
        lines.push(
            "    color: ".concat(
                modifyForegroundColor({r: 0, g: 0, b: 0}, filter),
                " !important;"
            )
        );
        lines.push("}");
        return lines.join("\n");
    }
    var unparsableColors = new Set([
        "inherit",
        "transparent",
        "initial",
        "currentcolor",
        "none",
        "unset"
    ]);
    function getColorModifier(prop, value, rule) {
        if (unparsableColors.has(value.toLowerCase())) {
            return value;
        }
        var rgb = parseColorWithCache(value);
        if (!rgb) {
            return null;
        }
        if (prop.includes("background")) {
            if (
                (rule.style.webkitMaskImage &&
                    rule.style.webkitMaskImage !== "none") ||
                (rule.style.webkitMask &&
                    !rule.style.webkitMask.startsWith("none")) ||
                (rule.style.mask && rule.style.mask !== "none") ||
                (rule.style.getPropertyValue("mask-image") &&
                    rule.style.getPropertyValue("mask-image") !== "none")
            ) {
                return function (filter) {
                    return modifyForegroundColor(rgb, filter);
                };
            }
            return function (filter) {
                return modifyBackgroundColor(rgb, filter);
            };
        }
        if (prop.includes("border") || prop.includes("outline")) {
            return function (filter) {
                return modifyBorderColor(rgb, filter);
            };
        }
        return function (filter) {
            return modifyForegroundColor(rgb, filter);
        };
    }
    var imageDetailsCache = new Map();
    var awaitingForImageLoading = new Map();
    function shouldIgnoreImage(selectorText, selectors) {
        if (!selectorText || selectors.length === 0) {
            return false;
        }
        if (
            selectors.some(function (s) {
                return s === "*";
            })
        ) {
            return true;
        }
        var ruleSelectors = selectorText.split(/,\s*/g);
        var _loop_1 = function (i) {
            var ignoredSelector = selectors[i];
            if (
                ruleSelectors.some(function (s) {
                    return s === ignoredSelector;
                })
            ) {
                return {value: true};
            }
        };
        for (var i = 0; i < selectors.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object") return state_1.value;
        }
        return false;
    }
    function getBgImageModifier(
        value,
        rule,
        ignoreImageSelectors,
        isCancelled
    ) {
        var _this = this;
        try {
            var gradients = parseGradient(value);
            var urls = getMatches(cssURLRegex, value);
            if (urls.length === 0 && gradients.length === 0) {
                return value;
            }
            var getIndices = function (matches) {
                var index = 0;
                return matches.map(function (match) {
                    var valueIndex = value.indexOf(match, index);
                    index = valueIndex + match.length;
                    return {match: match, index: valueIndex};
                });
            };
            var matches_1 = gradients
                .map(function (i) {
                    return __assign({type: "gradient"}, i);
                })
                .concat(
                    getIndices(urls).map(function (i) {
                        return __assign({type: "url", offset: 0}, i);
                    })
                )
                .sort(function (a, b) {
                    return a.index > b.index ? 1 : -1;
                });
            var getGradientModifier_1 = function (gradient) {
                var typeGradient = gradient.typeGradient,
                    match = gradient.match,
                    hasComma = gradient.hasComma;
                var partsRegex =
                    /([^\(\),]+(\([^\(\)]*(\([^\(\)]*\)*[^\(\)]*)?\))?([^\(\), ]|( (?!calc)))*),?/g;
                var colorStopRegex =
                    /^(from|color-stop|to)\(([^\(\)]*?,\s*)?(.*?)\)$/;
                var parts = getMatches(partsRegex, match, 1).map(function (
                    part
                ) {
                    part = part.trim();
                    var rgb = parseColorWithCache(part);
                    if (rgb) {
                        return function (filter) {
                            return modifyGradientColor(rgb, filter);
                        };
                    }
                    var space = part.lastIndexOf(" ");
                    rgb = parseColorWithCache(part.substring(0, space));
                    if (rgb) {
                        return function (filter) {
                            return ""
                                .concat(modifyGradientColor(rgb, filter), " ")
                                .concat(part.substring(space + 1));
                        };
                    }
                    var colorStopMatch = part.match(colorStopRegex);
                    if (colorStopMatch) {
                        rgb = parseColorWithCache(colorStopMatch[3]);
                        if (rgb) {
                            return function (filter) {
                                return ""
                                    .concat(colorStopMatch[1], "(")
                                    .concat(
                                        colorStopMatch[2]
                                            ? "".concat(colorStopMatch[2], ", ")
                                            : ""
                                    )
                                    .concat(
                                        modifyGradientColor(rgb, filter),
                                        ")"
                                    );
                            };
                        }
                    }
                    return function () {
                        return part;
                    };
                });
                return function (filter) {
                    return ""
                        .concat(typeGradient, "(")
                        .concat(
                            parts
                                .map(function (modify) {
                                    return modify(filter);
                                })
                                .join(", "),
                            ")"
                        )
                        .concat(hasComma ? ", " : "");
                };
            };
            var getURLModifier_1 = function (urlValue) {
                var _a;
                if (
                    shouldIgnoreImage(rule.selectorText, ignoreImageSelectors)
                ) {
                    return null;
                }
                var url = getCSSURLValue(urlValue);
                var isURLEmpty = url.length === 0;
                var parentStyleSheet = rule.parentStyleSheet;
                var baseURL =
                    parentStyleSheet && parentStyleSheet.href
                        ? getCSSBaseBath(parentStyleSheet.href)
                        : ((_a = parentStyleSheet.ownerNode) === null ||
                          _a === void 0
                              ? void 0
                              : _a.baseURI) || location.origin;
                url = getAbsoluteURL(baseURL, url);
                var absoluteValue = 'url("'.concat(url, '")');
                return function (filter) {
                    return __awaiter(_this, void 0, void 0, function () {
                        var imageDetails, awaiters_1, err_1, bgImageValue;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (isURLEmpty) {
                                        return [2, "url('')"];
                                    }
                                    if (!imageDetailsCache.has(url))
                                        return [3, 1];
                                    imageDetails = imageDetailsCache.get(url);
                                    return [3, 7];
                                case 1:
                                    _a.trys.push([1, 6, , 7]);
                                    if (!awaitingForImageLoading.has(url))
                                        return [3, 3];
                                    awaiters_1 =
                                        awaitingForImageLoading.get(url);
                                    return [
                                        4,
                                        new Promise(function (resolve) {
                                            return awaiters_1.push(resolve);
                                        })
                                    ];
                                case 2:
                                    imageDetails = _a.sent();
                                    if (!imageDetails) {
                                        return [2, null];
                                    }
                                    return [3, 5];
                                case 3:
                                    awaitingForImageLoading.set(url, []);
                                    return [4, getImageDetails(url)];
                                case 4:
                                    imageDetails = _a.sent();
                                    imageDetailsCache.set(url, imageDetails);
                                    awaitingForImageLoading
                                        .get(url)
                                        .forEach(function (resolve) {
                                            return resolve(imageDetails);
                                        });
                                    awaitingForImageLoading.delete(url);
                                    _a.label = 5;
                                case 5:
                                    if (isCancelled()) {
                                        return [2, null];
                                    }
                                    return [3, 7];
                                case 6:
                                    err_1 = _a.sent();
                                    logWarn(err_1);
                                    if (awaitingForImageLoading.has(url)) {
                                        awaitingForImageLoading
                                            .get(url)
                                            .forEach(function (resolve) {
                                                return resolve(null);
                                            });
                                        awaitingForImageLoading.delete(url);
                                    }
                                    return [2, absoluteValue];
                                case 7:
                                    bgImageValue =
                                        getBgImageValue_1(
                                            imageDetails,
                                            filter
                                        ) || absoluteValue;
                                    return [2, bgImageValue];
                            }
                        });
                    });
                };
            };
            var getBgImageValue_1 = function (imageDetails, filter) {
                var isDark = imageDetails.isDark,
                    isLight = imageDetails.isLight,
                    isTransparent = imageDetails.isTransparent,
                    isLarge = imageDetails.isLarge,
                    isTooLarge = imageDetails.isTooLarge,
                    width = imageDetails.width;
                var result;
                if (isTooLarge) {
                    result = 'url("'.concat(imageDetails.src, '")');
                } else if (
                    isDark &&
                    isTransparent &&
                    filter.mode === 1 &&
                    !isLarge &&
                    width > 2
                ) {
                    logInfo("Inverting dark image ".concat(imageDetails.src));
                    var inverted = getFilteredImageDataURL(
                        imageDetails,
                        __assign(__assign({}, filter), {
                            sepia: clamp(filter.sepia + 10, 0, 100)
                        })
                    );
                    result = 'url("'.concat(inverted, '")');
                } else if (isLight && !isTransparent && filter.mode === 1) {
                    if (isLarge) {
                        result = "none";
                    } else {
                        logInfo(
                            "Dimming light image ".concat(imageDetails.src)
                        );
                        var dimmed = getFilteredImageDataURL(
                            imageDetails,
                            filter
                        );
                        result = 'url("'.concat(dimmed, '")');
                    }
                } else if (filter.mode === 0 && isLight && !isLarge) {
                    logInfo(
                        "Applying filter to image ".concat(imageDetails.src)
                    );
                    var filtered = getFilteredImageDataURL(
                        imageDetails,
                        __assign(__assign({}, filter), {
                            brightness: clamp(filter.brightness - 10, 5, 200),
                            sepia: clamp(filter.sepia + 10, 0, 100)
                        })
                    );
                    result = 'url("'.concat(filtered, '")');
                } else {
                    result = null;
                }
                return result;
            };
            var modifiers_1 = [];
            var matchIndex_1 = 0;
            var prevHasComma_1 = false;
            matches_1.forEach(function (_a, i) {
                var type = _a.type,
                    match = _a.match,
                    index = _a.index,
                    typeGradient = _a.typeGradient,
                    hasComma = _a.hasComma,
                    offset = _a.offset;
                var matchStart = index;
                var prefixStart = matchIndex_1;
                var matchEnd = matchStart + match.length + offset;
                matchIndex_1 = matchEnd;
                if (prefixStart !== matchStart) {
                    if (prevHasComma_1) {
                        modifiers_1.push(function () {
                            var betweenValue = value.substring(
                                prefixStart,
                                matchStart
                            );
                            if (betweenValue[0] === ",") {
                                betweenValue = betweenValue.substring(1);
                            }
                            return betweenValue;
                        });
                    } else {
                        modifiers_1.push(function () {
                            return value.substring(prefixStart, matchStart);
                        });
                    }
                }
                prevHasComma_1 = hasComma || false;
                if (type === "url") {
                    modifiers_1.push(getURLModifier_1(match));
                } else if (type === "gradient") {
                    modifiers_1.push(
                        getGradientModifier_1({
                            match: match,
                            index: index,
                            typeGradient: typeGradient,
                            hasComma: hasComma,
                            offset: offset
                        })
                    );
                }
                if (i === matches_1.length - 1) {
                    modifiers_1.push(function () {
                        return value.substring(matchEnd);
                    });
                }
            });
            return function (filter) {
                var results = modifiers_1
                    .filter(Boolean)
                    .map(function (modify) {
                        return modify(filter);
                    });
                if (
                    results.some(function (r) {
                        return r instanceof Promise;
                    })
                ) {
                    return Promise.all(results).then(function (asyncResults) {
                        return asyncResults.filter(Boolean).join("");
                    });
                }
                var combinedResult = results.join("");
                if (combinedResult.endsWith(", initial")) {
                    return combinedResult.slice(0, -9);
                }
                return combinedResult;
            };
        } catch (err) {
            return null;
        }
    }
    function getShadowModifierWithInfo(value) {
        try {
            var index_1 = 0;
            var colorMatches_1 = getMatches(
                /(^|\s)(?!calc)([a-z]+\(.+?\)|#[0-9a-f]+|[a-z]+)(.*?(inset|outset)?($|,))/gi,
                value,
                2
            );
            var notParsed_1 = 0;
            var modifiers_2 = colorMatches_1.map(function (match, i) {
                var prefixIndex = index_1;
                var matchIndex = value.indexOf(match, index_1);
                var matchEnd = matchIndex + match.length;
                index_1 = matchEnd;
                var rgb = parseColorWithCache(match);
                if (!rgb) {
                    notParsed_1++;
                    return function () {
                        return value.substring(prefixIndex, matchEnd);
                    };
                }
                return function (filter) {
                    return ""
                        .concat(value.substring(prefixIndex, matchIndex))
                        .concat(modifyShadowColor(rgb, filter))
                        .concat(
                            i === colorMatches_1.length - 1
                                ? value.substring(matchEnd)
                                : ""
                        );
                };
            });
            return function (filter) {
                var modified = modifiers_2
                    .map(function (modify) {
                        return modify(filter);
                    })
                    .join("");
                return {
                    matchesLength: colorMatches_1.length,
                    unparseableMatchesLength: notParsed_1,
                    result: modified
                };
            };
        } catch (err) {
            return null;
        }
    }
    function getShadowModifier(value) {
        var shadowModifier = getShadowModifierWithInfo(value);
        if (!shadowModifier) {
            return null;
        }
        return function (theme) {
            return shadowModifier(theme).result;
        };
    }
    function getVariableModifier(
        variablesStore,
        prop,
        value,
        rule,
        ignoredImgSelectors,
        isCancelled
    ) {
        return variablesStore.getModifierForVariable({
            varName: prop,
            sourceValue: value,
            rule: rule,
            ignoredImgSelectors: ignoredImgSelectors,
            isCancelled: isCancelled
        });
    }
    function getVariableDependantModifier(variablesStore, prop, value) {
        return variablesStore.getModifierForVarDependant(prop, value);
    }
    function cleanModificationCache() {
        clearColorModificationCache();
        imageDetailsCache.clear();
        cleanImageProcessingCache();
        awaitingForImageLoading.clear();
    }

    var VAR_TYPE_BGCOLOR = 1 << 0;
    var VAR_TYPE_TEXTCOLOR = 1 << 1;
    var VAR_TYPE_BORDERCOLOR = 1 << 2;
    var VAR_TYPE_BGIMG = 1 << 3;
    var VariablesStore = (function () {
        function VariablesStore() {
            this.varTypes = new Map();
            this.rulesQueue = [];
            this.definedVars = new Set();
            this.varRefs = new Map();
            this.unknownColorVars = new Set();
            this.unknownBgVars = new Set();
            this.undefinedVars = new Set();
            this.initialVarTypes = new Map();
            this.changedTypeVars = new Set();
            this.typeChangeSubscriptions = new Map();
            this.unstableVarValues = new Map();
        }
        VariablesStore.prototype.clear = function () {
            this.varTypes.clear();
            this.rulesQueue.splice(0);
            this.definedVars.clear();
            this.varRefs.clear();
            this.unknownColorVars.clear();
            this.unknownBgVars.clear();
            this.undefinedVars.clear();
            this.initialVarTypes.clear();
            this.changedTypeVars.clear();
            this.typeChangeSubscriptions.clear();
            this.unstableVarValues.clear();
        };
        VariablesStore.prototype.isVarType = function (varName, typeNum) {
            return (
                this.varTypes.has(varName) &&
                (this.varTypes.get(varName) & typeNum) > 0
            );
        };
        VariablesStore.prototype.addRulesForMatching = function (rules) {
            this.rulesQueue.push(rules);
        };
        VariablesStore.prototype.matchVariablesAndDependants = function () {
            var _this = this;
            this.changedTypeVars.clear();
            this.initialVarTypes = new Map(this.varTypes);
            this.collectRootVariables();
            this.collectVariablesAndVarDep(this.rulesQueue);
            this.rulesQueue.splice(0);
            this.collectRootVarDependants();
            this.varRefs.forEach(function (refs, v) {
                refs.forEach(function (r) {
                    if (_this.varTypes.has(v)) {
                        _this.resolveVariableType(r, _this.varTypes.get(v));
                    }
                });
            });
            this.unknownColorVars.forEach(function (v) {
                if (_this.unknownBgVars.has(v)) {
                    _this.unknownColorVars.delete(v);
                    _this.unknownBgVars.delete(v);
                    _this.resolveVariableType(v, VAR_TYPE_BGCOLOR);
                } else if (
                    _this.isVarType(
                        v,
                        VAR_TYPE_BGCOLOR |
                            VAR_TYPE_TEXTCOLOR |
                            VAR_TYPE_BORDERCOLOR
                    )
                ) {
                    _this.unknownColorVars.delete(v);
                } else {
                    _this.undefinedVars.add(v);
                }
            });
            this.unknownBgVars.forEach(function (v) {
                var hasColor =
                    _this.findVarRef(v, function (ref) {
                        return (
                            _this.unknownColorVars.has(ref) ||
                            _this.isVarType(
                                ref,
                                VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
                            )
                        );
                    }) != null;
                if (hasColor) {
                    _this.itarateVarRefs(v, function (ref) {
                        _this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
                    });
                } else if (
                    _this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)
                ) {
                    _this.unknownBgVars.delete(v);
                } else {
                    _this.undefinedVars.add(v);
                }
            });
            this.changedTypeVars.forEach(function (varName) {
                if (_this.typeChangeSubscriptions.has(varName)) {
                    _this.typeChangeSubscriptions
                        .get(varName)
                        .forEach(function (callback) {
                            callback();
                        });
                }
            });
            this.changedTypeVars.clear();
        };
        VariablesStore.prototype.getModifierForVariable = function (options) {
            var _this = this;
            return function (theme) {
                var varName = options.varName,
                    sourceValue = options.sourceValue,
                    rule = options.rule,
                    ignoredImgSelectors = options.ignoredImgSelectors,
                    isCancelled = options.isCancelled;
                var getDeclarations = function () {
                    var declarations = [];
                    var addModifiedValue = function (
                        typeNum,
                        varNameWrapper,
                        colorModifier
                    ) {
                        if (!_this.isVarType(varName, typeNum)) {
                            return;
                        }
                        var property = varNameWrapper(varName);
                        var modifiedValue;
                        if (isVarDependant(sourceValue)) {
                            if (isConstructedColorVar(sourceValue)) {
                                var value = insertVarValues(
                                    sourceValue,
                                    _this.unstableVarValues
                                );
                                if (!value) {
                                    value =
                                        typeNum === VAR_TYPE_BGCOLOR
                                            ? "#ffffff"
                                            : "#000000";
                                }
                                modifiedValue = colorModifier(value, theme);
                            } else {
                                modifiedValue = replaceCSSVariablesNames(
                                    sourceValue,
                                    function (v) {
                                        return varNameWrapper(v);
                                    },
                                    function (fallback) {
                                        return colorModifier(fallback, theme);
                                    }
                                );
                            }
                        } else {
                            modifiedValue = colorModifier(sourceValue, theme);
                        }
                        declarations.push({
                            property: property,
                            value: modifiedValue
                        });
                    };
                    addModifiedValue(
                        VAR_TYPE_BGCOLOR,
                        wrapBgColorVariableName,
                        tryModifyBgColor
                    );
                    addModifiedValue(
                        VAR_TYPE_TEXTCOLOR,
                        wrapTextColorVariableName,
                        tryModifyTextColor
                    );
                    addModifiedValue(
                        VAR_TYPE_BORDERCOLOR,
                        wrapBorderColorVariableName,
                        tryModifyBorderColor
                    );
                    if (_this.isVarType(varName, VAR_TYPE_BGIMG)) {
                        var property = wrapBgImgVariableName(varName);
                        var modifiedValue = sourceValue;
                        if (isVarDependant(sourceValue)) {
                            modifiedValue = replaceCSSVariablesNames(
                                sourceValue,
                                function (v) {
                                    return wrapBgColorVariableName(v);
                                },
                                function (fallback) {
                                    return tryModifyBgColor(fallback, theme);
                                }
                            );
                        }
                        var bgModifier = getBgImageModifier(
                            modifiedValue,
                            rule,
                            ignoredImgSelectors,
                            isCancelled
                        );
                        modifiedValue =
                            typeof bgModifier === "function"
                                ? bgModifier(theme)
                                : bgModifier;
                        declarations.push({
                            property: property,
                            value: modifiedValue
                        });
                    }
                    return declarations;
                };
                var callbacks = new Set();
                var addListener = function (onTypeChange) {
                    var callback = function () {
                        var decs = getDeclarations();
                        onTypeChange(decs);
                    };
                    callbacks.add(callback);
                    _this.subscribeForVarTypeChange(varName, callback);
                };
                var removeListeners = function () {
                    callbacks.forEach(function (callback) {
                        _this.unsubscribeFromVariableTypeChanges(
                            varName,
                            callback
                        );
                    });
                };
                return {
                    declarations: getDeclarations(),
                    onTypeChange: {
                        addListener: addListener,
                        removeListeners: removeListeners
                    }
                };
            };
        };
        VariablesStore.prototype.getModifierForVarDependant = function (
            property,
            sourceValue
        ) {
            var _this = this;
            if (sourceValue.match(/^\s*(rgb|hsl)a?\(/)) {
                var isBg_1 = property.startsWith("background");
                var isText_1 = isTextColorProperty(property);
                return function (theme) {
                    var value = insertVarValues(
                        sourceValue,
                        _this.unstableVarValues
                    );
                    if (!value) {
                        value = isBg_1 ? "#ffffff" : "#000000";
                    }
                    var modifier = isBg_1
                        ? tryModifyBgColor
                        : isText_1
                        ? tryModifyTextColor
                        : tryModifyBorderColor;
                    return modifier(value, theme);
                };
            }
            if (property === "background-color") {
                return function (theme) {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        function (v) {
                            return wrapBgColorVariableName(v);
                        },
                        function (fallback) {
                            return tryModifyBgColor(fallback, theme);
                        }
                    );
                };
            }
            if (isTextColorProperty(property)) {
                return function (theme) {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        function (v) {
                            return wrapTextColorVariableName(v);
                        },
                        function (fallback) {
                            return tryModifyTextColor(fallback, theme);
                        }
                    );
                };
            }
            if (
                property === "background" ||
                property === "background-image" ||
                property === "box-shadow"
            ) {
                return function (theme) {
                    var unknownVars = new Set();
                    var modify = function () {
                        var variableReplaced = replaceCSSVariablesNames(
                            sourceValue,
                            function (v) {
                                if (_this.isVarType(v, VAR_TYPE_BGCOLOR)) {
                                    return wrapBgColorVariableName(v);
                                }
                                if (_this.isVarType(v, VAR_TYPE_BGIMG)) {
                                    return wrapBgImgVariableName(v);
                                }
                                unknownVars.add(v);
                                return v;
                            },
                            function (fallback) {
                                return tryModifyBgColor(fallback, theme);
                            }
                        );
                        if (property === "box-shadow") {
                            var shadowModifier =
                                getShadowModifierWithInfo(variableReplaced);
                            var modifiedShadow = shadowModifier(theme);
                            if (
                                modifiedShadow.unparseableMatchesLength !==
                                modifiedShadow.matchesLength
                            ) {
                                return modifiedShadow.result;
                            }
                        }
                        return variableReplaced;
                    };
                    var modified = modify();
                    if (unknownVars.size > 0) {
                        return new Promise(function (resolve) {
                            var firstUnknownVar = unknownVars
                                .values()
                                .next().value;
                            var callback = function () {
                                _this.unsubscribeFromVariableTypeChanges(
                                    firstUnknownVar,
                                    callback
                                );
                                var newValue = modify();
                                resolve(newValue);
                            };
                            _this.subscribeForVarTypeChange(
                                firstUnknownVar,
                                callback
                            );
                        });
                    }
                    return modified;
                };
            }
            if (
                property.startsWith("border") ||
                property.startsWith("outline")
            ) {
                return function (theme) {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        function (v) {
                            return wrapBorderColorVariableName(v);
                        },
                        function (fallback) {
                            return tryModifyBorderColor(fallback, theme);
                        }
                    );
                };
            }
            return null;
        };
        VariablesStore.prototype.subscribeForVarTypeChange = function (
            varName,
            callback
        ) {
            if (!this.typeChangeSubscriptions.has(varName)) {
                this.typeChangeSubscriptions.set(varName, new Set());
            }
            var rootStore = this.typeChangeSubscriptions.get(varName);
            if (!rootStore.has(callback)) {
                rootStore.add(callback);
            }
        };
        VariablesStore.prototype.unsubscribeFromVariableTypeChanges = function (
            varName,
            callback
        ) {
            if (this.typeChangeSubscriptions.has(varName)) {
                this.typeChangeSubscriptions.get(varName).delete(callback);
            }
        };
        VariablesStore.prototype.collectVariablesAndVarDep = function (
            ruleList
        ) {
            var _this = this;
            ruleList.forEach(function (rules) {
                iterateCSSRules(rules, function (rule) {
                    rule.style &&
                        iterateCSSDeclarations(
                            rule.style,
                            function (property, value) {
                                if (isVariable(property)) {
                                    _this.inspectVariable(property, value);
                                }
                                if (isVarDependant(value)) {
                                    _this.inspectVarDependant(property, value);
                                }
                            }
                        );
                });
            });
        };
        VariablesStore.prototype.collectRootVariables = function () {
            var _this = this;
            iterateCSSDeclarations(
                document.documentElement.style,
                function (property, value) {
                    if (isVariable(property)) {
                        _this.inspectVariable(property, value);
                    }
                }
            );
        };
        VariablesStore.prototype.inspectVariable = function (varName, value) {
            this.unstableVarValues.set(varName, value);
            if (isVarDependant(value) && isConstructedColorVar(value)) {
                this.unknownColorVars.add(varName);
                this.definedVars.add(varName);
            }
            if (this.definedVars.has(varName)) {
                return;
            }
            this.definedVars.add(varName);
            var color = parseColorWithCache(value);
            if (color) {
                this.unknownColorVars.add(varName);
            } else if (
                value.includes("url(") ||
                value.includes("linear-gradient(") ||
                value.includes("radial-gradient(")
            ) {
                this.resolveVariableType(varName, VAR_TYPE_BGIMG);
            }
        };
        VariablesStore.prototype.resolveVariableType = function (
            varName,
            typeNum
        ) {
            var initialType = this.initialVarTypes.get(varName) || 0;
            var currentType = this.varTypes.get(varName) || 0;
            var newType = currentType | typeNum;
            this.varTypes.set(varName, newType);
            if (newType !== initialType || this.undefinedVars.has(varName)) {
                this.changedTypeVars.add(varName);
                this.undefinedVars.delete(varName);
            }
            this.unknownColorVars.delete(varName);
            this.unknownBgVars.delete(varName);
        };
        VariablesStore.prototype.collectRootVarDependants = function () {
            var _this = this;
            iterateCSSDeclarations(
                document.documentElement.style,
                function (property, value) {
                    if (isVarDependant(value)) {
                        _this.inspectVarDependant(property, value);
                    }
                }
            );
        };
        VariablesStore.prototype.inspectVarDependant = function (
            property,
            value
        ) {
            var _this = this;
            if (isVariable(property)) {
                this.iterateVarDeps(value, function (ref) {
                    if (!_this.varRefs.has(property)) {
                        _this.varRefs.set(property, new Set());
                    }
                    _this.varRefs.get(property).add(ref);
                });
            } else if (
                property === "background-color" ||
                property === "box-shadow"
            ) {
                this.iterateVarDeps(value, function (v) {
                    return _this.resolveVariableType(v, VAR_TYPE_BGCOLOR);
                });
            } else if (isTextColorProperty(property)) {
                this.iterateVarDeps(value, function (v) {
                    return _this.resolveVariableType(v, VAR_TYPE_TEXTCOLOR);
                });
            } else if (
                property.startsWith("border") ||
                property.startsWith("outline")
            ) {
                this.iterateVarDeps(value, function (v) {
                    return _this.resolveVariableType(v, VAR_TYPE_BORDERCOLOR);
                });
            } else if (
                property === "background" ||
                property === "background-image"
            ) {
                this.iterateVarDeps(value, function (v) {
                    if (_this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {
                        return;
                    }
                    var isBgColor =
                        _this.findVarRef(v, function (ref) {
                            return (
                                _this.unknownColorVars.has(ref) ||
                                _this.isVarType(
                                    ref,
                                    VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
                                )
                            );
                        }) != null;
                    _this.itarateVarRefs(v, function (ref) {
                        if (isBgColor) {
                            _this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
                        } else {
                            _this.unknownBgVars.add(ref);
                        }
                    });
                });
            }
        };
        VariablesStore.prototype.iterateVarDeps = function (value, iterator) {
            var varDeps = new Set();
            iterateVarDependencies(value, function (v) {
                return varDeps.add(v);
            });
            varDeps.forEach(function (v) {
                return iterator(v);
            });
        };
        VariablesStore.prototype.findVarRef = function (
            varName,
            iterator,
            stack
        ) {
            var e_1, _a;
            if (stack === void 0) {
                stack = new Set();
            }
            if (stack.has(varName)) {
                return null;
            }
            stack.add(varName);
            var result = iterator(varName);
            if (result) {
                return varName;
            }
            var refs = this.varRefs.get(varName);
            if (!refs || refs.size === 0) {
                return null;
            }
            try {
                for (
                    var refs_1 = __values(refs), refs_1_1 = refs_1.next();
                    !refs_1_1.done;
                    refs_1_1 = refs_1.next()
                ) {
                    var ref = refs_1_1.value;
                    var found = this.findVarRef(ref, iterator, stack);
                    if (found) {
                        return found;
                    }
                }
            } catch (e_1_1) {
                e_1 = {error: e_1_1};
            } finally {
                try {
                    if (refs_1_1 && !refs_1_1.done && (_a = refs_1.return))
                        _a.call(refs_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return null;
        };
        VariablesStore.prototype.itarateVarRefs = function (varName, iterator) {
            this.findVarRef(varName, function (ref) {
                iterator(ref);
                return false;
            });
        };
        VariablesStore.prototype.setOnRootVariableChange = function (callback) {
            this.onRootVariableDefined = callback;
        };
        VariablesStore.prototype.putRootVars = function (styleElement, theme) {
            var e_2, _a;
            var _this = this;
            var sheet = styleElement.sheet;
            if (sheet.cssRules.length > 0) {
                sheet.deleteRule(0);
            }
            var declarations = new Map();
            iterateCSSDeclarations(
                document.documentElement.style,
                function (property, value) {
                    if (isVariable(property)) {
                        if (_this.isVarType(property, VAR_TYPE_BGCOLOR)) {
                            declarations.set(
                                wrapBgColorVariableName(property),
                                tryModifyBgColor(value, theme)
                            );
                        }
                        if (_this.isVarType(property, VAR_TYPE_TEXTCOLOR)) {
                            declarations.set(
                                wrapTextColorVariableName(property),
                                tryModifyTextColor(value, theme)
                            );
                        }
                        if (_this.isVarType(property, VAR_TYPE_BORDERCOLOR)) {
                            declarations.set(
                                wrapBorderColorVariableName(property),
                                tryModifyBorderColor(value, theme)
                            );
                        }
                        _this.subscribeForVarTypeChange(
                            property,
                            _this.onRootVariableDefined
                        );
                    }
                }
            );
            var cssLines = [];
            cssLines.push(":root {");
            try {
                for (
                    var declarations_1 = __values(declarations),
                        declarations_1_1 = declarations_1.next();
                    !declarations_1_1.done;
                    declarations_1_1 = declarations_1.next()
                ) {
                    var _b = __read(declarations_1_1.value, 2),
                        property = _b[0],
                        value = _b[1];
                    cssLines.push(
                        "    ".concat(property, ": ").concat(value, ";")
                    );
                }
            } catch (e_2_1) {
                e_2 = {error: e_2_1};
            } finally {
                try {
                    if (
                        declarations_1_1 &&
                        !declarations_1_1.done &&
                        (_a = declarations_1.return)
                    )
                        _a.call(declarations_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            cssLines.push("}");
            var cssText = cssLines.join("\n");
            sheet.insertRule(cssText);
        };
        return VariablesStore;
    })();
    var variablesStore = new VariablesStore();
    function getVariableRange(input, searchStart) {
        if (searchStart === void 0) {
            searchStart = 0;
        }
        var start = input.indexOf("var(", searchStart);
        if (start >= 0) {
            var range = getParenthesesRange(input, start + 3);
            if (range) {
                return {start: start, end: range.end};
            }
            return null;
        }
    }
    function getVariablesMatches(input) {
        var ranges = [];
        var i = 0;
        var range;
        while ((range = getVariableRange(input, i))) {
            var start = range.start,
                end = range.end;
            ranges.push({
                start: start,
                end: end,
                value: input.substring(start, end)
            });
            i = range.end + 1;
        }
        return ranges;
    }
    function replaceVariablesMatches(input, replacer) {
        var matches = getVariablesMatches(input);
        var matchesCount = matches.length;
        if (matchesCount === 0) {
            return input;
        }
        var inputLength = input.length;
        var replacements = matches.map(function (m) {
            return replacer(m.value);
        });
        var parts = [];
        parts.push(input.substring(0, matches[0].start));
        for (var i = 0; i < matchesCount; i++) {
            parts.push(replacements[i]);
            var start = matches[i].end;
            var end = i < matchesCount - 1 ? matches[i + 1].start : inputLength;
            parts.push(input.substring(start, end));
        }
        return parts.join("");
    }
    function getVariableNameAndFallback(match) {
        var commaIndex = match.indexOf(",");
        var name;
        var fallback;
        if (commaIndex >= 0) {
            name = match.substring(4, commaIndex).trim();
            fallback = match.substring(commaIndex + 1, match.length - 1).trim();
        } else {
            name = match.substring(4, match.length - 1).trim();
            fallback = "";
        }
        return {name: name, fallback: fallback};
    }
    function replaceCSSVariablesNames(value, nameReplacer, fallbackReplacer) {
        var matchReplacer = function (match) {
            var _a = getVariableNameAndFallback(match),
                name = _a.name,
                fallback = _a.fallback;
            var newName = nameReplacer(name);
            if (!fallback) {
                return "var(".concat(newName, ")");
            }
            var newFallback;
            if (isVarDependant(fallback)) {
                newFallback = replaceCSSVariablesNames(
                    fallback,
                    nameReplacer,
                    fallbackReplacer
                );
            } else if (fallbackReplacer) {
                newFallback = fallbackReplacer(fallback);
            } else {
                newFallback = fallback;
            }
            return "var(".concat(newName, ", ").concat(newFallback, ")");
        };
        return replaceVariablesMatches(value, matchReplacer);
    }
    function iterateVarDependencies(value, iterator) {
        replaceCSSVariablesNames(value, function (varName) {
            iterator(varName);
            return varName;
        });
    }
    function wrapBgColorVariableName(name) {
        return "--darkreader-bg".concat(name);
    }
    function wrapTextColorVariableName(name) {
        return "--darkreader-text".concat(name);
    }
    function wrapBorderColorVariableName(name) {
        return "--darkreader-border".concat(name);
    }
    function wrapBgImgVariableName(name) {
        return "--darkreader-bgimg".concat(name);
    }
    function isVariable(property) {
        return property.startsWith("--");
    }
    function isVarDependant(value) {
        return value.includes("var(");
    }
    function isConstructedColorVar(value) {
        return value.match(/^\s*(rgb|hsl)a?\(/);
    }
    function isTextColorProperty(property) {
        return (
            property === "color" ||
            property === "caret-color" ||
            property === "-webkit-text-fill-color"
        );
    }
    var rawValueRegex = /^\d{1,3}, ?\d{1,3}, ?\d{1,3}$/;
    function parseRawValue(color) {
        if (rawValueRegex.test(color)) {
            var splitted = color.split(",");
            var resultInRGB_1 = "rgb(";
            splitted.forEach(function (number) {
                resultInRGB_1 += "".concat(number.trim(), ", ");
            });
            resultInRGB_1 = resultInRGB_1.substring(
                0,
                resultInRGB_1.length - 2
            );
            resultInRGB_1 += ")";
            return {isRaw: true, color: resultInRGB_1};
        }
        return {isRaw: false, color: color};
    }
    function handleRawValue(color, theme, modifyFunction) {
        var _a = parseRawValue(color),
            isRaw = _a.isRaw,
            newColor = _a.color;
        var rgb = parseColorWithCache(newColor);
        if (rgb) {
            var outputColor = modifyFunction(rgb, theme);
            if (isRaw) {
                var outputInRGB = parseColorWithCache(outputColor);
                return outputInRGB
                    ? ""
                          .concat(outputInRGB.r, ", ")
                          .concat(outputInRGB.g, ", ")
                          .concat(outputInRGB.b)
                    : outputColor;
            }
            return outputColor;
        }
        return newColor;
    }
    function tryModifyBgColor(color, theme) {
        return handleRawValue(color, theme, modifyBackgroundColor);
    }
    function tryModifyTextColor(color, theme) {
        return handleRawValue(color, theme, modifyForegroundColor);
    }
    function tryModifyBorderColor(color, theme) {
        return handleRawValue(color, theme, modifyBorderColor);
    }
    function insertVarValues(source, varValues, stack) {
        if (stack === void 0) {
            stack = new Set();
        }
        var containsUnresolvedVar = false;
        var matchReplacer = function (match) {
            var _a = getVariableNameAndFallback(match),
                name = _a.name,
                fallback = _a.fallback;
            if (stack.has(name)) {
                containsUnresolvedVar = true;
                return null;
            }
            stack.add(name);
            var varValue = varValues.get(name) || fallback;
            var inserted = null;
            if (varValue) {
                if (isVarDependant(varValue)) {
                    inserted = insertVarValues(varValue, varValues, stack);
                } else {
                    inserted = varValue;
                }
            }
            if (!inserted) {
                containsUnresolvedVar = true;
                return null;
            }
            return inserted;
        };
        var replaced = replaceVariablesMatches(source, matchReplacer);
        if (containsUnresolvedVar) {
            return null;
        }
        return replaced;
    }

    var overrides = {
        "background-color": {
            customProp: "--darkreader-inline-bgcolor",
            cssProp: "background-color",
            dataAttr: "data-darkreader-inline-bgcolor"
        },
        "background-image": {
            customProp: "--darkreader-inline-bgimage",
            cssProp: "background-image",
            dataAttr: "data-darkreader-inline-bgimage"
        },
        "border-color": {
            customProp: "--darkreader-inline-border",
            cssProp: "border-color",
            dataAttr: "data-darkreader-inline-border"
        },
        "border-bottom-color": {
            customProp: "--darkreader-inline-border-bottom",
            cssProp: "border-bottom-color",
            dataAttr: "data-darkreader-inline-border-bottom"
        },
        "border-left-color": {
            customProp: "--darkreader-inline-border-left",
            cssProp: "border-left-color",
            dataAttr: "data-darkreader-inline-border-left"
        },
        "border-right-color": {
            customProp: "--darkreader-inline-border-right",
            cssProp: "border-right-color",
            dataAttr: "data-darkreader-inline-border-right"
        },
        "border-top-color": {
            customProp: "--darkreader-inline-border-top",
            cssProp: "border-top-color",
            dataAttr: "data-darkreader-inline-border-top"
        },
        "box-shadow": {
            customProp: "--darkreader-inline-boxshadow",
            cssProp: "box-shadow",
            dataAttr: "data-darkreader-inline-boxshadow"
        },
        "color": {
            customProp: "--darkreader-inline-color",
            cssProp: "color",
            dataAttr: "data-darkreader-inline-color"
        },
        "fill": {
            customProp: "--darkreader-inline-fill",
            cssProp: "fill",
            dataAttr: "data-darkreader-inline-fill"
        },
        "stroke": {
            customProp: "--darkreader-inline-stroke",
            cssProp: "stroke",
            dataAttr: "data-darkreader-inline-stroke"
        },
        "outline-color": {
            customProp: "--darkreader-inline-outline",
            cssProp: "outline-color",
            dataAttr: "data-darkreader-inline-outline"
        },
        "stop-color": {
            customProp: "--darkreader-inline-stopcolor",
            cssProp: "stop-color",
            dataAttr: "data-darkreader-inline-stopcolor"
        }
    };
    var overridesList = Object.values(overrides);
    var normalizedPropList = {};
    overridesList.forEach(function (_a) {
        var cssProp = _a.cssProp,
            customProp = _a.customProp;
        return (normalizedPropList[customProp] = cssProp);
    });
    var INLINE_STYLE_ATTRS = [
        "style",
        "fill",
        "stop-color",
        "stroke",
        "bgcolor",
        "color"
    ];
    var INLINE_STYLE_SELECTOR = INLINE_STYLE_ATTRS.map(function (attr) {
        return "[".concat(attr, "]");
    }).join(", ");
    function getInlineOverrideStyle() {
        return overridesList
            .map(function (_a) {
                var dataAttr = _a.dataAttr,
                    customProp = _a.customProp,
                    cssProp = _a.cssProp;
                return [
                    "[".concat(dataAttr, "] {"),
                    "  "
                        .concat(cssProp, ": var(")
                        .concat(customProp, ") !important;"),
                    "}"
                ].join("\n");
            })
            .join("\n");
    }
    function getInlineStyleElements(root) {
        var results = [];
        if (root instanceof Element && root.matches(INLINE_STYLE_SELECTOR)) {
            results.push(root);
        }
        if (
            root instanceof Element ||
            (isShadowDomSupported && root instanceof ShadowRoot) ||
            root instanceof Document
        ) {
            push(results, root.querySelectorAll(INLINE_STYLE_SELECTOR));
        }
        return results;
    }
    var treeObservers = new Map();
    var attrObservers = new Map();
    function watchForInlineStyles(elementStyleDidChange, shadowRootDiscovered) {
        deepWatchForInlineStyles(
            document,
            elementStyleDidChange,
            shadowRootDiscovered
        );
        iterateShadowHosts(document.documentElement, function (host) {
            deepWatchForInlineStyles(
                host.shadowRoot,
                elementStyleDidChange,
                shadowRootDiscovered
            );
        });
    }
    function deepWatchForInlineStyles(
        root,
        elementStyleDidChange,
        shadowRootDiscovered
    ) {
        if (treeObservers.has(root)) {
            treeObservers.get(root).disconnect();
            attrObservers.get(root).disconnect();
        }
        var discoveredNodes = new WeakSet();
        function discoverNodes(node) {
            getInlineStyleElements(node).forEach(function (el) {
                if (discoveredNodes.has(el)) {
                    return;
                }
                discoveredNodes.add(el);
                elementStyleDidChange(el);
            });
            iterateShadowHosts(node, function (n) {
                if (discoveredNodes.has(node)) {
                    return;
                }
                discoveredNodes.add(node);
                shadowRootDiscovered(n.shadowRoot);
                deepWatchForInlineStyles(
                    n.shadowRoot,
                    elementStyleDidChange,
                    shadowRootDiscovered
                );
            });
        }
        var treeObserver = createOptimizedTreeObserver(root, {
            onMinorMutations: function (_a) {
                var additions = _a.additions;
                additions.forEach(function (added) {
                    return discoverNodes(added);
                });
            },
            onHugeMutations: function () {
                discoverNodes(root);
            }
        });
        treeObservers.set(root, treeObserver);
        var attemptCount = 0;
        var start = null;
        var ATTEMPTS_INTERVAL = getDuration({seconds: 10});
        var RETRY_TIMEOUT = getDuration({seconds: 2});
        var MAX_ATTEMPTS_COUNT = 50;
        var cache = [];
        var timeoutId = null;
        var handleAttributeMutations = throttle(function (mutations) {
            mutations.forEach(function (m) {
                if (INLINE_STYLE_ATTRS.includes(m.attributeName)) {
                    elementStyleDidChange(m.target);
                }
            });
        });
        var attrObserver = new MutationObserver(function (mutations) {
            if (timeoutId) {
                cache.push.apply(
                    cache,
                    __spreadArray([], __read(mutations), false)
                );
                return;
            }
            attemptCount++;
            var now = Date.now();
            if (start == null) {
                start = now;
            } else if (attemptCount >= MAX_ATTEMPTS_COUNT) {
                if (now - start < ATTEMPTS_INTERVAL) {
                    timeoutId = setTimeout(function () {
                        start = null;
                        attemptCount = 0;
                        timeoutId = null;
                        var attributeCache = cache;
                        cache = [];
                        handleAttributeMutations(attributeCache);
                    }, RETRY_TIMEOUT);
                    cache.push.apply(
                        cache,
                        __spreadArray([], __read(mutations), false)
                    );
                    return;
                }
                start = now;
                attemptCount = 1;
            }
            handleAttributeMutations(mutations);
        });
        attrObserver.observe(root, {
            attributes: true,
            attributeFilter: INLINE_STYLE_ATTRS.concat(
                overridesList.map(function (_a) {
                    var dataAttr = _a.dataAttr;
                    return dataAttr;
                })
            ),
            subtree: true
        });
        attrObservers.set(root, attrObserver);
    }
    function stopWatchingForInlineStyles() {
        treeObservers.forEach(function (o) {
            return o.disconnect();
        });
        attrObservers.forEach(function (o) {
            return o.disconnect();
        });
        treeObservers.clear();
        attrObservers.clear();
    }
    var inlineStyleCache = new WeakMap();
    var filterProps = ["brightness", "contrast", "grayscale", "sepia", "mode"];
    function getInlineStyleCacheKey(el, theme) {
        return INLINE_STYLE_ATTRS.map(function (attr) {
            return "".concat(attr, '="').concat(el.getAttribute(attr), '"');
        })
            .concat(
                filterProps.map(function (prop) {
                    return "".concat(prop, '="').concat(theme[prop], '"');
                })
            )
            .join(" ");
    }
    function shouldIgnoreInlineStyle(element, selectors) {
        for (var i = 0, len = selectors.length; i < len; i++) {
            var ingnoredSelector = selectors[i];
            if (element.matches(ingnoredSelector)) {
                return true;
            }
        }
        return false;
    }
    function overrideInlineStyle(
        element,
        theme,
        ignoreInlineSelectors,
        ignoreImageSelectors
    ) {
        var cacheKey = getInlineStyleCacheKey(element, theme);
        if (cacheKey === inlineStyleCache.get(element)) {
            return;
        }
        var unsetProps = new Set(Object.keys(overrides));
        function setCustomProp(targetCSSProp, modifierCSSProp, cssVal) {
            var isPropertyVariable = targetCSSProp.startsWith("--");
            var _a = isPropertyVariable ? {} : overrides[targetCSSProp],
                customProp = _a.customProp,
                dataAttr = _a.dataAttr;
            var mod = getModifiableCSSDeclaration(
                modifierCSSProp,
                cssVal,
                {style: element.style},
                variablesStore,
                ignoreImageSelectors,
                null
            );
            if (!mod) {
                return;
            }
            var value = mod.value;
            if (typeof value === "function") {
                value = value(theme);
            }
            if (isPropertyVariable && typeof value === "object") {
                var typedValue = value;
                typedValue.declarations.forEach(function (_a) {
                    var property = _a.property,
                        value = _a.value;
                    !(value instanceof Promise) &&
                        element.style.setProperty(property, value);
                });
            } else {
                element.style.setProperty(customProp, value);
                if (!element.hasAttribute(dataAttr)) {
                    element.setAttribute(dataAttr, "");
                }
                unsetProps.delete(targetCSSProp);
            }
        }
        if (ignoreInlineSelectors.length > 0) {
            if (shouldIgnoreInlineStyle(element, ignoreInlineSelectors)) {
                unsetProps.forEach(function (cssProp) {
                    element.removeAttribute(overrides[cssProp].dataAttr);
                });
                return;
            }
        }
        if (element.hasAttribute("bgcolor")) {
            var value = element.getAttribute("bgcolor");
            if (
                value.match(/^[0-9a-f]{3}$/i) ||
                value.match(/^[0-9a-f]{6}$/i)
            ) {
                value = "#".concat(value);
            }
            setCustomProp("background-color", "background-color", value);
        }
        if (element.hasAttribute("color") && element.rel !== "mask-icon") {
            var value = element.getAttribute("color");
            if (
                value.match(/^[0-9a-f]{3}$/i) ||
                value.match(/^[0-9a-f]{6}$/i)
            ) {
                value = "#".concat(value);
            }
            setCustomProp("color", "color", value);
        }
        if (element instanceof SVGElement) {
            if (element.hasAttribute("fill")) {
                var SMALL_SVG_LIMIT_1 = 32;
                var value_1 = element.getAttribute("fill");
                if (value_1 !== "none") {
                    if (!(element instanceof SVGTextElement)) {
                        var handleSVGElement = function () {
                            var _a = element.getBoundingClientRect(),
                                width = _a.width,
                                height = _a.height;
                            var isBg =
                                width > SMALL_SVG_LIMIT_1 ||
                                height > SMALL_SVG_LIMIT_1;
                            setCustomProp(
                                "fill",
                                isBg ? "background-color" : "color",
                                value_1
                            );
                        };
                        if (isReadyStateComplete()) {
                            handleSVGElement();
                        } else {
                            addReadyStateCompleteListener(handleSVGElement);
                        }
                    } else {
                        setCustomProp("fill", "color", value_1);
                    }
                }
            }
            if (element.hasAttribute("stop-color")) {
                setCustomProp(
                    "stop-color",
                    "background-color",
                    element.getAttribute("stop-color")
                );
            }
        }
        if (element.hasAttribute("stroke")) {
            var value = element.getAttribute("stroke");
            setCustomProp(
                "stroke",
                element instanceof SVGLineElement ||
                    element instanceof SVGTextElement
                    ? "border-color"
                    : "color",
                value
            );
        }
        element.style &&
            iterateCSSDeclarations(element.style, function (property, value) {
                if (property === "background-image" && value.includes("url")) {
                    return;
                }
                if (
                    overrides.hasOwnProperty(property) ||
                    (property.startsWith("--") && !normalizedPropList[property])
                ) {
                    setCustomProp(property, property, value);
                } else {
                    var overridenProp = normalizedPropList[property];
                    if (
                        overridenProp &&
                        !element.style.getPropertyValue(overridenProp) &&
                        !element.hasAttribute(overridenProp)
                    ) {
                        if (
                            overridenProp === "background-color" &&
                            element.hasAttribute("bgcolor")
                        ) {
                            return;
                        }
                        element.style.setProperty(property, "");
                    }
                }
            });
        if (
            element.style &&
            element instanceof SVGTextElement &&
            element.style.fill
        ) {
            setCustomProp(
                "fill",
                "color",
                element.style.getPropertyValue("fill")
            );
        }
        forEach(unsetProps, function (cssProp) {
            element.removeAttribute(overrides[cssProp].dataAttr);
        });
        inlineStyleCache.set(element, getInlineStyleCacheKey(element, theme));
    }

    var metaThemeColorName = "theme-color";
    var metaThemeColorSelector = 'meta[name="'.concat(metaThemeColorName, '"]');
    var srcMetaThemeColor = null;
    var observer = null;
    function changeMetaThemeColor(meta, theme) {
        srcMetaThemeColor = srcMetaThemeColor || meta.content;
        var color = parseColorWithCache(srcMetaThemeColor);
        if (!color) {
            return;
        }
        meta.content = modifyBackgroundColor(color, theme);
    }
    function changeMetaThemeColorWhenAvailable(theme) {
        var meta = document.querySelector(metaThemeColorSelector);
        if (meta) {
            changeMetaThemeColor(meta, theme);
        } else {
            if (observer) {
                observer.disconnect();
            }
            observer = new MutationObserver(function (mutations) {
                loop: for (var i = 0; i < mutations.length; i++) {
                    var addedNodes = mutations[i].addedNodes;
                    for (var j = 0; j < addedNodes.length; j++) {
                        var node = addedNodes[j];
                        if (
                            node instanceof HTMLMetaElement &&
                            node.name === metaThemeColorName
                        ) {
                            observer.disconnect();
                            observer = null;
                            changeMetaThemeColor(node, theme);
                            break loop;
                        }
                    }
                }
            });
            observer.observe(document.head, {childList: true});
        }
    }
    function restoreMetaThemeColor() {
        if (observer) {
            observer.disconnect();
            observer = null;
        }
        var meta = document.querySelector(metaThemeColorSelector);
        if (meta && srcMetaThemeColor) {
            meta.content = srcMetaThemeColor;
        }
    }

    var themeCacheKeys = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
    ];
    function getThemeKey(theme) {
        var resultKey = "";
        themeCacheKeys.forEach(function (key) {
            resultKey += "".concat(key, ":").concat(theme[key], ";");
        });
        return resultKey;
    }
    var asyncQueue = createAsyncTasksQueue();
    function createStyleSheetModifier() {
        var renderId = 0;
        var rulesTextCache = new Set();
        var rulesModCache = new Map();
        var varTypeChangeCleaners = new Set();
        var prevFilterKey = null;
        var hasNonLoadedLink = false;
        var wasRebuilt = false;
        function shouldRebuildStyle() {
            return hasNonLoadedLink && !wasRebuilt;
        }
        function modifySheet(options) {
            var rules = options.sourceCSSRules;
            var theme = options.theme,
                ignoreImageAnalysis = options.ignoreImageAnalysis,
                force = options.force,
                prepareSheet = options.prepareSheet,
                isAsyncCancelled = options.isAsyncCancelled;
            var rulesChanged = rulesModCache.size === 0;
            var notFoundCacheKeys = new Set(rulesModCache.keys());
            var themeKey = getThemeKey(theme);
            var themeChanged = themeKey !== prevFilterKey;
            if (hasNonLoadedLink) {
                wasRebuilt = true;
            }
            var modRules = [];
            iterateCSSRules(
                rules,
                function (rule) {
                    var cssText = rule.cssText;
                    var textDiffersFromPrev = false;
                    notFoundCacheKeys.delete(cssText);
                    if (rule.parentRule instanceof CSSMediaRule) {
                        cssText += ";".concat(rule.parentRule.media.mediaText);
                    }
                    if (!rulesTextCache.has(cssText)) {
                        rulesTextCache.add(cssText);
                        textDiffersFromPrev = true;
                    }
                    if (textDiffersFromPrev) {
                        rulesChanged = true;
                    } else {
                        modRules.push(rulesModCache.get(cssText));
                        return;
                    }
                    var modDecs = [];
                    rule.style &&
                        iterateCSSDeclarations(
                            rule.style,
                            function (property, value) {
                                var mod = getModifiableCSSDeclaration(
                                    property,
                                    value,
                                    rule,
                                    variablesStore,
                                    ignoreImageAnalysis,
                                    isAsyncCancelled
                                );
                                if (mod) {
                                    modDecs.push(mod);
                                }
                            }
                        );
                    var modRule = null;
                    if (modDecs.length > 0) {
                        var parentRule = rule.parentRule;
                        modRule = {
                            selector: rule.selectorText,
                            declarations: modDecs,
                            parentRule: parentRule
                        };
                        modRules.push(modRule);
                    }
                    rulesModCache.set(cssText, modRule);
                },
                function () {
                    hasNonLoadedLink = true;
                }
            );
            notFoundCacheKeys.forEach(function (key) {
                rulesTextCache.delete(key);
                rulesModCache.delete(key);
            });
            prevFilterKey = themeKey;
            if (!force && !rulesChanged && !themeChanged) {
                return;
            }
            renderId++;
            function setRule(target, index, rule) {
                var selector = rule.selector,
                    declarations = rule.declarations;
                var getDeclarationText = function (dec) {
                    var property = dec.property,
                        value = dec.value,
                        important = dec.important,
                        sourceValue = dec.sourceValue;
                    return ""
                        .concat(property, ": ")
                        .concat(value == null ? sourceValue : value)
                        .concat(important ? " !important" : "", ";");
                };
                var cssRulesText = "";
                declarations.forEach(function (declarations) {
                    cssRulesText += "".concat(
                        getDeclarationText(declarations),
                        " "
                    );
                });
                var ruleText = ""
                    .concat(selector, " { ")
                    .concat(cssRulesText, " }");
                target.insertRule(ruleText, index);
            }
            var asyncDeclarations = new Map();
            var varDeclarations = new Map();
            var asyncDeclarationCounter = 0;
            var varDeclarationCounter = 0;
            var rootReadyGroup = {rule: null, rules: [], isGroup: true};
            var groupRefs = new WeakMap();
            function getGroup(rule) {
                if (rule == null) {
                    return rootReadyGroup;
                }
                if (groupRefs.has(rule)) {
                    return groupRefs.get(rule);
                }
                var group = {rule: rule, rules: [], isGroup: true};
                groupRefs.set(rule, group);
                var parentGroup = getGroup(rule.parentRule);
                parentGroup.rules.push(group);
                return group;
            }
            varTypeChangeCleaners.forEach(function (clear) {
                return clear();
            });
            varTypeChangeCleaners.clear();
            modRules
                .filter(function (r) {
                    return r;
                })
                .forEach(function (_a) {
                    var selector = _a.selector,
                        declarations = _a.declarations,
                        parentRule = _a.parentRule;
                    var group = getGroup(parentRule);
                    var readyStyleRule = {
                        selector: selector,
                        declarations: [],
                        isGroup: false
                    };
                    var readyDeclarations = readyStyleRule.declarations;
                    group.rules.push(readyStyleRule);
                    function handleAsyncDeclaration(
                        property,
                        modified,
                        important,
                        sourceValue
                    ) {
                        var asyncKey = ++asyncDeclarationCounter;
                        var asyncDeclaration = {
                            property: property,
                            value: null,
                            important: important,
                            asyncKey: asyncKey,
                            sourceValue: sourceValue
                        };
                        readyDeclarations.push(asyncDeclaration);
                        var currentRenderId = renderId;
                        modified.then(function (asyncValue) {
                            if (
                                !asyncValue ||
                                isAsyncCancelled() ||
                                currentRenderId !== renderId
                            ) {
                                return;
                            }
                            asyncDeclaration.value = asyncValue;
                            asyncQueue.add(function () {
                                if (
                                    isAsyncCancelled() ||
                                    currentRenderId !== renderId
                                ) {
                                    return;
                                }
                                rebuildAsyncRule(asyncKey);
                            });
                        });
                    }
                    function handleVarDeclarations(
                        property,
                        modified,
                        important,
                        sourceValue
                    ) {
                        var _a = modified,
                            varDecs = _a.declarations,
                            onTypeChange = _a.onTypeChange;
                        var varKey = ++varDeclarationCounter;
                        var currentRenderId = renderId;
                        var initialIndex = readyDeclarations.length;
                        var oldDecs = [];
                        if (varDecs.length === 0) {
                            var tempDec = {
                                property: property,
                                value: sourceValue,
                                important: important,
                                sourceValue: sourceValue,
                                varKey: varKey
                            };
                            readyDeclarations.push(tempDec);
                            oldDecs = [tempDec];
                        }
                        varDecs.forEach(function (mod) {
                            if (mod.value instanceof Promise) {
                                handleAsyncDeclaration(
                                    mod.property,
                                    mod.value,
                                    important,
                                    sourceValue
                                );
                            } else {
                                var readyDec = {
                                    property: mod.property,
                                    value: mod.value,
                                    important: important,
                                    sourceValue: sourceValue,
                                    varKey: varKey
                                };
                                readyDeclarations.push(readyDec);
                                oldDecs.push(readyDec);
                            }
                        });
                        onTypeChange.addListener(function (newDecs) {
                            if (
                                isAsyncCancelled() ||
                                currentRenderId !== renderId
                            ) {
                                return;
                            }
                            var readyVarDecs = newDecs.map(function (mod) {
                                return {
                                    property: mod.property,
                                    value: mod.value,
                                    important: important,
                                    sourceValue: sourceValue,
                                    varKey: varKey
                                };
                            });
                            var index = readyDeclarations.indexOf(
                                oldDecs[0],
                                initialIndex
                            );
                            readyDeclarations.splice.apply(
                                readyDeclarations,
                                __spreadArray(
                                    [index, oldDecs.length],
                                    __read(readyVarDecs),
                                    false
                                )
                            );
                            oldDecs = readyVarDecs;
                            rebuildVarRule(varKey);
                        });
                        varTypeChangeCleaners.add(function () {
                            return onTypeChange.removeListeners();
                        });
                    }
                    declarations.forEach(function (_a) {
                        var property = _a.property,
                            value = _a.value,
                            important = _a.important,
                            sourceValue = _a.sourceValue;
                        if (typeof value === "function") {
                            var modified = value(theme);
                            if (modified instanceof Promise) {
                                handleAsyncDeclaration(
                                    property,
                                    modified,
                                    important,
                                    sourceValue
                                );
                            } else if (property.startsWith("--")) {
                                handleVarDeclarations(
                                    property,
                                    modified,
                                    important,
                                    sourceValue
                                );
                            } else {
                                readyDeclarations.push({
                                    property: property,
                                    value: modified,
                                    important: important,
                                    sourceValue: sourceValue
                                });
                            }
                        } else {
                            readyDeclarations.push({
                                property: property,
                                value: value,
                                important: important,
                                sourceValue: sourceValue
                            });
                        }
                    });
                });
            var sheet = prepareSheet();
            function buildStyleSheet() {
                function createTarget(group, parent) {
                    var rule = group.rule;
                    if (rule instanceof CSSMediaRule) {
                        var media = rule.media;
                        var index = parent.cssRules.length;
                        parent.insertRule(
                            "@media ".concat(media.mediaText, " {}"),
                            index
                        );
                        return parent.cssRules[index];
                    }
                    return parent;
                }
                function iterateReadyRules(group, target, styleIterator) {
                    group.rules.forEach(function (r) {
                        if (r.isGroup) {
                            var t = createTarget(r, target);
                            iterateReadyRules(r, t, styleIterator);
                        } else {
                            styleIterator(r, target);
                        }
                    });
                }
                iterateReadyRules(
                    rootReadyGroup,
                    sheet,
                    function (rule, target) {
                        var index = target.cssRules.length;
                        rule.declarations.forEach(function (_a) {
                            var asyncKey = _a.asyncKey,
                                varKey = _a.varKey;
                            if (asyncKey != null) {
                                asyncDeclarations.set(asyncKey, {
                                    rule: rule,
                                    target: target,
                                    index: index
                                });
                            }
                            if (varKey != null) {
                                varDeclarations.set(varKey, {
                                    rule: rule,
                                    target: target,
                                    index: index
                                });
                            }
                        });
                        setRule(target, index, rule);
                    }
                );
            }
            function rebuildAsyncRule(key) {
                var _a = asyncDeclarations.get(key),
                    rule = _a.rule,
                    target = _a.target,
                    index = _a.index;
                target.deleteRule(index);
                setRule(target, index, rule);
                asyncDeclarations.delete(key);
            }
            function rebuildVarRule(key) {
                var _a = varDeclarations.get(key),
                    rule = _a.rule,
                    target = _a.target,
                    index = _a.index;
                target.deleteRule(index);
                setRule(target, index, rule);
            }
            buildStyleSheet();
        }
        return {
            modifySheet: modifySheet,
            shouldRebuildStyle: shouldRebuildStyle
        };
    }

    var STYLE_SELECTOR = 'style, link[rel*="stylesheet" i]:not([disabled])';
    function isFontsGoogleApiStyle(element) {
        if (!element.href) {
            return false;
        }
        try {
            var elementURL = new URL(element.href);
            return elementURL.hostname === "fonts.googleapis.com";
        } catch (err) {
            logInfo("Couldn't construct ".concat(element.href, " as URL"));
            return false;
        }
    }
    function shouldManageStyle(element) {
        return (
            (element instanceof HTMLStyleElement ||
                element instanceof SVGStyleElement ||
                (element instanceof HTMLLinkElement &&
                    element.rel &&
                    element.rel.toLowerCase().includes("stylesheet") &&
                    element.href &&
                    !element.disabled &&
                    (isFirefox
                        ? !element.href.startsWith("moz-extension://")
                        : true) &&
                    !isFontsGoogleApiStyle(element))) &&
            !element.classList.contains("darkreader") &&
            element.media.toLowerCase() !== "print" &&
            !element.classList.contains("stylus")
        );
    }
    function getManageableStyles(node, results, deep) {
        if (results === void 0) {
            results = [];
        }
        if (deep === void 0) {
            deep = true;
        }
        if (shouldManageStyle(node)) {
            results.push(node);
        } else if (
            node instanceof Element ||
            (isShadowDomSupported && node instanceof ShadowRoot) ||
            node === document
        ) {
            forEach(node.querySelectorAll(STYLE_SELECTOR), function (style) {
                return getManageableStyles(style, results, false);
            });
            if (deep) {
                iterateShadowHosts(node, function (host) {
                    return getManageableStyles(host.shadowRoot, results, false);
                });
            }
        }
        return results;
    }
    var syncStyleSet = new WeakSet();
    var corsStyleSet = new WeakSet();
    var canOptimizeUsingProxy$1 = false;
    document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        function () {
            canOptimizeUsingProxy$1 = true;
        }
    );
    var loadingLinkCounter = 0;
    var rejectorsForLoadingLinks = new Map();
    function cleanLoadingLinks() {
        rejectorsForLoadingLinks.clear();
    }
    function manageStyle(element, _a) {
        var update = _a.update,
            loadingStart = _a.loadingStart,
            loadingEnd = _a.loadingEnd;
        var prevStyles = [];
        var next = element;
        while (
            (next = next.nextElementSibling) &&
            next.matches(".darkreader")
        ) {
            prevStyles.push(next);
        }
        var corsCopy =
            prevStyles.find(function (el) {
                return el.matches(".darkreader--cors") && !corsStyleSet.has(el);
            }) || null;
        var syncStyle =
            prevStyles.find(function (el) {
                return el.matches(".darkreader--sync") && !syncStyleSet.has(el);
            }) || null;
        var corsCopyPositionWatcher = null;
        var syncStylePositionWatcher = null;
        var cancelAsyncOperations = false;
        var isOverrideEmpty = true;
        var sheetModifier = createStyleSheetModifier();
        var observer = new MutationObserver(function () {
            update();
        });
        var observerOptions = {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
        };
        function containsCSSImport() {
            return (
                element instanceof HTMLStyleElement &&
                element.textContent.trim().match(cssImportRegex)
            );
        }
        function hasImports(cssRules, checkCrossOrigin) {
            var result = false;
            if (cssRules) {
                var rule = void 0;
                cssRulesLoop: for (
                    var i = 0, len = cssRules.length;
                    i < len;
                    i++
                ) {
                    rule = cssRules[i];
                    if (rule.href) {
                        if (checkCrossOrigin) {
                            if (
                                rule.href.startsWith("http") &&
                                !rule.href.startsWith(location.origin)
                            ) {
                                result = true;
                                break cssRulesLoop;
                            }
                        } else {
                            result = true;
                            break cssRulesLoop;
                        }
                    }
                }
            }
            return result;
        }
        function getRulesSync() {
            if (corsCopy) {
                return corsCopy.sheet.cssRules;
            }
            if (containsCSSImport()) {
                return null;
            }
            var cssRules = safeGetSheetRules();
            if (
                element instanceof HTMLLinkElement &&
                !isRelativeHrefOnAbsolutePath(element.href) &&
                hasImports(cssRules, false)
            ) {
                return null;
            }
            if (hasImports(cssRules, true)) {
                return null;
            }
            return cssRules;
        }
        function insertStyle() {
            if (corsCopy) {
                if (element.nextSibling !== corsCopy) {
                    element.parentNode.insertBefore(
                        corsCopy,
                        element.nextSibling
                    );
                }
                if (corsCopy.nextSibling !== syncStyle) {
                    element.parentNode.insertBefore(
                        syncStyle,
                        corsCopy.nextSibling
                    );
                }
            } else if (element.nextSibling !== syncStyle) {
                element.parentNode.insertBefore(syncStyle, element.nextSibling);
            }
        }
        function createSyncStyle() {
            syncStyle =
                element instanceof SVGStyleElement
                    ? document.createElementNS(
                          "http://www.w3.org/2000/svg",
                          "style"
                      )
                    : document.createElement("style");
            syncStyle.classList.add("darkreader");
            syncStyle.classList.add("darkreader--sync");
            syncStyle.media = "screen";
            if (element.title) {
                syncStyle.title = element.title;
            }
            syncStyleSet.add(syncStyle);
        }
        var isLoadingRules = false;
        var wasLoadingError = false;
        var loadingLinkId = ++loadingLinkCounter;
        function getRulesAsync() {
            return __awaiter(this, void 0, void 0, function () {
                var cssText,
                    cssBasePath,
                    _a,
                    cssRules,
                    accessError,
                    fullCSSText;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!(element instanceof HTMLLinkElement))
                                return [3, 7];
                            (_a = __read(getRulesOrError(), 2)),
                                (cssRules = _a[0]),
                                (accessError = _a[1]);
                            if (
                                !(
                                    (!cssRules && !accessError && !isSafari) ||
                                    (isSafari && !element.sheet) ||
                                    isStillLoadingError(accessError)
                                )
                            )
                                return [3, 5];
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 3, , 4]);
                            return [4, linkLoading(element, loadingLinkId)];
                        case 2:
                            _c.sent();
                            return [3, 4];
                        case 3:
                            _c.sent();
                            wasLoadingError = true;
                            return [3, 4];
                        case 4:
                            if (cancelAsyncOperations) {
                                return [2, null];
                            }
                            (_b = __read(getRulesOrError(), 2)),
                                (cssRules = _b[0]),
                                (accessError = _b[1]);
                            _c.label = 5;
                        case 5:
                            if (cssRules) {
                                if (!hasImports(cssRules, false)) {
                                    return [2, cssRules];
                                }
                            }
                            return [4, loadText(element.href)];
                        case 6:
                            cssText = _c.sent();
                            cssBasePath = getCSSBaseBath(element.href);
                            if (cancelAsyncOperations) {
                                return [2, null];
                            }
                            return [3, 8];
                        case 7:
                            if (containsCSSImport()) {
                                cssText = element.textContent.trim();
                                cssBasePath = getCSSBaseBath(location.href);
                            } else {
                                return [2, null];
                            }
                            _c.label = 8;
                        case 8:
                            if (!cssText) return [3, 13];
                            _c.label = 9;
                        case 9:
                            _c.trys.push([9, 11, , 12]);
                            return [4, replaceCSSImports(cssText, cssBasePath)];
                        case 10:
                            fullCSSText = _c.sent();
                            corsCopy = createCORSCopy(element, fullCSSText);
                            return [3, 12];
                        case 11:
                            _c.sent();
                            return [3, 12];
                        case 12:
                            if (corsCopy) {
                                corsCopyPositionWatcher = watchForNodePosition(
                                    corsCopy,
                                    "prev-sibling"
                                );
                                return [2, corsCopy.sheet.cssRules];
                            }
                            _c.label = 13;
                        case 13:
                            return [2, null];
                    }
                });
            });
        }
        function details(options) {
            var rules = getRulesSync();
            if (!rules) {
                if (options.secondRound) {
                    return null;
                }
                if (isLoadingRules || wasLoadingError) {
                    return null;
                }
                isLoadingRules = true;
                loadingStart();
                getRulesAsync()
                    .then(function (results) {
                        isLoadingRules = false;
                        loadingEnd();
                        if (results) {
                            update();
                        }
                    })
                    .catch(function (err) {
                        isLoadingRules = false;
                        loadingEnd();
                    });
                return null;
            }
            return {rules: rules};
        }
        var forceRenderStyle = false;
        function render(theme, ignoreImageAnalysis) {
            var rules = getRulesSync();
            if (!rules) {
                return;
            }
            cancelAsyncOperations = false;
            function removeCSSRulesFromSheet(sheet) {
                for (var i = sheet.cssRules.length - 1; i >= 0; i--) {
                    sheet.deleteRule(i);
                }
            }
            function prepareOverridesSheet() {
                if (!syncStyle) {
                    createSyncStyle();
                }
                syncStylePositionWatcher && syncStylePositionWatcher.stop();
                insertStyle();
                if (syncStyle.sheet == null) {
                    syncStyle.textContent = "";
                }
                var sheet = syncStyle.sheet;
                removeCSSRulesFromSheet(sheet);
                if (syncStylePositionWatcher) {
                    syncStylePositionWatcher.run();
                } else {
                    syncStylePositionWatcher = watchForNodePosition(
                        syncStyle,
                        "prev-sibling",
                        function () {
                            forceRenderStyle = true;
                            buildOverrides();
                        }
                    );
                }
                return syncStyle.sheet;
            }
            function buildOverrides() {
                var force = forceRenderStyle;
                forceRenderStyle = false;
                sheetModifier.modifySheet({
                    prepareSheet: prepareOverridesSheet,
                    sourceCSSRules: rules,
                    theme: theme,
                    ignoreImageAnalysis: ignoreImageAnalysis,
                    force: force,
                    isAsyncCancelled: function () {
                        return cancelAsyncOperations;
                    }
                });
                isOverrideEmpty = syncStyle.sheet.cssRules.length === 0;
                if (sheetModifier.shouldRebuildStyle()) {
                    addReadyStateCompleteListener(function () {
                        return update();
                    });
                }
            }
            buildOverrides();
        }
        function getRulesOrError() {
            try {
                if (element.sheet == null) {
                    return [null, null];
                }
                return [element.sheet.cssRules, null];
            } catch (err) {
                return [null, err];
            }
        }
        function isStillLoadingError(error) {
            return error && error.message && error.message.includes("loading");
        }
        function safeGetSheetRules() {
            var _a = __read(getRulesOrError(), 2),
                cssRules = _a[0],
                err = _a[1];
            if (err) {
                return null;
            }
            return cssRules;
        }
        function watchForSheetChanges() {
            watchForSheetChangesUsingProxy();
            if (!(canOptimizeUsingProxy$1 && element.sheet)) {
                watchForSheetChangesUsingRAF();
            }
        }
        var rulesChangeKey = null;
        var rulesCheckFrameId = null;
        function getRulesChangeKey() {
            var rules = safeGetSheetRules();
            return rules ? rules.length : null;
        }
        function didRulesKeyChange() {
            return getRulesChangeKey() !== rulesChangeKey;
        }
        function watchForSheetChangesUsingRAF() {
            rulesChangeKey = getRulesChangeKey();
            stopWatchingForSheetChangesUsingRAF();
            var checkForUpdate = function () {
                if (didRulesKeyChange()) {
                    rulesChangeKey = getRulesChangeKey();
                    update();
                }
                if (canOptimizeUsingProxy$1 && element.sheet) {
                    stopWatchingForSheetChangesUsingRAF();
                    return;
                }
                rulesCheckFrameId = requestAnimationFrame(checkForUpdate);
            };
            checkForUpdate();
        }
        function stopWatchingForSheetChangesUsingRAF() {
            cancelAnimationFrame(rulesCheckFrameId);
        }
        var areSheetChangesPending = false;
        function onSheetChange() {
            canOptimizeUsingProxy$1 = true;
            stopWatchingForSheetChangesUsingRAF();
            if (areSheetChangesPending) {
                return;
            }
            function handleSheetChanges() {
                areSheetChangesPending = false;
                if (cancelAsyncOperations) {
                    return;
                }
                update();
            }
            areSheetChangesPending = true;
            if (typeof queueMicrotask === "function") {
                queueMicrotask(handleSheetChanges);
            } else {
                requestAnimationFrame(handleSheetChanges);
            }
        }
        function watchForSheetChangesUsingProxy() {
            element.addEventListener(
                "__darkreader__updateSheet",
                onSheetChange
            );
        }
        function stopWatchingForSheetChangesUsingProxy() {
            element.removeEventListener(
                "__darkreader__updateSheet",
                onSheetChange
            );
        }
        function stopWatchingForSheetChanges() {
            stopWatchingForSheetChangesUsingProxy();
            stopWatchingForSheetChangesUsingRAF();
        }
        function pause() {
            observer.disconnect();
            cancelAsyncOperations = true;
            corsCopyPositionWatcher && corsCopyPositionWatcher.stop();
            syncStylePositionWatcher && syncStylePositionWatcher.stop();
            stopWatchingForSheetChanges();
        }
        function destroy() {
            pause();
            removeNode(corsCopy);
            removeNode(syncStyle);
            loadingEnd();
            if (rejectorsForLoadingLinks.has(loadingLinkId)) {
                var reject = rejectorsForLoadingLinks.get(loadingLinkId);
                rejectorsForLoadingLinks.delete(loadingLinkId);
                reject && reject();
            }
        }
        function watch() {
            observer.observe(element, observerOptions);
            if (element instanceof HTMLStyleElement) {
                watchForSheetChanges();
            }
        }
        var maxMoveCount = 10;
        var moveCount = 0;
        function restore() {
            if (!syncStyle) {
                return;
            }
            moveCount++;
            if (moveCount > maxMoveCount) {
                return;
            }
            insertStyle();
            corsCopyPositionWatcher && corsCopyPositionWatcher.skip();
            syncStylePositionWatcher && syncStylePositionWatcher.skip();
            if (!isOverrideEmpty) {
                forceRenderStyle = true;
                update();
            }
        }
        return {
            details: details,
            render: render,
            pause: pause,
            destroy: destroy,
            watch: watch,
            restore: restore
        };
    }
    function linkLoading(link, loadingId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [
                    2,
                    new Promise(function (resolve, reject) {
                        var cleanUp = function () {
                            link.removeEventListener("load", onLoad);
                            link.removeEventListener("error", onError);
                            rejectorsForLoadingLinks.delete(loadingId);
                        };
                        var onLoad = function () {
                            cleanUp();
                            resolve();
                        };
                        var onError = function () {
                            cleanUp();
                            reject(
                                "Linkelement "
                                    .concat(loadingId, " couldn't be loaded. ")
                                    .concat(link.href)
                            );
                        };
                        rejectorsForLoadingLinks.set(loadingId, function () {
                            cleanUp();
                            reject();
                        });
                        link.addEventListener("load", onLoad);
                        link.addEventListener("error", onError);
                        if (!link.href) {
                            onError();
                        }
                    })
                ];
            });
        });
    }
    function getCSSImportURL(importDeclaration) {
        return getCSSURLValue(
            importDeclaration
                .substring(7)
                .trim()
                .replace(/;$/, "")
                .replace(/screen$/, "")
        );
    }
    function loadText(url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!url.startsWith("data:")) return [3, 3];
                        return [4, fetch(url)];
                    case 1:
                        return [4, _a.sent().text()];
                    case 2:
                        return [2, _a.sent()];
                    case 3:
                        return [
                            4,
                            bgFetch({
                                url: url,
                                responseType: "text",
                                mimeType: "text/css",
                                origin: window.location.origin
                            })
                        ];
                    case 4:
                        return [2, _a.sent()];
                }
            });
        });
    }
    function replaceCSSImports(cssText, basePath, cache) {
        if (cache === void 0) {
            cache = new Map();
        }
        return __awaiter(this, void 0, void 0, function () {
            var importMatches,
                importMatches_1,
                importMatches_1_1,
                match,
                importURL,
                absoluteURL,
                importedCSS,
                e_1_1;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cssText = removeCSSComments(cssText);
                        cssText = replaceCSSFontFace(cssText);
                        cssText = replaceCSSRelativeURLsWithAbsolute(
                            cssText,
                            basePath
                        );
                        importMatches = getMatches(cssImportRegex, cssText);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 10, 11, 12]);
                        (importMatches_1 = __values(importMatches)),
                            (importMatches_1_1 = importMatches_1.next());
                        _b.label = 2;
                    case 2:
                        if (!!importMatches_1_1.done) return [3, 9];
                        match = importMatches_1_1.value;
                        importURL = getCSSImportURL(match);
                        absoluteURL = getAbsoluteURL(basePath, importURL);
                        importedCSS = void 0;
                        if (!cache.has(absoluteURL)) return [3, 3];
                        importedCSS = cache.get(absoluteURL);
                        return [3, 7];
                    case 3:
                        _b.trys.push([3, 6, , 7]);
                        return [4, loadText(absoluteURL)];
                    case 4:
                        importedCSS = _b.sent();
                        cache.set(absoluteURL, importedCSS);
                        return [
                            4,
                            replaceCSSImports(
                                importedCSS,
                                getCSSBaseBath(absoluteURL),
                                cache
                            )
                        ];
                    case 5:
                        importedCSS = _b.sent();
                        return [3, 7];
                    case 6:
                        _b.sent();
                        importedCSS = "";
                        return [3, 7];
                    case 7:
                        cssText = cssText.split(match).join(importedCSS);
                        _b.label = 8;
                    case 8:
                        importMatches_1_1 = importMatches_1.next();
                        return [3, 2];
                    case 9:
                        return [3, 12];
                    case 10:
                        e_1_1 = _b.sent();
                        e_1 = {error: e_1_1};
                        return [3, 12];
                    case 11:
                        try {
                            if (
                                importMatches_1_1 &&
                                !importMatches_1_1.done &&
                                (_a = importMatches_1.return)
                            )
                                _a.call(importMatches_1);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                        return [7];
                    case 12:
                        cssText = cssText.trim();
                        return [2, cssText];
                }
            });
        });
    }
    function createCORSCopy(srcElement, cssText) {
        if (!cssText) {
            return null;
        }
        var cors = document.createElement("style");
        cors.classList.add("darkreader");
        cors.classList.add("darkreader--cors");
        cors.media = "screen";
        cors.textContent = cssText;
        srcElement.parentNode.insertBefore(cors, srcElement.nextSibling);
        cors.sheet.disabled = true;
        corsStyleSet.add(cors);
        return cors;
    }

    var observers = [];
    var observedRoots;
    var undefinedGroups = new Map();
    var elementsDefinitionCallback;
    function collectUndefinedElements(root) {
        if (!isDefinedSelectorSupported) {
            return;
        }
        forEach(root.querySelectorAll(":not(:defined)"), function (el) {
            var tag = el.tagName.toLowerCase();
            if (!tag.includes("-")) {
                var extendedTag = el.getAttribute("is");
                if (extendedTag) {
                    tag = extendedTag;
                } else {
                    return;
                }
            }
            if (!undefinedGroups.has(tag)) {
                undefinedGroups.set(tag, new Set());
                customElementsWhenDefined(tag).then(function () {
                    if (elementsDefinitionCallback) {
                        var elements = undefinedGroups.get(tag);
                        undefinedGroups.delete(tag);
                        elementsDefinitionCallback(Array.from(elements));
                    }
                });
            }
            undefinedGroups.get(tag).add(el);
        });
    }
    var canOptimizeUsingProxy = false;
    document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        function () {
            canOptimizeUsingProxy = true;
        }
    );
    var resolvers = new Map();
    function handleIsDefined(e) {
        canOptimizeUsingProxy = true;
        if (resolvers.has(e.detail.tag)) {
            var resolve = resolvers.get(e.detail.tag);
            resolve();
        }
    }
    function customElementsWhenDefined(tag) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [
                    2,
                    new Promise(function (resolve) {
                        if (
                            window.customElements &&
                            typeof customElements.whenDefined === "function"
                        ) {
                            customElements.whenDefined(tag).then(function () {
                                return resolve();
                            });
                        } else if (canOptimizeUsingProxy) {
                            resolvers.set(tag, resolve);
                            document.dispatchEvent(
                                new CustomEvent(
                                    "__darkreader__addUndefinedResolver",
                                    {detail: {tag: tag}}
                                )
                            );
                        } else {
                            var checkIfDefined_1 = function () {
                                var elements = undefinedGroups.get(tag);
                                if (elements && elements.size > 0) {
                                    if (
                                        elements
                                            .values()
                                            .next()
                                            .value.matches(":defined")
                                    ) {
                                        resolve();
                                    } else {
                                        requestAnimationFrame(checkIfDefined_1);
                                    }
                                }
                            };
                            requestAnimationFrame(checkIfDefined_1);
                        }
                    })
                ];
            });
        });
    }
    function watchWhenCustomElementsDefined(callback) {
        elementsDefinitionCallback = callback;
    }
    function unsubscribeFromDefineCustomElements() {
        elementsDefinitionCallback = null;
        undefinedGroups.clear();
        document.removeEventListener(
            "__darkreader__isDefined",
            handleIsDefined
        );
    }
    function watchForStyleChanges(currentStyles, update, shadowRootDiscovered) {
        stopWatchingForStyleChanges();
        var prevStyles = new Set(currentStyles);
        var prevStyleSiblings = new WeakMap();
        var nextStyleSiblings = new WeakMap();
        function saveStylePosition(style) {
            prevStyleSiblings.set(style, style.previousElementSibling);
            nextStyleSiblings.set(style, style.nextElementSibling);
        }
        function forgetStylePosition(style) {
            prevStyleSiblings.delete(style);
            nextStyleSiblings.delete(style);
        }
        function didStylePositionChange(style) {
            return (
                style.previousElementSibling !== prevStyleSiblings.get(style) ||
                style.nextElementSibling !== nextStyleSiblings.get(style)
            );
        }
        currentStyles.forEach(saveStylePosition);
        function handleStyleOperations(operations) {
            var createdStyles = operations.createdStyles,
                removedStyles = operations.removedStyles,
                movedStyles = operations.movedStyles;
            createdStyles.forEach(function (s) {
                return saveStylePosition(s);
            });
            movedStyles.forEach(function (s) {
                return saveStylePosition(s);
            });
            removedStyles.forEach(function (s) {
                return forgetStylePosition(s);
            });
            createdStyles.forEach(function (s) {
                return prevStyles.add(s);
            });
            removedStyles.forEach(function (s) {
                return prevStyles.delete(s);
            });
            if (
                createdStyles.size + removedStyles.size + movedStyles.size >
                0
            ) {
                update({
                    created: Array.from(createdStyles),
                    removed: Array.from(removedStyles),
                    moved: Array.from(movedStyles),
                    updated: []
                });
            }
        }
        function handleMinorTreeMutations(_a) {
            var additions = _a.additions,
                moves = _a.moves,
                deletions = _a.deletions;
            var createdStyles = new Set();
            var removedStyles = new Set();
            var movedStyles = new Set();
            additions.forEach(function (node) {
                return getManageableStyles(node).forEach(function (style) {
                    return createdStyles.add(style);
                });
            });
            deletions.forEach(function (node) {
                return getManageableStyles(node).forEach(function (style) {
                    return removedStyles.add(style);
                });
            });
            moves.forEach(function (node) {
                return getManageableStyles(node).forEach(function (style) {
                    return movedStyles.add(style);
                });
            });
            handleStyleOperations({
                createdStyles: createdStyles,
                removedStyles: removedStyles,
                movedStyles: movedStyles
            });
            additions.forEach(function (n) {
                iterateShadowHosts(n, subscribeForShadowRootChanges);
                collectUndefinedElements(n);
            });
        }
        function handleHugeTreeMutations(root) {
            var styles = new Set(getManageableStyles(root));
            var createdStyles = new Set();
            var removedStyles = new Set();
            var movedStyles = new Set();
            styles.forEach(function (s) {
                if (!prevStyles.has(s)) {
                    createdStyles.add(s);
                }
            });
            prevStyles.forEach(function (s) {
                if (!styles.has(s)) {
                    removedStyles.add(s);
                }
            });
            styles.forEach(function (s) {
                if (
                    !createdStyles.has(s) &&
                    !removedStyles.has(s) &&
                    didStylePositionChange(s)
                ) {
                    movedStyles.add(s);
                }
            });
            handleStyleOperations({
                createdStyles: createdStyles,
                removedStyles: removedStyles,
                movedStyles: movedStyles
            });
            iterateShadowHosts(root, subscribeForShadowRootChanges);
            collectUndefinedElements(root);
        }
        function handleAttributeMutations(mutations) {
            var updatedStyles = new Set();
            var removedStyles = new Set();
            mutations.forEach(function (m) {
                var target = m.target;
                if (target.isConnected) {
                    if (shouldManageStyle(target)) {
                        updatedStyles.add(target);
                    } else if (
                        target instanceof HTMLLinkElement &&
                        target.disabled
                    ) {
                        removedStyles.add(target);
                    }
                }
            });
            if (updatedStyles.size + removedStyles.size > 0) {
                update({
                    updated: Array.from(updatedStyles),
                    created: [],
                    removed: Array.from(removedStyles),
                    moved: []
                });
            }
        }
        function observe(root) {
            var treeObserver = createOptimizedTreeObserver(root, {
                onMinorMutations: handleMinorTreeMutations,
                onHugeMutations: handleHugeTreeMutations
            });
            var attrObserver = new MutationObserver(handleAttributeMutations);
            attrObserver.observe(root, {
                attributes: true,
                attributeFilter: ["rel", "disabled", "media", "href"],
                subtree: true
            });
            observers.push(treeObserver, attrObserver);
            observedRoots.add(root);
        }
        function subscribeForShadowRootChanges(node) {
            var shadowRoot = node.shadowRoot;
            if (shadowRoot == null || observedRoots.has(shadowRoot)) {
                return;
            }
            observe(shadowRoot);
            shadowRootDiscovered(shadowRoot);
        }
        observe(document);
        iterateShadowHosts(
            document.documentElement,
            subscribeForShadowRootChanges
        );
        watchWhenCustomElementsDefined(function (hosts) {
            var newStyles = [];
            hosts.forEach(function (host) {
                return push(newStyles, getManageableStyles(host.shadowRoot));
            });
            update({created: newStyles, updated: [], removed: [], moved: []});
            hosts.forEach(function (host) {
                var shadowRoot = host.shadowRoot;
                if (shadowRoot == null) {
                    return;
                }
                subscribeForShadowRootChanges(host);
                iterateShadowHosts(shadowRoot, subscribeForShadowRootChanges);
                collectUndefinedElements(shadowRoot);
            });
        });
        document.addEventListener("__darkreader__isDefined", handleIsDefined);
        collectUndefinedElements(document);
    }
    function resetObservers() {
        observers.forEach(function (o) {
            return o.disconnect();
        });
        observers.splice(0, observers.length);
        observedRoots = new WeakSet();
    }
    function stopWatchingForStyleChanges() {
        resetObservers();
        unsubscribeFromDefineCustomElements();
    }

    function hexify(number) {
        return (number < 16 ? "0" : "") + number.toString(16);
    }
    function generateUID() {
        if ("randomUUID" in crypto) {
            var uuid = crypto.randomUUID();
            return (
                uuid.substring(0, 8) +
                uuid.substring(9, 13) +
                uuid.substring(14, 18) +
                uuid.substring(19, 23) +
                uuid.substring(24)
            );
        }
        return Array.from(crypto.getRandomValues(new Uint8Array(16)))
            .map(function (x) {
                return hexify(x);
            })
            .join("");
    }

    var adoptedStyleOverrides = new WeakMap();
    var overrideList = new WeakSet();
    function createAdoptedStyleSheetOverride(node) {
        var cancelAsyncOperations = false;
        function injectSheet(sheet, override) {
            var newSheets = __spreadArray(
                [],
                __read(node.adoptedStyleSheets),
                false
            );
            var sheetIndex = newSheets.indexOf(sheet);
            var existingIndex = newSheets.indexOf(override);
            if (sheetIndex === existingIndex - 1) {
                return;
            }
            if (existingIndex >= 0) {
                newSheets.splice(existingIndex, 1);
            }
            newSheets.splice(sheetIndex + 1, 0, override);
            node.adoptedStyleSheets = newSheets;
        }
        function destroy() {
            cancelAsyncOperations = true;
            var newSheets = __spreadArray(
                [],
                __read(node.adoptedStyleSheets),
                false
            );
            node.adoptedStyleSheets.forEach(function (adoptedStyleSheet) {
                if (overrideList.has(adoptedStyleSheet)) {
                    var existingIndex = newSheets.indexOf(adoptedStyleSheet);
                    if (existingIndex >= 0) {
                        newSheets.splice(existingIndex, 1);
                    }
                    adoptedStyleOverrides.delete(adoptedStyleSheet);
                    overrideList.delete(adoptedStyleSheet);
                }
            });
            node.adoptedStyleSheets = newSheets;
        }
        function render(theme, ignoreImageAnalysis) {
            node.adoptedStyleSheets.forEach(function (sheet) {
                if (overrideList.has(sheet)) {
                    return;
                }
                var rules = sheet.rules;
                var override = new CSSStyleSheet();
                function prepareOverridesSheet() {
                    for (var i = override.cssRules.length - 1; i >= 0; i--) {
                        override.deleteRule(i);
                    }
                    injectSheet(sheet, override);
                    adoptedStyleOverrides.set(sheet, override);
                    overrideList.add(override);
                    return override;
                }
                var sheetModifier = createStyleSheetModifier();
                sheetModifier.modifySheet({
                    prepareSheet: prepareOverridesSheet,
                    sourceCSSRules: rules,
                    theme: theme,
                    ignoreImageAnalysis: ignoreImageAnalysis,
                    force: false,
                    isAsyncCancelled: function () {
                        return cancelAsyncOperations;
                    }
                });
            });
        }
        return {
            render: render,
            destroy: destroy
        };
    }

    function injectProxy(enableStyleSheetsProxy) {
        document.dispatchEvent(
            new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        var addRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "addRule"
        );
        var insertRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "insertRule"
        );
        var deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "deleteRule"
        );
        var removeRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "removeRule"
        );
        var documentStyleSheetsDescriptor = enableStyleSheetsProxy
            ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets")
            : null;
        var shouldWrapHTMLElement = [
            "baidu.com",
            "baike.baidu.com",
            "ditu.baidu.com",
            "map.baidu.com",
            "maps.baidu.com",
            "haokan.baidu.com",
            "pan.baidu.com",
            "passport.baidu.com",
            "tieba.baidu.com",
            "www.baidu.com"
        ].includes(location.hostname);
        var getElementsByTagNameDescriptor = shouldWrapHTMLElement
            ? Object.getOwnPropertyDescriptor(
                  Element.prototype,
                  "getElementsByTagName"
              )
            : null;
        var cleanUp = function () {
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "addRule",
                addRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "insertRule",
                insertRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "deleteRule",
                deleteRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "removeRule",
                removeRuleDescriptor
            );
            document.removeEventListener("__darkreader__cleanUp", cleanUp);
            document.removeEventListener(
                "__darkreader__addUndefinedResolver",
                addUndefinedResolver
            );
            if (enableStyleSheetsProxy) {
                Object.defineProperty(
                    Document.prototype,
                    "styleSheets",
                    documentStyleSheetsDescriptor
                );
            }
            if (shouldWrapHTMLElement) {
                Object.defineProperty(
                    Element.prototype,
                    "getElementsByTagName",
                    getElementsByTagNameDescriptor
                );
            }
        };
        var addUndefinedResolver = function (e) {
            customElements.whenDefined(e.detail.tag).then(function () {
                document.dispatchEvent(
                    new CustomEvent("__darkreader__isDefined", {
                        detail: {tag: e.detail.tag}
                    })
                );
            });
        };
        document.addEventListener("__darkreader__cleanUp", cleanUp);
        document.addEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver
        );
        var updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            var returnValue = insertRuleDescriptor.value.call(
                this,
                rule,
                index
            );
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            var _this = this;
            var getCurrentValue = function () {
                var docSheets = documentStyleSheetsDescriptor.get.call(_this);
                var filteredSheets = __spreadArray(
                    [],
                    __read(docSheets),
                    false
                ).filter(function (styleSheet) {
                    return !styleSheet.ownerNode.classList.contains(
                        "darkreader"
                    );
                });
                filteredSheets.item = function (item) {
                    return filteredSheets[item];
                };
                return Object.setPrototypeOf(
                    filteredSheets,
                    StyleSheetList.prototype
                );
            };
            var elements = getCurrentValue();
            var styleSheetListBehavior = {
                get: function (_, property) {
                    return getCurrentValue()[property];
                }
            };
            elements = new Proxy(elements, styleSheetListBehavior);
            return elements;
        }
        function proxyGetElementsByTagName(tagName) {
            var _this = this;
            if (tagName !== "style") {
                return getElementsByTagNameDescriptor.value.call(this, tagName);
            }
            var getCurrentElementValue = function () {
                var elements = getElementsByTagNameDescriptor.value.call(
                    _this,
                    tagName
                );
                return Object.setPrototypeOf(
                    __spreadArray([], __read(elements), false).filter(function (
                        element
                    ) {
                        return !element.classList.contains("darkreader");
                    }),
                    NodeList.prototype
                );
            };
            var elements = getCurrentElementValue();
            var nodeListBehavior = {
                get: function (_, property) {
                    return getCurrentElementValue()[
                        Number(property) || property
                    ];
                }
            };
            elements = new Proxy(elements, nodeListBehavior);
            return elements;
        }
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "addRule",
            Object.assign({}, addRuleDescriptor, {value: proxyAddRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "insertRule",
            Object.assign({}, insertRuleDescriptor, {value: proxyInsertRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "deleteRule",
            Object.assign({}, deleteRuleDescriptor, {value: proxyDeleteRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "removeRule",
            Object.assign({}, removeRuleDescriptor, {value: proxyRemoveRule})
        );
        if (enableStyleSheetsProxy) {
            Object.defineProperty(
                Document.prototype,
                "styleSheets",
                Object.assign({}, documentStyleSheetsDescriptor, {
                    get: proxyDocumentStyleSheets
                })
            );
        }
        if (shouldWrapHTMLElement) {
            Object.defineProperty(
                Element.prototype,
                "getElementsByTagName",
                Object.assign({}, getElementsByTagNameDescriptor, {
                    value: proxyGetElementsByTagName
                })
            );
        }
    }

    var INSTANCE_ID = generateUID();
    var styleManagers = new Map();
    var adoptedStyleManagers = [];
    var filter = null;
    var fixes = null;
    var isIFrame$1 = null;
    var ignoredImageAnalysisSelectors = null;
    var ignoredInlineSelectors = null;
    function createOrUpdateStyle(className, root) {
        if (root === void 0) {
            root = document.head || document;
        }
        var element = root.querySelector(".".concat(className));
        if (!element) {
            element = document.createElement("style");
            element.classList.add("darkreader");
            element.classList.add(className);
            element.media = "screen";
            element.textContent = "";
        }
        return element;
    }
    function createOrUpdateScript(className, root) {
        if (root === void 0) {
            root = document.head || document;
        }
        var element = root.querySelector(".".concat(className));
        if (!element) {
            element = document.createElement("script");
            element.classList.add("darkreader");
            element.classList.add(className);
        }
        return element;
    }
    var nodePositionWatchers = new Map();
    function setupNodePositionWatcher(node, alias) {
        nodePositionWatchers.has(alias) &&
            nodePositionWatchers.get(alias).stop();
        nodePositionWatchers.set(alias, watchForNodePosition(node, "parent"));
    }
    function stopStylePositionWatchers() {
        forEach(nodePositionWatchers.values(), function (watcher) {
            return watcher.stop();
        });
        nodePositionWatchers.clear();
    }
    function createStaticStyleOverrides() {
        var fallbackStyle = createOrUpdateStyle(
            "darkreader--fallback",
            document
        );
        fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
            strict: true
        });
        document.head.insertBefore(fallbackStyle, document.head.firstChild);
        setupNodePositionWatcher(fallbackStyle, "fallback");
        var userAgentStyle = createOrUpdateStyle("darkreader--user-agent");
        userAgentStyle.textContent = getModifiedUserAgentStyle(
            filter,
            isIFrame$1,
            filter.styleSystemControls
        );
        document.head.insertBefore(userAgentStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(userAgentStyle, "user-agent");
        var textStyle = createOrUpdateStyle("darkreader--text");
        if (filter.useFont || filter.textStroke > 0) {
            textStyle.textContent = createTextStyle(filter);
        } else {
            textStyle.textContent = "";
        }
        document.head.insertBefore(textStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(textStyle, "text");
        var invertStyle = createOrUpdateStyle("darkreader--invert");
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
            invertStyle.textContent = [
                "".concat(fixes.invert.join(", "), " {"),
                "    filter: ".concat(
                    getCSSFilterValue(
                        __assign(__assign({}, filter), {
                            contrast:
                                filter.mode === 0
                                    ? filter.contrast
                                    : clamp(filter.contrast - 10, 0, 100)
                        })
                    ),
                    " !important;"
                ),
                "}"
            ].join("\n");
        } else {
            invertStyle.textContent = "";
        }
        document.head.insertBefore(invertStyle, textStyle.nextSibling);
        setupNodePositionWatcher(invertStyle, "invert");
        var inlineStyle = createOrUpdateStyle("darkreader--inline");
        inlineStyle.textContent = getInlineOverrideStyle();
        document.head.insertBefore(inlineStyle, invertStyle.nextSibling);
        setupNodePositionWatcher(inlineStyle, "inline");
        var overrideStyle = createOrUpdateStyle("darkreader--override");
        overrideStyle.textContent =
            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        document.head.appendChild(overrideStyle);
        setupNodePositionWatcher(overrideStyle, "override");
        var variableStyle = createOrUpdateStyle("darkreader--variables");
        var selectionColors = getSelectionColor(filter);
        var darkSchemeBackgroundColor = filter.darkSchemeBackgroundColor,
            darkSchemeTextColor = filter.darkSchemeTextColor,
            lightSchemeBackgroundColor = filter.lightSchemeBackgroundColor,
            lightSchemeTextColor = filter.lightSchemeTextColor,
            mode = filter.mode;
        var schemeBackgroundColor =
            mode === 0 ? lightSchemeBackgroundColor : darkSchemeBackgroundColor;
        var schemeTextColor =
            mode === 0 ? lightSchemeTextColor : darkSchemeTextColor;
        schemeBackgroundColor = modifyBackgroundColor(
            parseColorWithCache(schemeBackgroundColor),
            filter
        );
        schemeTextColor = modifyForegroundColor(
            parseColorWithCache(schemeTextColor),
            filter
        );
        variableStyle.textContent = [
            ":root {",
            "   --darkreader-neutral-background: ".concat(
                schemeBackgroundColor,
                ";"
            ),
            "   --darkreader-neutral-text: ".concat(schemeTextColor, ";"),
            "   --darkreader-selection-background: ".concat(
                selectionColors.backgroundColorSelection,
                ";"
            ),
            "   --darkreader-selection-text: ".concat(
                selectionColors.foregroundColorSelection,
                ";"
            ),
            "}"
        ].join("\n");
        document.head.insertBefore(variableStyle, inlineStyle.nextSibling);
        setupNodePositionWatcher(variableStyle, "variables");
        var rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");
        document.head.insertBefore(rootVarsStyle, variableStyle.nextSibling);
        var injectProxyArg = !(fixes && fixes.disableStyleSheetsProxy);
        {
            var proxyScript = createOrUpdateScript("darkreader--proxy");
            proxyScript.append(
                "(".concat(injectProxy, ")(").concat(injectProxyArg, ")")
            );
            document.head.insertBefore(proxyScript, rootVarsStyle.nextSibling);
            proxyScript.remove();
        }
    }
    var shadowRootsWithOverrides = new Set();
    function createShadowStaticStyleOverrides(root) {
        var inlineStyle = createOrUpdateStyle("darkreader--inline", root);
        inlineStyle.textContent = getInlineOverrideStyle();
        root.insertBefore(inlineStyle, root.firstChild);
        var overrideStyle = createOrUpdateStyle("darkreader--override", root);
        overrideStyle.textContent =
            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        root.insertBefore(overrideStyle, inlineStyle.nextSibling);
        var invertStyle = createOrUpdateStyle("darkreader--invert", root);
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
            invertStyle.textContent = [
                "".concat(fixes.invert.join(", "), " {"),
                "    filter: ".concat(
                    getCSSFilterValue(
                        __assign(__assign({}, filter), {
                            contrast:
                                filter.mode === 0
                                    ? filter.contrast
                                    : clamp(filter.contrast - 10, 0, 100)
                        })
                    ),
                    " !important;"
                ),
                "}"
            ].join("\n");
        } else {
            invertStyle.textContent = "";
        }
        root.insertBefore(invertStyle, overrideStyle.nextSibling);
        shadowRootsWithOverrides.add(root);
    }
    function replaceCSSTemplates($cssText) {
        return $cssText.replace(/\${(.+?)}/g, function (_, $color) {
            var color = parseColorWithCache($color);
            if (color) {
                return modifyColor(color, filter);
            }
            return $color;
        });
    }
    function cleanFallbackStyle() {
        var fallback = document.querySelector(".darkreader--fallback");
        if (fallback) {
            fallback.textContent = "";
        }
    }
    function createDynamicStyleOverrides() {
        cancelRendering();
        var allStyles = getManageableStyles(document);
        var newManagers = allStyles
            .filter(function (style) {
                return !styleManagers.has(style);
            })
            .map(function (style) {
                return createManager(style);
            });
        newManagers
            .map(function (manager) {
                return manager.details({secondRound: false});
            })
            .filter(function (detail) {
                return detail && detail.rules.length > 0;
            })
            .forEach(function (detail) {
                variablesStore.addRulesForMatching(detail.rules);
            });
        variablesStore.matchVariablesAndDependants();
        variablesStore.setOnRootVariableChange(function () {
            variablesStore.putRootVars(
                document.head.querySelector(".darkreader--root-vars"),
                filter
            );
        });
        variablesStore.putRootVars(
            document.head.querySelector(".darkreader--root-vars"),
            filter
        );
        styleManagers.forEach(function (manager) {
            return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        if (loadingStyles.size === 0) {
            cleanFallbackStyle();
        }
        newManagers.forEach(function (manager) {
            return manager.watch();
        });
        var inlineStyleElements = toArray(
            document.querySelectorAll(INLINE_STYLE_SELECTOR)
        );
        iterateShadowHosts(document.documentElement, function (host) {
            createShadowStaticStyleOverrides(host.shadowRoot);
            var elements = host.shadowRoot.querySelectorAll(
                INLINE_STYLE_SELECTOR
            );
            if (elements.length > 0) {
                push(inlineStyleElements, elements);
            }
        });
        inlineStyleElements.forEach(function (el) {
            return overrideInlineStyle(
                el,
                filter,
                ignoredInlineSelectors,
                ignoredImageAnalysisSelectors
            );
        });
        handleAdoptedStyleSheets(document);
    }
    var loadingStylesCounter = 0;
    var loadingStyles = new Set();
    function createManager(element) {
        var loadingStyleId = ++loadingStylesCounter;
        function loadingStart() {
            if (!isDOMReady() || !didDocumentShowUp) {
                loadingStyles.add(loadingStyleId);
                logInfo(
                    "Current amount of styles loading: ".concat(
                        loadingStyles.size
                    )
                );
                var fallbackStyle = document.querySelector(
                    ".darkreader--fallback"
                );
                if (!fallbackStyle.textContent) {
                    fallbackStyle.textContent = getModifiedFallbackStyle(
                        filter,
                        {strict: false}
                    );
                }
            }
        }
        function loadingEnd() {
            loadingStyles.delete(loadingStyleId);
            logInfo(
                "Removed loadingStyle "
                    .concat(loadingStyleId, ", now awaiting: ")
                    .concat(loadingStyles.size)
            );
            if (loadingStyles.size === 0 && isDOMReady()) {
                cleanFallbackStyle();
            }
        }
        function update() {
            var details = manager.details({secondRound: true});
            if (!details) {
                return;
            }
            variablesStore.addRulesForMatching(details.rules);
            variablesStore.matchVariablesAndDependants();
            manager.render(filter, ignoredImageAnalysisSelectors);
        }
        var manager = manageStyle(element, {
            update: update,
            loadingStart: loadingStart,
            loadingEnd: loadingEnd
        });
        styleManagers.set(element, manager);
        return manager;
    }
    function removeManager(element) {
        var manager = styleManagers.get(element);
        if (manager) {
            manager.destroy();
            styleManagers.delete(element);
        }
    }
    var throttledRenderAllStyles = throttle(function (callback) {
        styleManagers.forEach(function (manager) {
            return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        adoptedStyleManagers.forEach(function (manager) {
            return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        callback && callback();
    });
    var cancelRendering = function () {
        throttledRenderAllStyles.cancel();
    };
    function onDOMReady() {
        if (loadingStyles.size === 0) {
            cleanFallbackStyle();
            return;
        }
    }
    var documentVisibilityListener = null;
    var didDocumentShowUp = !document.hidden;
    function watchForDocumentVisibility(callback) {
        var alreadyWatching = Boolean(documentVisibilityListener);
        documentVisibilityListener = function () {
            if (!document.hidden) {
                stopWatchingForDocumentVisibility();
                callback();
                didDocumentShowUp = true;
            }
        };
        if (!alreadyWatching) {
            document.addEventListener(
                "visibilitychange",
                documentVisibilityListener
            );
        }
    }
    function stopWatchingForDocumentVisibility() {
        document.removeEventListener(
            "visibilitychange",
            documentVisibilityListener
        );
        documentVisibilityListener = null;
    }
    function createThemeAndWatchForUpdates() {
        createStaticStyleOverrides();
        function runDynamicStyle() {
            createDynamicStyleOverrides();
            watchForUpdates();
        }
        if (document.hidden && !filter.immediateModify) {
            watchForDocumentVisibility(runDynamicStyle);
        } else {
            runDynamicStyle();
        }
        changeMetaThemeColorWhenAvailable(filter);
    }
    function handleAdoptedStyleSheets(node) {
        try {
            if (Array.isArray(node.adoptedStyleSheets)) {
                if (node.adoptedStyleSheets.length > 0) {
                    var newManger = createAdoptedStyleSheetOverride(node);
                    adoptedStyleManagers.push(newManger);
                    newManger.render(filter, ignoredImageAnalysisSelectors);
                }
            }
        } catch (err) {}
    }
    function watchForUpdates() {
        var managedStyles = Array.from(styleManagers.keys());
        watchForStyleChanges(
            managedStyles,
            function (_a) {
                var created = _a.created,
                    updated = _a.updated,
                    removed = _a.removed,
                    moved = _a.moved;
                var stylesToRemove = removed;
                var stylesToManage = created
                    .concat(updated)
                    .concat(moved)
                    .filter(function (style) {
                        return !styleManagers.has(style);
                    });
                var stylesToRestore = moved.filter(function (style) {
                    return styleManagers.has(style);
                });
                stylesToRemove.forEach(function (style) {
                    return removeManager(style);
                });
                var newManagers = stylesToManage.map(function (style) {
                    return createManager(style);
                });
                newManagers
                    .map(function (manager) {
                        return manager.details({secondRound: false});
                    })
                    .filter(function (detail) {
                        return detail && detail.rules.length > 0;
                    })
                    .forEach(function (detail) {
                        variablesStore.addRulesForMatching(detail.rules);
                    });
                variablesStore.matchVariablesAndDependants();
                newManagers.forEach(function (manager) {
                    return manager.render(
                        filter,
                        ignoredImageAnalysisSelectors
                    );
                });
                newManagers.forEach(function (manager) {
                    return manager.watch();
                });
                stylesToRestore.forEach(function (style) {
                    return styleManagers.get(style).restore();
                });
            },
            function (shadowRoot) {
                createShadowStaticStyleOverrides(shadowRoot);
                handleAdoptedStyleSheets(shadowRoot);
            }
        );
        watchForInlineStyles(
            function (element) {
                overrideInlineStyle(
                    element,
                    filter,
                    ignoredInlineSelectors,
                    ignoredImageAnalysisSelectors
                );
                if (element === document.documentElement) {
                    var styleAttr = element.getAttribute("style") || "";
                    if (styleAttr.includes("--")) {
                        variablesStore.matchVariablesAndDependants();
                        variablesStore.putRootVars(
                            document.head.querySelector(
                                ".darkreader--root-vars"
                            ),
                            filter
                        );
                    }
                }
            },
            function (root) {
                createShadowStaticStyleOverrides(root);
                var inlineStyleElements = root.querySelectorAll(
                    INLINE_STYLE_SELECTOR
                );
                if (inlineStyleElements.length > 0) {
                    forEach(inlineStyleElements, function (el) {
                        return overrideInlineStyle(
                            el,
                            filter,
                            ignoredInlineSelectors,
                            ignoredImageAnalysisSelectors
                        );
                    });
                }
            }
        );
        addDOMReadyListener(onDOMReady);
    }
    function stopWatchingForUpdates() {
        styleManagers.forEach(function (manager) {
            return manager.pause();
        });
        stopStylePositionWatchers();
        stopWatchingForStyleChanges();
        stopWatchingForInlineStyles();
        removeDOMReadyListener(onDOMReady);
        cleanReadyStateCompleteListeners();
    }
    var metaObserver;
    function addMetaListener() {
        metaObserver = new MutationObserver(function () {
            if (document.querySelector('meta[name="darkreader-lock"]')) {
                metaObserver.disconnect();
                removeDynamicTheme();
            }
        });
        metaObserver.observe(document.head, {childList: true, subtree: true});
    }
    function createDarkReaderInstanceMarker() {
        var metaElement = document.createElement("meta");
        metaElement.name = "darkreader";
        metaElement.content = INSTANCE_ID;
        document.head.appendChild(metaElement);
    }
    function isAnotherDarkReaderInstanceActive() {
        if (document.querySelector('meta[name="darkreader-lock"]')) {
            return true;
        }
        var meta = document.querySelector('meta[name="darkreader"]');
        if (meta) {
            if (meta.content !== INSTANCE_ID) {
                return true;
            }
            return false;
        }
        createDarkReaderInstanceMarker();
        addMetaListener();
        return false;
    }
    function createOrUpdateDynamicTheme(
        filterConfig,
        dynamicThemeFixes,
        iframe
    ) {
        filter = filterConfig;
        fixes = dynamicThemeFixes;
        if (fixes) {
            ignoredImageAnalysisSelectors = Array.isArray(
                fixes.ignoreImageAnalysis
            )
                ? fixes.ignoreImageAnalysis
                : [];
            ignoredInlineSelectors = Array.isArray(fixes.ignoreInlineStyle)
                ? fixes.ignoreInlineStyle
                : [];
        } else {
            ignoredImageAnalysisSelectors = [];
            ignoredInlineSelectors = [];
        }
        if (filter.immediateModify) {
            setIsDOMReady(function () {
                return true;
            });
        }
        isIFrame$1 = iframe;
        if (document.head) {
            if (isAnotherDarkReaderInstanceActive()) {
                return;
            }
            document.documentElement.setAttribute(
                "data-darkreader-mode",
                "dynamic"
            );
            document.documentElement.setAttribute(
                "data-darkreader-scheme",
                filter.mode ? "dark" : "dimmed"
            );
            createThemeAndWatchForUpdates();
        } else {
            if (!isFirefox) {
                var fallbackStyle = createOrUpdateStyle("darkreader--fallback");
                document.documentElement.appendChild(fallbackStyle);
                fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
                    strict: true
                });
            }
            var headObserver_1 = new MutationObserver(function () {
                if (document.head) {
                    headObserver_1.disconnect();
                    if (isAnotherDarkReaderInstanceActive()) {
                        removeDynamicTheme();
                        return;
                    }
                    createThemeAndWatchForUpdates();
                }
            });
            headObserver_1.observe(document, {childList: true, subtree: true});
        }
    }
    function removeProxy() {
        document.dispatchEvent(new CustomEvent("__darkreader__cleanUp"));
        removeNode(document.head.querySelector(".darkreader--proxy"));
    }
    function removeDynamicTheme() {
        document.documentElement.removeAttribute("data-darkreader-mode");
        document.documentElement.removeAttribute("data-darkreader-scheme");
        cleanDynamicThemeCache();
        removeNode(document.querySelector(".darkreader--fallback"));
        if (document.head) {
            restoreMetaThemeColor();
            removeNode(document.head.querySelector(".darkreader--user-agent"));
            removeNode(document.head.querySelector(".darkreader--text"));
            removeNode(document.head.querySelector(".darkreader--invert"));
            removeNode(document.head.querySelector(".darkreader--inline"));
            removeNode(document.head.querySelector(".darkreader--override"));
            removeNode(document.head.querySelector(".darkreader--variables"));
            removeNode(document.head.querySelector(".darkreader--root-vars"));
            removeNode(document.head.querySelector('meta[name="darkreader"]'));
            removeProxy();
        }
        shadowRootsWithOverrides.forEach(function (root) {
            removeNode(root.querySelector(".darkreader--inline"));
            removeNode(root.querySelector(".darkreader--override"));
        });
        shadowRootsWithOverrides.clear();
        forEach(styleManagers.keys(), function (el) {
            return removeManager(el);
        });
        loadingStyles.clear();
        cleanLoadingLinks();
        forEach(document.querySelectorAll(".darkreader"), removeNode);
        adoptedStyleManagers.forEach(function (manager) {
            manager.destroy();
        });
        adoptedStyleManagers.splice(0);
        metaObserver && metaObserver.disconnect();
    }
    function cleanDynamicThemeCache() {
        variablesStore.clear();
        parsedURLCache.clear();
        stopWatchingForDocumentVisibility();
        cancelRendering();
        stopWatchingForUpdates();
        cleanModificationCache();
        clearColorCache();
    }

    var blobRegex = /url\(\"(blob\:.*?)\"\)/g;
    function replaceBlobs(text) {
        return __awaiter(this, void 0, void 0, function () {
            var promises, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        getMatches(blobRegex, text, 1).forEach(function (url) {
                            var promise = loadAsDataURL(url);
                            promises.push(promise);
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        data = _a.sent();
                        return [
                            2,
                            text.replace(blobRegex, function () {
                                return 'url("'.concat(data.shift(), '")');
                            })
                        ];
                }
            });
        });
    }
    var banner =
        '/*\n                        _______\n                       /       \\\n                      .==.    .==.\n                     ((  ))==((  ))\n                    / "=="    "=="\\\n                   /____|| || ||___\\\n       ________     ____    ________  ___    ___\n       |  ___  \\   /    \\   |  ___  \\ |  |  /  /\n       |  |  \\  \\ /  /\\  \\  |  |  \\  \\|  |_/  /\n       |  |   )  /  /__\\  \\ |  |__/  /|  ___  \\\n       |  |__/  /  ______  \\|  ____  \\|  |  \\  \\\n_______|_______/__/ ____ \\__\\__|___\\__\\__|___\\__\\____\n|  ___  \\ |  ____/ /    \\   |  ___  \\ |  ____|  ___  \\\n|  |  \\  \\|  |___ /  /\\  \\  |  |  \\  \\|  |___|  |  \\  \\\n|  |__/  /|  ____/  /__\\  \\ |  |   )  |  ____|  |__/  /\n|  ____  \\|  |__/  ______  \\|  |__/  /|  |___|  ____  \\\n|__|   \\__\\____/__/      \\__\\_______/ |______|__|   \\__\\\n                https://darkreader.org\n*/\n\n/*! Dark reader generated CSS | Licensed under MIT https://github.com/darkreader/darkreader/blob/main/LICENSE */\n';
    function collectCSS() {
        return __awaiter(this, void 0, void 0, function () {
            function addStaticCSS(selector, comment) {
                var staticStyle = document.querySelector(selector);
                if (staticStyle && staticStyle.textContent) {
                    css.push("/* ".concat(comment, " */"));
                    css.push(staticStyle.textContent);
                    css.push("");
                }
            }
            var css, modifiedCSS, formattedCSS, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        css = [banner];
                        addStaticCSS(".darkreader--fallback", "Fallback Style");
                        addStaticCSS(
                            ".darkreader--user-agent",
                            "User-Agent Style"
                        );
                        addStaticCSS(".darkreader--text", "Text Style");
                        addStaticCSS(".darkreader--invert", "Invert Style");
                        addStaticCSS(
                            ".darkreader--variables",
                            "Variables Style"
                        );
                        modifiedCSS = [];
                        document
                            .querySelectorAll(".darkreader--sync")
                            .forEach(function (element) {
                                forEach(
                                    element.sheet.cssRules,
                                    function (rule) {
                                        rule &&
                                            rule.cssText &&
                                            modifiedCSS.push(rule.cssText);
                                    }
                                );
                            });
                        if (!modifiedCSS.length) return [3, 2];
                        formattedCSS = formatCSS(modifiedCSS.join("\n"));
                        css.push("/* Modified CSS */");
                        _b = (_a = css).push;
                        return [4, replaceBlobs(formattedCSS)];
                    case 1:
                        _b.apply(_a, [_c.sent()]);
                        css.push("");
                        _c.label = 2;
                    case 2:
                        addStaticCSS(".darkreader--override", "Override Style");
                        return [2, css.join("\n")];
                }
            });
        });
    }

    var isDarkReaderEnabled = false;
    var isIFrame = (function () {
        try {
            return window.self !== window.top;
        } catch (err) {
            console.warn(err);
            return true;
        }
    })();
    function enable(themeOptions, fixes) {
        if (themeOptions === void 0) {
            themeOptions = {};
        }
        if (fixes === void 0) {
            fixes = null;
        }
        var theme = __assign(__assign({}, DEFAULT_THEME), themeOptions);
        if (theme.engine !== ThemeEngine.dynamicTheme) {
            throw new Error("Theme engine is not supported.");
        }
        createOrUpdateDynamicTheme(theme, fixes, isIFrame);
        isDarkReaderEnabled = true;
    }
    function isEnabled() {
        return isDarkReaderEnabled;
    }
    function disable() {
        removeDynamicTheme();
        isDarkReaderEnabled = false;
    }
    var darkScheme = matchMedia("(prefers-color-scheme: dark)");
    var store = {
        themeOptions: null,
        fixes: null
    };
    function handleColorScheme() {
        if (darkScheme.matches) {
            enable(store.themeOptions, store.fixes);
        } else {
            disable();
        }
    }
    function auto(themeOptions, fixes) {
        if (themeOptions === void 0) {
            themeOptions = {};
        }
        if (fixes === void 0) {
            fixes = null;
        }
        if (themeOptions) {
            store = {themeOptions: themeOptions, fixes: fixes};
            handleColorScheme();
            if (isMatchMediaChangeEventListenerSupported) {
                darkScheme.addEventListener("change", handleColorScheme);
            } else {
                darkScheme.addListener(handleColorScheme);
            }
        } else {
            if (isMatchMediaChangeEventListenerSupported) {
                darkScheme.removeEventListener("change", handleColorScheme);
            } else {
                darkScheme.removeListener(handleColorScheme);
            }
            disable();
        }
    }
    function exportGeneratedCSS() {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        return [4, collectCSS()];
                    case 1:
                        return [2, _a.sent()];
                }
            });
        });
    }
    var setFetchMethod = setFetchMethod$1;

    exports.auto = auto;
    exports.disable = disable;
    exports.enable = enable;
    exports.exportGeneratedCSS = exportGeneratedCSS;
    exports.isEnabled = isEnabled;
    exports.setFetchMethod = setFetchMethod;

    Object.defineProperty(exports, "__esModule", {value: true});
});


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value; // eslint-disable-line no-param-reassign
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/ecurve/lib/curve.js":
/*!******************************************!*\
  !*** ./node_modules/ecurve/lib/curve.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
var BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js")

var Point = __webpack_require__(/*! ./point */ "./node_modules/ecurve/lib/point.js")

function Curve (p, a, b, Gx, Gy, n, h) {
  this.p = p
  this.a = a
  this.b = b
  this.G = Point.fromAffine(this, Gx, Gy)
  this.n = n
  this.h = h

  this.infinity = new Point(this, null, null, BigInteger.ZERO)

  // result caching
  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)

  // determine size of p in bytes
  this.pLength = Math.floor((this.p.bitLength() + 7) / 8)
}

Curve.prototype.pointFromX = function (isOdd, x) {
  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)
  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves

  var y = beta
  if (beta.isEven() ^ !isOdd) {
    y = this.p.subtract(y) // -y % p
  }

  return Point.fromAffine(this, x, y)
}

Curve.prototype.isInfinity = function (Q) {
  if (Q === this.infinity) return true

  return Q.z.signum() === 0 && Q.y.signum() !== 0
}

Curve.prototype.isOnCurve = function (Q) {
  if (this.isInfinity(Q)) return true

  var x = Q.affineX
  var y = Q.affineY
  var a = this.a
  var b = this.b
  var p = this.p

  // Check that xQ and yQ are integers in the interval [0, p - 1]
  if (x.signum() < 0 || x.compareTo(p) >= 0) return false
  if (y.signum() < 0 || y.compareTo(p) >= 0) return false

  // and check that y^2 = x^3 + ax + b (mod p)
  var lhs = y.square().mod(p)
  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)
  return lhs.equals(rhs)
}

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
Curve.prototype.validate = function (Q) {
  // Check Q != O
  assert(!this.isInfinity(Q), 'Point is at infinity')
  assert(this.isOnCurve(Q), 'Point is not on the curve')

  // Check nQ = O (where Q is a scalar multiple of G)
  var nQ = Q.multiply(this.n)
  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')

  return true
}

module.exports = Curve


/***/ }),

/***/ "./node_modules/ecurve/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/ecurve/lib/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Point = __webpack_require__(/*! ./point */ "./node_modules/ecurve/lib/point.js")
var Curve = __webpack_require__(/*! ./curve */ "./node_modules/ecurve/lib/curve.js")

var getCurveByName = __webpack_require__(/*! ./names */ "./node_modules/ecurve/lib/names.js")

module.exports = {
  Curve: Curve,
  Point: Point,
  getCurveByName: getCurveByName
}


/***/ }),

/***/ "./node_modules/ecurve/lib/names.js":
/*!******************************************!*\
  !*** ./node_modules/ecurve/lib/names.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js")

var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/ecurve/lib/curves.json")
var Curve = __webpack_require__(/*! ./curve */ "./node_modules/ecurve/lib/curve.js")

function getCurveByName (name) {
  var curve = curves[name]
  if (!curve) return null

  var p = new BigInteger(curve.p, 16)
  var a = new BigInteger(curve.a, 16)
  var b = new BigInteger(curve.b, 16)
  var n = new BigInteger(curve.n, 16)
  var h = new BigInteger(curve.h, 16)
  var Gx = new BigInteger(curve.Gx, 16)
  var Gy = new BigInteger(curve.Gy, 16)

  return new Curve(p, a, b, Gx, Gy, n, h)
}

module.exports = getCurveByName


/***/ }),

/***/ "./node_modules/ecurve/lib/point.js":
/*!******************************************!*\
  !*** ./node_modules/ecurve/lib/point.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
var BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js")

var THREE = BigInteger.valueOf(3)

function Point (curve, x, y, z) {
  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')

  this.curve = curve
  this.x = x
  this.y = y
  this.z = z
  this._zInv = null

  this.compressed = true
}

Object.defineProperty(Point.prototype, 'zInv', {
  get: function () {
    if (this._zInv === null) {
      this._zInv = this.z.modInverse(this.curve.p)
    }

    return this._zInv
  }
})

Object.defineProperty(Point.prototype, 'affineX', {
  get: function () {
    return this.x.multiply(this.zInv).mod(this.curve.p)
  }
})

Object.defineProperty(Point.prototype, 'affineY', {
  get: function () {
    return this.y.multiply(this.zInv).mod(this.curve.p)
  }
})

Point.fromAffine = function (curve, x, y) {
  return new Point(curve, x, y, BigInteger.ONE)
}

Point.prototype.equals = function (other) {
  if (other === this) return true
  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)
  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)

  // u = Y2 * Z1 - Y1 * Z2
  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)

  if (u.signum() !== 0) return false

  // v = X2 * Z1 - X1 * Z2
  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)

  return v.signum() === 0
}

Point.prototype.negate = function () {
  var y = this.curve.p.subtract(this.y)

  return new Point(this.curve, this.x, y, this.z)
}

Point.prototype.add = function (b) {
  if (this.curve.isInfinity(this)) return b
  if (this.curve.isInfinity(b)) return this

  var x1 = this.x
  var y1 = this.y
  var x2 = b.x
  var y2 = b.y

  // u = Y2 * Z1 - Y1 * Z2
  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)
  // v = X2 * Z1 - X1 * Z2
  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)

  if (v.signum() === 0) {
    if (u.signum() === 0) {
      return this.twice() // this == b, so double
    }

    return this.curve.infinity // this = -b, so infinity
  }

  var v2 = v.square()
  var v3 = v2.multiply(v)
  var x1v2 = x1.multiply(v2)
  var zu2 = u.square().multiply(this.z)

  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)
  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)
  // z3 = v^3 * z1 * z2
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

Point.prototype.twice = function () {
  if (this.curve.isInfinity(this)) return this
  if (this.y.signum() === 0) return this.curve.infinity

  var x1 = this.x
  var y1 = this.y

  var y1z1 = y1.multiply(this.z).mod(this.curve.p)
  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)
  var a = this.curve.a

  // w = 3 * x1^2 + a * z1^2
  var w = x1.square().multiply(THREE)

  if (a.signum() !== 0) {
    w = w.add(this.z.square().multiply(a))
  }

  w = w.mod(this.curve.p)
  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)
  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)
  // z3 = 8 * (y1 * z1)^3
  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
Point.prototype.multiply = function (k) {
  if (this.curve.isInfinity(this)) return this
  if (k.signum() === 0) return this.curve.infinity

  var e = k
  var h = e.multiply(THREE)

  var neg = this.negate()
  var R = this

  for (var i = h.bitLength() - 2; i > 0; --i) {
    var hBit = h.testBit(i)
    var eBit = e.testBit(i)

    R = R.twice()

    if (hBit !== eBit) {
      R = R.add(hBit ? this : neg)
    }
  }

  return R
}

// Compute this*j + x*k (simultaneous multiplication)
Point.prototype.multiplyTwo = function (j, x, k) {
  var i = Math.max(j.bitLength(), k.bitLength()) - 1
  var R = this.curve.infinity
  var both = this.add(x)

  while (i >= 0) {
    var jBit = j.testBit(i)
    var kBit = k.testBit(i)

    R = R.twice()

    if (jBit) {
      if (kBit) {
        R = R.add(both)
      } else {
        R = R.add(this)
      }
    } else if (kBit) {
      R = R.add(x)
    }
    --i
  }

  return R
}

Point.prototype.getEncoded = function (compressed) {
  if (compressed == null) compressed = this.compressed
  if (this.curve.isInfinity(this)) return Buffer.alloc(1, 0) // Infinity point encoded is simply '00'

  var x = this.affineX
  var y = this.affineY
  var byteLength = this.curve.pLength
  var buffer

  // 0x02/0x03 | X
  if (compressed) {
    buffer = Buffer.allocUnsafe(1 + byteLength)
    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)

  // 0x04 | X | Y
  } else {
    buffer = Buffer.allocUnsafe(1 + byteLength + byteLength)
    buffer.writeUInt8(0x04, 0)

    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
  }

  x.toBuffer(byteLength).copy(buffer, 1)

  return buffer
}

Point.decodeFrom = function (curve, buffer) {
  var type = buffer.readUInt8(0)
  var compressed = (type !== 4)

  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)
  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))

  var Q
  if (compressed) {
    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')
    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')

    var isOdd = (type === 0x03)
    Q = curve.pointFromX(isOdd, x)
  } else {
    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')

    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))
    Q = Point.fromAffine(curve, x, y)
  }

  Q.compressed = compressed
  return Q
}

Point.prototype.toString = function () {
  if (this.curve.isInfinity(this)) return '(INFINITY)'

  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'
}

module.exports = Point


/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");

module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ "./node_modules/js-sha256/src/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/js-sha256/src/sha256.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = __webpack_require__.g;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/schnorr-adaptor-points/src/adaptor.js":
/*!************************************************************!*\
  !*** ./node_modules/schnorr-adaptor-points/src/adaptor.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');
const { math, convert } = __webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js");
const check = __webpack_require__(/*! ./check */ "./node_modules/schnorr-adaptor-points/src/check.js")

const concat = Buffer.concat;
const G = curve.G;
const p = curve.p;
const n = curve.n;
const zero = BigInteger.ZERO;

function createAdaptorPoint(pubKeys, messages, rValues) {
  // https://github.com/discreetlogcontracts/dlcspecs/blob/c4fb12d95a4255eabb873611437d05b740bbeccc/CETCompression.md#adaptor-points-with-multiple-signatures
  // s * G = (s1 + s2 + ... + sn) * G = (R1 + R2 + ... + Rn) + H(R1, m1) * P + ... + H(Rn, mn) * P
  check.checkCreateAdaptorPointParams(pubKeys, messages, rValues)

  let sG = null;
  for (let i = 0; i < pubKeys.length; i++) {
    const P = math.liftX(pubKeys[i]);
    const Px = convert.intToBuffer(P.affineX);
    const r = convert.bufferToInt(rValues[i]);
    const e = math.getE(convert.intToBuffer(r), Px, messages[i]);
    const R = math.liftX(rValues[i]);

    if (i === 0) {
      sG = R;
    } else {
      sG = sG.add(R);
    }
    sG = sG.add(P.multiply(e));
  }

  return convert.intToBuffer(sG.affineX)
}

function createAdaptorSecret(privKeys, messages, kValues) {
  check.checkCreateAdaptorSecretParams(privKeys, messages, kValues)

  let s = null
  for (let i = 0; i < kValues.length; i++) {
    const privateKey = privKeys[i]
    const P = G.multiply(privateKey);
    const Px = convert.intToBuffer(P.affineX);

    const d = math.getEvenKey(P, privateKey);

    const message = messages[i]
    const kPrime = kValues[i]

    const R = G.multiply(kPrime);
    const k = math.getEvenKey(R, kPrime);
    const Rx = convert.intToBuffer(R.affineX);
    const e = math.getE(Rx, Px, message);

    if (s === null) {
      s = k
    } else {
      s = s.add(k)
    }
    s = s.add(e.multiply(d))
  }

  return convert.intToBuffer(s.mod(n))
}

function combineSecrets(secrets) {
  check.checkSecretArr(secrets)

  let s = convert.bufferToInt(secrets[0])
  for (let i = 1; i < secrets.length; i++) {
    s = s.add(convert.bufferToInt(secrets[i])).mod(n)
  }
  return convert.intToBuffer(s)
}

module.exports = {
  createAdaptorPoint,
  createAdaptorSecret,
  combineSecrets,
};


/***/ }),

/***/ "./node_modules/schnorr-adaptor-points/src/check.js":
/*!**********************************************************!*\
  !*** ./node_modules/schnorr-adaptor-points/src/check.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { check } = __webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js")


const BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
const Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
const ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
const curve = ecurve.getCurveByName('secp256k1');

const one = BigInteger.ONE;
const n = curve.n;
const p = curve.p;

function checkBuffer(name, buf, len, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!Buffer.isBuffer(buf)) {
    throw new Error(name + idxStr + ' must be a Buffer');
  }
  if (buf.length !== len) {
    throw new Error(name + idxStr + ' must be ' + len + ' bytes long');
  }
}

function checkSecretArr(secrets) {
  check.checkArray('secrets', secrets);
  for (let i = 0; i < secrets.length; i++) {
    checkBuffer('secrets', secrets[i], 32, i);
  }
}

function checkMessageArr(messages) {
  check.checkArray('messages', messages);
  for (let i = 0; i < messages.length; i++) {
    checkBuffer('message', messages[i], 32, i);
  }
}

function checkPrivateKey(privateKey, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!BigInteger.isBigInteger(privateKey)) {
    throw new Error('privateKey' + idxStr + ' must be a BigInteger');
  }
  check.checkRange('privateKey', privateKey);
}

function checkPrivateKeyArr(privateKeys) {
  check.checkArray('privateKeys', privateKeys)
  for (let i = 0; i < privateKeys.length; i++) {
    checkPrivateKey(privateKeys[i])
  }
}

function checkBigInteger(value, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!BigInteger.isBigInteger(value)) {
    throw new Error(idxStr + ' must be a BigInteger');
  }
}

function checkBigIntegerArr(values, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  check.checkArray(idx, values)
  for (let i = 0; i < values.length; i++) {
    checkBigInteger(values[i])
  }
}

function checkKValue(privateKey, idx) {
  const idxStr = (idx !== undefined ? '[' + idx + ']' : '');
  if (!BigInteger.isBigInteger(privateKey)) {
    throw new Error('kValue' + idxStr + ' must be a BigInteger');
  }
  check.checkRange('kValue', privateKey);
}

function checkKValueArr(kValues) {
  check.checkArray('KValues', kValues)
  for (let i = 0; i < kValues.length; i++) {
    checkKValue(kValues[i])
  }
}

function checkCreateAdaptorPointParams(pubKeys, messages, rValues) {
  check.checkPubKeyArr(pubKeys)
  checkMessageArr(messages)
  check.checkNonceArr(rValues)

  if (pubKeys.length !== messages.length || messages.length !== rValues.length) {
    throw new Error('all parameters must be an array with the same length')
  }
}

function checkCreateAdaptorSecretParams(privKeys, messages, kValues) {
  checkPrivateKeyArr(privKeys);
  checkMessageArr(messages);
  checkKValueArr(kValues);

  if (privKeys.length !== messages.length || messages.length !== kValues.length) {
    throw new Error('all parameters must be an array with the same length')
  }
}

module.exports = {
  checkCreateAdaptorPointParams,
  checkCreateAdaptorSecretParams,
  checkSecretArr
};


/***/ }),

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var dr_1 = __webpack_require__(/*! ./util/dr */ "./util/dr.ts");
var templates_1 = __webpack_require__(/*! ./util/templates */ "./util/templates.ts");
var schnorr_1 = __webpack_require__(/*! ./util/schnorr */ "./util/schnorr.ts");
var tx_1 = __webpack_require__(/*! ./util/tx */ "./util/tx.ts");
(0, dr_1.darkify)(window.document);
if (window.marloweWindow != undefined && !window.isMarlowe) {
    console.log('init api...');
    window.marloweWindow().then(function (mw) {
        window.api = {
            state: {
                isMarloweContractGenerated: false,
                isMarloweContractSampled: false,
                samplingInProgress: false
            },
            schnorrApi: schnorr_1.schnorrApi,
            txApi: tx_1.txApi,
            injectMarloweContract: function (c, updateState) {
                if (updateState === void 0) { updateState = true; }
                return __awaiter(void 0, void 0, void 0, function () {
                    var marloweHome, dontSave, raw, goToEditor, menuBar, meta, staticAnalysis, toInject, _a, goToBlocks, cancel;
                    var _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (updateState) {
                                    window.api.state.contract = c;
                                }
                                marloweHome = mw.document.querySelector(".h-10");
                                marloweHome === null || marloweHome === void 0 ? void 0 : marloweHome.click();
                                dontSave = mw.document.querySelector(".mr-medium");
                                dontSave === null || dontSave === void 0 ? void 0 : dontSave.click();
                                if (!(window.api.state.template == undefined)) return [3 /*break*/, 3];
                                return [4 /*yield*/, fetch(window.location.origin + "/marlowe-wolfram-webdoc/contracts/".concat(c.template, ".marlowe"))];
                            case 1: return [4 /*yield*/, (_c.sent()).text()];
                            case 2:
                                raw = _c.sent();
                                window.api.state.template = raw;
                                return [3 /*break*/, 4];
                            case 3:
                                raw = window.api.state.template;
                                _c.label = 4;
                            case 4:
                                goToEditor = mw.document.querySelector('.mr-4');
                                goToEditor === null || goToEditor === void 0 ? void 0 : goToEditor.click();
                                menuBar = mw.document.querySelector(".menu-bar");
                                menuBar === null || menuBar === void 0 ? void 0 : menuBar.setAttribute('style', "display: none");
                                meta = mw.document.querySelector(".text-secondary");
                                meta === null || meta === void 0 ? void 0 : meta.setAttribute('style', "display: none");
                                staticAnalysis = mw.document.querySelector(".text-gray-darkest");
                                staticAnalysis === null || staticAnalysis === void 0 ? void 0 : staticAnalysis.setAttribute('style', "display: none");
                                toInject = (0, templates_1.processTemplate)(c.template, c.terms, raw);
                                _c.label = 5;
                            case 5:
                                _c.trys.push([5, 7, , 8]);
                                return [4 /*yield*/, mw.monaco.editor.getModels()[mw.monaco.editor.getModels().length - 2].dispose()];
                            case 6:
                                _c.sent();
                                return [3 /*break*/, 8];
                            case 7:
                                _a = _c.sent();
                                return [3 /*break*/, 8];
                            case 8: return [4 /*yield*/, mw.monaco.editor.getModels()[mw.monaco.editor.getModels().length - 1].setValue(toInject)];
                            case 9:
                                _c.sent();
                                goToBlocks = (_b = mw.document.querySelector('.group')) === null || _b === void 0 ? void 0 : _b.querySelector('.btn');
                                goToBlocks === null || goToBlocks === void 0 ? void 0 : goToBlocks.click();
                                cancel = mw.document.querySelector(".uppercase");
                                cancel === null || cancel === void 0 ? void 0 : cancel.click();
                                window.api.state.isMarloweContractGenerated = true;
                                window.dispatchEvent(new Event("state"));
                                return [2 /*return*/];
                        }
                    });
                });
            },
            sampleMarloweContract: function () { return __awaiter(void 0, void 0, void 0, function () {
                var step, i, c, sendToSimulator, startSimulation, aliceDeposit, bobDeposit, skipToExercise, confirm_1, log, extractBobPayoffOpt, extractAlicePayoffOpt, bobPayoff, alicePayoff, endSimulation;
                var _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            window.dispatchEvent(new Event("sampling-started"));
                            window.api.state.samplingInProgress = true;
                            window.api.state.sample = [];
                            step = 100;
                            i = window.api.state.contract.terms.minValue;
                            _c.label = 1;
                        case 1:
                            if (!(i <= window.api.state.contract.terms.maxValue)) return [3 /*break*/, 7];
                            c = __assign(__assign({}, window.api.state.contract), { terms: __assign({}, window.api.state.contract.terms) });
                            window.dispatchEvent(new Event("sampling-step"));
                            c.terms.minValue = i;
                            c.terms.maxValue = i;
                            window.api.state.samplingProgress = (i - window.api.state.contract.terms.minValue) / (window.api.state.contract.terms.maxValue - window.api.state.contract.terms.minValue);
                            return [4 /*yield*/, window.api.injectMarloweContract(c, false)];
                        case 2:
                            _c.sent();
                            console.log(i);
                            sendToSimulator = mw.document.querySelectorAll('button')[1];
                            _c.label = 3;
                        case 3:
                            if (!sendToSimulator['disabled']) return [3 /*break*/, 5];
                            console.log("AWAIT");
                            return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, 100); })];
                        case 4:
                            _c.sent();
                            return [3 /*break*/, 3];
                        case 5:
                            //await new Promise(r => setTimeout(r, 3000));
                            sendToSimulator.click();
                            startSimulation = mw.document.querySelectorAll('button')[2];
                            startSimulation.click();
                            aliceDeposit = mw.document.querySelector('.plus-btn');
                            aliceDeposit === null || aliceDeposit === void 0 ? void 0 : aliceDeposit.click();
                            bobDeposit = mw.document.querySelector('.plus-btn');
                            bobDeposit === null || bobDeposit === void 0 ? void 0 : bobDeposit.click();
                            skipToExercise = mw.document.querySelectorAll('.plus-btn')[2];
                            skipToExercise === null || skipToExercise === void 0 ? void 0 : skipToExercise.click();
                            confirm_1 = mw.document.querySelector('.plus-btn');
                            confirm_1 === null || confirm_1 === void 0 ? void 0 : confirm_1.click();
                            log = mw.document.querySelector('.grid-cols-description-location');
                            extractBobPayoffOpt = (_a = /The contract pays ₳ (\d+) from account of Bob to Bob wallet/.exec(log.innerText)) === null || _a === void 0 ? void 0 : _a[1];
                            extractAlicePayoffOpt = (_b = /The contract pays ₳ (\d+) from account of Alice to Alice wallet/.exec(log.innerText)) === null || _b === void 0 ? void 0 : _b[1];
                            bobPayoff = extractBobPayoffOpt == null || Number.isNaN(parseInt(extractBobPayoffOpt)) ? 0 : parseInt(extractBobPayoffOpt);
                            alicePayoff = extractAlicePayoffOpt == null || Number.isNaN(parseInt(extractAlicePayoffOpt)) ? 0 : parseInt(extractAlicePayoffOpt);
                            //console.log(window.api.state.sample)
                            window.api.state.sample.push({ oracleValue: i, alicePayout: alicePayoff, bobPayout: bobPayoff });
                            endSimulation = mw.document.querySelectorAll('button')[0];
                            endSimulation.click();
                            _c.label = 6;
                        case 6:
                            i += step;
                            return [3 /*break*/, 1];
                        case 7:
                            console.log(window.api.state.sample);
                            window.api.state.samplingInProgress = false;
                            window.api.state.isMarloweContractSampled = true;
                            window.dispatchEvent(new Event("state"));
                            window.dispatchEvent(new Event("sampled"));
                            window.api.injectMarloweContract(window.api.state.contract, false);
                            return [2 /*return*/];
                    }
                });
            }); },
            plotMarloweContractAlpha: function () {
                var query = encodeURIComponent('plot ' + window.api.state.sample.map(function (row) { return "(".concat(row.oracleValue, ", ").concat(row.alicePayout, ")"); }));
                var url = 'https://www.wolframalpha.com/input?i=' + query;
                window.open(url);
            },
            downloadSampledContractAsCsv: function () {
                var csvContent = "data:text/csv;charset=utf-8,\noracle,alice,bob\n" + window.api.state.sample.map(function (row) { return "".concat(row.oracleValue, ", ").concat(row.alicePayout, ", ").concat(row.bobPayout); }).join("\n");
                var encodedUri = encodeURI(csvContent);
                window.open(encodedUri);
            },
            generateWolfNbUri: function () { return __awaiter(void 0, void 0, void 0, function () {
                var url, template, rowbox, points, nb, nbContent;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = window.location.origin + "/marlowe-wolfram-webdoc/notebooks/wolfram-plot.nb";
                            return [4 /*yield*/, fetch(url)];
                        case 1: return [4 /*yield*/, (_a.sent()).text()];
                        case 2:
                            template = (_a.sent());
                            rowbox = function (row) { return "RowBox[{\"{\",RowBox[{\"".concat(row.oracleValue, "\",\",\",\" \",\"").concat(row.alicePayout, "\"}],\"}\"}]"); };
                            points = window.api.state.sample.map(rowbox).join(",\",\",\" \",");
                            nb = template.replace("RowBox[{\"{\",RowBox[{\"1\",\",\",\" \",\"1\"}],\"}\"}],\",\",\" \",RowBox[{\"{\",RowBox[{\"2\",\",\",\" \",\"2\"}],\"}\"}]", points);
                            nbContent = "data:text/plain;base64," + btoa(nb);
                            return [2 /*return*/, encodeURI(nbContent)];
                    }
                });
            }); },
            downloadWolfNb: function () { return __awaiter(void 0, void 0, void 0, function () {
                var link, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            link = document.createElement('a');
                            link.download = 'wolfram-plot.nb';
                            _a = link;
                            return [4 /*yield*/, window.api.generateWolfNbUri()];
                        case 1:
                            _a.href = _b.sent();
                            link.click();
                            return [2 /*return*/];
                    }
                });
            }); },
            embedWolfPlot: function (container) { return __awaiter(void 0, void 0, void 0, function () {
                var query, url1, proxyUrl, result, url2, img;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            container.innerHTML = '<span id="img-loading-placeholder"></span>';
                            query = encodeURIComponent('plot ' + window.api.state.sample.map(function (row) { return "(".concat(row.oracleValue, ", ").concat(row.alicePayout, ")"); }).join(","));
                            url1 = "https://api.wolframalpha.com/v2/query?input=".concat(query, "&appid=").concat(window.wfAppId, "&output=JSON");
                            proxyUrl = window.corsProxyPrefix + encodeURIComponent(url1);
                            return [4 /*yield*/, fetch(proxyUrl)];
                        case 1: return [4 /*yield*/, (_a.sent()).json()];
                        case 2:
                            result = (_a.sent());
                            url2 = result.queryresult.pods[1].subpods[0].img.src;
                            console.log(url2);
                            img = document.createElement('img');
                            img.src = url2;
                            img.setAttribute("width", "500");
                            container.innerHTML = '';
                            container.appendChild(img);
                            return [2 /*return*/];
                    }
                });
            }); }
        };
        var poll = function () { return __awaiter(void 0, void 0, void 0, function () {
            var original, url, response, raw, rx, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        original = "https://api.wolframalpha.com/v1/result?appid=".concat(window.wfAppId, "&i=1%20btc%20to%20usd%20number");
                        url = window.corsProxyPrefix + encodeURIComponent(original);
                        response = fetch(url);
                        return [4 /*yield*/, response];
                    case 1: return [4 /*yield*/, (_a.sent()).text()];
                    case 2:
                        raw = (_a.sent());
                        rx = /\d+/g;
                        res = rx.exec(raw);
                        if (res != null)
                            window.tick = parseInt(res[0]);
                        window.dispatchEvent(new Event("tick"));
                        return [2 /*return*/];
                }
            });
        }); };
        poll();
        setInterval(poll, 10000);
        setInterval(function () { return window.dispatchEvent(new Event("clock")); }, 500);
    });
}


/***/ }),

/***/ "./util/dr.ts":
/*!********************!*\
  !*** ./util/dr.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.darkify = void 0;
var darkreader_1 = __webpack_require__(/*! darkreader */ "./node_modules/darkreader/darkreader.js");
function addStyle(doc, styleString) {
    var style = doc.createElement('style');
    style.textContent = styleString;
    doc.head.append(style);
}
var darkify = function (doc) { return __awaiter(void 0, void 0, void 0, function () {
    var CSS;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                (0, darkreader_1.setFetchMethod)(window.fetch);
                (0, darkreader_1.enable)({
                    brightness: 100,
                    contrast: 90,
                    sepia: 10,
                });
                return [4 /*yield*/, (0, darkreader_1.exportGeneratedCSS)()];
            case 1:
                CSS = _a.sent();
                addStyle(doc, CSS);
                return [2 /*return*/];
        }
    });
}); };
exports.darkify = darkify;
console.log(window.location.href);


/***/ }),

/***/ "./util/mu-sig.ts":
/*!************************!*\
  !*** ./util/mu-sig.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sign = void 0;
var sign = function (pk1, pk2, secret1, secret2, msg) {
    var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js");
    var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
    var BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
    var convert = (__webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js").convert);
    var muSig = (__webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js").muSig);
    var schnorr = __webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js");
    var math = (__webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js").math);
    var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
    var ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
    var curve = ecurve.getCurveByName('secp256k1');
    var randomBuffer = function (len) { return Buffer.from(randomBytes(len)); };
    var publicData = {
        pubKeys: [
            Buffer.from(pk1, 'hex'),
            Buffer.from(pk2, 'hex')
        ],
        message: msg,
        pubKeyHash: null,
        pubKeyCombined: null,
        pubKeyParity: null,
        commitments: [],
        nonces: [],
        nonceCombined: null,
        partialSignatures: [],
        signature: null,
    };
    // data only known by the individual party, these values are never shared
    // between the signers!
    var signerPrivateData = [
        // signer 1
        {
            privateKey: BigInteger.fromHex(secret1),
            session: null,
        },
        // signer 2
        {
            privateKey: BigInteger.fromHex(secret2),
            session: null,
        },
    ];
    // -----------------------------------------------------------------------
    // Step 1: Combine the public keys
    // The public keys P_i are combined into the combined public key P.
    // This can be done by every signer individually or by the initializing
    // party and then be distributed to every participant.
    // -----------------------------------------------------------------------
    publicData.pubKeyHash = muSig.computeEll(publicData.pubKeys);
    var pkCombined = muSig.pubKeyCombine(publicData.pubKeys, publicData.pubKeyHash);
    publicData.pubKeyCombined = convert.intToBuffer(pkCombined.affineX);
    publicData.pubKeyParity = math.isEven(pkCombined);
    // -----------------------------------------------------------------------
    // Step 2: Create the private signing session
    // Each signing party does this in private. The session ID *must* be
    // unique for every call to sessionInitialize, otherwise it's trivial for
    // an attacker to extract the secret key!
    // -----------------------------------------------------------------------
    signerPrivateData.forEach(function (data, idx) {
        var sessionId = randomBuffer(32); // must never be reused between sessions!
        data.session = muSig.sessionInitialize(sessionId, data.privateKey, publicData.message, publicData.pubKeyCombined, publicData.pubKeyParity, publicData.pubKeyHash, idx);
    });
    var signerSession = signerPrivateData[0].session;
    // -----------------------------------------------------------------------
    // Step 3: Exchange commitments (communication round 1)
    // The signers now exchange the commitments H(R_i). This is simulated here
    // by copying the values from the private data to public data array.
    // -----------------------------------------------------------------------
    for (var i = 0; i < publicData.pubKeys.length; i++) {
        publicData.commitments[i] = signerPrivateData[i].session.commitment;
    }
    // -----------------------------------------------------------------------
    // Step 4: Get nonces (communication round 2)
    // Now that everybody has commited to the session, the nonces (R_i) can be
    // exchanged. Again, this is simulated by copying.
    // -----------------------------------------------------------------------
    for (var i = 0; i < publicData.pubKeys.length; i++) {
        publicData.nonces[i] = signerPrivateData[i].session.nonce;
    }
    // -----------------------------------------------------------------------
    // Step 5: Combine nonces
    // The nonces can now be combined into R. Each participant should do this
    // and keep track of whether the nonce was negated or not. This is needed
    // for the later steps.
    // -----------------------------------------------------------------------
    publicData.nonceCombined = muSig.sessionNonceCombine(signerSession, publicData.nonces);
    signerPrivateData.forEach(function (data) { return (data.session.combinedNonceParity = signerSession.combinedNonceParity); });
    // -----------------------------------------------------------------------
    // Step 6: Generate partial signatures
    // Every participant can now create their partial signature s_i over the
    // given message.
    // -----------------------------------------------------------------------
    signerPrivateData.forEach(function (data) {
        data.session.partialSignature = muSig.partialSign(data.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);
    });
    // -----------------------------------------------------------------------
    // Step 7: Exchange partial signatures (communication round 3)
    // The partial signature of each signer is exchanged with the other
    // participants. Simulated here by copying.
    // -----------------------------------------------------------------------
    for (var i = 0; i < publicData.pubKeys.length; i++) {
        publicData.partialSignatures[i] = signerPrivateData[i].session.partialSignature;
    }
    // -----------------------------------------------------------------------
    // Step 8: Verify individual partial signatures
    // Every participant should verify the partial signatures received by the
    // other participants.
    // -----------------------------------------------------------------------
    for (var i = 0; i < publicData.pubKeys.length; i++) {
        muSig.partialSigVerify(signerSession, publicData.partialSignatures[i], publicData.nonceCombined, i, publicData.pubKeys[i], publicData.nonces[i]);
    }
    // -----------------------------------------------------------------------
    // Step 9: Combine partial signatures
    // Finally, the partial signatures can be combined into the full signature
    // (s, R) that can be verified against combined public key P.
    // -----------------------------------------------------------------------
    publicData.signature = muSig.partialSigCombine(publicData.nonceCombined, publicData.partialSignatures);
    // -----------------------------------------------------------------------
    // Step 10: Verify signature
    // The resulting signature can now be verified as a normal Schnorr
    // signature (s, R) over the message m and public key P.
    // -----------------------------------------------------------------------
    schnorr.verify(publicData.pubKeyCombined, publicData.message, publicData.signature);
    return publicData.signature.toString("hex");
};
exports.sign = sign;


/***/ }),

/***/ "./util/schnorr.ts":
/*!*************************!*\
  !*** ./util/schnorr.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.schnorrApi = void 0;
var adaptor = __webpack_require__(/*! schnorr-adaptor-points/src/adaptor.js */ "./node_modules/schnorr-adaptor-points/src/adaptor.js");
var BigInteger = __webpack_require__(/*! bigi */ "./node_modules/bigi/lib/index.js");
var _a = __webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js"), math = _a.math, convert = _a.convert;
var ecurve = __webpack_require__(/*! ecurve */ "./node_modules/ecurve/lib/index.js");
var curve = ecurve.getCurveByName('secp256k1');
var concat = Buffer.concat;
var G = curve.G;
var n = curve.n;
var schnorrApi = function () {
    return {
        adaptorPublic: function (oraclePbHex, msgHex, rHex) {
            var pubInt = convert.bufferToInt(adaptor.createAdaptorPoint([Buffer.from(oraclePbHex, 'hex')], [Buffer.from(msgHex, 'hex')], [Buffer.from(rHex, 'hex')]));
            return pubInt.toString(16);
        },
        genNonce: function (oraclePrivHex, questionHex, auxHex) {
            var aux = Buffer.from(auxHex, 'hex');
            var privKey = BigInteger.fromHex(oraclePrivHex);
            var P = G.multiply(privKey);
            var Px = convert.intToBuffer(P.affineX);
            var m = Buffer.from(questionHex, 'hex');
            var d = math.getEvenKey(P, privKey);
            var t = convert.intToBuffer(d.xor(convert.bufferToInt(math.taggedHash('BIP0340/aux', aux))));
            var rand = math.taggedHash('BIP0340/nonce', concat([t, Px, m]));
            var kPrime = convert.bufferToInt(rand).mod(n);
            return kPrime.toString(16);
        },
        signatureSValue: function (privHex, nonce, msgHex) {
            var privKey = BigInteger.fromHex(privHex);
            var kPrime = BigInteger.fromHex(nonce);
            var m = Buffer.from(msgHex, 'hex');
            var signature = adaptor.createAdaptorSecret([privKey], [m], [kPrime]);
            return signature.toString('hex');
        }
    };
};
exports.schnorrApi = schnorrApi;


/***/ }),

/***/ "./util/templates.ts":
/*!***************************!*\
  !*** ./util/templates.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processTemplate = void 0;
var processTemplate = function (name, subst, template) {
    switch (name) {
        case 'eurocall': return template
            .replace("$notional", subst.notional.toString())
            .replace("$margin", subst.margin.toString())
            .replace("$strike", subst.strike.toString())
            .replace("$premium", subst.premium.toString())
            .replace("$minValue", subst.minValue.toString())
            .replace("$maxValue", subst.maxValue.toString());
    }
    return template;
};
exports.processTemplate = processTemplate;


/***/ }),

/***/ "./util/tx.ts":
/*!********************!*\
  !*** ./util/tx.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.txApi = void 0;
var bitcoin = __webpack_require__(/*! bitcoinjs-lib */ "./node_modules/bitcoinjs-lib/src/index.js");
var ecc = __webpack_require__(/*! tiny-secp256k1 */ "./node_modules/tiny-secp256k1/lib/index.js");
ecc.then(function (ec) { return bitcoin.initEccLib(ec); });
var net = bitcoin.networks.testnet;
var p2pktr = function (pk) { return bitcoin.payments.p2tr({
    pubkey: Buffer.from(pk, "hex"),
    network: net
}); };
var schnorr = __webpack_require__(/*! bip-schnorr */ "./node_modules/bip-schnorr/src/index.js");
var muSig = schnorr.muSig;
var convert = schnorr.convert;
var multisig = __webpack_require__(/*! ./mu-sig */ "./util/mu-sig.ts");
function schnorrSignerSingle(pk, secret) {
    return {
        publicKey: Buffer.from(pk, "hex"),
        network: net,
        sign: function (hash, lowR) {
            return null;
        },
        signSchnorr: function (hash) {
            return schnorr.sign(hash, secret);
        },
        getPublicKey: function () {
            return Buffer.from(pk, "hex");
        }
    };
}
function schnorrSignerMulti(pk1, pk2, secret1, secret2) {
    var pkCombined = muSig.pubKeyCombine([Buffer.from(pk1, "hex"), Buffer.from(pk2, "hex")]);
    var pubKeyCombined = convert.intToBuffer(pkCombined.affineX);
    return {
        publicKey: pubKeyCombined,
        network: net,
        sign: function (hash, lowR) {
            return null;
        },
        signSchnorr: function (hash) {
            var muSignature = multisig.sign(pk1, pk2, secret1.toString("hex"), secret2.toString("hex"), hash.toString("hex"));
            return muSignature;
        },
        getPublicKey: function () {
            return pubKeyCombined;
        }
    };
}
var txApi = function () {
    return {
        genOpeningTx: function (aliceIn, bobIn, alicePk, bobPk, aliceAmount, bobAmount) {
            var psbt = new bitcoin.Psbt({ network: net });
            var aliceP2TR = p2pktr(alicePk);
            var bobP2TR = p2pktr(alicePk);
            psbt.addInput({
                hash: aliceIn.txid,
                index: aliceIn.vout,
                witnessUtxo: { value: aliceAmount, script: aliceP2TR.output },
                tapInternalKey: Buffer.from(alicePk, "hex")
            });
            psbt.addInput({
                hash: bobIn.txid,
                index: bobIn.vout,
                witnessUtxo: { value: bobAmount, script: bobP2TR.output },
                tapInternalKey: Buffer.from(bobPk, "hex")
            });
            psbt.addOutput({
                address: "mohjSavDdQYHRYXcS3uS6ttaHP8amyvX78",
                value: aliceAmount + bobAmount
            });
            psbt.signInput(0, schnorrSignerSingle(alicePk, aliceIn.secrets[0]));
            psbt.signInput(1, schnorrSignerSingle(bobPk, bobIn.secrets[0]));
            psbt.finalizeAllInputs();
            return {
                txid: psbt.extractTransaction().getId(),
                hex: psbt.extractTransaction().toHex()
            };
        },
        genClosingTx: function (multiIn, alicePk, bobPk, aliceAmount, bobAmount) {
            var psbt = new bitcoin.Psbt({ network: net });
            var pkCombined = muSig.pubKeyCombine([Buffer.from(alicePk, "hex"), Buffer.from(bobPk, "hex")]);
            var pubKeyCombined = convert.intToBuffer(pkCombined.affineX);
            var multiP2TR = p2pktr(pubKeyCombined);
            psbt.addInput({
                hash: multiIn.txid,
                index: multiIn.vout,
                witnessUtxo: { value: aliceAmount + bobAmount, script: multiP2TR.output },
                tapInternalKey: Buffer.from(alicePk, "hex")
            });
            psbt.addOutput({
                address: "mohjSavDdQYHRYXcS3uS6ttaHP8amyvX78",
                value: aliceAmount
            });
            psbt.addOutput({
                address: "mohjSavDdQYHRYXcS3uS6ttaHP8amyvX78",
                value: bobAmount
            });
            psbt.signInput(0, schnorrSignerMulti(alicePk, bobPk, multiIn.secrets[0], multiIn.secrets[1]));
            psbt.finalizeAllInputs();
            return {
                txid: psbt.extractTransaction().getId(),
                hex: psbt.extractTransaction().toHex()
            };
        },
        genAliceCet: function (multiIn, alicePk, bobPk, oracleMsgHex, oracleR, aliceAmount, bobAmount) {
            var psbt = new bitcoin.Psbt({ network: net });
            var pkCombined = muSig.pubKeyCombine([Buffer.from(alicePk, "hex"), Buffer.from(bobPk, "hex")]);
            var pubKeyCombined = convert.intToBuffer(pkCombined.affineX);
            var multiP2TR = p2pktr(pubKeyCombined);
            psbt.addInput({
                hash: multiIn.txid,
                index: multiIn.vout,
                witnessUtxo: { value: aliceAmount + bobAmount, script: multiP2TR.output },
                tapInternalKey: Buffer.from(alicePk, "hex")
            });
            psbt.addOutput({
                address: "mohjSavDdQYHRYXcS3uS6ttaHP8amyvX78",
                value: aliceAmount
            });
            psbt.addOutput({
                address: "mohjSavDdQYHRYXcS3uS6ttaHP8amyvX78",
                value: bobAmount
            });
            psbt.signInput(0, schnorrSignerMulti(alicePk, bobPk, multiIn.secrets[0], multiIn.secrets[1]));
            psbt.finalizeAllInputs();
            return {
                txid: psbt.extractTransaction().getId(),
                hex: psbt.extractTransaction().toHex()
            };
        },
        genAliceCetRedemption: function (aliceOracleIn, alicePk, oracleS) {
            return {
                txid: "0",
                hex: "0"
            };
        }
    };
};
exports.txApi = txApi;


/***/ }),

/***/ "./node_modules/typeforce/errors.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/errors.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var native = __webpack_require__(/*! ./native */ "./node_modules/typeforce/native.js")

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}


/***/ }),

/***/ "./node_modules/typeforce/extra.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/extra.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
var NATIVE = __webpack_require__(/*! ./native */ "./node_modules/typeforce/native.js")
var ERRORS = __webpack_require__(/*! ./errors */ "./node_modules/typeforce/errors.js")

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ "./node_modules/typeforce/index.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ERRORS = __webpack_require__(/*! ./errors */ "./node_modules/typeforce/errors.js")
var NATIVE = __webpack_require__(/*! ./native */ "./node_modules/typeforce/native.js")

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = __webpack_require__(/*! ./extra */ "./node_modules/typeforce/extra.js")
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce


/***/ }),

/***/ "./node_modules/typeforce/native.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/native.js ***!
  \******************************************/
/***/ ((module) => {

var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/varuint-bitcoin/index.js":
/*!***********************************************!*\
  !*** ./node_modules/varuint-bitcoin/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)

// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991

function checkUInt53 (n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
}

function encode (number, buffer, offset) {
  checkUInt53(number)

  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  // 8 bit
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset)
    encode.bytes = 1

  // 16 bit
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset)
    buffer.writeUInt16LE(number, offset + 1)
    encode.bytes = 3

  // 32 bit
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset)
    buffer.writeUInt32LE(number, offset + 1)
    encode.bytes = 5

  // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset)
    buffer.writeUInt32LE(number >>> 0, offset + 1)
    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
    encode.bytes = 9
  }

  return buffer
}

function decode (buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  var first = buffer.readUInt8(offset)

  // 8 bit
  if (first < 0xfd) {
    decode.bytes = 1
    return first

  // 16 bit
  } else if (first === 0xfd) {
    decode.bytes = 3
    return buffer.readUInt16LE(offset + 1)

  // 32 bit
  } else if (first === 0xfe) {
    decode.bytes = 5
    return buffer.readUInt32LE(offset + 1)

  // 64 bit
  } else {
    decode.bytes = 9
    var lo = buffer.readUInt32LE(offset + 1)
    var hi = buffer.readUInt32LE(offset + 5)
    var number = hi * 0x0100000000 + lo
    checkUInt53(number)

    return number
  }
}

function encodingLength (number) {
  checkUInt53(number)

  return (
    number < 0xfd ? 1
      : number <= 0xffff ? 3
        : number <= 0xffffffff ? 5
          : 9
  )
}

module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		cache['$' + typedArray] = callBind(arr.slice);
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var found = false;
	forEach(cache, function (getter, typedArray) {
		if (!found) {
			try {
				if ('$' + getter(value) === typedArray) {
					found = $slice(typedArray, 1);
				}
			} catch (e) { /**/ }
		}
	});
	return found;
};

var trySlices = function tryAllSlices(value) {
	var found = false;
	forEach(cache, function (getter, name) {
		if (!found) {
			try {
				getter(value);
				found = $slice(name, 1);
			} catch (e) { /**/ }
		}
	});
	return found;
};

module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/index.js ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __initializeContext: () => (/* binding */ __initializeContext),
/* harmony export */   isPoint: () => (/* binding */ isPoint),
/* harmony export */   isPointCompressed: () => (/* binding */ isPointCompressed),
/* harmony export */   isPrivate: () => (/* binding */ isPrivate),
/* harmony export */   isXOnlyPoint: () => (/* binding */ isXOnlyPoint),
/* harmony export */   pointAdd: () => (/* binding */ pointAdd),
/* harmony export */   pointAddScalar: () => (/* binding */ pointAddScalar),
/* harmony export */   pointCompress: () => (/* binding */ pointCompress),
/* harmony export */   pointFromScalar: () => (/* binding */ pointFromScalar),
/* harmony export */   pointMultiply: () => (/* binding */ pointMultiply),
/* harmony export */   privateAdd: () => (/* binding */ privateAdd),
/* harmony export */   privateNegate: () => (/* binding */ privateNegate),
/* harmony export */   privateSub: () => (/* binding */ privateSub),
/* harmony export */   recover: () => (/* binding */ recover),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   signRecoverable: () => (/* binding */ signRecoverable),
/* harmony export */   signSchnorr: () => (/* binding */ signSchnorr),
/* harmony export */   verify: () => (/* binding */ verify),
/* harmony export */   verifySchnorr: () => (/* binding */ verifySchnorr),
/* harmony export */   xOnlyPointAddTweak: () => (/* binding */ xOnlyPointAddTweak),
/* harmony export */   xOnlyPointAddTweakCheck: () => (/* binding */ xOnlyPointAddTweakCheck),
/* harmony export */   xOnlyPointFromPoint: () => (/* binding */ xOnlyPointFromPoint),
/* harmony export */   xOnlyPointFromScalar: () => (/* binding */ xOnlyPointFromScalar)
/* harmony export */ });
/* harmony import */ var uint8array_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8array-tools */ "./node_modules/uint8array-tools/src/mjs/browser.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validate.js */ "./node_modules/tiny-secp256k1/lib/validate.js");
/* harmony import */ var _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm_loader.js */ "./node_modules/tiny-secp256k1/lib/wasm_loader.browser.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__]);
_wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



const WASM_BUFFER = new Uint8Array(_wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].memory.buffer);
const WASM_PRIVATE_KEY_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRIVATE_INPUT.value;
const WASM_PUBLIC_KEY_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].PUBLIC_KEY_INPUT.value;
const WASM_PUBLIC_KEY_INPUT_PTR2 = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].PUBLIC_KEY_INPUT2.value;
const WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].X_ONLY_PUBLIC_KEY_INPUT.value;
const WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].X_ONLY_PUBLIC_KEY_INPUT2.value;
const WASM_TWEAK_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].TWEAK_INPUT.value;
const WASM_HASH_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].HASH_INPUT.value;
const WASM_EXTRA_DATA_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTRA_DATA_INPUT.value;
const WASM_SIGNATURE_INPUT_PTR = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].SIGNATURE_INPUT.value;
const PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_SIZE);
const PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_UNCOMPRESSED_SIZE);
const PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + _validate_js__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_UNCOMPRESSED_SIZE);
const X_ONLY_PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE);
const X_ONLY_PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE);
const TWEAK_INPUT = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.TWEAK_SIZE);
const HASH_INPUT = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.HASH_SIZE);
const EXTRA_DATA_INPUT = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.EXTRA_DATA_SIZE);
const SIGNATURE_INPUT = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + _validate_js__WEBPACK_IMPORTED_MODULE_1__.SIGNATURE_SIZE);
function assumeCompression(compressed, p) {
    if (compressed === undefined) {
        return p !== undefined ? p.length : _validate_js__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_COMPRESSED_SIZE;
    }
    return compressed
        ? _validate_js__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_COMPRESSED_SIZE
        : _validate_js__WEBPACK_IMPORTED_MODULE_1__.PUBLIC_KEY_UNCOMPRESSED_SIZE;
}
function _isPoint(p) {
    try {
        PUBLIC_KEY_INPUT.set(p);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].isPoint(p.length) === 1;
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
    }
}
function __initializeContext() {
    _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].initializeContext();
}
function isPoint(p) {
    return _validate_js__WEBPACK_IMPORTED_MODULE_1__.isDERPoint(p) && _isPoint(p);
}
function isPointCompressed(p) {
    return _validate_js__WEBPACK_IMPORTED_MODULE_1__.isPointCompressed(p) && _isPoint(p);
}
function isXOnlyPoint(p) {
    return _validate_js__WEBPACK_IMPORTED_MODULE_1__.isXOnlyPoint(p) && _isPoint(p);
}
function isPrivate(d) {
    return _validate_js__WEBPACK_IMPORTED_MODULE_1__.isPrivate(d);
}
function pointAdd(pA, pB, compressed) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(pA);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(pB);
    const outputlen = assumeCompression(compressed, pA);
    try {
        PUBLIC_KEY_INPUT.set(pA);
        PUBLIC_KEY_INPUT2.set(pB);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].pointAdd(pA.length, pB.length, outputlen) === 1
            ? PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
        PUBLIC_KEY_INPUT2.fill(0);
    }
}
function pointAddScalar(p, tweak, compressed) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(p);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
        PUBLIC_KEY_INPUT.set(p);
        TWEAK_INPUT.set(tweak);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].pointAddScalar(p.length, outputlen) === 1
            ? PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function pointCompress(p, compressed) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(p);
    const outputlen = assumeCompression(compressed, p);
    try {
        PUBLIC_KEY_INPUT.set(p);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].pointCompress(p.length, outputlen);
        return PUBLIC_KEY_INPUT.slice(0, outputlen);
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
    }
}
function pointFromScalar(d, compressed) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    const outputlen = assumeCompression(compressed);
    try {
        PRIVATE_KEY_INPUT.set(d);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].pointFromScalar(outputlen) === 1
            ? PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        PUBLIC_KEY_INPUT.fill(0);
    }
}
function xOnlyPointFromScalar(d) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    try {
        PRIVATE_KEY_INPUT.set(d);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].xOnlyPointFromScalar();
        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE);
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        X_ONLY_PUBLIC_KEY_INPUT.fill(0);
    }
}
function xOnlyPointFromPoint(p) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(p);
    try {
        PUBLIC_KEY_INPUT.set(p);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].xOnlyPointFromPoint(p.length);
        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE);
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
        X_ONLY_PUBLIC_KEY_INPUT.fill(0);
    }
}
function pointMultiply(p, tweak, compressed) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(p);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
        PUBLIC_KEY_INPUT.set(p);
        TWEAK_INPUT.set(tweak);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].pointMultiply(p.length, outputlen) === 1
            ? PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        PUBLIC_KEY_INPUT.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function privateAdd(d, tweak) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    try {
        PRIVATE_KEY_INPUT.set(d);
        TWEAK_INPUT.set(tweak);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].privateAdd() === 1
            ? PRIVATE_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_SIZE)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function privateSub(d, tweak) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    // We can not pass zero tweak to WASM, because WASM use `secp256k1_ec_seckey_negate` for tweak negate.
    // (zero is not valid seckey)
    if (_validate_js__WEBPACK_IMPORTED_MODULE_1__.isZero(tweak)) {
        return new Uint8Array(d);
    }
    try {
        PRIVATE_KEY_INPUT.set(d);
        TWEAK_INPUT.set(tweak);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].privateSub() === 1
            ? PRIVATE_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_SIZE)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function privateNegate(d) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    try {
        PRIVATE_KEY_INPUT.set(d);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].privateNegate();
        return PRIVATE_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.PRIVATE_KEY_SIZE);
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
    }
}
function xOnlyPointAddTweak(p, tweak) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateXOnlyPoint(p);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    try {
        X_ONLY_PUBLIC_KEY_INPUT.set(p);
        TWEAK_INPUT.set(tweak);
        const parity = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].xOnlyPointAddTweak();
        return parity !== -1
            ? {
                parity,
                xOnlyPubkey: X_ONLY_PUBLIC_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE),
            }
            : null;
    }
    finally {
        X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function xOnlyPointAddTweakCheck(point, tweak, resultToCheck, tweakParity) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateXOnlyPoint(point);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateXOnlyPoint(resultToCheck);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateTweak(tweak);
    const hasParity = tweakParity !== undefined;
    if (hasParity)
        _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateParity(tweakParity);
    try {
        X_ONLY_PUBLIC_KEY_INPUT.set(point);
        X_ONLY_PUBLIC_KEY_INPUT2.set(resultToCheck);
        TWEAK_INPUT.set(tweak);
        if (hasParity) {
            return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].xOnlyPointAddTweakCheck(tweakParity) === 1;
        }
        else {
            _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].xOnlyPointAddTweak();
            const newKey = X_ONLY_PUBLIC_KEY_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.X_ONLY_PUBLIC_KEY_SIZE);
            return (0,uint8array_tools__WEBPACK_IMPORTED_MODULE_0__.compare)(newKey, resultToCheck) === 0;
        }
    }
    finally {
        X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        X_ONLY_PUBLIC_KEY_INPUT2.fill(0);
        TWEAK_INPUT.fill(0);
    }
}
function sign(h, d, e) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateExtraData(e);
    try {
        HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            EXTRA_DATA_INPUT.set(e);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].sign(e === undefined ? 0 : 1);
        return SIGNATURE_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.SIGNATURE_SIZE);
    }
    finally {
        HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            EXTRA_DATA_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
    }
}
function signRecoverable(h, d, e) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateExtraData(e);
    try {
        HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            EXTRA_DATA_INPUT.set(e);
        const recoveryId = _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].signRecoverable(e === undefined ? 0 : 1);
        const signature = SIGNATURE_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.SIGNATURE_SIZE);
        return {
            signature,
            recoveryId,
        };
    }
    finally {
        HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            EXTRA_DATA_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
    }
}
function signSchnorr(h, d, e) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePrivate(d);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateExtraData(e);
    try {
        HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            EXTRA_DATA_INPUT.set(e);
        _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].signSchnorr(e === undefined ? 0 : 1);
        return SIGNATURE_INPUT.slice(0, _validate_js__WEBPACK_IMPORTED_MODULE_1__.SIGNATURE_SIZE);
    }
    finally {
        HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            EXTRA_DATA_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
    }
}
function verify(h, Q, signature, strict = false) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validatePoint(Q);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSignature(signature);
    try {
        HASH_INPUT.set(h);
        PUBLIC_KEY_INPUT.set(Q);
        SIGNATURE_INPUT.set(signature);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;
    }
    finally {
        HASH_INPUT.fill(0);
        PUBLIC_KEY_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
    }
}
function recover(h, signature, recoveryId, compressed = false) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSignature(signature);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSignatureNonzeroRS(signature);
    if (recoveryId & 2) {
        _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSigrPMinusN(signature);
    }
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSignatureCustom(() => isXOnlyPoint(signature.subarray(0, 32)));
    const outputlen = assumeCompression(compressed);
    try {
        HASH_INPUT.set(h);
        SIGNATURE_INPUT.set(signature);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].recover(outputlen, recoveryId) === 1
            ? PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        HASH_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
        PUBLIC_KEY_INPUT.fill(0);
    }
}
function verifySchnorr(h, Q, signature) {
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateHash(h);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateXOnlyPoint(Q);
    _validate_js__WEBPACK_IMPORTED_MODULE_1__.validateSignature(signature);
    try {
        HASH_INPUT.set(h);
        X_ONLY_PUBLIC_KEY_INPUT.set(Q);
        SIGNATURE_INPUT.set(signature);
        return _wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__["default"].verifySchnorr() === 1 ? true : false;
    }
    finally {
        HASH_INPUT.fill(0);
        X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        SIGNATURE_INPUT.fill(0);
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/rand.browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/rand.browser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateInt32: () => (/* binding */ generateInt32)
/* harmony export */ });
function get4RandomBytes() {
    const bytes = new Uint8Array(4);
    if (typeof crypto === "undefined") {
        throw new Error("The crypto object is unavailable. This may occur if your environment does not support the Web Cryptography API.");
    }
    crypto.getRandomValues(bytes);
    return bytes;
}
// Only to be used to initialize the context for rust-secp256k1
function generateInt32() {
    const array = get4RandomBytes();
    return ((array[0] << (3 * 8)) +
        (array[1] << (2 * 8)) +
        (array[2] << (1 * 8)) +
        array[3]);
}


/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/validate.js":
/*!*****************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/validate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTRA_DATA_SIZE: () => (/* binding */ EXTRA_DATA_SIZE),
/* harmony export */   HASH_SIZE: () => (/* binding */ HASH_SIZE),
/* harmony export */   PRIVATE_KEY_SIZE: () => (/* binding */ PRIVATE_KEY_SIZE),
/* harmony export */   PUBLIC_KEY_COMPRESSED_SIZE: () => (/* binding */ PUBLIC_KEY_COMPRESSED_SIZE),
/* harmony export */   PUBLIC_KEY_UNCOMPRESSED_SIZE: () => (/* binding */ PUBLIC_KEY_UNCOMPRESSED_SIZE),
/* harmony export */   SIGNATURE_SIZE: () => (/* binding */ SIGNATURE_SIZE),
/* harmony export */   TWEAK_SIZE: () => (/* binding */ TWEAK_SIZE),
/* harmony export */   X_ONLY_PUBLIC_KEY_SIZE: () => (/* binding */ X_ONLY_PUBLIC_KEY_SIZE),
/* harmony export */   isDERPoint: () => (/* binding */ isDERPoint),
/* harmony export */   isPoint: () => (/* binding */ isPoint),
/* harmony export */   isPointCompressed: () => (/* binding */ isPointCompressed),
/* harmony export */   isPrivate: () => (/* binding */ isPrivate),
/* harmony export */   isXOnlyPoint: () => (/* binding */ isXOnlyPoint),
/* harmony export */   isZero: () => (/* binding */ isZero),
/* harmony export */   validateExtraData: () => (/* binding */ validateExtraData),
/* harmony export */   validateHash: () => (/* binding */ validateHash),
/* harmony export */   validateParity: () => (/* binding */ validateParity),
/* harmony export */   validatePoint: () => (/* binding */ validatePoint),
/* harmony export */   validatePrivate: () => (/* binding */ validatePrivate),
/* harmony export */   validateSignature: () => (/* binding */ validateSignature),
/* harmony export */   validateSignatureCustom: () => (/* binding */ validateSignatureCustom),
/* harmony export */   validateSignatureNonzeroRS: () => (/* binding */ validateSignatureNonzeroRS),
/* harmony export */   validateSigrPMinusN: () => (/* binding */ validateSigrPMinusN),
/* harmony export */   validateTweak: () => (/* binding */ validateTweak),
/* harmony export */   validateXOnlyPoint: () => (/* binding */ validateXOnlyPoint)
/* harmony export */ });
/* harmony import */ var _validate_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate_error.js */ "./node_modules/tiny-secp256k1/lib/validate_error.js");

const PRIVATE_KEY_SIZE = 32;
const PUBLIC_KEY_COMPRESSED_SIZE = 33;
const PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;
const X_ONLY_PUBLIC_KEY_SIZE = 32;
const TWEAK_SIZE = 32;
const HASH_SIZE = 32;
const EXTRA_DATA_SIZE = 32;
const SIGNATURE_SIZE = 64;
const BN32_ZERO = new Uint8Array(32);
const BN32_N = new Uint8Array([
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,
]);
// Difference between field and order
const BN32_P_MINUS_N = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,
    196, 64, 45, 161, 114, 47, 201, 186, 238,
]);
function isUint8Array(value) {
    return value instanceof Uint8Array;
}
function cmpBN32(data1, data2) {
    for (let i = 0; i < 32; ++i) {
        if (data1[i] !== data2[i]) {
            return data1[i] < data2[i] ? -1 : 1;
        }
    }
    return 0;
}
function isZero(x) {
    return cmpBN32(x, BN32_ZERO) === 0;
}
function isPrivate(x) {
    return (isUint8Array(x) &&
        x.length === PRIVATE_KEY_SIZE &&
        cmpBN32(x, BN32_ZERO) > 0 &&
        cmpBN32(x, BN32_N) < 0);
}
function isPoint(p) {
    return (isUint8Array(p) &&
        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||
            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE ||
            p.length === X_ONLY_PUBLIC_KEY_SIZE));
}
function isXOnlyPoint(p) {
    return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;
}
function isDERPoint(p) {
    return (isUint8Array(p) &&
        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||
            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE));
}
function isPointCompressed(p) {
    return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}
function isTweak(tweak) {
    return (isUint8Array(tweak) &&
        tweak.length === TWEAK_SIZE &&
        cmpBN32(tweak, BN32_N) < 0);
}
function isHash(h) {
    return isUint8Array(h) && h.length === HASH_SIZE;
}
function isExtraData(e) {
    return e === undefined || (isUint8Array(e) && e.length === EXTRA_DATA_SIZE);
}
function isSignature(signature) {
    return (isUint8Array(signature) &&
        signature.length === 64 &&
        cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&
        cmpBN32(signature.subarray(32, 64), BN32_N) < 0);
}
function isSigrLessThanPMinusN(signature) {
    return (isUint8Array(signature) &&
        signature.length === 64 &&
        cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0);
}
function validateParity(p) {
    if (p !== 0 && p !== 1)
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_PARITY);
}
function validatePrivate(d) {
    if (!isPrivate(d))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_PRIVATE);
}
function validatePoint(p) {
    if (!isPoint(p))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_POINT);
}
function validateXOnlyPoint(p) {
    if (!isXOnlyPoint(p))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_POINT);
}
function validateTweak(tweak) {
    if (!isTweak(tweak))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_TWEAK);
}
function validateHash(h) {
    if (!isHash(h))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_HASH);
}
function validateExtraData(e) {
    if (!isExtraData(e))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_EXTRA_DATA);
}
function validateSignature(signature) {
    if (!isSignature(signature))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_SIGNATURE);
}
function validateSignatureCustom(validatorFn) {
    if (!validatorFn())
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_SIGNATURE);
}
function validateSignatureNonzeroRS(signature) {
    if (isZero(signature.subarray(0, 32)))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_SIGNATURE);
    if (isZero(signature.subarray(32, 64)))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_SIGNATURE);
}
function validateSigrPMinusN(signature) {
    if (!isSigrLessThanPMinusN(signature))
        (0,_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.throwError)(_validate_error_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_BAD_RECOVERY_ID);
}


/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/validate_error.js":
/*!***********************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/validate_error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERROR_BAD_EXTRA_DATA: () => (/* binding */ ERROR_BAD_EXTRA_DATA),
/* harmony export */   ERROR_BAD_HASH: () => (/* binding */ ERROR_BAD_HASH),
/* harmony export */   ERROR_BAD_PARITY: () => (/* binding */ ERROR_BAD_PARITY),
/* harmony export */   ERROR_BAD_POINT: () => (/* binding */ ERROR_BAD_POINT),
/* harmony export */   ERROR_BAD_PRIVATE: () => (/* binding */ ERROR_BAD_PRIVATE),
/* harmony export */   ERROR_BAD_RECOVERY_ID: () => (/* binding */ ERROR_BAD_RECOVERY_ID),
/* harmony export */   ERROR_BAD_SIGNATURE: () => (/* binding */ ERROR_BAD_SIGNATURE),
/* harmony export */   ERROR_BAD_TWEAK: () => (/* binding */ ERROR_BAD_TWEAK),
/* harmony export */   throwError: () => (/* binding */ throwError)
/* harmony export */ });
const ERROR_BAD_PRIVATE = 0;
const ERROR_BAD_POINT = 1;
const ERROR_BAD_TWEAK = 2;
const ERROR_BAD_HASH = 3;
const ERROR_BAD_SIGNATURE = 4;
const ERROR_BAD_EXTRA_DATA = 5;
const ERROR_BAD_PARITY = 6;
const ERROR_BAD_RECOVERY_ID = 7;
const ERRORS_MESSAGES = {
    [ERROR_BAD_PRIVATE.toString()]: "Expected Private",
    [ERROR_BAD_POINT.toString()]: "Expected Point",
    [ERROR_BAD_TWEAK.toString()]: "Expected Tweak",
    [ERROR_BAD_HASH.toString()]: "Expected Hash",
    [ERROR_BAD_SIGNATURE.toString()]: "Expected Signature",
    [ERROR_BAD_EXTRA_DATA.toString()]: "Expected Extra Data (32 bytes)",
    [ERROR_BAD_PARITY.toString()]: "Expected Parity (1 | 0)",
    [ERROR_BAD_RECOVERY_ID.toString()]: "Bad Recovery Id",
};
function throwError(errcode) {
    const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;
    throw new TypeError(message);
}


/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/wasm_loader.browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/wasm_loader.browser.js ***!
  \****************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _secp256k1_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./secp256k1.wasm */ "./node_modules/tiny-secp256k1/lib/secp256k1.wasm");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_secp256k1_wasm__WEBPACK_IMPORTED_MODULE_0__]);
_secp256k1_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// Suppress TS2792: Cannot find module './secp256k1.wasm'.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_secp256k1_wasm__WEBPACK_IMPORTED_MODULE_0__);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/uint8array-tools/src/mjs/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/uint8array-tools/src/mjs/browser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   fromHex: () => (/* binding */ fromHex),
/* harmony export */   toHex: () => (/* binding */ toHex)
/* harmony export */ });
const HEX_STRINGS = "0123456789abcdefABCDEF";
const HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
const HEX_CODEPOINTS = Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
const ENCODER = new TextEncoder();
const DECODER = new TextDecoder("ascii");
// There are two implementations.
// One optimizes for length of the bytes, and uses TextDecoder.
// One optimizes for iteration count, and appends strings.
// This removes the overhead of TextDecoder.
function toHex(bytes) {
    const b = bytes || new Uint8Array();
    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; ++i) {
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
    }
    return s;
}
function _toHexLengthPerf(bytes) {
    const hexBytes = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; ++i) {
        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
    }
    return DECODER.decode(hexBytes);
}
// Mimics Buffer.from(x, 'hex') logic
// Stops on first non-hex string and returns
// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261
function fromHex(hexString) {
    const hexBytes = ENCODER.encode(hexString || "");
    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
    let i;
    for (i = 0; i < resultBytes.length; i++) {
        const a = HEX_CODEPOINTS[hexBytes[i * 2]];
        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        resultBytes[i] = (a << 4) | b;
    }
    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
// Same behavior as Buffer.compare()
function compare(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
        if (v1[i] !== v2[i]) {
            return v1[i] < v2[i] ? -1 : 1;
        }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}


/***/ }),

/***/ "./node_modules/bigi/package.json":
/*!****************************************!*\
  !*** ./node_modules/bigi/package.json ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"bigi","version":"1.4.2","description":"Big integers.","keywords":["cryptography","math","bitcoin","arbitrary","precision","arithmetic","big","integer","int","number","biginteger","bigint","bignumber","decimal","float"],"devDependencies":{"coveralls":"^2.11.2","istanbul":"^0.3.5","jshint":"^2.5.1","mocha":"^2.1.0","mochify":"^2.1.0"},"repository":{"url":"https://github.com/cryptocoinjs/bigi","type":"git"},"main":"./lib/index.js","scripts":{"browser-test":"./node_modules/.bin/mochify --wd -R spec","test":"./node_modules/.bin/_mocha -- test/*.js","jshint":"./node_modules/.bin/jshint --config jshint.json lib/*.js ; true","unit":"./node_modules/.bin/mocha","coverage":"./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js","coveralls":"npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info"},"dependencies":{},"testling":{"files":"test/*.js","harness":"mocha","browsers":["ie/9..latest","firefox/latest","chrome/latest","safari/6.0..latest","iphone/6.0..latest","android-browser/4.2..latest"]}}');

/***/ }),

/***/ "./node_modules/ecurve/lib/curves.json":
/*!*********************************************!*\
  !*** ./node_modules/ecurve/lib/curves.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"secp128r1":{"p":"fffffffdffffffffffffffffffffffff","a":"fffffffdfffffffffffffffffffffffc","b":"e87579c11079f43dd824993c2cee5ed3","n":"fffffffe0000000075a30d1b9038a115","h":"01","Gx":"161ff7528b899b2d0c28607ca52c5b86","Gy":"cf5ac8395bafeb13c02da292dded7a83"},"secp160k1":{"p":"fffffffffffffffffffffffffffffffeffffac73","a":"00","b":"07","n":"0100000000000000000001b8fa16dfab9aca16b6b3","h":"01","Gx":"3b4c382ce37aa192a4019e763036f4f5dd4d7ebb","Gy":"938cf935318fdced6bc28286531733c3f03c4fee"},"secp160r1":{"p":"ffffffffffffffffffffffffffffffff7fffffff","a":"ffffffffffffffffffffffffffffffff7ffffffc","b":"1c97befc54bd7a8b65acf89f81d4d4adc565fa45","n":"0100000000000000000001f4c8f927aed3ca752257","h":"01","Gx":"4a96b5688ef573284664698968c38bb913cbfc82","Gy":"23a628553168947d59dcc912042351377ac5fb32"},"secp192k1":{"p":"fffffffffffffffffffffffffffffffffffffffeffffee37","a":"00","b":"03","n":"fffffffffffffffffffffffe26f2fc170f69466a74defd8d","h":"01","Gx":"db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d","Gy":"9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"},"secp192r1":{"p":"fffffffffffffffffffffffffffffffeffffffffffffffff","a":"fffffffffffffffffffffffffffffffefffffffffffffffc","b":"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1","n":"ffffffffffffffffffffffff99def836146bc9b1b4d22831","h":"01","Gx":"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012","Gy":"07192b95ffc8da78631011ed6b24cdd573f977a11e794811"},"secp256k1":{"p":"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f","a":"00","b":"07","n":"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","h":"01","Gx":"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","Gy":"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"},"secp256r1":{"p":"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff","a":"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc","b":"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b","n":"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551","h":"01","Gx":"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296","Gy":"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"}}');

/***/ }),

/***/ "./node_modules/tiny-secp256k1/lib/secp256k1.wasm":
/*!********************************************************!*\
  !*** ./node_modules/tiny-secp256k1/lib/secp256k1.wasm ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./rand.js */ "./node_modules/tiny-secp256k1/lib/rand.browser.js");
/* harmony import */ var WEBPACK_IMPORTED_MODULE_1 = __webpack_require__(/*! ./validate_error.js */ "./node_modules/tiny-secp256k1/lib/validate_error.js");
module.exports = __webpack_require__.v(exports, module.id, "30132f7f8e20a6adddcb", {
	"./rand.js": {
		"generateInt32": WEBPACK_IMPORTED_MODULE_0.generateInt32
	},
	"./validate_error.js": {
		"throwError": WEBPACK_IMPORTED_MODULE_1.throwError
	}
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/wasm loading */
/******/ 	(() => {
/******/ 		__webpack_require__.v = (exports, wasmModuleId, wasmModuleHash, importsObj) => {
/******/ 			var req = fetch(__webpack_require__.p + "" + wasmModuleHash + ".module.wasm");
/******/ 			if (typeof WebAssembly.instantiateStreaming === 'function') {
/******/ 				return WebAssembly.instantiateStreaming(req, importsObj)
/******/ 					.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 			}
/******/ 			return req
/******/ 				.then((x) => (x.arrayBuffer()))
/******/ 				.then((bytes) => (WebAssembly.instantiate(bytes, importsObj)))
/******/ 				.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./app.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxv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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNB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Ozs7QUN6S2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSx3RkFBa0M7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsU0FBUzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0EsK0JBQStCLE1BQU0sT0FBTyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLCtDQUErQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7Ozs7Ozs7Ozs7Ozs7O0FDNU5BO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBaUM7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQXNCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLHNFQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFZO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVTtBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlELE1BQU07QUFDTixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVywyQkFBMkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSxlQUFlO0FBQzlEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFLDBCQUEwQixTQUFTO0FBQ25DLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUSw4QkFBOEIsdUJBQXVCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsbUJBQW1CLE1BQU0sUUFBUSxHQUFHLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEUsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QixhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLE1BQU07QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLElBQUk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE1BQU07QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xzRGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsMkJBQTJCO0FBQzdCLEVBQUUsZ0NBQWdDO0FBQ2xDLEVBQUUsK0JBQStCO0FBQ2pDLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsaUNBQWlDO0FBQ25DLEVBQUUsMEJBQTBCO0FBQzVCLEVBQUUsZUFBZTtBQUNqQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFnQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBb0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsdUVBQWE7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsdUVBQWE7QUFDekM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVEQUF1RCxXQUFXLElBQUksSUFBSTtBQUMxRTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxNQUFNLE1BQU07QUFDWixNQUFNLE1BQU07QUFDWixTQUFTLE1BQU07QUFDZjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBTSxTQUFTLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ3BELDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUcsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUcsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEdBQUc7QUFDNUIsd0JBQXdCLE1BQU07QUFDOUIsd0JBQXdCLFFBQVE7QUFDaEMsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ2hDLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNW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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNy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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxRQUFRO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhDQUE4QywrQkFBK0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047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Q0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMvQmE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0dBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsa0hBQWdEOztBQUVoRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVc7QUFDWCxFQUFFLE9BQU87QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EscUdBQXNDOztBQUV0QyxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8scUNBQXFDO0FBQ3hFLDRCQUE0QixPQUFPLHNEQUFzRDtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COzs7Ozs7Ozs7Ozs7QUMxc0JQO0FBQ1osYUFBYSxzRkFBNkI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7Ozs7Ozs7Ozs7OztBQ3pGTjs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0RBQVU7QUFDaEMsMkJBQTJCLG1CQUFPLENBQUMsOEVBQXdCO0FBQzNELGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBcUI7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLDBDQUFNOztBQUV6QjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNFQUF1Qjs7QUFFcEQsNENBQTRDLHFCQUFNO0FBQ2xEOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEZhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxxQkFBTTs7QUFFbEQ7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCMkM7QUFDRDtBQUNOO0FBQ3BDLG1DQUFtQyx1REFBSTtBQUN2Qyw2QkFBNkIsdURBQUk7QUFDakMsa0NBQWtDLHVEQUFJO0FBQ3RDLG1DQUFtQyx1REFBSTtBQUN2Qyx5Q0FBeUMsdURBQUk7QUFDN0MsMENBQTBDLHVEQUFJO0FBQzlDLDZCQUE2Qix1REFBSTtBQUNqQyw0QkFBNEIsdURBQUk7QUFDaEMsa0NBQWtDLHVEQUFJO0FBQ3RDLGlDQUFpQyx1REFBSTtBQUNyQyw0RkFBNEYsMERBQXlCO0FBQ3JILHFHQUFxRyxzRUFBcUM7QUFDMUksd0dBQXdHLHNFQUFxQztBQUM3SSwwSEFBMEgsZ0VBQStCO0FBQ3pKLDZIQUE2SCxnRUFBK0I7QUFDNUosc0ZBQXNGLG9EQUFtQjtBQUN6RyxtRkFBbUYsbURBQWtCO0FBQ3JHLHFHQUFxRyx5REFBd0I7QUFDN0gsa0dBQWtHLHdEQUF1QjtBQUN6SDtBQUNBO0FBQ0EsNENBQTRDLG9FQUFtQztBQUMvRTtBQUNBO0FBQ0EsVUFBVSxvRUFBbUM7QUFDN0MsVUFBVSxzRUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQUk7QUFDUjtBQUNPO0FBQ1AsV0FBVyxvREFBbUI7QUFDOUI7QUFDTztBQUNQLFdBQVcsMkRBQTBCO0FBQ3JDO0FBQ087QUFDUCxXQUFXLHNEQUFxQjtBQUNoQztBQUNPO0FBQ1AsV0FBVyxtREFBa0I7QUFDN0I7QUFDTztBQUNQLElBQUksdURBQXNCO0FBQzFCLElBQUksdURBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFzQjtBQUMxQixJQUFJLHVEQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx1REFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUF3QjtBQUM1QjtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLGdEQUFnRCxnRUFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFzQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLGdEQUFnRCxnRUFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFzQjtBQUMxQixJQUFJLHVEQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBd0I7QUFDNUIsSUFBSSx1REFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBSTtBQUNuQix5Q0FBeUMsMERBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUF3QjtBQUM1QixJQUFJLHVEQUFzQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUSxnREFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBSTtBQUNuQix5Q0FBeUMsMERBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUF3QjtBQUM1QjtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLDBDQUEwQywwREFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSw0REFBMkI7QUFDL0IsSUFBSSx1REFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnRUFBK0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSw0REFBMkI7QUFDL0IsSUFBSSw0REFBMkI7QUFDL0IsSUFBSSx1REFBc0I7QUFDMUI7QUFDQTtBQUNBLFFBQVEsd0RBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQUk7QUFDdkI7QUFDQTtBQUNBLFlBQVksdURBQUk7QUFDaEIsNERBQTRELGdFQUErQjtBQUMzRixtQkFBbUIseURBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxzREFBcUI7QUFDekIsSUFBSSx5REFBd0I7QUFDNUIsSUFBSSwyREFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWix3Q0FBd0Msd0RBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxzREFBcUI7QUFDekIsSUFBSSx5REFBd0I7QUFDNUIsSUFBSSwyREFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBSTtBQUMvQixtREFBbUQsd0RBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFxQjtBQUN6QixJQUFJLHlEQUF3QjtBQUM1QixJQUFJLDJEQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLHdDQUF3Qyx3REFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFxQjtBQUN6QixJQUFJLHVEQUFzQjtBQUMxQixJQUFJLDJEQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksc0RBQXFCO0FBQ3pCLElBQUksMkRBQTBCO0FBQzlCLElBQUksb0VBQW1DO0FBQ3ZDO0FBQ0EsUUFBUSw2REFBNEI7QUFDcEM7QUFDQSxJQUFJLGlFQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFxQjtBQUN6QixJQUFJLDREQUEyQjtBQUMvQixJQUFJLDJEQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmMk07QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSw4REFBVSxDQUFDLGdFQUFnQjtBQUNuQztBQUNPO0FBQ1A7QUFDQSxRQUFRLDhEQUFVLENBQUMsaUVBQWlCO0FBQ3BDO0FBQ087QUFDUDtBQUNBLFFBQVEsOERBQVUsQ0FBQywrREFBZTtBQUNsQztBQUNPO0FBQ1A7QUFDQSxRQUFRLDhEQUFVLENBQUMsK0RBQWU7QUFDbEM7QUFDTztBQUNQO0FBQ0EsUUFBUSw4REFBVSxDQUFDLCtEQUFlO0FBQ2xDO0FBQ087QUFDUDtBQUNBLFFBQVEsOERBQVUsQ0FBQyw4REFBYztBQUNqQztBQUNPO0FBQ1A7QUFDQSxRQUFRLDhEQUFVLENBQUMsb0VBQW9CO0FBQ3ZDO0FBQ087QUFDUDtBQUNBLFFBQVEsOERBQVUsQ0FBQyxtRUFBbUI7QUFDdEM7QUFDTztBQUNQO0FBQ0EsUUFBUSw4REFBVSxDQUFDLG1FQUFtQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxRQUFRLDhEQUFVLENBQUMsbUVBQW1CO0FBQ3RDO0FBQ0EsUUFBUSw4REFBVSxDQUFDLG1FQUFtQjtBQUN0QztBQUNPO0FBQ1A7QUFDQSxRQUFRLDhEQUFVLENBQUMscUVBQXFCO0FBQ3hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpRkFBaUYsUUFBUTtBQUN6RjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekMsaUVBQWUsNENBQUksRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDOURBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsQ0FBQztXQUNEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQSxzR0FBc0c7V0FDdEc7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBLEVBQUU7V0FDRjtXQUNBOzs7OztXQ2hFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ1ZBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztVRWxCQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTEuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmVjaDMyL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9iaWdpLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlnaS9saWIvY29udmVydC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwLXNjaG5vcnIvc3JjL2NoZWNrLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwLXNjaG5vcnIvc3JjL2NvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAtc2Nobm9yci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAtc2Nobm9yci9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcC1zY2hub3JyL3NyYy9tdS1zaWcuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAtc2Nobm9yci9zcmMvc2Nobm9yci5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcC1zY2hub3JyL3NyYy90YXByb290LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29tYmluZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvZ2xvYmFsL2dsb2JhbFhwdWIuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvZ2xvYmFsL3Vuc2lnbmVkVHguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvZmluYWxTY3JpcHRTaWcuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvZmluYWxTY3JpcHRXaXRuZXNzLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L25vbldpdG5lc3NVdHhvLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3BhcnRpYWxTaWcuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvcG9yQ29tbWl0bWVudC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC9zaWdoYXNoVHlwZS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC90YXBLZXlTaWcuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvdGFwTGVhZlNjcmlwdC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC90YXBNZXJrbGVSb290LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcFNjcmlwdFNpZy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC93aXRuZXNzVXR4by5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9vdXRwdXQvdGFwVHJlZS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9zaGFyZWQvYmlwMzJEZXJpdmF0aW9uLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9jaGVja1B1YmtleS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9zaGFyZWQvcmVkZWVtU2NyaXB0LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24uanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvc2hhcmVkL3RhcEludGVybmFsS2V5LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC93aXRuZXNzU2NyaXB0LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3Rvb2xzLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3ZhcmludC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL3BhcnNlci9mcm9tQnVmZmVyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL3RvQnVmZmVyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcHNidC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL3R5cGVGaWVsZHMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2FkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9iaXA2Ni5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2Jsb2NrLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9lY2NfbGliLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9tZXJrbGUuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9uZXR3b3Jrcy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL29wcy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL2JpcDM0MS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL2VtYmVkLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9sYXp5LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJtcy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3AycGsuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnBraC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3Ayc2guanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnRyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3cGtoLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3c2guanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wc2J0LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC9iaXAzNzEuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wc2J0L3BzYnR1dGlscy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3B1c2hfZGF0YS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3NjcmlwdC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3NjcmlwdF9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfc2lnbmF0dXJlLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90eXBlcy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9iczU4Y2hlY2svYmFzZS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2JzNThjaGVjay9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9kYXJrcmVhZGVyL2RhcmtyZWFkZXIuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmUuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9uYW1lcy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9lczYtb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2hhcy1wcm90by9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9pcy1jYWxsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9qcy1zaGEyNTYvc3JjL3NoYTI1Ni5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvc2Nobm9yci1hZGFwdG9yLXBvaW50cy9zcmMvYWRhcHRvci5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3NjaG5vcnItYWRhcHRvci1wb2ludHMvc3JjL2NoZWNrLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9hcHAudHMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL3V0aWwvZHIudHMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL3V0aWwvbXUtc2lnLnRzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi91dGlsL3NjaG5vcnIudHMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL3V0aWwvdGVtcGxhdGVzLnRzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi91dGlsL3R4LnRzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9leHRyYS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdmFydWludC1iaXRjb2luL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy8uL25vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdGlueS1zZWNwMjU2azEvbGliL2luZGV4LmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdGlueS1zZWNwMjU2azEvbGliL3JhbmQuYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL2xpYi92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL2xpYi92YWxpZGF0ZV9lcnJvci5qcyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jLy4vbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL2xpYi93YXNtX2xvYWRlci5icm93c2VyLmpzIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheS10b29scy9zcmMvbWpzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jL3dlYnBhY2svcnVudGltZS9hbWQgb3B0aW9ucyIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jL3dlYnBhY2svcnVudGltZS9hc3luYyBtb2R1bGUiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2Mvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9tYXJsb3dlLXdvbGZyYW0td2ViZG9jL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy93ZWJwYWNrL3J1bnRpbWUvd2FzbSBsb2FkaW5nIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2Mvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vbWFybG93ZS13b2xmcmFtLXdlYmRvYy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2Mvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL21hcmxvd2Utd29sZnJhbS13ZWJkb2Mvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IG5ldyBVaW50MzJBcnJheShbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV0pO1xuY29uc3QgS3IgPSBuZXcgVWludDMyQXJyYXkoWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbFtncm91cF0sIGhiciA9IEtyW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIGYockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRltycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJJUEVNRDE2MCA9IFJJUEVNRDE2MDtcbi8qKlxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTEgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEExIHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uXG4vLyBJdCBpcyBzdGlsbCB3aWRlbHkgdXNlZCBpbiBsZWdhY3kgYXBwcy4gRG9uJ3QgdXNlIGl0IGZvciBhIG5ldyBwcm90b2NvbC5cbi8vIFJGQyAzMTc0XG5jb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gSW5pdGlhbCBzdGF0ZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEExX1cgPSBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBMSBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgZmFsc2UpO1xuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gcm90bChTSEExX1dbaSAtIDNdIF4gU0hBMV9XW2kgLSA4XSBeIFNIQTFfV1tpIC0gMTRdIF4gU0hBMV9XW2kgLSAxNl0sIDEpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBLO1xuICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9IE1haihCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKHJvdGwoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gcm90bChCLCAzMCk7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSBUO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTFfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnRzLnNoYTEgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEExKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbmV4cG9ydHMuYXN5bmNMb29wID0gYXN5bmNMb29wO1xuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZXJyb3JzJyksXG4gICAgX3JlcXVpcmUkY29kZXMgPSBfcmVxdWlyZS5jb2RlcyxcbiAgICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX0FSR19WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19WQUxVRSxcbiAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XG5cbnZhciBBc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvcicpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XG5cbnZhciBvYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IHJlcXVpcmUoJ2VzNi1vYmplY3QtYXNzaWduJykuYXNzaWduO1xudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogcmVxdWlyZSgnb2JqZWN0LWlzJyk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zJyk7XG5cbiAgaXNEZWVwRXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcEVxdWFsO1xuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XG59IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMgYnV0IG5vdCBcXG4gYW5kIFxcdCB0byBrZWVwIHRoZSBsaW5lIGJyZWFrcyBhbmRcbi8vIGluZGVudGF0aW9uIGludGFjdC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XG52YXIgbWV0YSA9IFtcIlxcXFx1MDAwMFwiLCBcIlxcXFx1MDAwMVwiLCBcIlxcXFx1MDAwMlwiLCBcIlxcXFx1MDAwM1wiLCBcIlxcXFx1MDAwNFwiLCBcIlxcXFx1MDAwNVwiLCBcIlxcXFx1MDAwNlwiLCBcIlxcXFx1MDAwN1wiLCAnXFxcXGInLCAnJywgJycsIFwiXFxcXHUwMDBiXCIsICdcXFxcZicsICcnLCBcIlxcXFx1MDAwZVwiLCBcIlxcXFx1MDAwZlwiLCBcIlxcXFx1MDAxMFwiLCBcIlxcXFx1MDAxMVwiLCBcIlxcXFx1MDAxMlwiLCBcIlxcXFx1MDAxM1wiLCBcIlxcXFx1MDAxNFwiLCBcIlxcXFx1MDAxNVwiLCBcIlxcXFx1MDAxNlwiLCBcIlxcXFx1MDAxN1wiLCBcIlxcXFx1MDAxOFwiLCBcIlxcXFx1MDAxOVwiLCBcIlxcXFx1MDAxYVwiLCBcIlxcXFx1MDAxYlwiLCBcIlxcXFx1MDAxY1wiLCBcIlxcXFx1MDAxZFwiLCBcIlxcXFx1MDAxZVwiLCBcIlxcXFx1MDAxZlwiXTtcblxudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gIHJldHVybiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcbn07XG5cbnZhciB3YXJuZWQgPSBmYWxzZTsgLy8gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xudmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9OyAvLyBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG9iai5tZXNzYWdlO1xuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGludGVybmFsTWVzc2FnZTtcblxuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgIGludGVybmFsTWVzc2FnZSA9ICdGYWlsZWQnO1xuICB9IGVsc2UgaWYgKGFyZ3NMZW4gPT09IDEpIHtcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHZhciB3YXJuID0gcHJvY2Vzcy5lbWl0V2FybmluZyA/IHByb2Nlc3MuZW1pdFdhcm5pbmcgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9JztcbiAgfVxuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XG4gIHZhciBlcnJBcmdzID0ge1xuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuIHx8IGZhaWxcbiAgfTtcblxuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncyk7XG5cbiAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuXG4gIHRocm93IGVycjtcbn1cblxuYXNzZXJ0LmZhaWwgPSBmYWlsOyAvLyBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBpbnRlcm5hbC9lcnJvci5cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG5cbiAgICBpZiAoYXJnTGVuID09PSAwKSB7XG4gICAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn0gLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISF2YWx1ZS5cblxuXG5mdW5jdGlvbiBvaygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQub2sgPSBvazsgLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxuLy8gZXF1YWwgd2l0aCAhPS5cblxuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cblxuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcblxuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKCFvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBDb21wYXJpc29uID0gZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgb2JqW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcbiAgaWYgKCEoa2V5IGluIGFjdHVhbCkgfHwgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKSkge1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICB2YXIgYSA9IG5ldyBDb21wYXJpc29uKGFjdHVhbCwga2V5cyk7XG4gICAgICB2YXIgYiA9IG5ldyBDb21wYXJpc29uKGV4cGVjdGVkLCBrZXlzLCBhY3R1YWwpO1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xuICAgICAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBtc2csIGZuKSB7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XG4gICAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cblxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gU3BlY2lhbCBoYW5kbGUgZXJyb3JzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBhbmQgdGhlIG1lc3NhZ2UgYXJlIGNvbXBhcmVkXG4gICAgLy8gYXMgd2VsbC5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnB1c2goJ25hbWUnLCAnbWVzc2FnZScpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2Vycm9yJywgZXhwZWN0ZWQsICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiYgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cblxuXG4gIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gY2hlY2tJc1Byb21pc2Uob2JqKSB7XG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgLy8gYGNhdGNoYCBoYW5kbGVyLlxuICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXG4gIC8vIGJ1dCBhY2NvcmRpbmcgdG8gZG9jdW1lbnRhdGlvbiwgdGhlIGB0aGVuYCBtZXRob2Qgc2hvdWxkIHJlY2VpdmVcbiAgLy8gdGhlIGBmdWxmaWxsYCBhbmQgYHJlamVjdGAgYXJndW1lbnRzIGFzIHdlbGwgb3IgaXQgbWF5IGJlIG5ldmVyIHJlc29sdmVkLlxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0UHJvbWlzZTtcblxuICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGlmIGBwcm9taXNlRm5gIHRocm93cyBzeW5jaHJvbm91c2x5LlxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpOyAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cblxuICAgICAgaWYgKCFjaGVja0lzUHJvbWlzZShyZXN1bHRQcm9taXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdpbnN0YW5jZSBvZiBQcm9taXNlJywgJ3Byb21pc2VGbicsIHJlc3VsdFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hlY2tJc1Byb21pc2UocHJvbWlzZUZuKSkge1xuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdwcm9taXNlRm4nLCBbJ0Z1bmN0aW9uJywgJ1Byb21pc2UnXSwgcHJvbWlzZUZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChhY3R1YWwubWVzc2FnZSA9PT0gZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBtZXNzYWdlIFxcXCJcIi5jb25jYXQoYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgXFxcIlwiLmNvbmNhdChhY3R1YWwsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCAmJiBfdHlwZW9mKGVycm9yKSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gIH1cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHtcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUpIHtcbiAgICAgIGRldGFpbHMgKz0gXCIgKFwiLmNvbmNhdChlcnJvci5uYW1lLCBcIilcIik7XG4gICAgfVxuXG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZXJyb3IgJiYgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UsIHN0YWNrU3RhcnRGbikpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0c05vRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgIHZhciBkZXRhaWxzID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAnZG9lc05vdFJlamVjdCcgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiR290IHVud2FudGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCBcIlxcblwiKSArIFwiQWN0dWFsIG1lc3NhZ2U6IFxcXCJcIi5jb25jYXQoYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlLCBcIlxcXCJcIiksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgYWN0dWFsO1xufVxuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbdGhyb3dzLCBnZXRBY3R1YWwocHJvbWlzZUZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5yZWplY3RzID0gZnVuY3Rpb24gcmVqZWN0cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuXG4gIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RUaHJvdywgZ2V0QWN0dWFsKGZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChmbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RSZWplY3QsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246ICc7XG5cbiAgICBpZiAoX3R5cGVvZihlcnIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIG5ld0VyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IGVycixcbiAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgb3BlcmF0b3I6ICdpZkVycm9yJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3JcbiAgICB9KTsgLy8gTWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzdGFjayB0cmFjZSFcblxuICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgLy8gZnJvbSB3aXRoaW4gYGlmRXJyb3JgIGFuZCBhZGQgdGhlIG9yaWdpbmFsIGVycm9yIGZyYW1lcyB0byB0aGUgbmV3bHlcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHRtcDIuc2hpZnQoKTsgLy8gRmlsdGVyIGFsbCBmcmFtZXMgZXhpc3RpbmcgaW4gZXJyLnN0YWNrLlxuXG4gICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBmcmFtZS5cbiAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKTtcblxuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgIC8vIE9ubHkga2VlcCBuZXcgZnJhbWVzLlxuICAgICAgICAgIHRtcDEgPSB0bXAxLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3RXJyLnN0YWNrID0gXCJcIi5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgXCJcXG5cIikuY29uY2F0KHRtcDIuam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHRocm93IG5ld0VycjtcbiAgfVxufTsgLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcblxuXG5mdW5jdGlvbiBzdHJpY3QoKSB7XG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzA4MTc4NDBmNzc1MDMyMTY5ZGRkNzBjODVhYzA1OWYxOGZmY2M4MWNcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3V0aWwvJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuLi9lcnJvcnMnKSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGNvdW50ID09IDApIHJldHVybiAnJztcbiAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50O1xuICBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2coY291bnQpIC8gTWF0aC5sb2coMikpO1xuXG4gIHdoaWxlIChjb3VudCkge1xuICAgIHN0ciArPSBzdHI7XG4gICAgY291bnQtLTtcbiAgfVxuXG4gIHN0ciArPSBzdHIuc3Vic3RyaW5nKDAsIG1heENvdW50IC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBibHVlID0gJyc7XG52YXIgZ3JlZW4gPSAnJztcbnZhciByZWQgPSAnJztcbnZhciB3aGl0ZSA9ICcnO1xudmFyIGtSZWFkYWJsZU9wZXJhdG9yID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBzdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86JyxcbiAgbm90SWRlbnRpY2FsOiAnVmFsdWVzIGlkZW50aWNhbCBidXQgbm90IHJlZmVyZW5jZS1lcXVhbDonXG59OyAvLyBDb21wYXJpbmcgc2hvcnQgcHJpbWl0aXZlcyBzaG91bGQganVzdCBzaG93ID09PSAvICE9PSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuLy8gZGlmZi5cblxudmFyIGtNYXhTaG9ydExlbmd0aCA9IDEwO1xuXG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICB2YWx1ZTogc291cmNlLm1lc3NhZ2VcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RWYWx1ZSh2YWwpIHtcbiAgLy8gVGhlIHV0aWwuaW5zcGVjdCBkZWZhdWx0IHZhbHVlcyBjb3VsZCBiZSBjaGFuZ2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gIC8vIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW4gdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBuZXZlcnRoZWxlc3MuXG4gIHJldHVybiBpbnNwZWN0KHZhbCwge1xuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgIGRlcHRoOiAxMDAwLFxuICAgIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgY29tcGFyZXMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgKHdpdGggYSBmZXcgZXhjZXB0aW9ucykuXG4gICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgLy8gSGF2aW5nIGEgbG9uZyBsaW5lIGFzIGVycm9yIGlzIGJldHRlciB0aGFuIHdyYXBwaW5nIHRoZSBsaW5lIGZvclxuICAgIC8vIGNvbXBhcmlzb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPKEJyaWRnZUFSKTogYGJyZWFrTGVuZ3RoYCBzaG91bGQgYmUgbGltaXRlZCBhcyBzb29uIGFzIHNvb24gYXMgd2VcbiAgICAvLyBoYXZlIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3BlY3RlZCBwcm9wZXJ0aWVzIChpLmUuLCBrbm93IHdoZXJlXG4gICAgLy8gaW4gd2hhdCBsaW5lIHRoZSBwcm9wZXJ0eSBzdGFydHMgYW5kIGVuZHMpLlxuICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgZG9lcyBub3QgZGV0ZWN0IHByb3hpZXMgY3VycmVudGx5LlxuICAgIHNob3dQcm94eTogZmFsc2UsXG4gICAgc29ydGVkOiB0cnVlLFxuICAgIC8vIEluc3BlY3QgZ2V0dGVycyBhcyB3ZSBhbHNvIGNoZWNrIHRoZW0gd2hlbiBjb21wYXJpbmcgZW50cmllcy5cbiAgICBnZXR0ZXJzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gIHZhciBvdGhlciA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGVuZCA9ICcnO1xuICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gIHZhciBhY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7XG4gIHZhciBleHBlY3RlZExpbmVzID0gaW5zcGVjdFZhbHVlKGV4cGVjdGVkKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGluZGljYXRvciA9ICcnOyAvLyBJbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzIGV4cGxpY2l0bHkgbWFyayB0aGVtIGFzIG5vdCByZWZlcmVuY2UgZXF1YWxcbiAgLy8gZm9yIHRoZSBgc3RyaWN0RXF1YWxgIG9wZXJhdG9yLlxuXG4gIGlmIChvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCc7XG4gIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcbiAgLy8gZXF1YWwsIGNoZWNrIGZ1cnRoZXIgc3BlY2lhbCBoYW5kbGluZy5cblxuXG4gIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDEgJiYgYWN0dWFsTGluZXNbMF0gIT09IGV4cGVjdGVkTGluZXNbMF0pIHtcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBhY3R1YWxMaW5lc1swXS5sZW5ndGggKyBleHBlY3RlZExpbmVzWzBdLmxlbmd0aDsgLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXG4gICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cblxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgIGlmICgoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmIChfdHlwZW9mKGV4cGVjdGVkKSAhPT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQgPT09IG51bGwpICYmIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApKSB7XG4gICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XG5cbiAgICAgIGlmIChpbnB1dExlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gLy8gSWdub3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICBpbmRpY2F0b3IgPSBcIlxcbiAgXCIuY29uY2F0KHJlcGVhdCgnICcsIGkpLCBcIl5cIik7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cblxuXG4gIHZhciBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuXG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQoYSkuY29uY2F0KGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG5cbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcbiAgICBleHBlY3RlZExpbmVzLnBvcCgpO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDAgfHwgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgICBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgdmFyIG1heExpbmVzID0gTWF0aC5tYXgoYWN0dWFsTGluZXMubGVuZ3RoLCBleHBlY3RlZExpbmVzLmxlbmd0aCk7IC8vIFN0cmljdCBlcXVhbCB3aXRoIGlkZW50aWNhbCBvYmplY3RzIHRoYXQgYXJlIG5vdCBpZGVudGljYWwgYnkgcmVmZXJlbmNlLlxuICAvLyBFLmcuLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHsgYTogU3ltYm9sKCkgfSwgeyBhOiBTeW1ib2woKSB9KVxuXG4gIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgIC8vIFdlIGhhdmUgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW4uIFRoZSBsaW5lcyB3ZXJlIGFsbCByZW1vdmVkIGJlZm9yZS5cbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTsgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICBpZiAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICBfYWN0dWFsTGluZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgd2hpbGUgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAyNykge1xuICAgICAgICBfYWN0dWFsTGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgXCJcXG5cXG5cIikuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgXCJcXG5cIik7XG4gIH1cblxuICBpZiAoaSA+IDMpIHtcbiAgICBlbmQgPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpO1xuICAgIHNraXBwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG90aGVyICE9PSAnJykge1xuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xuICAgIG90aGVyID0gJyc7XG4gIH1cblxuICB2YXIgcHJpbnRlZExpbmVzID0gMDtcbiAgdmFyIG1zZyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSArIFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIisgYWN0dWFsXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChyZWQsIFwiLSBleHBlY3RlZFwiKS5jb25jYXQod2hpdGUpO1xuICB2YXIgc2tpcHBlZE1zZyA9IFwiIFwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUsIFwiIExpbmVzIHNraXBwZWRcIik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XG4gICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zO1xuXG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuXG4gICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIExpbmVzIGRpdmVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XG4gICAgICB2YXIgYWN0dWFsTGluZSA9IGFjdHVhbExpbmVzW2ldOyAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgLy8gYSB0cmFpbGluZyBjb21tYS4gSW4gdGhhdCBjYXNlIGl0IGlzIGFjdHVhbGx5IGlkZW50aWNhbCBhbmQgd2Ugc2hvdWxkXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG5cbiAgICAgIHZhciBkaXZlcmdpbmdMaW5lcyA9IGFjdHVhbExpbmUgIT09IGV4cGVjdGVkTGluZSAmJiAoIWVuZHNXaXRoKGFjdHVhbExpbmUsICcsJykgfHwgYWN0dWFsTGluZS5zbGljZSgwLCAtMSkgIT09IGV4cGVjdGVkTGluZSk7IC8vIElmIHRoZSBleHBlY3RlZCBsaW5lIGhhcyBhIHRyYWlsaW5nIGNvbW1hIGJ1dCBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLFxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgW1xuICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgLy8gKyAgIDJcbiAgICAgIC8vICAgXVxuICAgICAgLy9cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XG4gICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbExpbmUgKz0gJywnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0IGFuZCBjYWNoZSB0aGUgZXhwZWN0ZWQgZGl2ZXJnaW5nXG4gICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxuXG4gICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XG4gICAgICAgIHByaW50ZWRMaW5lcyArPSAyOyAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgIHJlcyArPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSAnJzsgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgLy8gdmVyeSBmaXJzdCBsaW5lLCBhZGQgdGhlIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuXG5cbiAgICBpZiAocHJpbnRlZExpbmVzID4gMjAgJiYgaSA8IG1heExpbmVzIC0gMikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWRNc2csIFwiXFxuXCIpLmNvbmNhdChyZXMsIFwiXFxuXCIpLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChvdGhlciwgXCJcXG5cIikgKyBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkID8gc2tpcHBlZE1zZyA6ICcnLCBcIlxcblwiKS5jb25jYXQocmVzKS5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpLmNvbmNhdChpbmRpY2F0b3IpO1xufVxuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XG5cbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuO1xuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuXG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgU3RyaW5nKG1lc3NhZ2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMSkge1xuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xuICAgICAgICAgIGdyZWVuID0gXCJcXHgxQlszMm1cIjtcbiAgICAgICAgICB3aGl0ZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibHVlID0gJyc7XG4gICAgICAgICAgZ3JlZW4gPSAnJztcbiAgICAgICAgICB3aGl0ZSA9ICcnO1xuICAgICAgICAgIHJlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgdGhlIGVycm9yIHN0YWNrIGZyb20gYmVpbmcgdmlzaWJsZSBieSBkdXBsaWNhdGluZyB0aGUgZXJyb3JcbiAgICAgIC8vIGluIGEgdmVyeSBjbG9zZSB3YXkgdG8gdGhlIG9yaWdpbmFsIGluIGNhc2UgYm90aCBzaWRlcyBhcmUgYWN0dWFsbHlcbiAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cblxuXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhY3R1YWwgPSBjb3B5RXJyb3IoYWN0dWFsKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKSk7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJykge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBidXQgdGhlIG9wZXJhdG9yIHJlcXVpcmVzIHVuZXF1YWwsIHNob3dcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcbiAgICAgICAgdmFyIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJyk7IC8vIEluIGNhc2UgXCJhY3R1YWxcIiBpcyBhbiBvYmplY3QsIGl0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlIGVxdWFsLlxuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvci5ub3RTdHJpY3RFcXVhbE9iamVjdDtcbiAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgIHJlc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggPiAyNykge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPbmx5IHByaW50IGEgc2luZ2xlIGlucHV0LlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIiBcIikuY29uY2F0KHJlc1swXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIlxcblxcblwiKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuXG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xuICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDEwMjEpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChvdGhlci5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnZXF1YWwnKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa25vd25PcGVyYXRvcnMsIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzLCBcIlxcblxcbnNob3VsZCBlcXVhbFxcblxcblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXIgPSBcIiBcIi5jb25jYXQob3BlcmF0b3IsIFwiIFwiKS5jb25jYXQob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnQXNzZXJ0aW9uRXJyb3IgW0VSUl9BU1NFUlRJT05dJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIF90aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHN0YWNrU3RhcnRGbik7XG4gICAgfSAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGUgaW4gdGhlIG5hbWUuXG5cblxuICAgIF90aGlzLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZS5cblxuICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXNzZXJ0aW9uRXJyb3IsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgW1wiKS5jb25jYXQodGhpcy5jb2RlLCBcIl06IFwiKS5jb25jYXQodGhpcy5tZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IGluc3BlY3QuY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgLy8gVGhpcyBsaW1pdHMgdGhlIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIHByb3BlcnR5IGRlZmF1bHQgaW5zcGVjdGlvbiB0b1xuICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAvLyBpbnB1dCB2YWx1ZXMuXG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBjdHgsIHtcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuJ3VzZSBzdHJpY3QnOyAvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBjb2RlcyA9IHt9OyAvLyBMYXp5IGxvYWRlZFxuXG52YXIgYXNzZXJ0O1xudmFyIHV0aWw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZUVycm9yKS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpKTtcbiAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9BTUJJR1VPVVNfQVJHVU1FTlQnLCAnVGhlIFwiJXNcIiBhcmd1bWVudCBpcyBhbWJpZ3VvdXMuICVzJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpOyAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG5cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2lzIGludmFsaWQnO1xuICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKSB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XG5cbiAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XG4gIH1cblxuICByZXR1cm4gXCJUaGUgYXJndW1lbnQgJ1wiLmNvbmNhdChuYW1lLCBcIicgXCIpLmNvbmNhdChyZWFzb24sIFwiLiBSZWNlaXZlZCBcIikuY29uY2F0KGluc3BlY3RlZCk7XG59LCBUeXBlRXJyb3IsIFJhbmdlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLCBmdW5jdGlvbiAoaW5wdXQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcInR5cGUgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiLmNvbmNhdChpbnB1dCwgXCIgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcIlwiKS5jb25jYXQobmFtZSwgXCJcXFwiXCIpICsgXCIgZnVuY3Rpb24gYnV0IGdvdCBcIi5jb25jYXQodHlwZSwgXCIuXCIpO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01JU1NJTkdfQVJHUycsIGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzOyIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufTtcbnZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTiA/IE51bWJlci5pc05hTiA6IHJlcXVpcmUoJ2lzLW5hbicpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSByZXF1aXJlKCd1dGlsLycpLnR5cGVzLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07IiwiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpXG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iZWNoMzJtID0gZXhwb3J0cy5iZWNoMzIgPSB2b2lkIDA7XG5jb25zdCBBTFBIQUJFVCA9ICdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCc7XG5jb25zdCBBTFBIQUJFVF9NQVAgPSB7fTtcbmZvciAobGV0IHogPSAwOyB6IDwgQUxQSEFCRVQubGVuZ3RoOyB6KyspIHtcbiAgICBjb25zdCB4ID0gQUxQSEFCRVQuY2hhckF0KHopO1xuICAgIEFMUEhBQkVUX01BUFt4XSA9IHo7XG59XG5mdW5jdGlvbiBwb2x5bW9kU3RlcChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIHJldHVybiAoKChwcmUgJiAweDFmZmZmZmYpIDw8IDUpIF5cbiAgICAgICAgKC0oKGIgPj4gMCkgJiAxKSAmIDB4M2I2YTU3YjIpIF5cbiAgICAgICAgKC0oKGIgPj4gMSkgJiAxKSAmIDB4MjY1MDhlNmQpIF5cbiAgICAgICAgKC0oKGIgPj4gMikgJiAxKSAmIDB4MWVhMTE5ZmEpIF5cbiAgICAgICAgKC0oKGIgPj4gMykgJiAxKSAmIDB4M2Q0MjMzZGQpIF5cbiAgICAgICAgKC0oKGIgPj4gNCkgJiAxKSAmIDB4MmExNDYyYjMpKTtcbn1cbmZ1bmN0aW9uIHByZWZpeENoayhwcmVmaXgpIHtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBwcmVmaXggKCcgKyBwcmVmaXggKyAnKSc7XG4gICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2ID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAodiAmIDB4MWYpO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gY29udmVydChkYXRhLCBpbkJpdHMsIG91dEJpdHMsIHBhZCkge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGNvbnN0IG1heFYgPSAoMSA8PCBvdXRCaXRzKSAtIDE7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIDw8IGluQml0cykgfCBkYXRhW2ldO1xuICAgICAgICBiaXRzICs9IGluQml0cztcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gb3V0Qml0cykge1xuICAgICAgICAgICAgYml0cyAtPSBvdXRCaXRzO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHZhbHVlID4+IGJpdHMpICYgbWF4Vik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhZCkge1xuICAgICAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoYml0cyA+PSBpbkJpdHMpXG4gICAgICAgICAgICByZXR1cm4gJ0V4Y2VzcyBwYWRkaW5nJztcbiAgICAgICAgaWYgKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpXG4gICAgICAgICAgICByZXR1cm4gJ05vbi16ZXJvIHBhZGRpbmcnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9Xb3JkcyhieXRlcykge1xuICAgIHJldHVybiBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Xb3Jkc1Vuc2FmZSh3b3Jkcykge1xuICAgIGNvbnN0IHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKVxuICAgICAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZnJvbVdvcmRzKHdvcmRzKSB7XG4gICAgY29uc3QgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKHJlcyk7XG59XG5mdW5jdGlvbiBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgbGV0IEVOQ09ESU5HX0NPTlNUO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2JlY2gzMicpIHtcbiAgICAgICAgRU5DT0RJTkdfQ09OU1QgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgRU5DT0RJTkdfQ09OU1QgPSAweDJiYzgzMGEzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgTElNSVQpIHtcbiAgICAgICAgTElNSVQgPSBMSU1JVCB8fCA5MDtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoID4gTElNSVQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNlZWRzIGxlbmd0aCBsaW1pdCcpO1xuICAgICAgICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGNoayBtb2RcbiAgICAgICAgbGV0IGNoayA9IHByZWZpeENoayhwcmVmaXgpO1xuICAgICAgICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hrKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHByZWZpeCArICcxJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgaWYgKHggPj4gNSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiA1LWJpdCB3b3JkJyk7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4geDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoayk7XG4gICAgICAgIH1cbiAgICAgICAgY2hrIF49IEVOQ09ESU5HX0NPTlNUO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IChjaGsgPj4gKCg1IC0gaSkgKiA1KSkgJiAweDFmO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfX2RlY29kZShzdHIsIExJTUlUKSB7XG4gICAgICAgIExJTUlUID0gTElNSVQgfHwgOTA7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDwgOClcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnIHRvbyBzaG9ydCc7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gTElNSVQpXG4gICAgICAgICAgICByZXR1cm4gJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0JztcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHVwcGVyZWQgPSBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHVwcGVyZWQpXG4gICAgICAgICAgICByZXR1cm4gJ01peGVkLWNhc2Ugc3RyaW5nICcgKyBzdHI7XG4gICAgICAgIHN0ciA9IGxvd2VyZWQ7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzcGxpdCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gJ05vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yICcgKyBzdHI7XG4gICAgICAgIGlmIChzcGxpdCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAnTWlzc2luZyBwcmVmaXggZm9yICcgKyBzdHI7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzcGxpdCk7XG4gICAgICAgIGNvbnN0IHdvcmRDaGFycyA9IHN0ci5zbGljZShzcGxpdCArIDEpO1xuICAgICAgICBpZiAod29yZENoYXJzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICByZXR1cm4gJ0RhdGEgdG9vIHNob3J0JztcbiAgICAgICAgbGV0IGNoayA9IHByZWZpeENoayhwcmVmaXgpO1xuICAgICAgICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gY2hrO1xuICAgICAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHdvcmRDaGFycy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb25zdCB2ID0gQUxQSEFCRVRfTUFQW2NdO1xuICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1Vua25vd24gY2hhcmFjdGVyICcgKyBjO1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHY7XG4gICAgICAgICAgICAvLyBub3QgaW4gdGhlIGNoZWNrc3VtP1xuICAgICAgICAgICAgaWYgKGkgKyA2ID49IHdvcmRDaGFycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGsgIT09IEVOQ09ESU5HX0NPTlNUKVxuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIGNoZWNrc3VtIGZvciAnICsgc3RyO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVVuc2FmZShzdHIsIExJTUlUKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZGVjb2RlKHN0ciwgTElNSVQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBMSU1JVCkge1xuICAgICAgICBjb25zdCByZXMgPSBfX2RlY29kZShzdHIsIExJTUlUKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlY29kZVVuc2FmZSxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIHRvV29yZHMsXG4gICAgICAgIGZyb21Xb3Jkc1Vuc2FmZSxcbiAgICAgICAgZnJvbVdvcmRzLFxuICAgIH07XG59XG5leHBvcnRzLmJlY2gzMiA9IGdldExpYnJhcnlGcm9tRW5jb2RpbmcoJ2JlY2gzMicpO1xuZXhwb3J0cy5iZWNoMzJtID0gZ2V0TGlicmFyeUZyb21FbmNvZGluZygnYmVjaDMybScpO1xuIiwiLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcbmZ1bmN0aW9uIEJpZ0ludGVnZXIoYSwgYiwgYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmlnSW50ZWdlcikpXG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGEsIGIsIGMpXG5cbiAgaWYgKGEgIT0gbnVsbCkge1xuICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBhKSB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYylcbiAgICBlbHNlIGlmIChiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgdGhpcy5mcm9tU3RyaW5nKGEsIDI1NilcbiAgICBlbHNlIHRoaXMuZnJvbVN0cmluZyhhLCBiKVxuICB9XG59XG5cbnZhciBwcm90byA9IEJpZ0ludGVnZXIucHJvdG90eXBlXG5cbi8vIGR1Y2stdHlwZWQgaXNCaWdJbnRlZ2VyXG5wcm90by5fX2JpZ2kgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5CaWdJbnRlZ2VyLmlzQmlnSW50ZWdlciA9IGZ1bmN0aW9uIChvYmosIGNoZWNrX3Zlcikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2JpZ2kgJiYgKCFjaGVja192ZXIgfHwgb2JqLl9fYmlnaSA9PT0gcHJvdG8uX19iaWdpKVxufVxuXG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzXG5cbi8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2Fycmllcyxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbi8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbi8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSwgeCwgdywgaiwgYywgbikge1xuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgdiA9IHggKiB0aGlzW2krK10gKyB3W2pdICsgY1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyAweDQwMDAwMDApXG4gICAgd1tqKytdID0gdiAmIDB4M2ZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG4vLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbi8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4vLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG5mdW5jdGlvbiBhbTIoaSwgeCwgdywgaiwgYywgbikge1xuICB2YXIgeGwgPSB4ICYgMHg3ZmZmLFxuICAgIHhoID0geCA+PiAxNVxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDdmZmZcbiAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNVxuICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsXG4gICAgbCA9IHhsICogbCArICgobSAmIDB4N2ZmZikgPDwgMTUpICsgd1tqXSArIChjICYgMHgzZmZmZmZmZilcbiAgICBjID0gKGwgPj4+IDMwKSArIChtID4+PiAxNSkgKyB4aCAqIGggKyAoYyA+Pj4gMzApXG4gICAgd1tqKytdID0gbCAmIDB4M2ZmZmZmZmZcbiAgfVxuICByZXR1cm4gY1xufVxuLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4vLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG5mdW5jdGlvbiBhbTMoaSwgeCwgdywgaiwgYywgbikge1xuICB2YXIgeGwgPSB4ICYgMHgzZmZmLFxuICAgIHhoID0geCA+PiAxNFxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDNmZmZcbiAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNFxuICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsXG4gICAgbCA9IHhsICogbCArICgobSAmIDB4M2ZmZikgPDwgMTQpICsgd1tqXSArIGNcbiAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoXG4gICAgd1tqKytdID0gbCAmIDB4ZmZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG5cbi8vIHd0Zj9cbkJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xXG5kYml0cyA9IDI2XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHNcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxIDw8IGRiaXRzKSAtIDEpXG52YXIgRFYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxIDw8IGRiaXRzKVxuXG52YXIgQklfRlAgPSA1MlxuQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLCBCSV9GUClcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAgLSBkYml0c1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUFxuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIlxudmFyIEJJX1JDID0gbmV3IEFycmF5KClcbnZhciByciwgdnZcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDA7IHZ2IDw9IDk7ICsrdnYpIEJJX1JDW3JyKytdID0gdnZcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMClcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2dlxuXG5mdW5jdGlvbiBpbnQyY2hhcihuKSB7XG4gIHJldHVybiBCSV9STS5jaGFyQXQobilcbn1cblxuZnVuY3Rpb24gaW50QXQocywgaSkge1xuICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV1cbiAgcmV0dXJuIChjID09IG51bGwpID8gLTEgOiBjXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG5mdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSB0aGlzW2ldXG4gIHIudCA9IHRoaXMudFxuICByLnMgPSB0aGlzLnNcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG5mdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgdGhpcy50ID0gMVxuICB0aGlzLnMgPSAoeCA8IDApID8gLTEgOiAwXG4gIGlmICh4ID4gMCkgdGhpc1swXSA9IHhcbiAgZWxzZSBpZiAoeCA8IC0xKSB0aGlzWzBdID0geCArIERWXG4gIGVsc2UgdGhpcy50ID0gMFxufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgci5mcm9tSW50KGkpXG4gIHJldHVybiByXG59XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocywgYikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIga1xuICBpZiAoYiA9PSAxNikgayA9IDRcbiAgZWxzZSBpZiAoYiA9PSA4KSBrID0gM1xuICBlbHNlIGlmIChiID09IDI1NikgayA9IDg7IC8vIGJ5dGUgYXJyYXlcbiAgZWxzZSBpZiAoYiA9PSAyKSBrID0gMVxuICBlbHNlIGlmIChiID09IDMyKSBrID0gNVxuICBlbHNlIGlmIChiID09IDQpIGsgPSAyXG4gIGVsc2Uge1xuICAgIHNlbGYuZnJvbVJhZGl4KHMsIGIpXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi50ID0gMFxuICBzZWxmLnMgPSAwXG4gIHZhciBpID0gcy5sZW5ndGgsXG4gICAgbWkgPSBmYWxzZSxcbiAgICBzaCA9IDBcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoayA9PSA4KSA/IHNbaV0gJiAweGZmIDogaW50QXQocywgaSlcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBtaSA9IGZhbHNlXG4gICAgaWYgKHNoID09IDApXG4gICAgICBzZWxmW3NlbGYudCsrXSA9IHhcbiAgICBlbHNlIGlmIChzaCArIGsgPiBzZWxmLkRCKSB7XG4gICAgICBzZWxmW3NlbGYudCAtIDFdIHw9ICh4ICYgKCgxIDw8IChzZWxmLkRCIC0gc2gpKSAtIDEpKSA8PCBzaFxuICAgICAgc2VsZltzZWxmLnQrK10gPSAoeCA+PiAoc2VsZi5EQiAtIHNoKSlcbiAgICB9IGVsc2VcbiAgICAgIHNlbGZbc2VsZi50IC0gMV0gfD0geCA8PCBzaFxuICAgIHNoICs9IGtcbiAgICBpZiAoc2ggPj0gc2VsZi5EQikgc2ggLT0gc2VsZi5EQlxuICB9XG4gIGlmIChrID09IDggJiYgKHNbMF0gJiAweDgwKSAhPSAwKSB7XG4gICAgc2VsZi5zID0gLTFcbiAgICBpZiAoc2ggPiAwKSBzZWxmW3NlbGYudCAtIDFdIHw9ICgoMSA8PCAoc2VsZi5EQiAtIHNoKSkgLSAxKSA8PCBzaFxuICB9XG4gIHNlbGYuY2xhbXAoKVxuICBpZiAobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLCBzZWxmKVxufVxuXG4vLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbmZ1bmN0aW9uIGJucENsYW1wKCkge1xuICB2YXIgYyA9IHRoaXMucyAmIHRoaXMuRE1cbiAgd2hpbGUgKHRoaXMudCA+IDAgJiYgdGhpc1t0aGlzLnQgLSAxXSA9PSBjKS0tdGhpcy50XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gZ2l2ZW4gcmFkaXhcbmZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYucyA8IDApIHJldHVybiBcIi1cIiArIHNlbGYubmVnYXRlKClcbiAgICAudG9TdHJpbmcoYilcbiAgdmFyIGtcbiAgaWYgKGIgPT0gMTYpIGsgPSA0XG4gIGVsc2UgaWYgKGIgPT0gOCkgayA9IDNcbiAgZWxzZSBpZiAoYiA9PSAyKSBrID0gMVxuICBlbHNlIGlmIChiID09IDMyKSBrID0gNVxuICBlbHNlIGlmIChiID09IDQpIGsgPSAyXG4gIGVsc2UgcmV0dXJuIHNlbGYudG9SYWRpeChiKVxuICB2YXIga20gPSAoMSA8PCBrKSAtIDEsXG4gICAgZCwgbSA9IGZhbHNlLFxuICAgIHIgPSBcIlwiLFxuICAgIGkgPSBzZWxmLnRcbiAgdmFyIHAgPSBzZWxmLkRCIC0gKGkgKiBzZWxmLkRCKSAlIGtcbiAgaWYgKGktLSA+IDApIHtcbiAgICBpZiAocCA8IHNlbGYuREIgJiYgKGQgPSBzZWxmW2ldID4+IHApID4gMCkge1xuICAgICAgbSA9IHRydWVcbiAgICAgIHIgPSBpbnQyY2hhcihkKVxuICAgIH1cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICBpZiAocCA8IGspIHtcbiAgICAgICAgZCA9IChzZWxmW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcClcbiAgICAgICAgZCB8PSBzZWxmWy0taV0gPj4gKHAgKz0gc2VsZi5EQiAtIGspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gKHNlbGZbaV0gPj4gKHAgLT0gaykpICYga21cbiAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgIHAgKz0gc2VsZi5EQlxuICAgICAgICAgIC0taVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZCA+IDApIG0gPSB0cnVlXG4gICAgICBpZiAobSkgciArPSBpbnQyY2hhcihkKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbSA/IHIgOiBcIjBcIlxufVxuXG4vLyAocHVibGljKSAtdGhpc1xuZnVuY3Rpb24gYm5OZWdhdGUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHtcbiAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zIC0gYS5zXG4gIGlmIChyICE9IDApIHJldHVybiByXG4gIHZhciBpID0gdGhpcy50XG4gIHIgPSBpIC0gYS50XG4gIGlmIChyICE9IDApIHJldHVybiAodGhpcy5zIDwgMCkgPyAtciA6IHJcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIGlmICgociA9IHRoaXNbaV0gLSBhW2ldKSAhPSAwKSByZXR1cm4gclxuICByZXR1cm4gMFxufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsXG4gICAgdFxuICBpZiAoKHQgPSB4ID4+PiAxNikgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAxNlxuICB9XG4gIGlmICgodCA9IHggPj4gOCkgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSA4XG4gIH1cbiAgaWYgKCh0ID0geCA+PiA0KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDRcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDIpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gMlxuICB9XG4gIGlmICgodCA9IHggPj4gMSkgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAxXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcInRoaXNcIlxuZnVuY3Rpb24gYm5CaXRMZW5ndGgoKSB7XG4gIGlmICh0aGlzLnQgPD0gMCkgcmV0dXJuIDBcbiAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzW3RoaXMudCAtIDFdIF4gKHRoaXMucyAmIHRoaXMuRE0pKVxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiBcInRoaXNcIlxuZnVuY3Rpb24gYm5CeXRlTGVuZ3RoKCkge1xuICByZXR1cm4gdGhpcy5iaXRMZW5ndGgoKSA+PiAzXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcbmZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLCByKSB7XG4gIHZhciBpXG4gIGZvciAoaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSByW2kgKyBuXSA9IHRoaXNbaV1cbiAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSByW2ldID0gMFxuICByLnQgPSB0aGlzLnQgKyBuXG4gIHIucyA9IHRoaXMuc1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuKkRCXG5mdW5jdGlvbiBibnBEUlNoaWZ0VG8obiwgcikge1xuICBmb3IgKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByW2kgLSBuXSA9IHRoaXNbaV1cbiAgci50ID0gTWF0aC5tYXgodGhpcy50IC0gbiwgMClcbiAgci5zID0gdGhpcy5zXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJucExTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBicyA9IG4gJSBzZWxmLkRCXG4gIHZhciBjYnMgPSBzZWxmLkRCIC0gYnNcbiAgdmFyIGJtID0gKDEgPDwgY2JzKSAtIDFcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gc2VsZi5EQiksXG4gICAgYyA9IChzZWxmLnMgPDwgYnMpICYgc2VsZi5ETSxcbiAgICBpXG4gIGZvciAoaSA9IHNlbGYudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgcltpICsgZHMgKyAxXSA9IChzZWxmW2ldID4+IGNicykgfCBjXG4gICAgYyA9IChzZWxmW2ldICYgYm0pIDw8IGJzXG4gIH1cbiAgZm9yIChpID0gZHMgLSAxOyBpID49IDA7IC0taSkgcltpXSA9IDBcbiAgcltkc10gPSBjXG4gIHIudCA9IHNlbGYudCArIGRzICsgMVxuICByLnMgPSBzZWxmLnNcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJucFJTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHIucyA9IHNlbGYuc1xuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyBzZWxmLkRCKVxuICBpZiAoZHMgPj0gc2VsZi50KSB7XG4gICAgci50ID0gMFxuICAgIHJldHVyblxuICB9XG4gIHZhciBicyA9IG4gJSBzZWxmLkRCXG4gIHZhciBjYnMgPSBzZWxmLkRCIC0gYnNcbiAgdmFyIGJtID0gKDEgPDwgYnMpIC0gMVxuICByWzBdID0gc2VsZltkc10gPj4gYnNcbiAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHNlbGYudDsgKytpKSB7XG4gICAgcltpIC0gZHMgLSAxXSB8PSAoc2VsZltpXSAmIGJtKSA8PCBjYnNcbiAgICByW2kgLSBkc10gPSBzZWxmW2ldID4+IGJzXG4gIH1cbiAgaWYgKGJzID4gMCkgcltzZWxmLnQgLSBkcyAtIDFdIHw9IChzZWxmLnMgJiBibSkgPDwgY2JzXG4gIHIudCA9IHNlbGYudCAtIGRzXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbmZ1bmN0aW9uIGJucFN1YlRvKGEsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpID0gMCxcbiAgICBjID0gMCxcbiAgICBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGMgKz0gc2VsZltpXSAtIGFbaV1cbiAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgIGMgPj49IHNlbGYuREJcbiAgfVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgYyAtPSBhLnNcbiAgICB3aGlsZSAoaSA8IHNlbGYudCkge1xuICAgICAgYyArPSBzZWxmW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IHNlbGYuc1xuICB9IGVsc2Uge1xuICAgIGMgKz0gc2VsZi5zXG4gICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgIGMgLT0gYVtpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyAtPSBhLnNcbiAgfVxuICByLnMgPSAoYyA8IDApID8gLTEgOiAwXG4gIGlmIChjIDwgLTEpIHJbaSsrXSA9IHNlbGYuRFYgKyBjXG4gIGVsc2UgaWYgKGMgPiAwKSByW2krK10gPSBjXG4gIHIudCA9IGlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICogYSwgciAhPSB0aGlzLGEgKEhBQyAxNC4xMilcbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSwgcikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksXG4gICAgeSA9IGEuYWJzKClcbiAgdmFyIGkgPSB4LnRcbiAgci50ID0gaSArIHkudFxuICB3aGlsZSAoLS1pID49IDApIHJbaV0gPSAwXG4gIGZvciAoaSA9IDA7IGkgPCB5LnQ7ICsraSkgcltpICsgeC50XSA9IHguYW0oMCwgeVtpXSwgciwgaSwgMCwgeC50KVxuICByLnMgPSAwXG4gIHIuY2xhbXAoKVxuICBpZiAodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICB2YXIgeCA9IHRoaXMuYWJzKClcbiAgdmFyIGkgPSByLnQgPSAyICogeC50XG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IHgudCAtIDE7ICsraSkge1xuICAgIHZhciBjID0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSlcbiAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XG4gICAgICByW2kgKyB4LnRdIC09IHguRFZcbiAgICAgIHJbaSArIHgudCArIDFdID0gMVxuICAgIH1cbiAgfVxuICBpZiAoci50ID4gMCkgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKVxuICByLnMgPSAwXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSwgcSwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBtID0gbS5hYnMoKVxuICBpZiAocG0udCA8PSAwKSByZXR1cm5cbiAgdmFyIHB0ID0gc2VsZi5hYnMoKVxuICBpZiAocHQudCA8IHBtLnQpIHtcbiAgICBpZiAocSAhPSBudWxsKSBxLmZyb21JbnQoMClcbiAgICBpZiAociAhPSBudWxsKSBzZWxmLmNvcHlUbyhyKVxuICAgIHJldHVyblxuICB9XG4gIGlmIChyID09IG51bGwpIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHZhciB5ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB0cyA9IHNlbGYucyxcbiAgICBtcyA9IG0uc1xuICB2YXIgbnNoID0gc2VsZi5EQiAtIG5iaXRzKHBtW3BtLnQgLSAxXSk7IC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmIChuc2ggPiAwKSB7XG4gICAgcG0ubFNoaWZ0VG8obnNoLCB5KVxuICAgIHB0LmxTaGlmdFRvKG5zaCwgcilcbiAgfSBlbHNlIHtcbiAgICBwbS5jb3B5VG8oeSlcbiAgICBwdC5jb3B5VG8ocilcbiAgfVxuICB2YXIgeXMgPSB5LnRcbiAgdmFyIHkwID0geVt5cyAtIDFdXG4gIGlmICh5MCA9PSAwKSByZXR1cm5cbiAgdmFyIHl0ID0geTAgKiAoMSA8PCBzZWxmLkYxKSArICgoeXMgPiAxKSA/IHlbeXMgLSAyXSA+PiBzZWxmLkYyIDogMClcbiAgdmFyIGQxID0gc2VsZi5GViAvIHl0LFxuICAgIGQyID0gKDEgPDwgc2VsZi5GMSkgLyB5dCxcbiAgICBlID0gMSA8PCBzZWxmLkYyXG4gIHZhciBpID0gci50LFxuICAgIGogPSBpIC0geXMsXG4gICAgdCA9IChxID09IG51bGwpID8gbmV3IEJpZ0ludGVnZXIoKSA6IHFcbiAgeS5kbFNoaWZ0VG8oaiwgdClcbiAgaWYgKHIuY29tcGFyZVRvKHQpID49IDApIHtcbiAgICByW3IudCsrXSA9IDFcbiAgICByLnN1YlRvKHQsIHIpXG4gIH1cbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLCB0KVxuICB0LnN1YlRvKHksIHkpOyAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICB3aGlsZSAoeS50IDwgeXMpIHlbeS50KytdID0gMFxuICB3aGlsZSAoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyWy0taV0gPT0geTApID8gc2VsZi5ETSA6IE1hdGguZmxvb3IocltpXSAqIGQxICsgKHJbaSAtIDFdICsgZSkgKiBkMilcbiAgICBpZiAoKHJbaV0gKz0geS5hbSgwLCBxZCwgciwgaiwgMCwgeXMpKSA8IHFkKSB7IC8vIFRyeSBpdCBvdXRcbiAgICAgIHkuZGxTaGlmdFRvKGosIHQpXG4gICAgICByLnN1YlRvKHQsIHIpXG4gICAgICB3aGlsZSAocltpXSA8IC0tcWQpIHIuc3ViVG8odCwgcilcbiAgICB9XG4gIH1cbiAgaWYgKHEgIT0gbnVsbCkge1xuICAgIHIuZHJTaGlmdFRvKHlzLCBxKVxuICAgIGlmICh0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpXG4gIH1cbiAgci50ID0geXNcbiAgci5jbGFtcCgpXG4gIGlmIChuc2ggPiAwKSByLnJTaGlmdFRvKG5zaCwgcik7IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICBpZiAodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcilcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5hYnMoKVxuICAgIC5kaXZSZW1UbyhhLCBudWxsLCByKVxuICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLCByKVxuICByZXR1cm4gclxufVxuXG4vLyBNb2R1bGFyIHJlZHVjdGlvbiB1c2luZyBcImNsYXNzaWNcIiBhbGdvcml0aG1cbmZ1bmN0aW9uIENsYXNzaWMobSkge1xuICB0aGlzLm0gPSBtXG59XG5cbmZ1bmN0aW9uIGNDb252ZXJ0KHgpIHtcbiAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSByZXR1cm4geC5tb2QodGhpcy5tKVxuICBlbHNlIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIGNSZXZlcnQoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBjUmVkdWNlKHgpIHtcbiAgeC5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHgpXG59XG5cbmZ1bmN0aW9uIGNNdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5mdW5jdGlvbiBjU3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydFxuQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydFxuQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZVxuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG9cbkNsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvXG5cbi8vIChwcm90ZWN0ZWQpIHJldHVybiBcIi0xL3RoaXMgJSAyXkRCXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXG4vLyBqdXN0aWZpY2F0aW9uOlxuLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbi8vICAgICAgICAgeHkgPSAgMStrbVxuLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4vLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXG4vLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4vLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbi8vIEpTIG11bHRpcGx5IFwib3ZlcmZsb3dzXCIgZGlmZmVyZW50bHkgZnJvbSBDL0MrKywgc28gY2FyZSBpcyBuZWVkZWQgaGVyZS5cbmZ1bmN0aW9uIGJucEludkRpZ2l0KCkge1xuICBpZiAodGhpcy50IDwgMSkgcmV0dXJuIDBcbiAgdmFyIHggPSB0aGlzWzBdXG4gIGlmICgoeCAmIDEpID09IDApIHJldHVybiAwXG4gIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZikgKiB5KSkgJiAweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZmYpICogeSkpICYgMHhmZjsgLy8geSA9PSAxL3ggbW9kIDJeOFxuICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseVxuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5ICogKDIgLSB4ICogeSAlIHRoaXMuRFYpKSAlIHRoaXMuRFY7IC8vIHkgPT0gMS94IG1vZCAyXmRiaXRzXG4gIC8vIHdlIHJlYWxseSB3YW50IHRoZSBuZWdhdGl2ZSBpbnZlcnNlLCBhbmQgLURWIDwgeSA8IERWXG4gIHJldHVybiAoeSA+IDApID8gdGhpcy5EViAtIHkgOiAteVxufVxuXG4vLyBNb250Z29tZXJ5IHJlZHVjdGlvblxuZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XG4gIHRoaXMubSA9IG1cbiAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKVxuICB0aGlzLm1wbCA9IHRoaXMubXAgJiAweDdmZmZcbiAgdGhpcy5tcGggPSB0aGlzLm1wID4+IDE1XG4gIHRoaXMudW0gPSAoMSA8PCAobS5EQiAtIDE1KSkgLSAxXG4gIHRoaXMubXQyID0gMiAqIG0udFxufVxuXG4vLyB4UiBtb2QgbVxuZnVuY3Rpb24gbW9udENvbnZlcnQoeCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgeC5hYnMoKVxuICAgIC5kbFNoaWZ0VG8odGhpcy5tLnQsIHIpXG4gIHIuZGl2UmVtVG8odGhpcy5tLCBudWxsLCByKVxuICBpZiAoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgdGhpcy5tLnN1YlRvKHIsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIHgvUiBtb2QgbVxuZnVuY3Rpb24gbW9udFJldmVydCh4KSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB4LmNvcHlUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxuICByZXR1cm4gclxufVxuXG4vLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG5mdW5jdGlvbiBtb250UmVkdWNlKHgpIHtcbiAgd2hpbGUgKHgudCA8PSB0aGlzLm10MikgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgeFt4LnQrK10gPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4W2ldKm1wIG1vZCBEVlxuICAgIHZhciBqID0geFtpXSAmIDB4N2ZmZlxuICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETVxuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpICsgdGhpcy5tLnRcbiAgICB4W2pdICs9IHRoaXMubS5hbSgwLCB1MCwgeCwgaSwgMCwgdGhpcy5tLnQpXG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUgKHhbal0gPj0geC5EVikge1xuICAgICAgeFtqXSAtPSB4LkRWXG4gICAgICB4Wysral0rK1xuICAgIH1cbiAgfVxuICB4LmNsYW1wKClcbiAgeC5kclNoaWZ0VG8odGhpcy5tLnQsIHgpXG4gIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLCB4KVxufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbk1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydFxuTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydFxuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZVxuTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG9cbk1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvXG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkge1xuICByZXR1cm4gKCh0aGlzLnQgPiAwKSA/ICh0aGlzWzBdICYgMSkgOiB0aGlzLnMpID09IDBcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUsIHopIHtcbiAgaWYgKGUgPiAweGZmZmZmZmZmIHx8IGUgPCAxKSByZXR1cm4gQmlnSW50ZWdlci5PTkVcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHIyID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICBnID0gei5jb252ZXJ0KHRoaXMpLFxuICAgIGkgPSBuYml0cyhlKSAtIDFcbiAgZy5jb3B5VG8ocilcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLCByMilcbiAgICBpZiAoKGUgJiAoMSA8PCBpKSkgPiAwKSB6Lm11bFRvKHIyLCBnLCByKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHQgPSByXG4gICAgICByID0gcjJcbiAgICAgIHIyID0gdFxuICAgIH1cbiAgfVxuICByZXR1cm4gei5yZXZlcnQocilcbn1cblxuLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSwgbSkge1xuICB2YXIgelxuICBpZiAoZSA8IDI1NiB8fCBtLmlzRXZlbigpKSB6ID0gbmV3IENsYXNzaWMobSlcbiAgZWxzZSB6ID0gbmV3IE1vbnRnb21lcnkobSlcbiAgcmV0dXJuIHRoaXMuZXhwKGUsIHopXG59XG5cbi8vIHByb3RlY3RlZFxucHJvdG8uY29weVRvID0gYm5wQ29weVRvXG5wcm90by5mcm9tSW50ID0gYm5wRnJvbUludFxucHJvdG8uZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmdcbnByb3RvLmNsYW1wID0gYm5wQ2xhbXBcbnByb3RvLmRsU2hpZnRUbyA9IGJucERMU2hpZnRUb1xucHJvdG8uZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvXG5wcm90by5sU2hpZnRUbyA9IGJucExTaGlmdFRvXG5wcm90by5yU2hpZnRUbyA9IGJucFJTaGlmdFRvXG5wcm90by5zdWJUbyA9IGJucFN1YlRvXG5wcm90by5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUb1xucHJvdG8uc3F1YXJlVG8gPSBibnBTcXVhcmVUb1xucHJvdG8uZGl2UmVtVG8gPSBibnBEaXZSZW1Ub1xucHJvdG8uaW52RGlnaXQgPSBibnBJbnZEaWdpdFxucHJvdG8uaXNFdmVuID0gYm5wSXNFdmVuXG5wcm90by5leHAgPSBibnBFeHBcblxuLy8gcHVibGljXG5wcm90by50b1N0cmluZyA9IGJuVG9TdHJpbmdcbnByb3RvLm5lZ2F0ZSA9IGJuTmVnYXRlXG5wcm90by5hYnMgPSBibkFic1xucHJvdG8uY29tcGFyZVRvID0gYm5Db21wYXJlVG9cbnByb3RvLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoXG5wcm90by5ieXRlTGVuZ3RoID0gYm5CeXRlTGVuZ3RoXG5wcm90by5tb2QgPSBibk1vZFxucHJvdG8ubW9kUG93SW50ID0gYm5Nb2RQb3dJbnRcblxuLy8gKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmNvcHlUbyhyKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuZnVuY3Rpb24gYm5JbnRWYWx1ZSgpIHtcbiAgaWYgKHRoaXMucyA8IDApIHtcbiAgICBpZiAodGhpcy50ID09IDEpIHJldHVybiB0aGlzWzBdIC0gdGhpcy5EVlxuICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSByZXR1cm4gLTFcbiAgfSBlbHNlIGlmICh0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF1cbiAgZWxzZSBpZiAodGhpcy50ID09IDApIHJldHVybiAwXG4gIC8vIGFzc3VtZXMgMTYgPCBEQiA8IDMyXG4gIHJldHVybiAoKHRoaXNbMV0gJiAoKDEgPDwgKDMyIC0gdGhpcy5EQikpIC0gMSkpIDw8IHRoaXMuREIpIHwgdGhpc1swXVxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7XG4gIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMjQpID4+IDI0XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7XG4gIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMTYpID4+IDE2XG59XG5cbi8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yICogdGhpcy5EQiAvIE1hdGgubG9nKHIpKVxufVxuXG4vLyAocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuZnVuY3Rpb24gYm5TaWdOdW0oKSB7XG4gIGlmICh0aGlzLnMgPCAwKSByZXR1cm4gLTFcbiAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHJldHVybiAwXG4gIGVsc2UgcmV0dXJuIDFcbn1cblxuLy8gKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuICBpZiAoYiA9PSBudWxsKSBiID0gMTBcbiAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHJldHVybiBcIjBcIlxuICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKVxuICB2YXIgYSA9IE1hdGgucG93KGIsIGNzKVxuICB2YXIgZCA9IG5idihhKSxcbiAgICB5ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB6ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICByID0gXCJcIlxuICB0aGlzLmRpdlJlbVRvKGQsIHksIHopXG4gIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xuICAgIHIgPSAoYSArIHouaW50VmFsdWUoKSlcbiAgICAgIC50b1N0cmluZyhiKVxuICAgICAgLnN1YnN0cigxKSArIHJcbiAgICB5LmRpdlJlbVRvKGQsIHksIHopXG4gIH1cbiAgcmV0dXJuIHouaW50VmFsdWUoKVxuICAgIC50b1N0cmluZyhiKSArIHJcbn1cblxuLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wRnJvbVJhZGl4KHMsIGIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZnJvbUludCgwKVxuICBpZiAoYiA9PSBudWxsKSBiID0gMTBcbiAgdmFyIGNzID0gc2VsZi5jaHVua1NpemUoYilcbiAgdmFyIGQgPSBNYXRoLnBvdyhiLCBjcyksXG4gICAgbWkgPSBmYWxzZSxcbiAgICBqID0gMCxcbiAgICB3ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgeCA9IGludEF0KHMsIGkpXG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgc2VsZi5zaWdudW0oKSA9PSAwKSBtaSA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHcgPSBiICogdyArIHhcbiAgICBpZiAoKytqID49IGNzKSB7XG4gICAgICBzZWxmLmRNdWx0aXBseShkKVxuICAgICAgc2VsZi5kQWRkT2Zmc2V0KHcsIDApXG4gICAgICBqID0gMFxuICAgICAgdyA9IDBcbiAgICB9XG4gIH1cbiAgaWYgKGogPiAwKSB7XG4gICAgc2VsZi5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpXG4gICAgc2VsZi5kQWRkT2Zmc2V0KHcsIDApXG4gIH1cbiAgaWYgKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8oc2VsZiwgc2VsZilcbn1cblxuLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsIGIsIGMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gICAgaWYgKGEgPCAyKSBzZWxmLmZyb21JbnQoMSlcbiAgICBlbHNlIHtcbiAgICAgIHNlbGYuZnJvbU51bWJlcihhLCBjKVxuICAgICAgaWYgKCFzZWxmLnRlc3RCaXQoYSAtIDEpKSAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgIHNlbGYuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCBzZWxmKVxuICAgICAgaWYgKHNlbGYuaXNFdmVuKCkpIHNlbGYuZEFkZE9mZnNldCgxLCAwKTsgLy8gZm9yY2Ugb2RkXG4gICAgICB3aGlsZSAoIXNlbGYuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgIHNlbGYuZEFkZE9mZnNldCgyLCAwKVxuICAgICAgICBpZiAoc2VsZi5iaXRMZW5ndGgoKSA+IGEpIHNlbGYuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgc2VsZilcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiAgICB2YXIgeCA9IG5ldyBBcnJheSgpLFxuICAgICAgdCA9IGEgJiA3XG4gICAgeC5sZW5ndGggPSAoYSA+PiAzKSArIDFcbiAgICBiLm5leHRCeXRlcyh4KVxuICAgIGlmICh0ID4gMCkgeFswXSAmPSAoKDEgPDwgdCkgLSAxKVxuICAgIGVsc2UgeFswXSA9IDBcbiAgICBzZWxmLmZyb21TdHJpbmcoeCwgMjU2KVxuICB9XG59XG5cbi8vIChwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcbmZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaSA9IHNlbGYudCxcbiAgICByID0gbmV3IEFycmF5KClcbiAgclswXSA9IHNlbGYuc1xuICB2YXIgcCA9IHNlbGYuREIgLSAoaSAqIHNlbGYuREIpICUgOCxcbiAgICBkLCBrID0gMFxuICBpZiAoaS0tID4gMCkge1xuICAgIGlmIChwIDwgc2VsZi5EQiAmJiAoZCA9IHNlbGZbaV0gPj4gcCkgIT0gKHNlbGYucyAmIHNlbGYuRE0pID4+IHApXG4gICAgICByW2srK10gPSBkIHwgKHNlbGYucyA8PCAoc2VsZi5EQiAtIHApKVxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGlmIChwIDwgOCkge1xuICAgICAgICBkID0gKHNlbGZbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKDggLSBwKVxuICAgICAgICBkIHw9IHNlbGZbLS1pXSA+PiAocCArPSBzZWxmLkRCIC0gOClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSA+PiAocCAtPSA4KSkgJiAweGZmXG4gICAgICAgIGlmIChwIDw9IDApIHtcbiAgICAgICAgICBwICs9IHNlbGYuREJcbiAgICAgICAgICAtLWlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChkICYgMHg4MCkgIT0gMCkgZCB8PSAtMjU2XG4gICAgICBpZiAoayA9PT0gMCAmJiAoc2VsZi5zICYgMHg4MCkgIT0gKGQgJiAweDgwKSkrK2tcbiAgICAgIGlmIChrID4gMCB8fCBkICE9IHNlbGYucykgcltrKytdID0gZFxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBibkVxdWFscyhhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPT0gMClcbn1cblxuZnVuY3Rpb24gYm5NaW4oYSkge1xuICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpIDwgMCkgPyB0aGlzIDogYVxufVxuXG5mdW5jdGlvbiBibk1heChhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPiAwKSA/IHRoaXMgOiBhXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG5mdW5jdGlvbiBibnBCaXR3aXNlVG8oYSwgb3AsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpLCBmLCBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHJbaV0gPSBvcChzZWxmW2ldLCBhW2ldKVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgZiA9IGEucyAmIHNlbGYuRE1cbiAgICBmb3IgKGkgPSBtOyBpIDwgc2VsZi50OyArK2kpIHJbaV0gPSBvcChzZWxmW2ldLCBmKVxuICAgIHIudCA9IHNlbGYudFxuICB9IGVsc2Uge1xuICAgIGYgPSBzZWxmLnMgJiBzZWxmLkRNXG4gICAgZm9yIChpID0gbTsgaSA8IGEudDsgKytpKSByW2ldID0gb3AoZiwgYVtpXSlcbiAgICByLnQgPSBhLnRcbiAgfVxuICByLnMgPSBvcChzZWxmLnMsIGEucylcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCwgeSkge1xuICByZXR1cm4geCAmIHlcbn1cblxuZnVuY3Rpb24gYm5BbmQoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIHwgYVxuZnVuY3Rpb24gb3Bfb3IoeCwgeSkge1xuICByZXR1cm4geCB8IHlcbn1cblxuZnVuY3Rpb24gYm5PcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9vciwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBeIGFcbmZ1bmN0aW9uIG9wX3hvcih4LCB5KSB7XG4gIHJldHVybiB4IF4geVxufVxuXG5mdW5jdGlvbiBiblhvcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF94b3IsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgsIHkpIHtcbiAgcmV0dXJuIHggJiB+eVxufVxuXG5mdW5jdGlvbiBibkFuZE5vdChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmRub3QsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIH50aGlzXG5mdW5jdGlvbiBibk5vdCgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSB0aGlzLkRNICYgfnRoaXNbaV1cbiAgci50ID0gdGhpcy50XG4gIHIucyA9IH50aGlzLnNcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBpZiAobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4sIHIpXG4gIGVsc2UgdGhpcy5sU2hpZnRUbyhuLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJuU2hpZnRSaWdodChuKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBpZiAobiA8IDApIHRoaXMubFNoaWZ0VG8oLW4sIHIpXG4gIGVsc2UgdGhpcy5yU2hpZnRUbyhuLCByKVxuICByZXR1cm4gclxufVxuXG4vLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5mdW5jdGlvbiBsYml0KHgpIHtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC0xXG4gIHZhciByID0gMFxuICBpZiAoKHggJiAweGZmZmYpID09IDApIHtcbiAgICB4ID4+PSAxNlxuICAgIHIgKz0gMTZcbiAgfVxuICBpZiAoKHggJiAweGZmKSA9PSAwKSB7XG4gICAgeCA+Pj0gOFxuICAgIHIgKz0gOFxuICB9XG4gIGlmICgoeCAmIDB4ZikgPT0gMCkge1xuICAgIHggPj49IDRcbiAgICByICs9IDRcbiAgfVxuICBpZiAoKHggJiAzKSA9PSAwKSB7XG4gICAgeCA+Pj0gMlxuICAgIHIgKz0gMlxuICB9XG4gIGlmICgoeCAmIDEpID09IDApKytyXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpXG4gICAgaWYgKHRoaXNbaV0gIT0gMCkgcmV0dXJuIGkgKiB0aGlzLkRCICsgbGJpdCh0aGlzW2ldKVxuICBpZiAodGhpcy5zIDwgMCkgcmV0dXJuIHRoaXMudCAqIHRoaXMuREJcbiAgcmV0dXJuIC0xXG59XG5cbi8vIHJldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcbmZ1bmN0aW9uIGNiaXQoeCkge1xuICB2YXIgciA9IDBcbiAgd2hpbGUgKHggIT0gMCkge1xuICAgIHggJj0geCAtIDFcbiAgICArK3JcbiAgfVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG5mdW5jdGlvbiBibkJpdENvdW50KCkge1xuICB2YXIgciA9IDAsXG4gICAgeCA9IHRoaXMucyAmIHRoaXMuRE1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgciArPSBjYml0KHRoaXNbaV0gXiB4KVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuZnVuY3Rpb24gYm5UZXN0Qml0KG4pIHtcbiAgdmFyIGogPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKVxuICBpZiAoaiA+PSB0aGlzLnQpIHJldHVybiAodGhpcy5zICE9IDApXG4gIHJldHVybiAoKHRoaXNbal0gJiAoMSA8PCAobiAlIHRoaXMuREIpKSkgIT0gMClcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbmZ1bmN0aW9uIGJucENoYW5nZUJpdChuLCBvcCkge1xuICB2YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKVxuICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuZnVuY3Rpb24gYm5TZXRCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3Bfb3IpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXG5mdW5jdGlvbiBibkNsZWFyQml0KG4pIHtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX2FuZG5vdClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX3hvcilcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG5mdW5jdGlvbiBibnBBZGRUbyhhLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBpID0gMCxcbiAgICBjID0gMCxcbiAgICBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGMgKz0gc2VsZltpXSArIGFbaV1cbiAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgIGMgPj49IHNlbGYuREJcbiAgfVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgYyArPSBhLnNcbiAgICB3aGlsZSAoaSA8IHNlbGYudCkge1xuICAgICAgYyArPSBzZWxmW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IHNlbGYuc1xuICB9IGVsc2Uge1xuICAgIGMgKz0gc2VsZi5zXG4gICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgIGMgKz0gYVtpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyArPSBhLnNcbiAgfVxuICByLnMgPSAoYyA8IDApID8gLTEgOiAwXG4gIGlmIChjID4gMCkgcltpKytdID0gY1xuICBlbHNlIGlmIChjIDwgLTEpIHJbaSsrXSA9IHNlbGYuRFYgKyBjXG4gIHIudCA9IGlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgKyBhXG5mdW5jdGlvbiBibkFkZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmFkZFRvKGEsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuc3ViVG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAqIGFcbmZ1bmN0aW9uIGJuTXVsdGlwbHkoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5tdWx0aXBseVRvKGEsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXNeMlxuZnVuY3Rpb24gYm5TcXVhcmUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLnNxdWFyZVRvKHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgLyBhXG5mdW5jdGlvbiBibkRpdmlkZShhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIHIsIG51bGwpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJSBhXG5mdW5jdGlvbiBiblJlbWFpbmRlcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIG51bGwsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIFt0aGlzL2EsdGhpcyVhXVxuZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSkge1xuICB2YXIgcSA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKVxuICByZXR1cm4gbmV3IEFycmF5KHEsIHIpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG5mdW5jdGlvbiBibnBETXVsdGlwbHkobikge1xuICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsIG4gLSAxLCB0aGlzLCAwLCAwLCB0aGlzLnQpXG4gICsrdGhpcy50XG4gIHRoaXMuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG5mdW5jdGlvbiBibnBEQWRkT2Zmc2V0KG4sIHcpIHtcbiAgaWYgKG4gPT0gMCkgcmV0dXJuXG4gIHdoaWxlICh0aGlzLnQgPD0gdykgdGhpc1t0aGlzLnQrK10gPSAwXG4gIHRoaXNbd10gKz0gblxuICB3aGlsZSAodGhpc1t3XSA+PSB0aGlzLkRWKSB7XG4gICAgdGhpc1t3XSAtPSB0aGlzLkRWXG4gICAgaWYgKCsrdyA+PSB0aGlzLnQpIHRoaXNbdGhpcy50KytdID0gMFxuICAgICsrdGhpc1t3XVxuICB9XG59XG5cbi8vIEEgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5cbmZ1bmN0aW9uIG5Ob3AoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBuTXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbn1cblxuZnVuY3Rpb24gblNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxufVxuXG5OdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gbk5vcFxuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcFxuTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG9cbk51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvXG5cbi8vIChwdWJsaWMpIHRoaXNeZVxuZnVuY3Rpb24gYm5Qb3coZSkge1xuICByZXR1cm4gdGhpcy5leHAoZSwgbmV3IE51bGxFeHAoKSlcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsIG4sIHIpIHtcbiAgdmFyIGkgPSBNYXRoLm1pbih0aGlzLnQgKyBhLnQsIG4pXG4gIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgci50ID0gaVxuICB3aGlsZSAoaSA+IDApIHJbLS1pXSA9IDBcbiAgdmFyIGpcbiAgZm9yIChqID0gci50IC0gdGhpcy50OyBpIDwgajsgKytpKSByW2kgKyB0aGlzLnRdID0gdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCB0aGlzLnQpXG4gIGZvciAoaiA9IE1hdGgubWluKGEudCwgbik7IGkgPCBqOyArK2kpIHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgbiAtIGkpXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gXCJ0aGlzICogYVwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLCBuLCByKSB7XG4gIC0tblxuICB2YXIgaSA9IHIudCA9IHRoaXMudCArIGEudCAtIG5cbiAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICB3aGlsZSAoLS1pID49IDApIHJbaV0gPSAwXG4gIGZvciAoaSA9IE1hdGgubWF4KG4gLSB0aGlzLnQsIDApOyBpIDwgYS50OyArK2kpXG4gICAgclt0aGlzLnQgKyBpIC0gbl0gPSB0aGlzLmFtKG4gLSBpLCBhW2ldLCByLCAwLCAwLCB0aGlzLnQgKyBpIC0gbilcbiAgci5jbGFtcCgpXG4gIHIuZHJTaGlmdFRvKDEsIHIpXG59XG5cbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbmZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAvLyBzZXR1cCBCYXJyZXR0XG4gIHRoaXMucjIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMucTMgPSBuZXcgQmlnSW50ZWdlcigpXG4gIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyICogbS50LCB0aGlzLnIyKVxuICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSlcbiAgdGhpcy5tID0gbVxufVxuXG5mdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KSB7XG4gIGlmICh4LnMgPCAwIHx8IHgudCA+IDIgKiB0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSlcbiAgZWxzZSBpZiAoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHJldHVybiB4XG4gIGVsc2Uge1xuICAgIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICAgIHguY29weVRvKHIpXG4gICAgdGhpcy5yZWR1Y2UocilcbiAgICByZXR1cm4gclxuICB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkge1xuICByZXR1cm4geFxufVxuXG4vLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB4LmRyU2hpZnRUbyhzZWxmLm0udCAtIDEsIHNlbGYucjIpXG4gIGlmICh4LnQgPiBzZWxmLm0udCArIDEpIHtcbiAgICB4LnQgPSBzZWxmLm0udCArIDFcbiAgICB4LmNsYW1wKClcbiAgfVxuICBzZWxmLm11Lm11bHRpcGx5VXBwZXJUbyhzZWxmLnIyLCBzZWxmLm0udCArIDEsIHNlbGYucTMpXG4gIHNlbGYubS5tdWx0aXBseUxvd2VyVG8oc2VsZi5xMywgc2VsZi5tLnQgKyAxLCBzZWxmLnIyKVxuICB3aGlsZSAoeC5jb21wYXJlVG8oc2VsZi5yMikgPCAwKSB4LmRBZGRPZmZzZXQoMSwgc2VsZi5tLnQgKyAxKVxuICB4LnN1YlRvKHNlbGYucjIsIHgpXG4gIHdoaWxlICh4LmNvbXBhcmVUbyhzZWxmLm0pID49IDApIHguc3ViVG8oc2VsZi5tLCB4KVxufVxuXG4vLyByID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnRcbkJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnRcbkJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2VcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvXG5CYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUb1xuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtIChIQUMgMTQuODUpXG5mdW5jdGlvbiBibk1vZFBvdyhlLCBtKSB7XG4gIHZhciBpID0gZS5iaXRMZW5ndGgoKSxcbiAgICBrLCByID0gbmJ2KDEpLFxuICAgIHpcbiAgaWYgKGkgPD0gMCkgcmV0dXJuIHJcbiAgZWxzZSBpZiAoaSA8IDE4KSBrID0gMVxuICBlbHNlIGlmIChpIDwgNDgpIGsgPSAzXG4gIGVsc2UgaWYgKGkgPCAxNDQpIGsgPSA0XG4gIGVsc2UgaWYgKGkgPCA3NjgpIGsgPSA1XG4gIGVsc2UgayA9IDZcbiAgaWYgKGkgPCA4KVxuICAgIHogPSBuZXcgQ2xhc3NpYyhtKVxuICBlbHNlIGlmIChtLmlzRXZlbigpKVxuICAgIHogPSBuZXcgQmFycmV0dChtKVxuICBlbHNlXG4gICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pXG5cbiAgLy8gcHJlY29tcHV0YXRpb25cbiAgdmFyIGcgPSBuZXcgQXJyYXkoKSxcbiAgICBuID0gMyxcbiAgICBrMSA9IGsgLSAxLFxuICAgIGttID0gKDEgPDwgaykgLSAxXG4gIGdbMV0gPSB6LmNvbnZlcnQodGhpcylcbiAgaWYgKGsgPiAxKSB7XG4gICAgdmFyIGcyID0gbmV3IEJpZ0ludGVnZXIoKVxuICAgIHouc3FyVG8oZ1sxXSwgZzIpXG4gICAgd2hpbGUgKG4gPD0ga20pIHtcbiAgICAgIGdbbl0gPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgICB6Lm11bFRvKGcyLCBnW24gLSAyXSwgZ1tuXSlcbiAgICAgIG4gKz0gMlxuICAgIH1cbiAgfVxuXG4gIHZhciBqID0gZS50IC0gMSxcbiAgICB3LCBpczEgPSB0cnVlLFxuICAgIHIyID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB0XG4gIGkgPSBuYml0cyhlW2pdKSAtIDFcbiAgd2hpbGUgKGogPj0gMCkge1xuICAgIGlmIChpID49IGsxKSB3ID0gKGVbal0gPj4gKGkgLSBrMSkpICYga21cbiAgICBlbHNlIHtcbiAgICAgIHcgPSAoZVtqXSAmICgoMSA8PCAoaSArIDEpKSAtIDEpKSA8PCAoazEgLSBpKVxuICAgICAgaWYgKGogPiAwKSB3IHw9IGVbaiAtIDFdID4+ICh0aGlzLkRCICsgaSAtIGsxKVxuICAgIH1cblxuICAgIG4gPSBrXG4gICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgdyA+Pj0gMVxuICAgICAgLS1uXG4gICAgfVxuICAgIGlmICgoaSAtPSBuKSA8IDApIHtcbiAgICAgIGkgKz0gdGhpcy5EQlxuICAgICAgLS1qXG4gICAgfVxuICAgIGlmIChpczEpIHsgLy8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgICAgZ1t3XS5jb3B5VG8ocilcbiAgICAgIGlzMSA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICB6LnNxclRvKHIsIHIyKVxuICAgICAgICB6LnNxclRvKHIyLCByKVxuICAgICAgICBuIC09IDJcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMCkgei5zcXJUbyhyLCByMilcbiAgICAgIGVsc2Uge1xuICAgICAgICB0ID0gclxuICAgICAgICByID0gcjJcbiAgICAgICAgcjIgPSB0XG4gICAgICB9XG4gICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKVxuICAgIH1cblxuICAgIHdoaWxlIChqID49IDAgJiYgKGVbal0gJiAoMSA8PCBpKSkgPT0gMCkge1xuICAgICAgei5zcXJUbyhyLCByMilcbiAgICAgIHQgPSByXG4gICAgICByID0gcjJcbiAgICAgIHIyID0gdFxuICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgaSA9IHRoaXMuREIgLSAxXG4gICAgICAgIC0talxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gei5yZXZlcnQocilcbn1cblxuLy8gKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbmZ1bmN0aW9uIGJuR0NEKGEpIHtcbiAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpXG4gIHZhciB5ID0gKGEucyA8IDApID8gYS5uZWdhdGUoKSA6IGEuY2xvbmUoKVxuICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XG4gICAgdmFyIHQgPSB4XG4gICAgeCA9IHlcbiAgICB5ID0gdFxuICB9XG4gIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKSxcbiAgICBnID0geS5nZXRMb3dlc3RTZXRCaXQoKVxuICBpZiAoZyA8IDApIHJldHVybiB4XG4gIGlmIChpIDwgZykgZyA9IGlcbiAgaWYgKGcgPiAwKSB7XG4gICAgeC5yU2hpZnRUbyhnLCB4KVxuICAgIHkuclNoaWZ0VG8oZywgeSlcbiAgfVxuICB3aGlsZSAoeC5zaWdudW0oKSA+IDApIHtcbiAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHguclNoaWZ0VG8oaSwgeClcbiAgICBpZiAoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHkuclNoaWZ0VG8oaSwgeSlcbiAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgeC5zdWJUbyh5LCB4KVxuICAgICAgeC5yU2hpZnRUbygxLCB4KVxuICAgIH0gZWxzZSB7XG4gICAgICB5LnN1YlRvKHgsIHkpXG4gICAgICB5LnJTaGlmdFRvKDEsIHkpXG4gICAgfVxuICB9XG4gIGlmIChnID4gMCkgeS5sU2hpZnRUbyhnLCB5KVxuICByZXR1cm4geVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbmZ1bmN0aW9uIGJucE1vZEludChuKSB7XG4gIGlmIChuIDw9IDApIHJldHVybiAwXG4gIHZhciBkID0gdGhpcy5EViAlIG4sXG4gICAgciA9ICh0aGlzLnMgPCAwKSA/IG4gLSAxIDogMFxuICBpZiAodGhpcy50ID4gMClcbiAgICBpZiAoZCA9PSAwKSByID0gdGhpc1swXSAlIG5cbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHIgPSAoZCAqIHIgKyB0aGlzW2ldKSAlIG5cbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pIHtcbiAgdmFyIGFjID0gbS5pc0V2ZW4oKVxuICBpZiAodGhpcy5zaWdudW0oKSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcbiAgaWYgKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cbiAgdmFyIHUgPSBtLmNsb25lKCksXG4gICAgdiA9IHRoaXMuY2xvbmUoKVxuICB2YXIgYSA9IG5idigxKSxcbiAgICBiID0gbmJ2KDApLFxuICAgIGMgPSBuYnYoMCksXG4gICAgZCA9IG5idigxKVxuICB3aGlsZSAodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgd2hpbGUgKHUuaXNFdmVuKCkpIHtcbiAgICAgIHUuclNoaWZ0VG8oMSwgdSlcbiAgICAgIGlmIChhYykge1xuICAgICAgICBpZiAoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICBhLmFkZFRvKHRoaXMsIGEpXG4gICAgICAgICAgYi5zdWJUbyhtLCBiKVxuICAgICAgICB9XG4gICAgICAgIGEuclNoaWZ0VG8oMSwgYSlcbiAgICAgIH0gZWxzZSBpZiAoIWIuaXNFdmVuKCkpIGIuc3ViVG8obSwgYilcbiAgICAgIGIuclNoaWZ0VG8oMSwgYilcbiAgICB9XG4gICAgd2hpbGUgKHYuaXNFdmVuKCkpIHtcbiAgICAgIHYuclNoaWZ0VG8oMSwgdilcbiAgICAgIGlmIChhYykge1xuICAgICAgICBpZiAoIWMuaXNFdmVuKCkgfHwgIWQuaXNFdmVuKCkpIHtcbiAgICAgICAgICBjLmFkZFRvKHRoaXMsIGMpXG4gICAgICAgICAgZC5zdWJUbyhtLCBkKVxuICAgICAgICB9XG4gICAgICAgIGMuclNoaWZ0VG8oMSwgYylcbiAgICAgIH0gZWxzZSBpZiAoIWQuaXNFdmVuKCkpIGQuc3ViVG8obSwgZClcbiAgICAgIGQuclNoaWZ0VG8oMSwgZClcbiAgICB9XG4gICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgIHUuc3ViVG8odiwgdSlcbiAgICAgIGlmIChhYykgYS5zdWJUbyhjLCBhKVxuICAgICAgYi5zdWJUbyhkLCBiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2LnN1YlRvKHUsIHYpXG4gICAgICBpZiAoYWMpIGMuc3ViVG8oYSwgYylcbiAgICAgIGQuc3ViVG8oYiwgZClcbiAgICB9XG4gIH1cbiAgaWYgKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPXG4gIHdoaWxlIChkLmNvbXBhcmVUbyhtKSA+PSAwKSBkLnN1YlRvKG0sIGQpXG4gIHdoaWxlIChkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLCBkKVxuICByZXR1cm4gZFxufVxuXG52YXIgbG93cHJpbWVzID0gW1xuICAyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzcsIDQxLCA0MywgNDcsIDUzLCA1OSwgNjEsIDY3LCA3MSxcbiAgNzMsIDc5LCA4MywgODksIDk3LCAxMDEsIDEwMywgMTA3LCAxMDksIDExMywgMTI3LCAxMzEsIDEzNywgMTM5LCAxNDksIDE1MSxcbiAgMTU3LCAxNjMsIDE2NywgMTczLCAxNzksIDE4MSwgMTkxLCAxOTMsIDE5NywgMTk5LCAyMTEsIDIyMywgMjI3LCAyMjksIDIzMyxcbiAgMjM5LCAyNDEsIDI1MSwgMjU3LCAyNjMsIDI2OSwgMjcxLCAyNzcsIDI4MSwgMjgzLCAyOTMsIDMwNywgMzExLCAzMTMsIDMxNyxcbiAgMzMxLCAzMzcsIDM0NywgMzQ5LCAzNTMsIDM1OSwgMzY3LCAzNzMsIDM3OSwgMzgzLCAzODksIDM5NywgNDAxLCA0MDksIDQxOSxcbiAgNDIxLCA0MzEsIDQzMywgNDM5LCA0NDMsIDQ0OSwgNDU3LCA0NjEsIDQ2MywgNDY3LCA0NzksIDQ4NywgNDkxLCA0OTksIDUwMyxcbiAgNTA5LCA1MjEsIDUyMywgNTQxLCA1NDcsIDU1NywgNTYzLCA1NjksIDU3MSwgNTc3LCA1ODcsIDU5MywgNTk5LCA2MDEsIDYwNyxcbiAgNjEzLCA2MTcsIDYxOSwgNjMxLCA2NDEsIDY0MywgNjQ3LCA2NTMsIDY1OSwgNjYxLCA2NzMsIDY3NywgNjgzLCA2OTEsIDcwMSxcbiAgNzA5LCA3MTksIDcyNywgNzMzLCA3MzksIDc0MywgNzUxLCA3NTcsIDc2MSwgNzY5LCA3NzMsIDc4NywgNzk3LCA4MDksIDgxMSxcbiAgODIxLCA4MjMsIDgyNywgODI5LCA4MzksIDg1MywgODU3LCA4NTksIDg2MywgODc3LCA4ODEsIDg4MywgODg3LCA5MDcsIDkxMSxcbiAgOTE5LCA5MjksIDkzNywgOTQxLCA5NDcsIDk1MywgOTY3LCA5NzEsIDk3NywgOTgzLCA5OTEsIDk5N1xuXVxuXG52YXIgbHBsaW0gPSAoMSA8PCAyNikgLyBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdXG5cbi8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuZnVuY3Rpb24gYm5Jc1Byb2JhYmxlUHJpbWUodCkge1xuICB2YXIgaSwgeCA9IHRoaXMuYWJzKClcbiAgaWYgKHgudCA9PSAxICYmIHhbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICAgICBpZiAoeFswXSA9PSBsb3dwcmltZXNbaV0pIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKHguaXNFdmVuKCkpIHJldHVybiBmYWxzZVxuICBpID0gMVxuICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXSxcbiAgICAgIGogPSBpICsgMVxuICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIG0gKj0gbG93cHJpbWVzW2orK11cbiAgICBtID0geC5tb2RJbnQobSlcbiAgICB3aGlsZSAoaSA8IGopIGlmIChtICUgbG93cHJpbWVzW2krK10gPT0gMCkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHgubWlsbGVyUmFiaW4odClcbn1cblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZiBwcm9iYWJseSBwcmltZSAoSEFDIDQuMjQsIE1pbGxlci1SYWJpbilcbmZ1bmN0aW9uIGJucE1pbGxlclJhYmluKHQpIHtcbiAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSlcbiAgdmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKVxuICBpZiAoayA8PSAwKSByZXR1cm4gZmFsc2VcbiAgdmFyIHIgPSBuMS5zaGlmdFJpZ2h0KGspXG4gIHQgPSAodCArIDEpID4+IDFcbiAgaWYgKHQgPiBsb3dwcmltZXMubGVuZ3RoKSB0ID0gbG93cHJpbWVzLmxlbmd0aFxuICB2YXIgYSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpXG4gIHZhciBqLCBiYXNlcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgaiA9IGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsb3dwcmltZXMubGVuZ3RoKV1cbiAgICAgIGlmIChiYXNlcy5pbmRleE9mKGopID09IC0xKSBicmVha1xuICAgIH1cbiAgICBiYXNlcy5wdXNoKGopXG4gICAgYS5mcm9tSW50KGopXG4gICAgdmFyIHkgPSBhLm1vZFBvdyhyLCB0aGlzKVxuICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgdmFyIGogPSAxXG4gICAgICB3aGlsZSAoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICB5ID0geS5tb2RQb3dJbnQoMiwgdGhpcylcbiAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIHByb3RlY3RlZFxucHJvdG8uY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplXG5wcm90by50b1JhZGl4ID0gYm5wVG9SYWRpeFxucHJvdG8uZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4XG5wcm90by5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlclxucHJvdG8uYml0d2lzZVRvID0gYm5wQml0d2lzZVRvXG5wcm90by5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXRcbnByb3RvLmFkZFRvID0gYm5wQWRkVG9cbnByb3RvLmRNdWx0aXBseSA9IGJucERNdWx0aXBseVxucHJvdG8uZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXRcbnByb3RvLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUb1xucHJvdG8ubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvXG5wcm90by5tb2RJbnQgPSBibnBNb2RJbnRcbnByb3RvLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW5cblxuLy8gcHVibGljXG5wcm90by5jbG9uZSA9IGJuQ2xvbmVcbnByb3RvLmludFZhbHVlID0gYm5JbnRWYWx1ZVxucHJvdG8uYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWVcbnByb3RvLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWVcbnByb3RvLnNpZ251bSA9IGJuU2lnTnVtXG5wcm90by50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXlcbnByb3RvLmVxdWFscyA9IGJuRXF1YWxzXG5wcm90by5taW4gPSBibk1pblxucHJvdG8ubWF4ID0gYm5NYXhcbnByb3RvLmFuZCA9IGJuQW5kXG5wcm90by5vciA9IGJuT3JcbnByb3RvLnhvciA9IGJuWG9yXG5wcm90by5hbmROb3QgPSBibkFuZE5vdFxucHJvdG8ubm90ID0gYm5Ob3RcbnByb3RvLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0XG5wcm90by5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0XG5wcm90by5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdFxucHJvdG8uYml0Q291bnQgPSBibkJpdENvdW50XG5wcm90by50ZXN0Qml0ID0gYm5UZXN0Qml0XG5wcm90by5zZXRCaXQgPSBiblNldEJpdFxucHJvdG8uY2xlYXJCaXQgPSBibkNsZWFyQml0XG5wcm90by5mbGlwQml0ID0gYm5GbGlwQml0XG5wcm90by5hZGQgPSBibkFkZFxucHJvdG8uc3VidHJhY3QgPSBiblN1YnRyYWN0XG5wcm90by5tdWx0aXBseSA9IGJuTXVsdGlwbHlcbnByb3RvLmRpdmlkZSA9IGJuRGl2aWRlXG5wcm90by5yZW1haW5kZXIgPSBiblJlbWFpbmRlclxucHJvdG8uZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXJcbnByb3RvLm1vZFBvdyA9IGJuTW9kUG93XG5wcm90by5tb2RJbnZlcnNlID0gYm5Nb2RJbnZlcnNlXG5wcm90by5wb3cgPSBiblBvd1xucHJvdG8uZ2NkID0gYm5HQ0RcbnByb3RvLmlzUHJvYmFibGVQcmltZSA9IGJuSXNQcm9iYWJsZVByaW1lXG5cbi8vIEpTQk4tc3BlY2lmaWMgZXh0ZW5zaW9uXG5wcm90by5zcXVhcmUgPSBiblNxdWFyZVxuXG4vLyBjb25zdGFudHNcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKVxuQmlnSW50ZWdlci5PTkUgPSBuYnYoMSlcbkJpZ0ludGVnZXIudmFsdWVPZiA9IG5idlxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ0ludGVnZXJcbiIsIi8vIEZJWE1FOiBLaW5kIG9mIGEgd2VpcmQgd2F5IHRvIHRocm93IGV4Y2VwdGlvbnMsIGNvbnNpZGVyIHJlbW92aW5nXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnLi9iaWdpJylcblxuLyoqXG4gKiBUdXJucyBhIGJ5dGUgYXJyYXkgaW50byBhIGJpZyBpbnRlZ2VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBpbnRlcnByZXQgYSBieXRlIGFycmF5IGFzIGEgYmlnIGludGVnZXIgaW4gYmlnXG4gKiBlbmRpYW4gbm90YXRpb24uXG4gKi9cbkJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkID0gZnVuY3Rpb24oYnl0ZUFycmF5KSB7XG4gIC8vIEJpZ0ludGVnZXIgZXhwZWN0cyBhIERFUiBpbnRlZ2VyIGNvbmZvcm1hbnQgYnl0ZSBhcnJheVxuICBpZiAoYnl0ZUFycmF5WzBdICYgMHg4MCkge1xuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMF0uY29uY2F0KGJ5dGVBcnJheSkpXG4gIH1cblxuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnl0ZUFycmF5KVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWcgaW50ZWdlci5cbiAqXG4gKiBUaGlzIHJldHVybnMgdGhlIGFic29sdXRlIG9mIHRoZSBjb250YWluZWQgdmFsdWUgaW4gYmlnIGVuZGlhblxuICogZm9ybS4gQSB2YWx1ZSBvZiB6ZXJvIHJlc3VsdHMgaW4gYW4gZW1wdHkgYXJyYXkuXG4gKi9cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5VW5zaWduZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IHRoaXMudG9CeXRlQXJyYXkoKVxuICByZXR1cm4gYnl0ZUFycmF5WzBdID09PSAwID8gYnl0ZUFycmF5LnNsaWNlKDEpIDogYnl0ZUFycmF5XG59XG5cbkJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIgPSBmdW5jdGlvbihieXRlQXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJ5dGVBcnJheSlcbn1cblxuLypcbiAqIENvbnZlcnRzIEJpZ0ludGVnZXIgdG8gYSBERVIgaW50ZWdlciByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBUaGUgZm9ybWF0IGZvciB0aGlzIHZhbHVlIHVzZXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGFzIGEgc2lnblxuICogYml0LiAgSWYgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIGFscmVhZHkgc2V0IGFuZCB0aGUgaW50ZWdlciBpc1xuICogcG9zaXRpdmUsIGEgMHgwMCBpcyBwcmVwZW5kZWQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAwID0+ICAgICAweDAwXG4gKiAgICAgIDEgPT4gICAgIDB4MDFcbiAqICAgICAtMSA9PiAgICAgMHhmZlxuICogICAgMTI3ID0+ICAgICAweDdmXG4gKiAgIC0xMjcgPT4gICAgIDB4ODFcbiAqICAgIDEyOCA9PiAgIDB4MDA4MFxuICogICAtMTI4ID0+ICAgICAweDgwXG4gKiAgICAyNTUgPT4gICAweDAwZmZcbiAqICAgLTI1NSA9PiAgIDB4ZmYwMVxuICogIDE2MzAwID0+ICAgMHgzZmFjXG4gKiAtMTYzMDAgPT4gICAweGMwNTRcbiAqICA2MjMwMCA9PiAweDAwZjM1Y1xuICogLTYyMzAwID0+IDB4ZmYwY2E0XG4qL1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9ERVJJbnRlZ2VyID0gQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlcblxuQmlnSW50ZWdlci5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIEJpZ0ludGVnZXIgZXhwZWN0cyBhIERFUiBpbnRlZ2VyIGNvbmZvcm1hbnQgYnl0ZSBhcnJheVxuICBpZiAoYnVmZmVyWzBdICYgMHg4MCkge1xuICAgIHZhciBieXRlQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChidWZmZXIpXG5cbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoWzBdLmNvbmNhdChieXRlQXJyYXkpKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJ1ZmZlcilcbn1cblxuQmlnSW50ZWdlci5mcm9tSGV4ID0gZnVuY3Rpb24oaGV4KSB7XG4gIGlmIChoZXggPT09ICcnKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPXG5cbiAgYXNzZXJ0LmVxdWFsKGhleCwgaGV4Lm1hdGNoKC9eW0EtRmEtZjAtOV0rLyksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICBhc3NlcnQuZXF1YWwoaGV4Lmxlbmd0aCAlIDIsIDAsICdJbmNvbXBsZXRlIGhleCcpXG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihoZXgsIDE2KVxufVxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IHRoaXMudG9CeXRlQXJyYXlVbnNpZ25lZCgpXG4gIHZhciB6ZXJvcyA9IFtdXG5cbiAgdmFyIHBhZGRpbmcgPSBzaXplIC0gYnl0ZUFycmF5Lmxlbmd0aFxuICB3aGlsZSAoemVyb3MubGVuZ3RoIDwgcGFkZGluZykgemVyb3MucHVzaCgwKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHplcm9zLmNvbmNhdChieXRlQXJyYXkpKVxufVxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoc2l6ZSkudG9TdHJpbmcoJ2hleCcpXG59XG4iLCJ2YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJy4vYmlnaScpXG5cbi8vYWRkb25zXG5yZXF1aXJlKCcuL2NvbnZlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ0ludGVnZXIiLCJjb25zdCBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5jb25zdCBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcbmNvbnN0IGN1cnZlID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcblxuY29uc3Qgb25lID0gQmlnSW50ZWdlci5PTkU7XG5jb25zdCBuID0gY3VydmUubjtcbmNvbnN0IHAgPSBjdXJ2ZS5wO1xuXG5mdW5jdGlvbiBjaGVja0J1ZmZlcihuYW1lLCBidWYsIGxlbiwgaWR4KSB7XG4gIGNvbnN0IGlkeFN0ciA9IChpZHggIT09IHVuZGVmaW5lZCA/ICdbJyArIGlkeCArICddJyA6ICcnKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgaWR4U3RyICsgJyBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gIH1cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgaWR4U3RyICsgJyBtdXN0IGJlICcgKyBsZW4gKyAnIGJ5dGVzIGxvbmcnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5KG5hbWUsIGFycikge1xuICBpZiAoIWFyciB8fCAhYXJyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBtdXN0IGJlIGFuIGFycmF5IHdpdGggb25lIG9yIG1vcmUgZWxlbWVudHMnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1B1YktleUFycihwdWJLZXlzKSB7XG4gIGNoZWNrQXJyYXkoJ3B1YktleXMnLCBwdWJLZXlzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hlY2tCdWZmZXIoJ3B1YktleScsIHB1YktleXNbaV0sIDMyLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja01lc3NhZ2VBcnIobWVzc2FnZXMpIHtcbiAgY2hlY2tBcnJheSgnbWVzc2FnZXMnLCBtZXNzYWdlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja0J1ZmZlcignbWVzc2FnZScsIG1lc3NhZ2VzW2ldLCAzMiwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTaWduYXR1cmVBcnIoc2lnbmF0dXJlcykge1xuICBjaGVja0FycmF5KCdzaWduYXR1cmVzJywgc2lnbmF0dXJlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoZWNrQnVmZmVyKCdzaWduYXR1cmUnLCBzaWduYXR1cmVzW2ldLCA2NCwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb25jZUFycihub25jZXMpIHtcbiAgY2hlY2tBcnJheSgnbm9uY2VzJywgbm9uY2VzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub25jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja0J1ZmZlcignbm9uY2UnLCBub25jZXNbaV0sIDMyLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1ByaXZhdGVLZXkocHJpdmF0ZUtleSwgaWR4KSB7XG4gIGNvbnN0IGlkeFN0ciA9IChpZHggIT09IHVuZGVmaW5lZCA/ICdbJyArIGlkeCArICddJyA6ICcnKTtcbiAgaWYgKCFCaWdJbnRlZ2VyLmlzQmlnSW50ZWdlcihwcml2YXRlS2V5KSAmJiAhKHR5cGVvZiBwcml2YXRlS2V5ID09ICdzdHJpbmcnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZUtleScgKyBpZHhTdHIgKyAnIG11c3QgYmUgYSBCaWdJbnRlZ2VyIG9yIHZhbGlkIGhleCBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YocHJpdmF0ZUtleSkgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAocHJpdmF0ZUtleS5tYXRjaCgvW15hLWZeQS1GXjAtOV0rLykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZUtleSBtdXN0IGJlIGEgQmlnSW50ZWdlciBvciB2YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgY2hlY2tSYW5nZSgncHJpdmF0ZUtleScsIEJpZ0ludGVnZXIuZnJvbUhleChwcml2YXRlS2V5KSk7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjaGVja1JhbmdlKCdwcml2YXRlS2V5JywgcHJpdmF0ZUtleSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2lnblBhcmFtcyhwcml2YXRlS2V5LCBtZXNzYWdlKSB7XG4gIGNoZWNrUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgY2hlY2tCdWZmZXIoJ21lc3NhZ2UnLCBtZXNzYWdlLCAzMik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmVyaWZ5UGFyYW1zKHB1YktleSwgbWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gIGNoZWNrQnVmZmVyKCdwdWJLZXknLCBwdWJLZXksIDMyKTtcbiAgY2hlY2tCdWZmZXIoJ21lc3NhZ2UnLCBtZXNzYWdlLCAzMik7XG4gIGNoZWNrQnVmZmVyKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCYXRjaFZlcmlmeVBhcmFtcyhwdWJLZXlzLCBtZXNzYWdlcywgc2lnbmF0dXJlcykge1xuICBjaGVja1B1YktleUFycihwdWJLZXlzKTtcbiAgY2hlY2tNZXNzYWdlQXJyKG1lc3NhZ2VzKTtcbiAgY2hlY2tTaWduYXR1cmVBcnIoc2lnbmF0dXJlcyk7XG4gIGlmIChwdWJLZXlzLmxlbmd0aCAhPT0gbWVzc2FnZXMubGVuZ3RoIHx8IG1lc3NhZ2VzLmxlbmd0aCAhPT0gc2lnbmF0dXJlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FsbCBwYXJhbWV0ZXJzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGgnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2Vzc2lvblBhcmFtcyhzZXNzaW9uSWQsIHByaXZhdGVLZXksIG1lc3NhZ2UsIHB1YktleUNvbWJpbmVkLCBlbGwpIHtcbiAgY2hlY2tTaWduUGFyYW1zKHByaXZhdGVLZXksIG1lc3NhZ2UpO1xuICBjaGVja0J1ZmZlcignc2Vzc2lvbklkJywgc2Vzc2lvbklkLCAzMik7XG4gIGNoZWNrQnVmZmVyKCdwdWJLZXlDb21iaW5lZCcsIHB1YktleUNvbWJpbmVkLCAzMik7XG4gIGNoZWNrQnVmZmVyKCdlbGwnLCBlbGwsIDMyKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSYW5nZShuYW1lLCBzY2FsYXIpIHtcbiAgaWYgKHNjYWxhci5jb21wYXJlVG8ob25lKSA8IDAgfHwgc2NhbGFyLmNvbXBhcmVUbyhuLnN1YnRyYWN0KG9uZSkpID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIDEuLm4tMScpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTaWduYXR1cmVJbnB1dChyLCBzKSB7XG4gIGlmIChyLmNvbXBhcmVUbyhwKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyIGlzIGxhcmdlciB0aGFuIG9yIGVxdWFsIHRvIGZpZWxkIHNpemUnKTtcbiAgfVxuICBpZiAocy5jb21wYXJlVG8obikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncyBpcyBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byBjdXJ2ZSBvcmRlcicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUG9pbnRFeGlzdHMocHViS2V5RXZlbiwgUCkge1xuICBpZiAoUC5jdXJ2ZS5pc0luZmluaXR5KFApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBpcyBhdCBpbmZpbml0eScpO1xuICB9XG4gIGNvbnN0IHBFdmVuID0gUC5hZmZpbmVZLmlzRXZlbigpO1xuICBpZiAocHViS2V5RXZlbiAhPT0gcEV2ZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGRvZXMgbm90IGV4aXN0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tBdXgoYXV4KSB7XG4gIGlmIChhdXgubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignYXV4IG11c3QgYmUgMzIgYnl0ZXMnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hlY2tTZXNzaW9uUGFyYW1zLFxuICBjaGVja1NpZ25QYXJhbXMsXG4gIGNoZWNrVmVyaWZ5UGFyYW1zLFxuICBjaGVja0JhdGNoVmVyaWZ5UGFyYW1zLFxuICBjaGVja1JhbmdlLFxuICBjaGVja1NpZ25hdHVyZUlucHV0LFxuICBjaGVja1BvaW50RXhpc3RzLFxuICBjaGVja1B1YktleUFycixcbiAgY2hlY2tBcnJheSxcbiAgY2hlY2tOb25jZUFycixcbiAgY2hlY2tBdXgsXG59O1xuIiwiY29uc3QgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuY29uc3Qgc2hhMjU2ID0gcmVxdWlyZSgnanMtc2hhMjU2Jyk7XG5cbmZ1bmN0aW9uIGJ1ZmZlclRvSW50KGJ1ZmZlcikge1xuICByZXR1cm4gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGJpZ0ludGVnZXIpIHtcbiAgcmV0dXJuIGJpZ0ludGVnZXIudG9CdWZmZXIoMzIpO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2hhMjU2LmNyZWF0ZSgpLnVwZGF0ZShidWZmZXIpLmFycmF5KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVmZmVyVG9JbnQsXG4gIGludFRvQnVmZmVyLFxuICBoYXNoLFxufTtcbiIsImNvbnN0IHNjaG5vcnIgPSByZXF1aXJlKCcuL3NjaG5vcnInKTtcbnNjaG5vcnIuY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG5zY2hub3JyLmNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnQnKTtcbnNjaG5vcnIubWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuc2Nobm9yci5tdVNpZyA9IHJlcXVpcmUoJy4vbXUtc2lnJyk7XG5zY2hub3JyLnRhcHJvb3QgPSByZXF1aXJlKCcuL3RhcHJvb3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY2hub3JyO1xuIiwiY29uc3QgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuY29uc3QgZWN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5jb25zdCBjdXJ2ZSA9IGVjdXJ2ZS5nZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG5jb25zdCBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnQnKTtcblxuY29uc3QgY29uY2F0ID0gQnVmZmVyLmNvbmNhdDtcbmNvbnN0IEcgPSBjdXJ2ZS5HO1xuY29uc3QgcCA9IGN1cnZlLnA7XG5jb25zdCBuID0gY3VydmUubjtcbmNvbnN0IHplcm8gPSBCaWdJbnRlZ2VyLlpFUk87XG5jb25zdCBvbmUgPSBCaWdJbnRlZ2VyLk9ORTtcbmNvbnN0IHR3byA9IEJpZ0ludGVnZXIudmFsdWVPZigyKTtcbmNvbnN0IHRocmVlID0gQmlnSW50ZWdlci52YWx1ZU9mKDMpO1xuY29uc3QgZm91ciA9IEJpZ0ludGVnZXIudmFsdWVPZig0KTtcbmNvbnN0IHNldmVuID0gQmlnSW50ZWdlci52YWx1ZU9mKDcpO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljR2V0SzAocHJpdmF0ZUtleSwgcHVibGljS2V5LCBtZXNzYWdlKSB7XG4gIGNoZWNrLmNoZWNrU2lnblBhcmFtcyhwcml2YXRlS2V5LCBtZXNzYWdlKTtcblxuICBjb25zdCBoID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIGNvbmNhdChbY29udmVydC5pbnRUb0J1ZmZlcihwcml2YXRlS2V5KSwgcHVibGljS2V5LCBtZXNzYWdlXSkpO1xuICBjb25zdCBpID0gY29udmVydC5idWZmZXJUb0ludChoKTtcbiAgcmV0dXJuIGkubW9kKG4pO1xufVxuXG5mdW5jdGlvbiBpc0V2ZW4ocHViS2V5KSB7XG4gIHJldHVybiBwdWJLZXkuYWZmaW5lWS5tb2QodHdvKS5lcXVhbHMoemVybyk7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW5LZXkocHViS2V5LCBwcml2YXRlS2V5KSB7XG4gIGlmIChpc0V2ZW4ocHViS2V5KSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5LmNsb25lKCk7XG4gIH1cblxuICByZXR1cm4gbi5zdWJ0cmFjdChwcml2YXRlS2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0RShSeCwgUHgsIG0pIHtcbiAgY29uc3QgaGFzaCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgY29uY2F0KFtSeCwgUHgsIG1dKSk7XG4gIHJldHVybiBjb252ZXJ0LmJ1ZmZlclRvSW50KGhhc2gpLm1vZChuKTtcbn1cblxuZnVuY3Rpb24gZ2V0UihzLCBlLCBQKSB7XG4gIGNvbnN0IHNHID0gRy5tdWx0aXBseShzKTtcbiAgY29uc3QgZVAgPSBQLm11bHRpcGx5KGUpO1xuICByZXR1cm4gc0cuYWRkKGVQLm5lZ2F0ZSgpKTtcbn1cblxuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIG1zZykge1xuICBjb25zdCB0YWdIYXNoID0gY29udmVydC5oYXNoKHRhZyk7XG4gIHJldHVybiBjb252ZXJ0Lmhhc2goY29uY2F0KFt0YWdIYXNoLCB0YWdIYXNoLCBCdWZmZXIuZnJvbShtc2cpXSkpO1xufVxuXG5mdW5jdGlvbiBsaWZ0WChQeCkge1xuICBjb25zdCB4ID0gY29udmVydC5idWZmZXJUb0ludChQeCk7XG5cbiAgY29uc3QgYyA9IHgucG93KHRocmVlKS5hZGQoc2V2ZW4pLm1vZChwKTtcbiAgY29uc3QgeSA9IGMubW9kUG93KHAuYWRkKG9uZSkuZGl2aWRlKGZvdXIpLCBwKTtcbiAgaWYgKGMuY29tcGFyZVRvKHkubW9kUG93KHR3bywgcCkpICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjIGlzIG5vdCBlcXVhbCB0byB5XjInKTtcbiAgfVxuICBsZXQgUCA9IGVjdXJ2ZS5Qb2ludC5mcm9tQWZmaW5lKGN1cnZlLCB4LCB5KTtcbiAgaWYgKCFpc0V2ZW4oUCkpIHtcbiAgICBQID0gZWN1cnZlLlBvaW50LmZyb21BZmZpbmUoY3VydmUsIHgsIHAuc3VidHJhY3QoeSkpO1xuICB9XG5cbiAgY2hlY2suY2hlY2tQb2ludEV4aXN0cyh0cnVlLCBQKTtcbiAgcmV0dXJuIFA7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbUEoKSB7XG4gIGxldCBhID0gbnVsbDtcbiAgZm9yICg7IDspIHtcbiAgICBhID0gY29udmVydC5idWZmZXJUb0ludChCdWZmZXIuZnJvbShyYW5kb21CeXRlcygzMikpKTtcbiAgICB0cnkge1xuICAgICAgY2hlY2suY2hlY2tSYW5nZSgnYScsIGEpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gb3V0IG9mIHJhbmdlLCBnZW5lcmF0ZSBhbm90aGVyIG9uZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGV0ZXJtaW5pc3RpY0dldEswLFxuICBpc0V2ZW4sXG4gIGdldEV2ZW5LZXksXG4gIGdldEUsXG4gIGdldFIsXG4gIHRhZ2dlZEhhc2gsXG4gIGxpZnRYLFxuICByYW5kb21BLFxufTtcbiIsImNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuY29uc3QgZWN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5jb25zdCBjdXJ2ZSA9IGVjdXJ2ZS5nZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG5jb25zdCBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnQnKTtcblxuY29uc3QgY29uY2F0ID0gQnVmZmVyLmNvbmNhdDtcbmNvbnN0IEcgPSBjdXJ2ZS5HO1xuY29uc3QgbiA9IGN1cnZlLm47XG5jb25zdCBNVVNJR19UQUcgPSBjb252ZXJ0Lmhhc2goQnVmZmVyLmZyb20oJ011U2lnIGNvZWZmaWNpZW50JykpO1xuXG4vLyBDb21wdXRlcyBlbGwgPSBTSEEyNTYocHViS2V5c1swXSwgLi4uLCBwdWJLZXlzW3B1YktleXMubGVuZ3RoLTFdKSB3aXRoXG4vLyBwdWJLZXlzIHNlcmlhbGl6ZWQgaW4gY29tcHJlc3NlZCBmb3JtLlxuZnVuY3Rpb24gY29tcHV0ZUVsbChwdWJLZXlzKSB7XG4gIGNoZWNrLmNoZWNrUHViS2V5QXJyKHB1YktleXMpO1xuICByZXR1cm4gY29udmVydC5oYXNoKGNvbmNhdChwdWJLZXlzKSlcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNvZWZmaWNpZW50KGVsbCwgaWR4KSB7XG4gIGNvbnN0IGlkeEJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgaWR4QnVmLndyaXRlVUludDMyTEUoaWR4KTtcbiAgY29uc3QgZGF0YSA9IGNvbmNhdChbTVVTSUdfVEFHLCBNVVNJR19UQUcsIGVsbCwgaWR4QnVmXSk7XG4gIHJldHVybiBjb252ZXJ0LmJ1ZmZlclRvSW50KGNvbnZlcnQuaGFzaChkYXRhKSkubW9kKG4pO1xufVxuXG5mdW5jdGlvbiBwdWJLZXlDb21iaW5lKHB1YktleXMsIHB1YktleUhhc2gpIHtcbiAgY29uc3QgZWxsID0gcHViS2V5SGFzaCB8fCBjb21wdXRlRWxsKHB1YktleXMpO1xuICBsZXQgWCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHViS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFhpID0gbWF0aC5saWZ0WChwdWJLZXlzW2ldKTtcbiAgICBjb25zdCBjb2VmZmljaWVudCA9IGNvbXB1dGVDb2VmZmljaWVudChlbGwsIGkpO1xuICAgIGNvbnN0IHN1bW1hbmQgPSBYaS5tdWx0aXBseShjb2VmZmljaWVudCk7XG4gICAgaWYgKFggPT09IG51bGwpIHtcbiAgICAgIFggPSBzdW1tYW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBYID0gWC5hZGQoc3VtbWFuZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBYO1xufVxuXG5mdW5jdGlvbiBzZXNzaW9uSW5pdGlhbGl6ZShzZXNzaW9uSWQsIHByaXZhdGVLZXksIG1lc3NhZ2UsIHB1YktleUNvbWJpbmVkLCBwa1Bhcml0eSwgZWxsLCBpZHgpIHtcbiAgY2hlY2suY2hlY2tTZXNzaW9uUGFyYW1zKHNlc3Npb25JZCwgcHJpdmF0ZUtleSwgbWVzc2FnZSwgcHViS2V5Q29tYmluZWQsIGVsbCk7XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICBzZXNzaW9uSWQsXG4gICAgbWVzc2FnZSxcbiAgICBwdWJLZXlDb21iaW5lZCxcbiAgICBwa1Bhcml0eSxcbiAgICBlbGwsXG4gICAgaWR4LFxuICB9O1xuXG4gIGNvbnN0IGNvZWZmaWNpZW50ID0gY29tcHV0ZUNvZWZmaWNpZW50KGVsbCwgaWR4KTtcbiAgc2Vzc2lvbi5zZWNyZXRLZXkgPSBwcml2YXRlS2V5Lm11bHRpcGx5KGNvZWZmaWNpZW50KS5tb2Qobik7XG4gIHNlc3Npb24ub3duS2V5UGFyaXR5ID0gbWF0aC5pc0V2ZW4oRy5tdWx0aXBseShwcml2YXRlS2V5KSk7XG4gIGlmIChzZXNzaW9uLnBrUGFyaXR5ICE9PSBzZXNzaW9uLm93bktleVBhcml0eSkge1xuICAgIHNlc3Npb24uc2VjcmV0S2V5ID0gbi5zdWJ0cmFjdChzZXNzaW9uLnNlY3JldEtleSk7XG4gIH1cblxuICBjb25zdCBub25jZURhdGEgPSBjb25jYXQoW3Nlc3Npb25JZCwgbWVzc2FnZSwgc2Vzc2lvbi5wdWJLZXlDb21iaW5lZCwgY29udmVydC5pbnRUb0J1ZmZlcihwcml2YXRlS2V5KV0pO1xuICBzZXNzaW9uLnNlY3JldE5vbmNlID0gY29udmVydC5idWZmZXJUb0ludChjb252ZXJ0Lmhhc2gobm9uY2VEYXRhKSk7XG4gIGNoZWNrLmNoZWNrUmFuZ2UoJ3NlY3JldE5vbmNlJywgc2Vzc2lvbi5zZWNyZXROb25jZSk7XG4gIGNvbnN0IFIgPSBHLm11bHRpcGx5KHNlc3Npb24uc2VjcmV0Tm9uY2UpO1xuICBzZXNzaW9uLm5vbmNlID0gY29udmVydC5pbnRUb0J1ZmZlcihSLmFmZmluZVgpO1xuICBzZXNzaW9uLm5vbmNlUGFyaXR5ID0gbWF0aC5pc0V2ZW4oUik7XG4gIHNlc3Npb24uY29tbWl0bWVudCA9IGNvbnZlcnQuaGFzaChzZXNzaW9uLm5vbmNlKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbmZ1bmN0aW9uIHNlc3Npb25Ob25jZUNvbWJpbmUoc2Vzc2lvbiwgbm9uY2VzKSB7XG4gIGNoZWNrLmNoZWNrTm9uY2VBcnIobm9uY2VzKTtcbiAgbGV0IFIgPSBtYXRoLmxpZnRYKG5vbmNlc1swXSk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbm9uY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgUiA9IFIuYWRkKG1hdGgubGlmdFgobm9uY2VzW2ldKSk7XG4gIH1cbiAgc2Vzc2lvbi5jb21iaW5lZE5vbmNlUGFyaXR5ID0gbWF0aC5pc0V2ZW4oUik7XG4gIHJldHVybiBjb252ZXJ0LmludFRvQnVmZmVyKFIuYWZmaW5lWCk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWxTaWduKHNlc3Npb24sIG1lc3NhZ2UsIG5vbmNlQ29tYmluZWQsIHB1YktleUNvbWJpbmVkKSB7XG4gIGNvbnN0IGUgPSBtYXRoLmdldEUobm9uY2VDb21iaW5lZCwgcHViS2V5Q29tYmluZWQsIG1lc3NhZ2UpO1xuICBjb25zdCBzayA9IHNlc3Npb24uc2VjcmV0S2V5O1xuICBsZXQgayA9IHNlc3Npb24uc2VjcmV0Tm9uY2U7XG4gIGlmIChzZXNzaW9uLm5vbmNlUGFyaXR5ICE9PSBzZXNzaW9uLmNvbWJpbmVkTm9uY2VQYXJpdHkpIHtcbiAgICBrID0gbi5zdWJ0cmFjdChrKTtcbiAgfVxuICByZXR1cm4gc2subXVsdGlwbHkoZSkuYWRkKGspLm1vZChuKTtcbn1cblxuZnVuY3Rpb24gcGFydGlhbFNpZ1ZlcmlmeShzZXNzaW9uLCBwYXJ0aWFsU2lnLCBub25jZUNvbWJpbmVkLCBpZHgsIHB1YktleSwgbm9uY2UpIHtcbiAgbGV0IGUgPSBtYXRoLmdldEUobm9uY2VDb21iaW5lZCwgc2Vzc2lvbi5wdWJLZXlDb21iaW5lZCwgc2Vzc2lvbi5tZXNzYWdlKTtcbiAgY29uc3QgY29lZmZpY2llbnQgPSBjb21wdXRlQ29lZmZpY2llbnQoc2Vzc2lvbi5lbGwsIGlkeCk7XG4gIGNvbnN0IFBqID0gbWF0aC5saWZ0WChwdWJLZXkpO1xuICBjb25zdCBSaSA9IG1hdGgubGlmdFgobm9uY2UpO1xuXG4gIGlmICghc2Vzc2lvbi5wa1Bhcml0eSkge1xuICAgIGUgPSBuLnN1YnRyYWN0KGUpO1xuICB9XG5cbiAgbGV0IFJQID0gbWF0aC5nZXRSKHBhcnRpYWxTaWcsIGUubXVsdGlwbHkoY29lZmZpY2llbnQpLm1vZChuKSwgUGopO1xuICBpZiAoc2Vzc2lvbi5jb21iaW5lZE5vbmNlUGFyaXR5KSB7XG4gICAgUlAgPSBSUC5uZWdhdGUoKTtcbiAgfVxuICBjb25zdCBzdW0gPSBSUC5hZGQoUmkpO1xuICBpZiAoIXN1bS5jdXJ2ZS5pc0luZmluaXR5KHN1bSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWwgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aWFsU2lnQ29tYmluZShub25jZUNvbWJpbmVkLCBwYXJ0aWFsU2lncykge1xuICBjb25zdCBSID0gbWF0aC5saWZ0WChub25jZUNvbWJpbmVkKTtcbiAgY2hlY2suY2hlY2tBcnJheSgncGFydGlhbFNpZ3MnLCBwYXJ0aWFsU2lncyk7XG4gIGNvbnN0IFJ4ID0gY29udmVydC5pbnRUb0J1ZmZlcihSLmFmZmluZVgpO1xuICBsZXQgcyA9IHBhcnRpYWxTaWdzWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRpYWxTaWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgcyA9IHMuYWRkKHBhcnRpYWxTaWdzW2ldKS5tb2Qobik7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdChbUngsIGNvbnZlcnQuaW50VG9CdWZmZXIocyldKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXB1dGVFbGwsXG4gIGNvbXB1dGVDb2VmZmljaWVudCxcbiAgcHViS2V5Q29tYmluZSxcbiAgc2Vzc2lvbkluaXRpYWxpemUsXG4gIHNlc3Npb25Ob25jZUNvbWJpbmUsXG4gIHBhcnRpYWxTaWduLFxuICBwYXJ0aWFsU2lnVmVyaWZ5LFxuICBwYXJ0aWFsU2lnQ29tYmluZSxcbn07XG4iLCJjb25zdCBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5jb25zdCBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcbmNvbnN0IGN1cnZlID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbmNvbnN0IG1hdGggPSByZXF1aXJlKCcuL21hdGgnKTtcbmNvbnN0IGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpO1xuXG5jb25zdCBjb25jYXQgPSBCdWZmZXIuY29uY2F0O1xuY29uc3QgRyA9IGN1cnZlLkc7XG5jb25zdCBwID0gY3VydmUucDtcbmNvbnN0IG4gPSBjdXJ2ZS5uO1xuY29uc3QgemVybyA9IEJpZ0ludGVnZXIuWkVSTztcblxuZnVuY3Rpb24gc2lnbihwcml2YXRlS2V5LCBtZXNzYWdlLCBhdXgpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2kjc2lnbmluZ1xuICBjaGVjay5jaGVja1NpZ25QYXJhbXMocHJpdmF0ZUtleSwgbWVzc2FnZSk7XG4gIHByaXZhdGVLZXkgPSB0eXBlb2YgKHByaXZhdGVLZXkpID09ICdzdHJpbmcnID8gQmlnSW50ZWdlci5mcm9tSGV4KHByaXZhdGVLZXkpIDogcHJpdmF0ZUtleTtcblxuICBjb25zdCBQID0gRy5tdWx0aXBseShwcml2YXRlS2V5KTtcbiAgY29uc3QgUHggPSBjb252ZXJ0LmludFRvQnVmZmVyKFAuYWZmaW5lWCk7XG5cbiAgY29uc3QgZCA9IG1hdGguZ2V0RXZlbktleShQLCBwcml2YXRlS2V5KTtcbiAgbGV0IGtQcmltZVxuICBpZiAoYXV4KSB7XG4gICAgY2hlY2suY2hlY2tBdXgoYXV4KTtcblxuICAgIGNvbnN0IHQgPSBjb252ZXJ0LmludFRvQnVmZmVyKGQueG9yKGNvbnZlcnQuYnVmZmVyVG9JbnQobWF0aC50YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGF1eCkpKSk7XG4gICAgY29uc3QgcmFuZCA9IG1hdGgudGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIGNvbmNhdChbdCwgUHgsIG1lc3NhZ2VdKSlcbiAgICBrUHJpbWUgPSBjb252ZXJ0LmJ1ZmZlclRvSW50KHJhbmQpLm1vZChuKTtcbiAgfSBlbHNlIHtcbiAgICBrUHJpbWUgPSBtYXRoLmRldGVybWluaXN0aWNHZXRLMChkLCBQeCwgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoa1ByaW1lLnNpZ251bSgpID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrUHJpbWUgaXMgemVybycpO1xuICB9XG5cbiAgY29uc3QgUiA9IEcubXVsdGlwbHkoa1ByaW1lKTtcbiAgY29uc3QgayA9IG1hdGguZ2V0RXZlbktleShSLCBrUHJpbWUpO1xuICBjb25zdCBSeCA9IGNvbnZlcnQuaW50VG9CdWZmZXIoUi5hZmZpbmVYKTtcbiAgY29uc3QgZSA9IG1hdGguZ2V0RShSeCwgUHgsIG1lc3NhZ2UpO1xuICByZXR1cm4gY29uY2F0KFtSeCwgY29udmVydC5pbnRUb0J1ZmZlcihrLmFkZChlLm11bHRpcGx5KGQpKS5tb2QobikpXSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeShwdWJLZXksIG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICBjaGVjay5jaGVja1ZlcmlmeVBhcmFtcyhwdWJLZXksIG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2kjdmVyaWZpY2F0aW9uXG4gIGNvbnN0IFAgPSBtYXRoLmxpZnRYKHB1YktleSk7XG4gIGNvbnN0IFB4ID0gY29udmVydC5pbnRUb0J1ZmZlcihQLmFmZmluZVgpO1xuICBjb25zdCByID0gY29udmVydC5idWZmZXJUb0ludChzaWduYXR1cmUuc2xpY2UoMCwgMzIpKTtcbiAgY29uc3QgcyA9IGNvbnZlcnQuYnVmZmVyVG9JbnQoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuICBjaGVjay5jaGVja1NpZ25hdHVyZUlucHV0KHIsIHMpO1xuICBjb25zdCBlID0gbWF0aC5nZXRFKGNvbnZlcnQuaW50VG9CdWZmZXIociksIFB4LCBtZXNzYWdlKTtcbiAgY29uc3QgUiA9IG1hdGguZ2V0UihzLCBlLCBQKTtcbiAgaWYgKFIuY3VydmUuaXNJbmZpbml0eShSKSB8fCAhbWF0aC5pc0V2ZW4oUikgfHwgIVIuYWZmaW5lWC5lcXVhbHMocikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmF0Y2hWZXJpZnkocHViS2V5cywgbWVzc2FnZXMsIHNpZ25hdHVyZXMpIHtcbiAgY2hlY2suY2hlY2tCYXRjaFZlcmlmeVBhcmFtcyhwdWJLZXlzLCBtZXNzYWdlcywgc2lnbmF0dXJlcyk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2kjQmF0Y2hfVmVyaWZpY2F0aW9uXG4gIGxldCBsZWZ0U2lkZSA9IHplcm87XG4gIGxldCByaWdodFNpZGUgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBQID0gbWF0aC5saWZ0WChwdWJLZXlzW2ldKTtcbiAgICBjb25zdCBQeCA9IGNvbnZlcnQuaW50VG9CdWZmZXIoUC5hZmZpbmVYKTtcbiAgICBjb25zdCByID0gY29udmVydC5idWZmZXJUb0ludChzaWduYXR1cmVzW2ldLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IGNvbnZlcnQuYnVmZmVyVG9JbnQoc2lnbmF0dXJlc1tpXS5zbGljZSgzMiwgNjQpKTtcbiAgICBjaGVjay5jaGVja1NpZ25hdHVyZUlucHV0KHIsIHMpO1xuICAgIGNvbnN0IGUgPSBtYXRoLmdldEUoY29udmVydC5pbnRUb0J1ZmZlcihyKSwgUHgsIG1lc3NhZ2VzW2ldKTtcbiAgICBjb25zdCBSID0gbWF0aC5saWZ0WChzaWduYXR1cmVzW2ldLnNsaWNlKDAsIDMyKSk7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbGVmdFNpZGUgPSBsZWZ0U2lkZS5hZGQocyk7XG4gICAgICByaWdodFNpZGUgPSBSO1xuICAgICAgcmlnaHRTaWRlID0gcmlnaHRTaWRlLmFkZChQLm11bHRpcGx5KGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYSA9IG1hdGgucmFuZG9tQSgpO1xuICAgICAgbGVmdFNpZGUgPSBsZWZ0U2lkZS5hZGQoYS5tdWx0aXBseShzKSk7XG4gICAgICByaWdodFNpZGUgPSByaWdodFNpZGUuYWRkKFIubXVsdGlwbHkoYSkpO1xuICAgICAgcmlnaHRTaWRlID0gcmlnaHRTaWRlLmFkZChQLm11bHRpcGx5KGEubXVsdGlwbHkoZSkpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIUcubXVsdGlwbHkobGVmdFNpZGUpLmVxdWFscyhyaWdodFNpZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaWduLFxuICB2ZXJpZnksXG4gIGJhdGNoVmVyaWZ5LFxufTtcbiIsImNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuY29uc3QgZWN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5jb25zdCBjdXJ2ZSA9IGVjdXJ2ZS5nZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG5jb25zdCBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0Jyk7XG5cbmNvbnN0IGNvbmNhdCA9IEJ1ZmZlci5jb25jYXQ7XG5jb25zdCBHID0gY3VydmUuRztcblxuZnVuY3Rpb24gdGFwcm9vdENvbnN0cnVjdChwdWJLZXksIG1lcmtsZVJvb3QpIHtcbiAgLy8gSWYgdGhlIHNwZW5kaW5nIGNvbmRpdGlvbnMgZG8gbm90IHJlcXVpcmUgYSBzY3JpcHQgcGF0aCwgdGhlIG91dHB1dCBrZXkgc2hvdWxkIGNvbW1pdCB0byBhbiB1bnNwZW5kYWJsZSBzY3JpcHQgcGF0aFxuICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBubyBzY3JpcHQgcGF0aC4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgY29tcHV0aW5nIHRoZSBvdXRwdXQga2V5IHBvaW50IGFzXG4gIC8vIFEgPSBQICsgaW50KGhhc2hUYXBUd2VhayhieXRlcyhQKSkpRy5cbiAgLy8gaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvQklQXzAzNDEjY2l0ZV9ub3RlLTIyXG4gIGlmICghbWVya2xlUm9vdCB8fCBtZXJrbGVSb290Lmxlbmd0aCA9PT0gMCkge1xuICAgIG1lcmtsZVJvb3QgPSBCdWZmZXIuYWxsb2MoMCwgMCk7XG4gIH1cbiAgY29uc3QgUHggPSBjb252ZXJ0LmludFRvQnVmZmVyKHB1YktleS5hZmZpbmVYKTtcbiAgY29uc3QgUCA9IG1hdGgubGlmdFgoUHgpO1xuICBjb25zdCB0d2VhayA9IGNvbnZlcnQuYnVmZmVyVG9JbnQobWF0aC50YWdnZWRIYXNoKCdUYXBUd2VhaycsIGNvbmNhdChbUHgsIG1lcmtsZVJvb3RdKSkpO1xuICBjb25zdCBRID0gUC5hZGQoRy5tdWx0aXBseSh0d2VhaykpO1xuICByZXR1cm4gY29udmVydC5pbnRUb0J1ZmZlcihRLmFmZmluZVgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdGFwcm9vdENvbnN0cnVjdCxcbn07XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKCcuLi9wYXJzZXInKTtcbmZ1bmN0aW9uIGNvbWJpbmUocHNidHMpIHtcbiAgY29uc3Qgc2VsZiA9IHBzYnRzWzBdO1xuICBjb25zdCBzZWxmS2V5VmFscyA9IHBhcnNlcl8xLnBzYnRUb0tleVZhbHMoc2VsZik7XG4gIGNvbnN0IG90aGVycyA9IHBzYnRzLnNsaWNlKDEpO1xuICBpZiAob3RoZXJzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBOb3RoaW5nIHRvIGNvbWJpbmUnKTtcbiAgY29uc3Qgc2VsZlR4ID0gZ2V0VHgoc2VsZik7XG4gIGlmIChzZWxmVHggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tYmluZTogU2VsZiBtaXNzaW5nIHRyYW5zYWN0aW9uJyk7XG4gIH1cbiAgY29uc3Qgc2VsZkdsb2JhbFNldCA9IGdldEtleVNldChzZWxmS2V5VmFscy5nbG9iYWxLZXlWYWxzKTtcbiAgY29uc3Qgc2VsZklucHV0U2V0cyA9IHNlbGZLZXlWYWxzLmlucHV0S2V5VmFscy5tYXAoZ2V0S2V5U2V0KTtcbiAgY29uc3Qgc2VsZk91dHB1dFNldHMgPSBzZWxmS2V5VmFscy5vdXRwdXRLZXlWYWxzLm1hcChnZXRLZXlTZXQpO1xuICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xuICAgIGNvbnN0IG90aGVyVHggPSBnZXRUeChvdGhlcik7XG4gICAgaWYgKFxuICAgICAgb3RoZXJUeCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhb3RoZXJUeC50b0J1ZmZlcigpLmVxdWFscyhzZWxmVHgudG9CdWZmZXIoKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NvbWJpbmU6IE9uZSBvZiB0aGUgUHNidHMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSB0cmFuc2FjdGlvbi4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJLZXlWYWxzID0gcGFyc2VyXzEucHNidFRvS2V5VmFscyhvdGhlcik7XG4gICAgY29uc3Qgb3RoZXJHbG9iYWxTZXQgPSBnZXRLZXlTZXQob3RoZXJLZXlWYWxzLmdsb2JhbEtleVZhbHMpO1xuICAgIG90aGVyR2xvYmFsU2V0LmZvckVhY2goXG4gICAgICBrZXlQdXNoZXIoXG4gICAgICAgIHNlbGZHbG9iYWxTZXQsXG4gICAgICAgIHNlbGZLZXlWYWxzLmdsb2JhbEtleVZhbHMsXG4gICAgICAgIG90aGVyS2V5VmFscy5nbG9iYWxLZXlWYWxzLFxuICAgICAgKSxcbiAgICApO1xuICAgIGNvbnN0IG90aGVySW5wdXRTZXRzID0gb3RoZXJLZXlWYWxzLmlucHV0S2V5VmFscy5tYXAoZ2V0S2V5U2V0KTtcbiAgICBvdGhlcklucHV0U2V0cy5mb3JFYWNoKChpbnB1dFNldCwgaWR4KSA9PlxuICAgICAgaW5wdXRTZXQuZm9yRWFjaChcbiAgICAgICAga2V5UHVzaGVyKFxuICAgICAgICAgIHNlbGZJbnB1dFNldHNbaWR4XSxcbiAgICAgICAgICBzZWxmS2V5VmFscy5pbnB1dEtleVZhbHNbaWR4XSxcbiAgICAgICAgICBvdGhlcktleVZhbHMuaW5wdXRLZXlWYWxzW2lkeF0sXG4gICAgICAgICksXG4gICAgICApLFxuICAgICk7XG4gICAgY29uc3Qgb3RoZXJPdXRwdXRTZXRzID0gb3RoZXJLZXlWYWxzLm91dHB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gICAgb3RoZXJPdXRwdXRTZXRzLmZvckVhY2goKG91dHB1dFNldCwgaWR4KSA9PlxuICAgICAgb3V0cHV0U2V0LmZvckVhY2goXG4gICAgICAgIGtleVB1c2hlcihcbiAgICAgICAgICBzZWxmT3V0cHV0U2V0c1tpZHhdLFxuICAgICAgICAgIHNlbGZLZXlWYWxzLm91dHB1dEtleVZhbHNbaWR4XSxcbiAgICAgICAgICBvdGhlcktleVZhbHMub3V0cHV0S2V5VmFsc1tpZHhdLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBwYXJzZXJfMS5wc2J0RnJvbUtleVZhbHMoc2VsZlR4LCB7XG4gICAgZ2xvYmFsTWFwS2V5VmFsczogc2VsZktleVZhbHMuZ2xvYmFsS2V5VmFscyxcbiAgICBpbnB1dEtleVZhbHM6IHNlbGZLZXlWYWxzLmlucHV0S2V5VmFscyxcbiAgICBvdXRwdXRLZXlWYWxzOiBzZWxmS2V5VmFscy5vdXRwdXRLZXlWYWxzLFxuICB9KTtcbn1cbmV4cG9ydHMuY29tYmluZSA9IGNvbWJpbmU7XG5mdW5jdGlvbiBrZXlQdXNoZXIoc2VsZlNldCwgc2VsZktleVZhbHMsIG90aGVyS2V5VmFscykge1xuICByZXR1cm4ga2V5ID0+IHtcbiAgICBpZiAoc2VsZlNldC5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0t2ID0gb3RoZXJLZXlWYWxzLmZpbHRlcihrdiA9PiBrdi5rZXkudG9TdHJpbmcoJ2hleCcpID09PSBrZXkpWzBdO1xuICAgIHNlbGZLZXlWYWxzLnB1c2gobmV3S3YpO1xuICAgIHNlbGZTZXQuYWRkKGtleSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUeChwc2J0KSB7XG4gIHJldHVybiBwc2J0Lmdsb2JhbE1hcC51bnNpZ25lZFR4O1xufVxuZnVuY3Rpb24gZ2V0S2V5U2V0KGtleVZhbHMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBrZXlWYWxzLmZvckVhY2goa2V5VmFsID0+IHtcbiAgICBjb25zdCBoZXggPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoc2V0LmhhcyhoZXgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBLZXlWYWx1ZSBNYXAga2V5cyBzaG91bGQgYmUgdW5pcXVlJyk7XG4gICAgc2V0LmFkZChoZXgpO1xuICB9KTtcbiAgcmV0dXJuIHNldDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5jb25zdCByYW5nZSA9IG4gPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuR0xPQkFMX1hQVUIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGdsb2JhbFhwdWIgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoa2V5VmFsLmtleS5sZW5ndGggIT09IDc5IHx8ICFbMiwgM10uaW5jbHVkZXMoa2V5VmFsLmtleVs0Nl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogZ2xvYmFsWHB1YiBoYXMgaW52YWxpZCBleHRlbmRlZCBwdWJrZXkgaW4ga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgaWYgKChrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCkgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogR2xvYmFsIEdMT0JBTF9YUFVCIHZhbHVlIGxlbmd0aCBzaG91bGQgYmUgbXVsdGlwbGUgb2YgNCcsXG4gICAgKTtcbiAgfVxuICBjb25zdCBleHRlbmRlZFB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbWFzdGVyRmluZ2VycHJpbnQ6IGtleVZhbC52YWx1ZS5zbGljZSgwLCA0KSxcbiAgICBleHRlbmRlZFB1YmtleSxcbiAgICBwYXRoOiAnbScsXG4gIH07XG4gIGZvciAoY29uc3QgaSBvZiByYW5nZShrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCAtIDEpKSB7XG4gICAgY29uc3QgdmFsID0ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRShpICogNCArIDQpO1xuICAgIGNvbnN0IGlzSGFyZCA9ICEhKHZhbCAmIDB4ODAwMDAwMDApO1xuICAgIGNvbnN0IGlkeCA9IHZhbCAmIDB4N2ZmZmZmZmY7XG4gICAgZGF0YS5wYXRoICs9ICcvJyArIGlkeC50b1N0cmluZygxMCkgKyAoaXNIYXJkID8gXCInXCIgOiAnJyk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCXSk7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5jb25jYXQoW2hlYWQsIGRhdGEuZXh0ZW5kZWRQdWJrZXldKTtcbiAgY29uc3Qgc3BsaXRQYXRoID0gZGF0YS5wYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IHZhbHVlID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNwbGl0UGF0aC5sZW5ndGggKiA0KTtcbiAgZGF0YS5tYXN0ZXJGaW5nZXJwcmludC5jb3B5KHZhbHVlLCAwKTtcbiAgbGV0IG9mZnNldCA9IDQ7XG4gIHNwbGl0UGF0aC5zbGljZSgxKS5mb3JFYWNoKGxldmVsID0+IHtcbiAgICBjb25zdCBpc0hhcmQgPSBsZXZlbC5zbGljZSgtMSkgPT09IFwiJ1wiO1xuICAgIGxldCBudW0gPSAweDdmZmZmZmZmICYgcGFyc2VJbnQoaXNIYXJkID8gbGV2ZWwuc2xpY2UoMCwgLTEpIDogbGV2ZWwsIDEwKTtcbiAgICBpZiAoaXNIYXJkKSBudW0gKz0gMHg4MDAwMDAwMDtcbiAgICB2YWx1ZS53cml0ZVVJbnQzMkxFKG51bSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID1cbiAgJ3sgbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgZXh0ZW5kZWRQdWJrZXk6IEJ1ZmZlcjsgcGF0aDogc3RyaW5nOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgY29uc3QgZXBrID0gZGF0YS5leHRlbmRlZFB1YmtleTtcbiAgY29uc3QgbWZwID0gZGF0YS5tYXN0ZXJGaW5nZXJwcmludDtcbiAgY29uc3QgcCA9IGRhdGEucGF0aDtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoZXBrKSAmJlxuICAgIGVway5sZW5ndGggPT09IDc4ICYmXG4gICAgWzIsIDNdLmluZGV4T2YoZXBrWzQ1XSkgPiAtMSAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihtZnApICYmXG4gICAgbWZwLmxlbmd0aCA9PT0gNCAmJlxuICAgIHR5cGVvZiBwID09PSAnc3RyaW5nJyAmJlxuICAgICEhcC5tYXRjaCgvXm0oXFwvXFxkKyc/KSokLylcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0uZXh0ZW5kZWRQdWJrZXkudG9TdHJpbmcoJ2hleCcpO1xuICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgZHVwZVNldC5hZGQoZHVwZVN0cmluZyk7XG4gIHJldHVybiAoXG4gICAgYXJyYXkuZmlsdGVyKHYgPT4gdi5leHRlbmRlZFB1YmtleS5lcXVhbHMoaXRlbS5leHRlbmRlZFB1YmtleSkpLmxlbmd0aCA9PT0gMFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGRUb0FycmF5ID0gY2FuQWRkVG9BcnJheTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5VTlNJR05FRF9UWF0pLFxuICAgIHZhbHVlOiBkYXRhLnRvQnVmZmVyKCksXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi90eXBlRmllbGRzJyk7XG5jb25zdCBnbG9iYWxYcHViID0gcmVxdWlyZSgnLi9nbG9iYWwvZ2xvYmFsWHB1YicpO1xuY29uc3QgdW5zaWduZWRUeCA9IHJlcXVpcmUoJy4vZ2xvYmFsL3Vuc2lnbmVkVHgnKTtcbmNvbnN0IGZpbmFsU2NyaXB0U2lnID0gcmVxdWlyZSgnLi9pbnB1dC9maW5hbFNjcmlwdFNpZycpO1xuY29uc3QgZmluYWxTY3JpcHRXaXRuZXNzID0gcmVxdWlyZSgnLi9pbnB1dC9maW5hbFNjcmlwdFdpdG5lc3MnKTtcbmNvbnN0IG5vbldpdG5lc3NVdHhvID0gcmVxdWlyZSgnLi9pbnB1dC9ub25XaXRuZXNzVXR4bycpO1xuY29uc3QgcGFydGlhbFNpZyA9IHJlcXVpcmUoJy4vaW5wdXQvcGFydGlhbFNpZycpO1xuY29uc3QgcG9yQ29tbWl0bWVudCA9IHJlcXVpcmUoJy4vaW5wdXQvcG9yQ29tbWl0bWVudCcpO1xuY29uc3Qgc2lnaGFzaFR5cGUgPSByZXF1aXJlKCcuL2lucHV0L3NpZ2hhc2hUeXBlJyk7XG5jb25zdCB0YXBLZXlTaWcgPSByZXF1aXJlKCcuL2lucHV0L3RhcEtleVNpZycpO1xuY29uc3QgdGFwTGVhZlNjcmlwdCA9IHJlcXVpcmUoJy4vaW5wdXQvdGFwTGVhZlNjcmlwdCcpO1xuY29uc3QgdGFwTWVya2xlUm9vdCA9IHJlcXVpcmUoJy4vaW5wdXQvdGFwTWVya2xlUm9vdCcpO1xuY29uc3QgdGFwU2NyaXB0U2lnID0gcmVxdWlyZSgnLi9pbnB1dC90YXBTY3JpcHRTaWcnKTtcbmNvbnN0IHdpdG5lc3NVdHhvID0gcmVxdWlyZSgnLi9pbnB1dC93aXRuZXNzVXR4bycpO1xuY29uc3QgdGFwVHJlZSA9IHJlcXVpcmUoJy4vb3V0cHV0L3RhcFRyZWUnKTtcbmNvbnN0IGJpcDMyRGVyaXZhdGlvbiA9IHJlcXVpcmUoJy4vc2hhcmVkL2JpcDMyRGVyaXZhdGlvbicpO1xuY29uc3QgY2hlY2tQdWJrZXkgPSByZXF1aXJlKCcuL3NoYXJlZC9jaGVja1B1YmtleScpO1xuY29uc3QgcmVkZWVtU2NyaXB0ID0gcmVxdWlyZSgnLi9zaGFyZWQvcmVkZWVtU2NyaXB0Jyk7XG5jb25zdCB0YXBCaXAzMkRlcml2YXRpb24gPSByZXF1aXJlKCcuL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24nKTtcbmNvbnN0IHRhcEludGVybmFsS2V5ID0gcmVxdWlyZSgnLi9zaGFyZWQvdGFwSW50ZXJuYWxLZXknKTtcbmNvbnN0IHdpdG5lc3NTY3JpcHQgPSByZXF1aXJlKCcuL3NoYXJlZC93aXRuZXNzU2NyaXB0Jyk7XG5jb25zdCBnbG9iYWxzID0ge1xuICB1bnNpZ25lZFR4LFxuICBnbG9iYWxYcHViLFxuICAvLyBwYXNzIGFuIEFycmF5IG9mIGtleSBieXRlcyB0aGF0IHJlcXVpcmUgcHVia2V5IGJlc2lkZSB0aGUga2V5XG4gIGNoZWNrUHVia2V5OiBjaGVja1B1YmtleS5tYWtlQ2hlY2tlcihbXSksXG59O1xuZXhwb3J0cy5nbG9iYWxzID0gZ2xvYmFscztcbmNvbnN0IGlucHV0cyA9IHtcbiAgbm9uV2l0bmVzc1V0eG8sXG4gIHBhcnRpYWxTaWcsXG4gIHNpZ2hhc2hUeXBlLFxuICBmaW5hbFNjcmlwdFNpZyxcbiAgZmluYWxTY3JpcHRXaXRuZXNzLFxuICBwb3JDb21taXRtZW50LFxuICB3aXRuZXNzVXR4byxcbiAgYmlwMzJEZXJpdmF0aW9uOiBiaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICApLFxuICByZWRlZW1TY3JpcHQ6IHJlZGVlbVNjcmlwdC5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICksXG4gIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1NDUklQVCxcbiAgKSxcbiAgY2hlY2tQdWJrZXk6IGNoZWNrUHVia2V5Lm1ha2VDaGVja2VyKFtcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRyxcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICBdKSxcbiAgdGFwS2V5U2lnLFxuICB0YXBTY3JpcHRTaWcsXG4gIHRhcExlYWZTY3JpcHQsXG4gIHRhcEJpcDMyRGVyaXZhdGlvbjogdGFwQmlwMzJEZXJpdmF0aW9uLm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0JJUDMyX0RFUklWQVRJT04sXG4gICksXG4gIHRhcEludGVybmFsS2V5OiB0YXBJbnRlcm5hbEtleS5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9JTlRFUk5BTF9LRVksXG4gICksXG4gIHRhcE1lcmtsZVJvb3QsXG59O1xuZXhwb3J0cy5pbnB1dHMgPSBpbnB1dHM7XG5jb25zdCBvdXRwdXRzID0ge1xuICBiaXAzMkRlcml2YXRpb246IGJpcDMyRGVyaXZhdGlvbi5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICApLFxuICByZWRlZW1TY3JpcHQ6IHJlZGVlbVNjcmlwdC5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5SRURFRU1fU0NSSVBULFxuICApLFxuICB3aXRuZXNzU2NyaXB0OiB3aXRuZXNzU2NyaXB0Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLldJVE5FU1NfU0NSSVBULFxuICApLFxuICBjaGVja1B1YmtleTogY2hlY2tQdWJrZXkubWFrZUNoZWNrZXIoW1xuICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OLFxuICBdKSxcbiAgdGFwQmlwMzJEZXJpdmF0aW9uOiB0YXBCaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX0JJUDMyX0RFUklWQVRJT04sXG4gICksXG4gIHRhcFRyZWUsXG4gIHRhcEludGVybmFsS2V5OiB0YXBJbnRlcm5hbEtleS5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZLFxuICApLFxufTtcbmV4cG9ydHMub3V0cHV0cyA9IG91dHB1dHM7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBmaW5hbFNjcmlwdFNpZyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUddKTtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgdmFsdWU6IGRhdGEsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEuZmluYWxTY3JpcHRTaWcgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGZpbmFsU2NyaXB0V2l0bmVzcyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRXSVRORVNTXSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBkYXRhLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuIChcbiAgICAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5maW5hbFNjcmlwdFdpdG5lc3MgPT09IHVuZGVmaW5lZFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgbm9uV2l0bmVzc1V0eG8gd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE9dKSxcbiAgICB2YWx1ZTogZGF0YSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdCdWZmZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5ub25XaXRuZXNzVXR4byA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUEFSVElBTF9TSUcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHBhcnRpYWxTaWcgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgIShrZXlWYWwua2V5Lmxlbmd0aCA9PT0gMzQgfHwga2V5VmFsLmtleS5sZW5ndGggPT09IDY2KSB8fFxuICAgICFbMiwgMywgNF0uaW5jbHVkZXMoa2V5VmFsLmtleVsxXSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogcGFydGlhbFNpZyBoYXMgaW52YWxpZCBwdWJrZXkgaW4ga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJrZXksXG4gICAgc2lnbmF0dXJlOiBrZXlWYWwudmFsdWUsXG4gIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShwU2lnKSB7XG4gIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUEFSVElBTF9TSUddKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IEJ1ZmZlci5jb25jYXQoW2hlYWQsIHBTaWcucHVia2V5XSksXG4gICAgdmFsdWU6IHBTaWcuc2lnbmF0dXJlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ3sgcHVia2V5OiBCdWZmZXI7IHNpZ25hdHVyZTogQnVmZmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5wdWJrZXkpICYmXG4gICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEuc2lnbmF0dXJlKSAmJlxuICAgIFszMywgNjVdLmluY2x1ZGVzKGRhdGEucHVia2V5Lmxlbmd0aCkgJiZcbiAgICBbMiwgMywgNF0uaW5jbHVkZXMoZGF0YS5wdWJrZXlbMF0pICYmXG4gICAgaXNEZXJTaWdXaXRoU2lnaGFzaChkYXRhLnNpZ25hdHVyZSlcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGlzRGVyU2lnV2l0aFNpZ2hhc2goYnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgfHwgYnVmLmxlbmd0aCA8IDkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZlswXSAhPT0gMHgzMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmLmxlbmd0aCAhPT0gYnVmWzFdICsgMykgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmWzJdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHJMZW4gPSBidWZbM107XG4gIGlmIChyTGVuID4gMzMgfHwgckxlbiA8IDEpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZlszICsgckxlbiArIDFdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNMZW4gPSBidWZbMyArIHJMZW4gKyAyXTtcbiAgaWYgKHNMZW4gPiAzMyB8fCBzTGVuIDwgMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmLmxlbmd0aCAhPT0gMyArIHJMZW4gKyAyICsgc0xlbiArIDIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gIGNvbnN0IGR1cGVTdHJpbmcgPSBpdGVtLnB1YmtleS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkpLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHBvckNvbW1pdG1lbnQgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QT1JfQ09NTUlUTUVOVF0pO1xuICByZXR1cm4ge1xuICAgIGtleSxcbiAgICB2YWx1ZTogQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdzdHJpbmcnO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5wb3JDb21taXRtZW50ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHNpZ2hhc2hUeXBlIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbC52YWx1ZS5yZWFkVUludDMyTEUoMCk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEVdKTtcbiAgY29uc3QgdmFsdWUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gIHZhbHVlLndyaXRlVUludDMyTEUoZGF0YSwgMCk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ251bWJlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnNpZ2hhc2hUeXBlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChcbiAgICBrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfS0VZX1NJRyB8fFxuICAgIGtleVZhbC5rZXkubGVuZ3RoICE9PSAxXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwS2V5U2lnIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgaWYgKCFjaGVjayhrZXlWYWwudmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogdGFwS2V5U2lnIG5vdCBhIHZhbGlkIDY0LTY1LWJ5dGUgQklQMzQwIHNpZ25hdHVyZScsXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9LRVlfU0lHXSk7XG4gIHJldHVybiB7IGtleSwgdmFsdWUgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdCdWZmZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIChkYXRhLmxlbmd0aCA9PT0gNjQgfHwgZGF0YS5sZW5ndGggPT09IDY1KTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEudGFwS2V5U2lnID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTEVBRl9TQ1JJUFQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHRhcExlYWZTY3JpcHQgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoKGtleVZhbC5rZXkubGVuZ3RoIC0gMikgJSAzMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IHRhcExlYWZTY3JpcHQgaGFzIGludmFsaWQgY29udHJvbCBibG9jayBpbiBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBjb25zdCBsZWFmVmVyc2lvbiA9IGtleVZhbC52YWx1ZVtrZXlWYWwudmFsdWUubGVuZ3RoIC0gMV07XG4gIGlmICgoa2V5VmFsLmtleVsxXSAmIDB4ZmUpICE9PSBsZWFmVmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IHRhcExlYWZTY3JpcHQgYmFkIGxlYWYgdmVyc2lvbiBpbiBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBjb25zdCBzY3JpcHQgPSBrZXlWYWwudmFsdWUuc2xpY2UoMCwgLTEpO1xuICBjb25zdCBjb250cm9sQmxvY2sgPSBrZXlWYWwua2V5LnNsaWNlKDEpO1xuICByZXR1cm4geyBjb250cm9sQmxvY2ssIHNjcmlwdCwgbGVhZlZlcnNpb24gfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHRTY3JpcHQpIHtcbiAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTEVBRl9TQ1JJUFRdKTtcbiAgY29uc3QgdmVyQnVmID0gQnVmZmVyLmZyb20oW3RTY3JpcHQubGVhZlZlcnNpb25dKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IEJ1ZmZlci5jb25jYXQoW2hlYWQsIHRTY3JpcHQuY29udHJvbEJsb2NrXSksXG4gICAgdmFsdWU6IEJ1ZmZlci5jb25jYXQoW3RTY3JpcHQuc2NyaXB0LCB2ZXJCdWZdKSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9XG4gICd7IGNvbnRyb2xCbG9jazogQnVmZmVyOyBsZWFmVmVyc2lvbjogbnVtYmVyLCBzY3JpcHQ6IEJ1ZmZlcjsgfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiAoXG4gICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEuY29udHJvbEJsb2NrKSAmJlxuICAgIChkYXRhLmNvbnRyb2xCbG9jay5sZW5ndGggLSAxKSAlIDMyID09PSAwICYmXG4gICAgKGRhdGEuY29udHJvbEJsb2NrWzBdICYgMHhmZSkgPT09IGRhdGEubGVhZlZlcnNpb24gJiZcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5zY3JpcHQpXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gIGNvbnN0IGR1cGVTdHJpbmcgPSBpdGVtLmNvbnRyb2xCbG9jay50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgcmV0dXJuIChcbiAgICBhcnJheS5maWx0ZXIodiA9PiB2LmNvbnRyb2xCbG9jay5lcXVhbHMoaXRlbS5jb250cm9sQmxvY2spKS5sZW5ndGggPT09IDBcbiAgKTtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoXG4gICAga2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX01FUktMRV9ST09UIHx8XG4gICAga2V5VmFsLmtleS5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB0YXBNZXJrbGVSb290IHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgaWYgKCFjaGVjayhrZXlWYWwudmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IHRhcE1lcmtsZVJvb3Qgbm90IGEgMzItYnl0ZSBoYXNoJyk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1RdKTtcbiAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IDMyO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS50YXBNZXJrbGVSb290ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfU0NSSVBUX1NJRykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwU2NyaXB0U2lnIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgaWYgKGtleVZhbC5rZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IHRhcFNjcmlwdFNpZyBoYXMgaW52YWxpZCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoa2V5VmFsLnZhbHVlLmxlbmd0aCAhPT0gNjQgJiYga2V5VmFsLnZhbHVlLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiB0YXBTY3JpcHRTaWcgaGFzIGludmFsaWQgc2lnbmF0dXJlIGluIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGNvbnN0IHB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSwgMzMpO1xuICBjb25zdCBsZWFmSGFzaCA9IGtleVZhbC5rZXkuc2xpY2UoMzMpO1xuICByZXR1cm4ge1xuICAgIHB1YmtleSxcbiAgICBsZWFmSGFzaCxcbiAgICBzaWduYXR1cmU6IGtleVZhbC52YWx1ZSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHRTaWcpIHtcbiAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfU0NSSVBUX1NJR10pO1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmNvbmNhdChbaGVhZCwgdFNpZy5wdWJrZXksIHRTaWcubGVhZkhhc2hdKSxcbiAgICB2YWx1ZTogdFNpZy5zaWduYXR1cmUsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBwdWJrZXk6IEJ1ZmZlcjsgbGVhZkhhc2g6IEJ1ZmZlcjsgc2lnbmF0dXJlOiBCdWZmZXI7IH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gKFxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnB1YmtleSkgJiZcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5sZWFmSGFzaCkgJiZcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5zaWduYXR1cmUpICYmXG4gICAgZGF0YS5wdWJrZXkubGVuZ3RoID09PSAzMiAmJlxuICAgIGRhdGEubGVhZkhhc2gubGVuZ3RoID09PSAzMiAmJlxuICAgIChkYXRhLnNpZ25hdHVyZS5sZW5ndGggPT09IDY0IHx8IGRhdGEuc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjUpXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gIGNvbnN0IGR1cGVTdHJpbmcgPVxuICAgIGl0ZW0ucHVia2V5LnRvU3RyaW5nKCdoZXgnKSArIGl0ZW0ubGVhZkhhc2gudG9TdHJpbmcoJ2hleCcpO1xuICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgZHVwZVNldC5hZGQoZHVwZVN0cmluZyk7XG4gIHJldHVybiAoXG4gICAgYXJyYXkuZmlsdGVyKFxuICAgICAgdiA9PiB2LnB1YmtleS5lcXVhbHMoaXRlbS5wdWJrZXkpICYmIHYubGVhZkhhc2guZXF1YWxzKGl0ZW0ubGVhZkhhc2gpLFxuICAgICkubGVuZ3RoID09PSAwXG4gICk7XG59XG5leHBvcnRzLmNhbkFkZFRvQXJyYXkgPSBjYW5BZGRUb0FycmF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmNvbnN0IHRvb2xzXzEgPSByZXF1aXJlKCcuLi90b29scycpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL3ZhcmludCcpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB3aXRuZXNzVXR4byB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gdG9vbHNfMS5yZWFkVUludDY0TEUoa2V5VmFsLnZhbHVlLCAwKTtcbiAgbGV0IF9vZmZzZXQgPSA4O1xuICBjb25zdCBzY3JpcHRMZW4gPSB2YXJ1aW50LmRlY29kZShrZXlWYWwudmFsdWUsIF9vZmZzZXQpO1xuICBfb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoc2NyaXB0TGVuKTtcbiAgY29uc3Qgc2NyaXB0ID0ga2V5VmFsLnZhbHVlLnNsaWNlKF9vZmZzZXQpO1xuICBpZiAoc2NyaXB0Lmxlbmd0aCAhPT0gc2NyaXB0TGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IFdJVE5FU1NfVVRYTyBzY3JpcHQgaXMgbm90IHByb3BlciBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcmlwdCxcbiAgICB2YWx1ZSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgeyBzY3JpcHQsIHZhbHVlIH0gPSBkYXRhO1xuICBjb25zdCB2YXJpbnRMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdC5sZW5ndGgpO1xuICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHZhcmludExlbiArIHNjcmlwdC5sZW5ndGgpO1xuICB0b29sc18xLndyaXRlVUludDY0TEUocmVzdWx0LCB2YWx1ZSwgMCk7XG4gIHZhcnVpbnQuZW5jb2RlKHNjcmlwdC5sZW5ndGgsIHJlc3VsdCwgOCk7XG4gIHNjcmlwdC5jb3B5KHJlc3VsdCwgOCArIHZhcmludExlbik7XG4gIHJldHVybiB7XG4gICAga2V5OiBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPXSksXG4gICAgdmFsdWU6IHJlc3VsdCxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICd7IHNjcmlwdDogQnVmZmVyOyB2YWx1ZTogbnVtYmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNjcmlwdCkgJiYgdHlwZW9mIGRhdGEudmFsdWUgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS53aXRuZXNzVXR4byA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL3ZhcmludCcpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoXG4gICAga2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFIHx8XG4gICAga2V5VmFsLmtleS5sZW5ndGggIT09IDFcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB0YXBUcmVlIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgbGV0IF9vZmZzZXQgPSAwO1xuICBjb25zdCBkYXRhID0gW107XG4gIHdoaWxlIChfb2Zmc2V0IDwga2V5VmFsLnZhbHVlLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlcHRoID0ga2V5VmFsLnZhbHVlW19vZmZzZXQrK107XG4gICAgY29uc3QgbGVhZlZlcnNpb24gPSBrZXlWYWwudmFsdWVbX29mZnNldCsrXTtcbiAgICBjb25zdCBzY3JpcHRMZW4gPSB2YXJ1aW50LmRlY29kZShrZXlWYWwudmFsdWUsIF9vZmZzZXQpO1xuICAgIF9vZmZzZXQgKz0gdmFydWludC5lbmNvZGluZ0xlbmd0aChzY3JpcHRMZW4pO1xuICAgIGRhdGEucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIGxlYWZWZXJzaW9uLFxuICAgICAgc2NyaXB0OiBrZXlWYWwudmFsdWUuc2xpY2UoX29mZnNldCwgX29mZnNldCArIHNjcmlwdExlbiksXG4gICAgfSk7XG4gICAgX29mZnNldCArPSBzY3JpcHRMZW47XG4gIH1cbiAgcmV0dXJuIHsgbGVhdmVzOiBkYXRhIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZSh0cmVlKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX1RSRUVdKTtcbiAgY29uc3QgYnVmcyA9IFtdLmNvbmNhdChcbiAgICAuLi50cmVlLmxlYXZlcy5tYXAodGFwTGVhZiA9PiBbXG4gICAgICBCdWZmZXIub2YodGFwTGVhZi5kZXB0aCwgdGFwTGVhZi5sZWFmVmVyc2lvbiksXG4gICAgICB2YXJ1aW50LmVuY29kZSh0YXBMZWFmLnNjcmlwdC5sZW5ndGgpLFxuICAgICAgdGFwTGVhZi5zY3JpcHQsXG4gICAgXSksXG4gICk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBCdWZmZXIuY29uY2F0KGJ1ZnMpLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID1cbiAgJ3sgbGVhdmVzOiBbeyBkZXB0aDogbnVtYmVyOyBsZWFmVmVyc2lvbjogbnVtYmVyLCBzY3JpcHQ6IEJ1ZmZlcjsgfV0gfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLmxlYXZlcykgJiZcbiAgICBkYXRhLmxlYXZlcy5ldmVyeShcbiAgICAgIHRhcExlYWYgPT5cbiAgICAgICAgdGFwTGVhZi5kZXB0aCA+PSAwICYmXG4gICAgICAgIHRhcExlYWYuZGVwdGggPD0gMTI4ICYmXG4gICAgICAgICh0YXBMZWFmLmxlYWZWZXJzaW9uICYgMHhmZSkgPT09IHRhcExlYWYubGVhZlZlcnNpb24gJiZcbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKHRhcExlYWYuc2NyaXB0KSxcbiAgICApXG4gICk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnRhcFRyZWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJhbmdlID0gbiA9PiBbLi4uQXJyYXkobikua2V5cygpXTtcbmNvbnN0IGlzVmFsaWRERVJLZXkgPSBwdWJrZXkgPT5cbiAgKHB1YmtleS5sZW5ndGggPT09IDMzICYmIFsyLCAzXS5pbmNsdWRlcyhwdWJrZXlbMF0pKSB8fFxuICAocHVia2V5Lmxlbmd0aCA9PT0gNjUgJiYgNCA9PT0gcHVia2V5WzBdKTtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFLCBpc1ZhbGlkUHVia2V5ID0gaXNWYWxpZERFUktleSkge1xuICBmdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IFRZUEVfQllURSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGJpcDMyRGVyaXZhdGlvbiB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgICBpZiAoIWlzVmFsaWRQdWJrZXkocHVia2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBiaXAzMkRlcml2YXRpb24gaGFzIGludmFsaWQgcHVia2V5IGluIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKChrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCkgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IElucHV0IEJJUDMyX0RFUklWQVRJT04gdmFsdWUgbGVuZ3RoIHNob3VsZCBiZSBtdWx0aXBsZSBvZiA0JyxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBtYXN0ZXJGaW5nZXJwcmludDoga2V5VmFsLnZhbHVlLnNsaWNlKDAsIDQpLFxuICAgICAgcHVia2V5LFxuICAgICAgcGF0aDogJ20nLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKGtleVZhbC52YWx1ZS5sZW5ndGggLyA0IC0gMSkpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGtleVZhbC52YWx1ZS5yZWFkVUludDMyTEUoaSAqIDQgKyA0KTtcbiAgICAgIGNvbnN0IGlzSGFyZCA9ICEhKHZhbCAmIDB4ODAwMDAwMDApO1xuICAgICAgY29uc3QgaWR4ID0gdmFsICYgMHg3ZmZmZmZmZjtcbiAgICAgIGRhdGEucGF0aCArPSAnLycgKyBpZHgudG9TdHJpbmcoMTApICsgKGlzSGFyZCA/IFwiJ1wiIDogJycpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbVFlQRV9CWVRFXSk7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmNvbmNhdChbaGVhZCwgZGF0YS5wdWJrZXldKTtcbiAgICBjb25zdCBzcGxpdFBhdGggPSBkYXRhLnBhdGguc3BsaXQoJy8nKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzcGxpdFBhdGgubGVuZ3RoICogNCk7XG4gICAgZGF0YS5tYXN0ZXJGaW5nZXJwcmludC5jb3B5KHZhbHVlLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gNDtcbiAgICBzcGxpdFBhdGguc2xpY2UoMSkuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zdCBpc0hhcmQgPSBsZXZlbC5zbGljZSgtMSkgPT09IFwiJ1wiO1xuICAgICAgbGV0IG51bSA9IDB4N2ZmZmZmZmYgJiBwYXJzZUludChpc0hhcmQgPyBsZXZlbC5zbGljZSgwLCAtMSkgOiBsZXZlbCwgMTApO1xuICAgICAgaWYgKGlzSGFyZCkgbnVtICs9IDB4ODAwMDAwMDA7XG4gICAgICB2YWx1ZS53cml0ZVVJbnQzMkxFKG51bSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGV4cGVjdGVkID1cbiAgICAneyBtYXN0ZXJGaW5nZXJwcmludDogQnVmZmVyOyBwdWJrZXk6IEJ1ZmZlcjsgcGF0aDogc3RyaW5nOyB9JztcbiAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5wdWJrZXkpICYmXG4gICAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5tYXN0ZXJGaW5nZXJwcmludCkgJiZcbiAgICAgIHR5cGVvZiBkYXRhLnBhdGggPT09ICdzdHJpbmcnICYmXG4gICAgICBpc1ZhbGlkUHVia2V5KGRhdGEucHVia2V5KSAmJlxuICAgICAgZGF0YS5tYXN0ZXJGaW5nZXJwcmludC5sZW5ndGggPT09IDRcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgICBjb25zdCBkdXBlU3RyaW5nID0gaXRlbS5wdWJrZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICAgIGR1cGVTZXQuYWRkKGR1cGVTdHJpbmcpO1xuICAgIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnB1YmtleS5lcXVhbHMoaXRlbS5wdWJrZXkpKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlLFxuICAgIGNoZWNrLFxuICAgIGV4cGVjdGVkLFxuICAgIGNhbkFkZFRvQXJyYXksXG4gIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VDaGVja2VyKHB1YmtleVR5cGVzKSB7XG4gIHJldHVybiBjaGVja1B1YmtleTtcbiAgZnVuY3Rpb24gY2hlY2tQdWJrZXkoa2V5VmFsKSB7XG4gICAgbGV0IHB1YmtleTtcbiAgICBpZiAocHVia2V5VHlwZXMuaW5jbHVkZXMoa2V5VmFsLmtleVswXSkpIHtcbiAgICAgIHB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gICAgICBpZiAoXG4gICAgICAgICEocHVia2V5Lmxlbmd0aCA9PT0gMzMgfHwgcHVia2V5Lmxlbmd0aCA9PT0gNjUpIHx8XG4gICAgICAgICFbMiwgMywgNF0uaW5jbHVkZXMocHVia2V5WzBdKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRm9ybWF0IEVycm9yOiBpbnZhbGlkIHB1YmtleSBpbiBrZXkgMHgnICsga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwdWJrZXk7XG4gIH1cbn1cbmV4cG9ydHMubWFrZUNoZWNrZXIgPSBtYWtlQ2hlY2tlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSkge1xuICBmdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IFRZUEVfQllURSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHJlZGVlbVNjcmlwdCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfTtcbiAgfVxuICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICBmdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEucmVkZWVtU2NyaXB0ID09PSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlLFxuICAgIGNoZWNrLFxuICAgIGV4cGVjdGVkLFxuICAgIGNhbkFkZCxcbiAgfTtcbn1cbmV4cG9ydHMubWFrZUNvbnZlcnRlciA9IG1ha2VDb252ZXJ0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL3ZhcmludCcpO1xuY29uc3QgYmlwMzJEZXJpdmF0aW9uID0gcmVxdWlyZSgnLi9iaXAzMkRlcml2YXRpb24nKTtcbmNvbnN0IGlzVmFsaWRCSVAzNDBLZXkgPSBwdWJrZXkgPT4gcHVia2V5Lmxlbmd0aCA9PT0gMzI7XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSkge1xuICBjb25zdCBwYXJlbnQgPSBiaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihUWVBFX0JZVEUsIGlzVmFsaWRCSVAzNDBLZXkpO1xuICBmdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgY29uc3Qgbkhhc2hlcyA9IHZhcnVpbnQuZGVjb2RlKGtleVZhbC52YWx1ZSk7XG4gICAgY29uc3Qgbkhhc2hlc0xlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobkhhc2hlcyk7XG4gICAgY29uc3QgYmFzZSA9IHBhcmVudC5kZWNvZGUoe1xuICAgICAga2V5OiBrZXlWYWwua2V5LFxuICAgICAgdmFsdWU6IGtleVZhbC52YWx1ZS5zbGljZShuSGFzaGVzTGVuICsgbkhhc2hlcyAqIDMyKSxcbiAgICB9KTtcbiAgICBjb25zdCBsZWFmSGFzaGVzID0gbmV3IEFycmF5KG5IYXNoZXMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBfb2Zmc2V0ID0gbkhhc2hlc0xlbjsgaSA8IG5IYXNoZXM7IGkrKywgX29mZnNldCArPSAzMikge1xuICAgICAgbGVhZkhhc2hlc1tpXSA9IGtleVZhbC52YWx1ZS5zbGljZShfb2Zmc2V0LCBfb2Zmc2V0ICsgMzIpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYmFzZSwgeyBsZWFmSGFzaGVzIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3QgYmFzZSA9IHBhcmVudC5lbmNvZGUoZGF0YSk7XG4gICAgY29uc3Qgbkhhc2hlc0xlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoZGF0YS5sZWFmSGFzaGVzLmxlbmd0aCk7XG4gICAgY29uc3Qgbkhhc2hlc0J1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuSGFzaGVzTGVuKTtcbiAgICB2YXJ1aW50LmVuY29kZShkYXRhLmxlYWZIYXNoZXMubGVuZ3RoLCBuSGFzaGVzQnVmKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQoW25IYXNoZXNCdWYsIC4uLmRhdGEubGVhZkhhc2hlcywgYmFzZS52YWx1ZV0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBiYXNlLCB7IHZhbHVlIH0pO1xuICB9XG4gIGNvbnN0IGV4cGVjdGVkID1cbiAgICAneyAnICtcbiAgICAnbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgJyArXG4gICAgJ3B1YmtleTogQnVmZmVyOyAnICtcbiAgICAncGF0aDogc3RyaW5nOyAnICtcbiAgICAnbGVhZkhhc2hlczogQnVmZmVyW107ICcgK1xuICAgICd9JztcbiAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICBBcnJheS5pc0FycmF5KGRhdGEubGVhZkhhc2hlcykgJiZcbiAgICAgIGRhdGEubGVhZkhhc2hlcy5ldmVyeShcbiAgICAgICAgbGVhZkhhc2ggPT4gQnVmZmVyLmlzQnVmZmVyKGxlYWZIYXNoKSAmJiBsZWFmSGFzaC5sZW5ndGggPT09IDMyLFxuICAgICAgKSAmJlxuICAgICAgcGFyZW50LmNoZWNrKGRhdGEpXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGUsXG4gICAgY2hlY2ssXG4gICAgZXhwZWN0ZWQsXG4gICAgY2FuQWRkVG9BcnJheTogcGFyZW50LmNhbkFkZFRvQXJyYXksXG4gIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFKSB7XG4gIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFIHx8IGtleVZhbC5rZXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwSW50ZXJuYWxLZXkgd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXlWYWwudmFsdWUubGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiB0YXBJbnRlcm5hbEtleSBub3QgYSAzMi1ieXRlIHgtb25seSBwdWJrZXknLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbVFlQRV9CWVRFXSk7XG4gICAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xuICB9XG4gIGNvbnN0IGV4cGVjdGVkID0gJ0J1ZmZlcic7XG4gIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSAzMjtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEudGFwSW50ZXJuYWxLZXkgPT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlLFxuICAgIGNoZWNrLFxuICAgIGV4cGVjdGVkLFxuICAgIGNhbkFkZCxcbiAgfTtcbn1cbmV4cG9ydHMubWFrZUNvbnZlcnRlciA9IG1ha2VDb252ZXJ0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUpIHtcbiAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSBUWVBFX0JZVEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB3aXRuZXNzU2NyaXB0IHdpdGgga2V5IDB4JyArXG4gICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW1RZUEVfQllURV0pO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGV4cGVjdGVkID0gJ0J1ZmZlcic7XG4gIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS53aXRuZXNzU2NyaXB0ID09PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZSxcbiAgICBjaGVjayxcbiAgICBleHBlY3RlZCxcbiAgICBjYW5BZGQsXG4gIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCcuL3ZhcmludCcpO1xuZXhwb3J0cy5yYW5nZSA9IG4gPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5mdW5jdGlvbiByZXZlcnNlQnVmZmVyKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDEpIHJldHVybiBidWZmZXI7XG4gIGxldCBqID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIGxldCB0bXAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0bXAgPSBidWZmZXJbaV07XG4gICAgYnVmZmVyW2ldID0gYnVmZmVyW2pdO1xuICAgIGJ1ZmZlcltqXSA9IHRtcDtcbiAgICBqLS07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMucmV2ZXJzZUJ1ZmZlciA9IHJldmVyc2VCdWZmZXI7XG5mdW5jdGlvbiBrZXlWYWxzVG9CdWZmZXIoa2V5VmFscykge1xuICBjb25zdCBidWZmZXJzID0ga2V5VmFscy5tYXAoa2V5VmFsVG9CdWZmZXIpO1xuICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oWzBdKSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xufVxuZXhwb3J0cy5rZXlWYWxzVG9CdWZmZXIgPSBrZXlWYWxzVG9CdWZmZXI7XG5mdW5jdGlvbiBrZXlWYWxUb0J1ZmZlcihrZXlWYWwpIHtcbiAgY29uc3Qga2V5TGVuID0ga2V5VmFsLmtleS5sZW5ndGg7XG4gIGNvbnN0IHZhbExlbiA9IGtleVZhbC52YWx1ZS5sZW5ndGg7XG4gIGNvbnN0IGtleVZhckludExlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoa2V5TGVuKTtcbiAgY29uc3QgdmFsVmFySW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aCh2YWxMZW4pO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoXG4gICAga2V5VmFySW50TGVuICsga2V5TGVuICsgdmFsVmFySW50TGVuICsgdmFsTGVuLFxuICApO1xuICB2YXJ1aW50LmVuY29kZShrZXlMZW4sIGJ1ZmZlciwgMCk7XG4gIGtleVZhbC5rZXkuY29weShidWZmZXIsIGtleVZhckludExlbik7XG4gIHZhcnVpbnQuZW5jb2RlKHZhbExlbiwgYnVmZmVyLCBrZXlWYXJJbnRMZW4gKyBrZXlMZW4pO1xuICBrZXlWYWwudmFsdWUuY29weShidWZmZXIsIGtleVZhckludExlbiArIGtleUxlbiArIHZhbFZhckludExlbik7XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmtleVZhbFRvQnVmZmVyID0ga2V5VmFsVG9CdWZmZXI7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL21hc3Rlci9pbmRleC5qcyNMMTEyN1xuZnVuY3Rpb24gdmVyaWZ1aW50KHZhbHVlLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG4gIGlmICh2YWx1ZSA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpO1xuICBpZiAodmFsdWUgPiBtYXgpIHRocm93IG5ldyBFcnJvcignUmFuZ2VFcnJvcjogdmFsdWUgb3V0IG9mIHJhbmdlJyk7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNvbnN0IGEgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gIGxldCBiID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgYiAqPSAweDEwMDAwMDAwMDtcbiAgdmVyaWZ1aW50KGIgKyBhLCAweDAwMWZmZmZmZmZmZmZmZmYpO1xuICByZXR1cm4gYiArIGE7XG59XG5leHBvcnRzLnJlYWRVSW50NjRMRSA9IHJlYWRVSW50NjRMRTtcbmZ1bmN0aW9uIHdyaXRlVUludDY0TEUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gIHZlcmlmdWludCh2YWx1ZSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh2YWx1ZSAmIC0xLCBvZmZzZXQpO1xuICBidWZmZXIud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKHZhbHVlIC8gMHgxMDAwMDAwMDApLCBvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5leHBvcnRzLndyaXRlVUludDY0TEUgPSB3cml0ZVVJbnQ2NExFO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbmZ1bmN0aW9uIGNoZWNrVUludDUzKG4pIHtcbiAgaWYgKG4gPCAwIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSIHx8IG4gJSAxICE9PSAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbn1cbmZ1bmN0aW9uIGVuY29kZShfbnVtYmVyLCBidWZmZXIsIG9mZnNldCkge1xuICBjaGVja1VJbnQ1MyhfbnVtYmVyKTtcbiAgaWYgKCFidWZmZXIpIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChfbnVtYmVyKSk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDA7XG4gIC8vIDggYml0XG4gIGlmIChfbnVtYmVyIDwgMHhmZCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KF9udW1iZXIsIG9mZnNldCk7XG4gICAgT2JqZWN0LmFzc2lnbihlbmNvZGUsIHsgYnl0ZXM6IDEgfSk7XG4gICAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAoX251bWJlciA8PSAweGZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZkLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKF9udW1iZXIsIG9mZnNldCArIDEpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiAzIH0pO1xuICAgIC8vIDMyIGJpdFxuICB9IGVsc2UgaWYgKF9udW1iZXIgPD0gMHhmZmZmZmZmZikge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmUsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoX251bWJlciwgb2Zmc2V0ICsgMSk7XG4gICAgT2JqZWN0LmFzc2lnbihlbmNvZGUsIHsgYnl0ZXM6IDUgfSk7XG4gICAgLy8gNjQgYml0XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShfbnVtYmVyID4+PiAwLCBvZmZzZXQgKyAxKTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRSgoX251bWJlciAvIDB4MTAwMDAwMDAwKSB8IDAsIG9mZnNldCArIDUpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiA5IH0pO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwO1xuICBjb25zdCBmaXJzdCA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgLy8gOCBiaXRcbiAgaWYgKGZpcnN0IDwgMHhmZCkge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiAxIH0pO1xuICAgIHJldHVybiBmaXJzdDtcbiAgICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZCkge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiAzIH0pO1xuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCArIDEpO1xuICAgIC8vIDMyIGJpdFxuICB9IGVsc2UgaWYgKGZpcnN0ID09PSAweGZlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihkZWNvZGUsIHsgYnl0ZXM6IDUgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSk7XG4gICAgLy8gNjQgYml0XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmFzc2lnbihkZWNvZGUsIHsgYnl0ZXM6IDkgfSk7XG4gICAgY29uc3QgbG8gPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpO1xuICAgIGNvbnN0IGhpID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA1KTtcbiAgICBjb25zdCBfbnVtYmVyID0gaGkgKiAweDAxMDAwMDAwMDAgKyBsbztcbiAgICBjaGVja1VJbnQ1MyhfbnVtYmVyKTtcbiAgICByZXR1cm4gX251bWJlcjtcbiAgfVxufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGluZ0xlbmd0aChfbnVtYmVyKSB7XG4gIGNoZWNrVUludDUzKF9udW1iZXIpO1xuICByZXR1cm4gX251bWJlciA8IDB4ZmRcbiAgICA/IDFcbiAgICA6IF9udW1iZXIgPD0gMHhmZmZmXG4gICAgPyAzXG4gICAgOiBfbnVtYmVyIDw9IDB4ZmZmZmZmZmZcbiAgICA/IDVcbiAgICA6IDk7XG59XG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGg7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlcicpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci90b29scycpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci92YXJpbnQnKTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIHBzYnRGcm9tQnVmZmVyKGJ1ZmZlciwgdHhHZXR0ZXIpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZ1bmN0aW9uIHZhclNsaWNlKCkge1xuICAgIGNvbnN0IGtleUxlbiA9IHZhcnVpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdmFydWludC5lbmNvZGluZ0xlbmd0aChrZXlMZW4pO1xuICAgIGNvbnN0IGtleSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGtleUxlbik7XG4gICAgb2Zmc2V0ICs9IGtleUxlbjtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVSW50MzJCRSgpIHtcbiAgICBjb25zdCBudW0gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIG51bTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVUludDgoKSB7XG4gICAgY29uc3QgbnVtID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHJldHVybiBudW07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0S2V5VmFsdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gdmFyU2xpY2UoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhclNsaWNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tFbmRPZktleVZhbFBhaXJzKCkge1xuICAgIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IFVuZXhwZWN0ZWQgRW5kIG9mIFBTQlQnKTtcbiAgICB9XG4gICAgY29uc3QgaXNFbmQgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCkgPT09IDA7XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIGlzRW5kO1xuICB9XG4gIGlmIChyZWFkVUludDMyQkUoKSAhPT0gMHg3MDczNjI3NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnZhbGlkIE1hZ2ljIE51bWJlcicpO1xuICB9XG4gIGlmIChyZWFkVUludDgoKSAhPT0gMHhmZikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3JtYXQgRXJyb3I6IE1hZ2ljIE51bWJlciBtdXN0IGJlIGZvbGxvd2VkIGJ5IDB4ZmYgc2VwYXJhdG9yJyxcbiAgICApO1xuICB9XG4gIGNvbnN0IGdsb2JhbE1hcEtleVZhbHMgPSBbXTtcbiAgY29uc3QgZ2xvYmFsS2V5SW5kZXggPSB7fTtcbiAgd2hpbGUgKCFjaGVja0VuZE9mS2V5VmFsUGFpcnMoKSkge1xuICAgIGNvbnN0IGtleVZhbCA9IGdldEtleVZhbHVlKCk7XG4gICAgY29uc3QgaGV4S2V5ID0ga2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKGdsb2JhbEtleUluZGV4W2hleEtleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZ2xvYmFsIGtleW1hcDoga2V5ICcgKyBoZXhLZXksXG4gICAgICApO1xuICAgIH1cbiAgICBnbG9iYWxLZXlJbmRleFtoZXhLZXldID0gMTtcbiAgICBnbG9iYWxNYXBLZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgfVxuICBjb25zdCB1bnNpZ25lZFR4TWFwcyA9IGdsb2JhbE1hcEtleVZhbHMuZmlsdGVyKFxuICAgIGtleVZhbCA9PiBrZXlWYWwua2V5WzBdID09PSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFgsXG4gICk7XG4gIGlmICh1bnNpZ25lZFR4TWFwcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT25seSBvbmUgVU5TSUdORURfVFggYWxsb3dlZCcpO1xuICB9XG4gIGNvbnN0IHVuc2lnbmVkVHggPSB0eEdldHRlcih1bnNpZ25lZFR4TWFwc1swXS52YWx1ZSk7XG4gIC8vIEdldCBpbnB1dCBhbmQgb3V0cHV0IGNvdW50cyB0byBsb29wIHRoZSByZXNwZWN0aXZlIGZpZWxkc1xuICBjb25zdCB7IGlucHV0Q291bnQsIG91dHB1dENvdW50IH0gPSB1bnNpZ25lZFR4LmdldElucHV0T3V0cHV0Q291bnRzKCk7XG4gIGNvbnN0IGlucHV0S2V5VmFscyA9IFtdO1xuICBjb25zdCBvdXRwdXRLZXlWYWxzID0gW107XG4gIC8vIEdldCBpbnB1dCBmaWVsZHNcbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKGlucHV0Q291bnQpKSB7XG4gICAgY29uc3QgaW5wdXRLZXlJbmRleCA9IHt9O1xuICAgIGNvbnN0IGlucHV0ID0gW107XG4gICAgd2hpbGUgKCFjaGVja0VuZE9mS2V5VmFsUGFpcnMoKSkge1xuICAgICAgY29uc3Qga2V5VmFsID0gZ2V0S2V5VmFsdWUoKTtcbiAgICAgIGNvbnN0IGhleEtleSA9IGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaWYgKGlucHV0S2V5SW5kZXhbaGV4S2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZWFjaCBpbnB1dDogJyArXG4gICAgICAgICAgICAnaW5wdXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCArXG4gICAgICAgICAgICAnIGtleSAnICtcbiAgICAgICAgICAgIGhleEtleSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0S2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgICBpbnB1dC5wdXNoKGtleVZhbCk7XG4gICAgfVxuICAgIGlucHV0S2V5VmFscy5wdXNoKGlucHV0KTtcbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4IG9mIHRvb2xzXzEucmFuZ2Uob3V0cHV0Q291bnQpKSB7XG4gICAgY29uc3Qgb3V0cHV0S2V5SW5kZXggPSB7fTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoIWNoZWNrRW5kT2ZLZXlWYWxQYWlycygpKSB7XG4gICAgICBjb25zdCBrZXlWYWwgPSBnZXRLZXlWYWx1ZSgpO1xuICAgICAgY29uc3QgaGV4S2V5ID0ga2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBpZiAob3V0cHV0S2V5SW5kZXhbaGV4S2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZWFjaCBvdXRwdXQ6ICcgK1xuICAgICAgICAgICAgJ291dHB1dCBpbmRleCAnICtcbiAgICAgICAgICAgIGluZGV4ICtcbiAgICAgICAgICAgICcga2V5ICcgK1xuICAgICAgICAgICAgaGV4S2V5LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb3V0cHV0S2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgICBvdXRwdXQucHVzaChrZXlWYWwpO1xuICAgIH1cbiAgICBvdXRwdXRLZXlWYWxzLnB1c2gob3V0cHV0KTtcbiAgfVxuICByZXR1cm4gcHNidEZyb21LZXlWYWxzKHVuc2lnbmVkVHgsIHtcbiAgICBnbG9iYWxNYXBLZXlWYWxzLFxuICAgIGlucHV0S2V5VmFscyxcbiAgICBvdXRwdXRLZXlWYWxzLFxuICB9KTtcbn1cbmV4cG9ydHMucHNidEZyb21CdWZmZXIgPSBwc2J0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGNoZWNrS2V5QnVmZmVyKHR5cGUsIGtleUJ1Ziwga2V5TnVtKSB7XG4gIGlmICgha2V5QnVmLmVxdWFscyhCdWZmZXIuZnJvbShba2V5TnVtXSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZvcm1hdCBFcnJvcjogSW52YWxpZCAke3R5cGV9IGtleTogJHtrZXlCdWYudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0cy5jaGVja0tleUJ1ZmZlciA9IGNoZWNrS2V5QnVmZmVyO1xuZnVuY3Rpb24gcHNidEZyb21LZXlWYWxzKFxuICB1bnNpZ25lZFR4LFxuICB7IGdsb2JhbE1hcEtleVZhbHMsIGlucHV0S2V5VmFscywgb3V0cHV0S2V5VmFscyB9LFxuKSB7XG4gIC8vIFRoYXQgd2FzIGVhc3kgOi0pXG4gIGNvbnN0IGdsb2JhbE1hcCA9IHtcbiAgICB1bnNpZ25lZFR4LFxuICB9O1xuICBsZXQgdHhDb3VudCA9IDA7XG4gIGZvciAoY29uc3Qga2V5VmFsIG9mIGdsb2JhbE1hcEtleVZhbHMpIHtcbiAgICAvLyBJZiBhIGdsb2JhbE1hcCBpdGVtIG5lZWRzIHB1YmtleSwgdW5jb21tZW50XG4gICAgLy8gY29uc3QgcHVia2V5ID0gY29udmVydC5nbG9iYWxzLmNoZWNrUHVia2V5KGtleVZhbCk7XG4gICAgc3dpdGNoIChrZXlWYWwua2V5WzBdKSB7XG4gICAgICBjYXNlIHR5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5VTlNJR05FRF9UWDpcbiAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgJ2dsb2JhbCcsXG4gICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFgsXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eENvdW50ID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBHbG9iYWxNYXAgaGFzIG11bHRpcGxlIFVOU0lHTkVEX1RYJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHhDb3VudCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCOlxuICAgICAgICBpZiAoZ2xvYmFsTWFwLmdsb2JhbFhwdWIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGdsb2JhbE1hcC5nbG9iYWxYcHViID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsTWFwLmdsb2JhbFhwdWIucHVzaChjb252ZXJ0Lmdsb2JhbHMuZ2xvYmFsWHB1Yi5kZWNvZGUoa2V5VmFsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsbG93IGluY2x1c2lvbiBkdXJpbmcgc2VyaWFsaXphdGlvbi5cbiAgICAgICAgaWYgKCFnbG9iYWxNYXAudW5rbm93bktleVZhbHMpIGdsb2JhbE1hcC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICBnbG9iYWxNYXAudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIH1cbiAgfVxuICAvLyBHZXQgaW5wdXQgYW5kIG91dHB1dCBjb3VudHMgdG8gbG9vcCB0aGUgcmVzcGVjdGl2ZSBmaWVsZHNcbiAgY29uc3QgaW5wdXRDb3VudCA9IGlucHV0S2V5VmFscy5sZW5ndGg7XG4gIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0S2V5VmFscy5sZW5ndGg7XG4gIGNvbnN0IGlucHV0cyA9IFtdO1xuICBjb25zdCBvdXRwdXRzID0gW107XG4gIC8vIEdldCBpbnB1dCBmaWVsZHNcbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKGlucHV0Q291bnQpKSB7XG4gICAgY29uc3QgaW5wdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleVZhbCBvZiBpbnB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICBjb252ZXJ0LmlucHV0cy5jaGVja1B1YmtleShrZXlWYWwpO1xuICAgICAgc3dpdGNoIChrZXlWYWwua2V5WzBdKSB7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTzpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBOT05fV0lUTkVTU19VVFhPJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvID0gY29udmVydC5pbnB1dHMubm9uV2l0bmVzc1V0eG8uZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1VUWE8sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5wdXQud2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1VUWE8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQud2l0bmVzc1V0eG8gPSBjb252ZXJ0LmlucHV0cy53aXRuZXNzVXR4by5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRzpcbiAgICAgICAgICBpZiAoaW5wdXQucGFydGlhbFNpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnB1dC5wYXJ0aWFsU2lnID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnBhcnRpYWxTaWcucHVzaChjb252ZXJ0LmlucHV0cy5wYXJ0aWFsU2lnLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEU6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnB1dC5zaWdoYXNoVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogSW5wdXQgaGFzIG11bHRpcGxlIFNJR0hBU0hfVFlQRScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5zaWdoYXNoVHlwZSA9IGNvbnZlcnQuaW5wdXRzLnNpZ2hhc2hUeXBlLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5wdXQucmVkZWVtU2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnB1dCBoYXMgbXVsdGlwbGUgUkVERUVNX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0LmlucHV0cy5yZWRlZW1TY3JpcHQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfU0NSSVBULFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC53aXRuZXNzU2NyaXB0ID0gY29udmVydC5pbnB1dHMud2l0bmVzc1NjcmlwdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChpbnB1dC5iaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQuYmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LmJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5pbnB1dHMuYmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUcsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC5maW5hbFNjcmlwdFNpZyA9IGNvbnZlcnQuaW5wdXRzLmZpbmFsU2NyaXB0U2lnLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1M6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MgPSBjb252ZXJ0LmlucHV0cy5maW5hbFNjcmlwdFdpdG5lc3MuZGVjb2RlKFxuICAgICAgICAgICAga2V5VmFsLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBPUl9DT01NSVRNRU5ULFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXQucG9yQ29tbWl0bWVudCA9IGNvbnZlcnQuaW5wdXRzLnBvckNvbW1pdG1lbnQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUc6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9LRVlfU0lHLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXQudGFwS2V5U2lnID0gY29udmVydC5pbnB1dHMudGFwS2V5U2lnLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9TQ1JJUFRfU0lHOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBTY3JpcHRTaWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQudGFwU2NyaXB0U2lnID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnRhcFNjcmlwdFNpZy5wdXNoKGNvbnZlcnQuaW5wdXRzLnRhcFNjcmlwdFNpZy5kZWNvZGUoa2V5VmFsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0xFQUZfU0NSSVBUOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnRhcExlYWZTY3JpcHQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdC5wdXNoKGNvbnZlcnQuaW5wdXRzLnRhcExlYWZTY3JpcHQuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5pbnB1dHMudGFwQmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWTpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0LnRhcEludGVybmFsS2V5ID0gY29udmVydC5pbnB1dHMudGFwSW50ZXJuYWxLZXkuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX01FUktMRV9ST09UOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1QsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC50YXBNZXJrbGVSb290ID0gY29udmVydC5pbnB1dHMudGFwTWVya2xlUm9vdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgaW5jbHVzaW9uIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIGlmICghaW5wdXQudW5rbm93bktleVZhbHMpIGlucHV0LnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnB1dHMucHVzaChpbnB1dCk7XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKG91dHB1dENvdW50KSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5VmFsIG9mIG91dHB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICBjb252ZXJ0Lm91dHB1dHMuY2hlY2tQdWJrZXkoa2V5VmFsKTtcbiAgICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5SRURFRU1fU0NSSVBUOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob3V0cHV0LnJlZGVlbVNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBSRURFRU1fU0NSSVBUJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0Lm91dHB1dHMucmVkZWVtU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChvdXRwdXQud2l0bmVzc1NjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQud2l0bmVzc1NjcmlwdCA9IGNvbnZlcnQub3V0cHV0cy53aXRuZXNzU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChvdXRwdXQuYmlwMzJEZXJpdmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dHB1dC5iaXAzMkRlcml2YXRpb24gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5vdXRwdXRzLmJpcDMyRGVyaXZhdGlvbi5kZWNvZGUoa2V5VmFsKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9JTlRFUk5BTF9LRVksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvdXRwdXQudGFwSW50ZXJuYWxLZXkgPSBjb252ZXJ0Lm91dHB1dHMudGFwSW50ZXJuYWxLZXkuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFLFxuICAgICAgICAgICk7XG4gICAgICAgICAgb3V0cHV0LnRhcFRyZWUgPSBjb252ZXJ0Lm91dHB1dHMudGFwVHJlZS5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX0JJUDMyX0RFUklWQVRJT046XG4gICAgICAgICAgaWYgKG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbiA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uLnB1c2goXG4gICAgICAgICAgICBjb252ZXJ0Lm91dHB1dHMudGFwQmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFvdXRwdXQudW5rbm93bktleVZhbHMpIG91dHB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICAgIG91dHB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICB9XG4gIHJldHVybiB7IGdsb2JhbE1hcCwgaW5wdXRzLCBvdXRwdXRzIH07XG59XG5leHBvcnRzLnBzYnRGcm9tS2V5VmFscyA9IHBzYnRGcm9tS2V5VmFscztcbiIsIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZnJvbUJ1ZmZlcicpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vdG9CdWZmZXInKSk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlcicpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci90b29scycpO1xuZnVuY3Rpb24gcHNidFRvQnVmZmVyKHsgZ2xvYmFsTWFwLCBpbnB1dHMsIG91dHB1dHMgfSkge1xuICBjb25zdCB7IGdsb2JhbEtleVZhbHMsIGlucHV0S2V5VmFscywgb3V0cHV0S2V5VmFscyB9ID0gcHNidFRvS2V5VmFscyh7XG4gICAgZ2xvYmFsTWFwLFxuICAgIGlucHV0cyxcbiAgICBvdXRwdXRzLFxuICB9KTtcbiAgY29uc3QgZ2xvYmFsQnVmZmVyID0gdG9vbHNfMS5rZXlWYWxzVG9CdWZmZXIoZ2xvYmFsS2V5VmFscyk7XG4gIGNvbnN0IGtleVZhbHNPckVtcHR5VG9CdWZmZXIgPSBrZXlWYWxzID0+XG4gICAga2V5VmFscy5sZW5ndGggPT09IDBcbiAgICAgID8gW0J1ZmZlci5mcm9tKFswXSldXG4gICAgICA6IGtleVZhbHMubWFwKHRvb2xzXzEua2V5VmFsc1RvQnVmZmVyKTtcbiAgY29uc3QgaW5wdXRCdWZmZXJzID0ga2V5VmFsc09yRW1wdHlUb0J1ZmZlcihpbnB1dEtleVZhbHMpO1xuICBjb25zdCBvdXRwdXRCdWZmZXJzID0ga2V5VmFsc09yRW1wdHlUb0J1ZmZlcihvdXRwdXRLZXlWYWxzKTtcbiAgY29uc3QgaGVhZGVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDUpO1xuICBoZWFkZXIud3JpdGVVSW50QkUoMHg3MDczNjI3NGZmLCAwLCA1KTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoXG4gICAgW2hlYWRlciwgZ2xvYmFsQnVmZmVyXS5jb25jYXQoaW5wdXRCdWZmZXJzLCBvdXRwdXRCdWZmZXJzKSxcbiAgKTtcbn1cbmV4cG9ydHMucHNidFRvQnVmZmVyID0gcHNidFRvQnVmZmVyO1xuY29uc3Qgc29ydEtleVZhbHMgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS5rZXkuY29tcGFyZShiLmtleSk7XG59O1xuZnVuY3Rpb24ga2V5VmFsc0Zyb21NYXAoa2V5VmFsTWFwLCBjb252ZXJ0ZXJGYWN0b3J5KSB7XG4gIGNvbnN0IGtleUhleFNldCA9IG5ldyBTZXQoKTtcbiAgY29uc3Qga2V5VmFscyA9IE9iamVjdC5lbnRyaWVzKGtleVZhbE1hcCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgPT09ICd1bmtub3duS2V5VmFscycpIHJldHVybiByZXN1bHQ7XG4gICAgLy8gV2UgYXJlIGNoZWNraW5nIGZvciB1bmRlZmluZWQgYW55d2F5cy4gU28gaWdub3JlIFRTIGVycm9yXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlckZhY3Rvcnlba2V5XTtcbiAgICBpZiAoY29udmVydGVyID09PSB1bmRlZmluZWQpIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgZW5jb2RlZEtleVZhbHMgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pLm1hcChcbiAgICAgIGNvbnZlcnRlci5lbmNvZGUsXG4gICAgKTtcbiAgICBjb25zdCBrZXlIZXhlcyA9IGVuY29kZWRLZXlWYWxzLm1hcChrdiA9PiBrdi5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBrZXlIZXhlcy5mb3JFYWNoKGhleCA9PiB7XG4gICAgICBpZiAoa2V5SGV4U2V0LmhhcyhoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcmlhbGl6ZSBFcnJvcjogRHVwbGljYXRlIGtleTogJyArIGhleCk7XG4gICAgICBrZXlIZXhTZXQuYWRkKGhleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoZW5jb2RlZEtleVZhbHMpO1xuICB9LCBbXSk7XG4gIC8vIEdldCBvdGhlciBrZXlWYWxzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gZ290dGVuXG4gIGNvbnN0IG90aGVyS2V5VmFscyA9IGtleVZhbE1hcC51bmtub3duS2V5VmFsc1xuICAgID8ga2V5VmFsTWFwLnVua25vd25LZXlWYWxzLmZpbHRlcihrZXlWYWwgPT4ge1xuICAgICAgICByZXR1cm4gIWtleUhleFNldC5oYXMoa2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgICAgfSlcbiAgICA6IFtdO1xuICByZXR1cm4ga2V5VmFscy5jb25jYXQob3RoZXJLZXlWYWxzKS5zb3J0KHNvcnRLZXlWYWxzKTtcbn1cbmZ1bmN0aW9uIHBzYnRUb0tleVZhbHMoeyBnbG9iYWxNYXAsIGlucHV0cywgb3V0cHV0cyB9KSB7XG4gIC8vIEZpcnN0IHBhcnNlIHRoZSBnbG9iYWwga2V5VmFsc1xuICAvLyBHZXQgYW55IGV4dHJhIGtleXZhbHMgdG8gcGFzcyBhbG9uZ1xuICByZXR1cm4ge1xuICAgIGdsb2JhbEtleVZhbHM6IGtleVZhbHNGcm9tTWFwKGdsb2JhbE1hcCwgY29udmVydC5nbG9iYWxzKSxcbiAgICBpbnB1dEtleVZhbHM6IGlucHV0cy5tYXAoaSA9PiBrZXlWYWxzRnJvbU1hcChpLCBjb252ZXJ0LmlucHV0cykpLFxuICAgIG91dHB1dEtleVZhbHM6IG91dHB1dHMubWFwKG8gPT4ga2V5VmFsc0Zyb21NYXAobywgY29udmVydC5vdXRwdXRzKSksXG4gIH07XG59XG5leHBvcnRzLnBzYnRUb0tleVZhbHMgPSBwc2J0VG9LZXlWYWxzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbWJpbmVyXzEgPSByZXF1aXJlKCcuL2NvbWJpbmVyJyk7XG5jb25zdCBwYXJzZXJfMSA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuL3R5cGVGaWVsZHMnKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jbGFzcyBQc2J0IHtcbiAgY29uc3RydWN0b3IodHgpIHtcbiAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIHRoaXMuZ2xvYmFsTWFwID0ge1xuICAgICAgdW5zaWduZWRUeDogdHgsXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZnJvbUJhc2U2NChkYXRhLCB0eEZyb21CdWZmZXIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihidWZmZXIsIHR4RnJvbUJ1ZmZlcik7XG4gIH1cbiAgc3RhdGljIGZyb21IZXgoZGF0YSwgdHhGcm9tQnVmZmVyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCB0eEZyb21CdWZmZXIpO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgdHhGcm9tQnVmZmVyKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHBhcnNlcl8xLnBzYnRGcm9tQnVmZmVyKGJ1ZmZlciwgdHhGcm9tQnVmZmVyKTtcbiAgICBjb25zdCBwc2J0ID0gbmV3IHRoaXMocmVzdWx0cy5nbG9iYWxNYXAudW5zaWduZWRUeCk7XG4gICAgT2JqZWN0LmFzc2lnbihwc2J0LCByZXN1bHRzKTtcbiAgICByZXR1cm4gcHNidDtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIHJldHVybiBwYXJzZXJfMS5wc2J0VG9CdWZmZXIodGhpcyk7XG4gIH1cbiAgdXBkYXRlR2xvYmFsKHVwZGF0ZURhdGEpIHtcbiAgICB1dGlsc18xLnVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhLCB0aGlzLmdsb2JhbE1hcCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdXBkYXRlRGF0YSkge1xuICAgIGNvbnN0IGlucHV0ID0gdXRpbHNfMS5jaGVja0ZvcklucHV0KHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICB1dGlsc18xLnVwZGF0ZUlucHV0KHVwZGF0ZURhdGEsIGlucHV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGRhdGVPdXRwdXQob3V0cHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB1dGlsc18xLmNoZWNrRm9yT3V0cHV0KHRoaXMub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgIHV0aWxzXzEudXBkYXRlT3V0cHV0KHVwZGF0ZURhdGEsIG91dHB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkVW5rbm93bktleVZhbFRvR2xvYmFsKGtleVZhbCkge1xuICAgIHV0aWxzXzEuY2hlY2tIYXNLZXkoXG4gICAgICBrZXlWYWwsXG4gICAgICB0aGlzLmdsb2JhbE1hcC51bmtub3duS2V5VmFscyxcbiAgICAgIHV0aWxzXzEuZ2V0RW51bUxlbmd0aCh0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMpLFxuICAgICk7XG4gICAgaWYgKCF0aGlzLmdsb2JhbE1hcC51bmtub3duS2V5VmFscykgdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbE1hcC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwga2V5VmFsKSB7XG4gICAgY29uc3QgaW5wdXQgPSB1dGlsc18xLmNoZWNrRm9ySW5wdXQodGhpcy5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIHV0aWxzXzEuY2hlY2tIYXNLZXkoXG4gICAgICBrZXlWYWwsXG4gICAgICBpbnB1dC51bmtub3duS2V5VmFscyxcbiAgICAgIHV0aWxzXzEuZ2V0RW51bUxlbmd0aCh0eXBlRmllbGRzXzEuSW5wdXRUeXBlcyksXG4gICAgKTtcbiAgICBpZiAoIWlucHV0LnVua25vd25LZXlWYWxzKSBpbnB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgIGlucHV0LnVua25vd25LZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHV0aWxzXzEuY2hlY2tGb3JPdXRwdXQodGhpcy5vdXRwdXRzLCBvdXRwdXRJbmRleCk7XG4gICAgdXRpbHNfMS5jaGVja0hhc0tleShcbiAgICAgIGtleVZhbCxcbiAgICAgIG91dHB1dC51bmtub3duS2V5VmFscyxcbiAgICAgIHV0aWxzXzEuZ2V0RW51bUxlbmd0aCh0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMpLFxuICAgICk7XG4gICAgaWYgKCFvdXRwdXQudW5rbm93bktleVZhbHMpIG91dHB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgIG91dHB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkSW5wdXQoaW5wdXREYXRhKSB7XG4gICAgdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC5hZGRJbnB1dChpbnB1dERhdGEpO1xuICAgIHRoaXMuaW5wdXRzLnB1c2goe1xuICAgICAgdW5rbm93bktleVZhbHM6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IGFkZEtleVZhbHMgPSBpbnB1dERhdGEudW5rbm93bktleVZhbHMgfHwgW107XG4gICAgY29uc3QgaW5wdXRJbmRleCA9IHRoaXMuaW5wdXRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZEtleVZhbHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd25LZXlWYWxzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICB9XG4gICAgYWRkS2V5VmFscy5mb3JFYWNoKGtleVZhbCA9PlxuICAgICAgdGhpcy5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBrZXlWYWwpLFxuICAgICk7XG4gICAgdXRpbHNfMS5hZGRJbnB1dEF0dHJpYnV0ZXModGhpcy5pbnB1dHMsIGlucHV0RGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICB0aGlzLmdsb2JhbE1hcC51bnNpZ25lZFR4LmFkZE91dHB1dChvdXRwdXREYXRhKTtcbiAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICB1bmtub3duS2V5VmFsczogW10sXG4gICAgfSk7XG4gICAgY29uc3QgYWRkS2V5VmFscyA9IG91dHB1dERhdGEudW5rbm93bktleVZhbHMgfHwgW107XG4gICAgY29uc3Qgb3V0cHV0SW5kZXggPSB0aGlzLm91dHB1dHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkS2V5VmFscykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93bktleVZhbHMgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgIH1cbiAgICBhZGRLZXlWYWxzLmZvckVhY2goa2V5VmFsID0+XG4gICAgICB0aGlzLmFkZFVua25vd25LZXlWYWxUb0lucHV0KG91dHB1dEluZGV4LCBrZXlWYWwpLFxuICAgICk7XG4gICAgdXRpbHNfMS5hZGRPdXRwdXRBdHRyaWJ1dGVzKHRoaXMub3V0cHV0cywgb3V0cHV0RGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KSB7XG4gICAgY29uc3QgaW5wdXQgPSB1dGlsc18xLmNoZWNrRm9ySW5wdXQodGhpcy5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIHV0aWxzXzEuaW5wdXRDaGVja1VuY2xlYW5GaW5hbGl6ZWQoaW5wdXRJbmRleCwgaW5wdXQpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGlucHV0KSkge1xuICAgICAgaWYgKFxuICAgICAgICAhW1xuICAgICAgICAgICd3aXRuZXNzVXR4bycsXG4gICAgICAgICAgJ25vbldpdG5lc3NVdHhvJyxcbiAgICAgICAgICAnZmluYWxTY3JpcHRTaWcnLFxuICAgICAgICAgICdmaW5hbFNjcmlwdFdpdG5lc3MnLFxuICAgICAgICAgICd1bmtub3duS2V5VmFscycsXG4gICAgICAgIF0uaW5jbHVkZXMoa2V5KVxuICAgICAgKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGVsZXRlIGlucHV0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbWJpbmUoLi4udGhvc2UpIHtcbiAgICAvLyBDb21iaW5lIHRoaXMgd2l0aCB0aG9zZS5cbiAgICAvLyBSZXR1cm4gc2VsZiBmb3IgY2hhaW5pbmcuXG4gICAgY29uc3QgcmVzdWx0ID0gY29tYmluZXJfMS5jb21iaW5lKFt0aGlzXS5jb25jYXQodGhvc2UpKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudG9CdWZmZXIoKTtcbiAgfVxufVxuZXhwb3J0cy5Qc2J0ID0gUHNidDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR2xvYmFsVHlwZXM7XG4oZnVuY3Rpb24oR2xvYmFsVHlwZXMpIHtcbiAgR2xvYmFsVHlwZXNbKEdsb2JhbFR5cGVzWydVTlNJR05FRF9UWCddID0gMCldID0gJ1VOU0lHTkVEX1RYJztcbiAgR2xvYmFsVHlwZXNbKEdsb2JhbFR5cGVzWydHTE9CQUxfWFBVQiddID0gMSldID0gJ0dMT0JBTF9YUFVCJztcbn0pKChHbG9iYWxUeXBlcyA9IGV4cG9ydHMuR2xvYmFsVHlwZXMgfHwgKGV4cG9ydHMuR2xvYmFsVHlwZXMgPSB7fSkpKTtcbmV4cG9ydHMuR0xPQkFMX1RZUEVfTkFNRVMgPSBbJ3Vuc2lnbmVkVHgnLCAnZ2xvYmFsWHB1YiddO1xudmFyIElucHV0VHlwZXM7XG4oZnVuY3Rpb24oSW5wdXRUeXBlcykge1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydOT05fV0lUTkVTU19VVFhPJ10gPSAwKV0gPSAnTk9OX1dJVE5FU1NfVVRYTyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1dJVE5FU1NfVVRYTyddID0gMSldID0gJ1dJVE5FU1NfVVRYTyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1BBUlRJQUxfU0lHJ10gPSAyKV0gPSAnUEFSVElBTF9TSUcnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydTSUdIQVNIX1RZUEUnXSA9IDMpXSA9ICdTSUdIQVNIX1RZUEUnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydSRURFRU1fU0NSSVBUJ10gPSA0KV0gPSAnUkVERUVNX1NDUklQVCc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1dJVE5FU1NfU0NSSVBUJ10gPSA1KV0gPSAnV0lUTkVTU19TQ1JJUFQnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydCSVAzMl9ERVJJVkFUSU9OJ10gPSA2KV0gPSAnQklQMzJfREVSSVZBVElPTic7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ0ZJTkFMX1NDUklQVFNJRyddID0gNyldID0gJ0ZJTkFMX1NDUklQVFNJRyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ0ZJTkFMX1NDUklQVFdJVE5FU1MnXSA9IDgpXSA9ICdGSU5BTF9TQ1JJUFRXSVRORVNTJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snUE9SX0NPTU1JVE1FTlQnXSA9IDkpXSA9ICdQT1JfQ09NTUlUTUVOVCc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1RBUF9LRVlfU0lHJ10gPSAxOSldID0gJ1RBUF9LRVlfU0lHJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snVEFQX1NDUklQVF9TSUcnXSA9IDIwKV0gPSAnVEFQX1NDUklQVF9TSUcnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydUQVBfTEVBRl9TQ1JJUFQnXSA9IDIxKV0gPSAnVEFQX0xFQUZfU0NSSVBUJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snVEFQX0JJUDMyX0RFUklWQVRJT04nXSA9IDIyKV0gPVxuICAgICdUQVBfQklQMzJfREVSSVZBVElPTic7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1RBUF9JTlRFUk5BTF9LRVknXSA9IDIzKV0gPSAnVEFQX0lOVEVSTkFMX0tFWSc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1RBUF9NRVJLTEVfUk9PVCddID0gMjQpXSA9ICdUQVBfTUVSS0xFX1JPT1QnO1xufSkoKElucHV0VHlwZXMgPSBleHBvcnRzLklucHV0VHlwZXMgfHwgKGV4cG9ydHMuSW5wdXRUeXBlcyA9IHt9KSkpO1xuZXhwb3J0cy5JTlBVVF9UWVBFX05BTUVTID0gW1xuICAnbm9uV2l0bmVzc1V0eG8nLFxuICAnd2l0bmVzc1V0eG8nLFxuICAncGFydGlhbFNpZycsXG4gICdzaWdoYXNoVHlwZScsXG4gICdyZWRlZW1TY3JpcHQnLFxuICAnd2l0bmVzc1NjcmlwdCcsXG4gICdiaXAzMkRlcml2YXRpb24nLFxuICAnZmluYWxTY3JpcHRTaWcnLFxuICAnZmluYWxTY3JpcHRXaXRuZXNzJyxcbiAgJ3BvckNvbW1pdG1lbnQnLFxuICAndGFwS2V5U2lnJyxcbiAgJ3RhcFNjcmlwdFNpZycsXG4gICd0YXBMZWFmU2NyaXB0JyxcbiAgJ3RhcEJpcDMyRGVyaXZhdGlvbicsXG4gICd0YXBJbnRlcm5hbEtleScsXG4gICd0YXBNZXJrbGVSb290Jyxcbl07XG52YXIgT3V0cHV0VHlwZXM7XG4oZnVuY3Rpb24oT3V0cHV0VHlwZXMpIHtcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydSRURFRU1fU0NSSVBUJ10gPSAwKV0gPSAnUkVERUVNX1NDUklQVCc7XG4gIE91dHB1dFR5cGVzWyhPdXRwdXRUeXBlc1snV0lUTkVTU19TQ1JJUFQnXSA9IDEpXSA9ICdXSVRORVNTX1NDUklQVCc7XG4gIE91dHB1dFR5cGVzWyhPdXRwdXRUeXBlc1snQklQMzJfREVSSVZBVElPTiddID0gMildID0gJ0JJUDMyX0RFUklWQVRJT04nO1xuICBPdXRwdXRUeXBlc1soT3V0cHV0VHlwZXNbJ1RBUF9JTlRFUk5BTF9LRVknXSA9IDUpXSA9ICdUQVBfSU5URVJOQUxfS0VZJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydUQVBfVFJFRSddID0gNildID0gJ1RBUF9UUkVFJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydUQVBfQklQMzJfREVSSVZBVElPTiddID0gNyldID1cbiAgICAnVEFQX0JJUDMyX0RFUklWQVRJT04nO1xufSkoKE91dHB1dFR5cGVzID0gZXhwb3J0cy5PdXRwdXRUeXBlcyB8fCAoZXhwb3J0cy5PdXRwdXRUeXBlcyA9IHt9KSkpO1xuZXhwb3J0cy5PVVRQVVRfVFlQRV9OQU1FUyA9IFtcbiAgJ3JlZGVlbVNjcmlwdCcsXG4gICd3aXRuZXNzU2NyaXB0JyxcbiAgJ2JpcDMyRGVyaXZhdGlvbicsXG4gICd0YXBJbnRlcm5hbEtleScsXG4gICd0YXBUcmVlJyxcbiAgJ3RhcEJpcDMyRGVyaXZhdGlvbicsXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnZlcnRlciA9IHJlcXVpcmUoJy4vY29udmVydGVyJyk7XG5mdW5jdGlvbiBjaGVja0ZvcklucHV0KGlucHV0cywgaW5wdXRJbmRleCkge1xuICBjb25zdCBpbnB1dCA9IGlucHV0c1tpbnB1dEluZGV4XTtcbiAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgTm8gaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgcmV0dXJuIGlucHV0O1xufVxuZXhwb3J0cy5jaGVja0ZvcklucHV0ID0gY2hlY2tGb3JJbnB1dDtcbmZ1bmN0aW9uIGNoZWNrRm9yT3V0cHV0KG91dHB1dHMsIG91dHB1dEluZGV4KSB7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbb3V0cHV0SW5kZXhdO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgTm8gb3V0cHV0ICMke291dHB1dEluZGV4fWApO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZXhwb3J0cy5jaGVja0Zvck91dHB1dCA9IGNoZWNrRm9yT3V0cHV0O1xuZnVuY3Rpb24gY2hlY2tIYXNLZXkoY2hlY2tLZXlWYWwsIGtleVZhbHMsIGVudW1MZW5ndGgpIHtcbiAgaWYgKGNoZWNrS2V5VmFsLmtleVswXSA8IGVudW1MZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVXNlIHRoZSBtZXRob2QgZm9yIHlvdXIgc3BlY2lmaWMga2V5IGluc3RlYWQgb2YgYWRkVW5rbm93bktleVZhbCpgLFxuICAgICk7XG4gIH1cbiAgaWYgKFxuICAgIGtleVZhbHMgJiZcbiAgICBrZXlWYWxzLmZpbHRlcihrdiA9PiBrdi5rZXkuZXF1YWxzKGNoZWNrS2V5VmFsLmtleSkpLmxlbmd0aCAhPT0gMFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBLZXk6ICR7Y2hlY2tLZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgfVxufVxuZXhwb3J0cy5jaGVja0hhc0tleSA9IGNoZWNrSGFzS2V5O1xuZnVuY3Rpb24gZ2V0RW51bUxlbmd0aChteWVudW0pIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgT2JqZWN0LmtleXMobXllbnVtKS5mb3JFYWNoKHZhbCA9PiB7XG4gICAgaWYgKE51bWJlcihpc05hTihOdW1iZXIodmFsKSkpKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb3VudDtcbn1cbmV4cG9ydHMuZ2V0RW51bUxlbmd0aCA9IGdldEVudW1MZW5ndGg7XG5mdW5jdGlvbiBpbnB1dENoZWNrVW5jbGVhbkZpbmFsaXplZChpbnB1dEluZGV4LCBpbnB1dCkge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4byB8fCBpbnB1dC53aXRuZXNzVXR4bykge1xuICAgIGNvbnN0IG5lZWRTY3JpcHRTaWcgPSAhIWlucHV0LnJlZGVlbVNjcmlwdDtcbiAgICBjb25zdCBuZWVkV2l0bmVzc1NjcmlwdCA9ICEhaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgICBjb25zdCBzY3JpcHRTaWdPSyA9ICFuZWVkU2NyaXB0U2lnIHx8ICEhaW5wdXQuZmluYWxTY3JpcHRTaWc7XG4gICAgY29uc3Qgd2l0bmVzc1NjcmlwdE9LID0gIW5lZWRXaXRuZXNzU2NyaXB0IHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xuICAgIGNvbnN0IGhhc09uZUZpbmFsID0gISFpbnB1dC5maW5hbFNjcmlwdFNpZyB8fCAhIWlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcztcbiAgICByZXN1bHQgPSBzY3JpcHRTaWdPSyAmJiB3aXRuZXNzU2NyaXB0T0sgJiYgaGFzT25lRmluYWw7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW5wdXQgIyR7aW5wdXRJbmRleH0gaGFzIHRvbyBtdWNoIG9yIHRvbyBsaXR0bGUgZGF0YSB0byBjbGVhbmAsXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0cy5pbnB1dENoZWNrVW5jbGVhbkZpbmFsaXplZCA9IGlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkO1xuZnVuY3Rpb24gdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBEYXRhIGZvciAke3R5cGVOYW1lfSBrZXkgJHtuYW1lfSBpcyBpbmNvcnJlY3Q6IEV4cGVjdGVkIGAgK1xuICAgICAgYCR7ZXhwZWN0ZWR9IGFuZCBnb3QgJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gLFxuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlTWFrZXIodHlwZU5hbWUpIHtcbiAgcmV0dXJuICh1cGRhdGVEYXRhLCBtYWluRGF0YSkgPT4ge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh1cGRhdGVEYXRhKSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgZGF0YSA9IHVwZGF0ZURhdGFbbmFtZV07XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB7IGNhbkFkZCwgY2FuQWRkVG9BcnJheSwgY2hlY2ssIGV4cGVjdGVkIH0gPVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnZlcnRlclt0eXBlTmFtZSArICdzJ11bbmFtZV0gfHwge307XG4gICAgICBjb25zdCBpc0FycmF5ID0gISFjYW5BZGRUb0FycmF5O1xuICAgICAgLy8gSWYgdW5rbm93biBkYXRhLiBpZ25vcmUgYW5kIGRvIG5vdCBhZGRcbiAgICAgIGlmIChjaGVjaykge1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAobWFpbkRhdGFbbmFtZV0gJiYgIUFycmF5LmlzQXJyYXkobWFpbkRhdGFbbmFtZV0pKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgdHlwZSAke25hbWV9IG11c3QgYmUgYW4gYXJyYXlgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkYXRhLmV2ZXJ5KGNoZWNrKSkge1xuICAgICAgICAgICAgdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3QgYXJyID0gbWFpbkRhdGFbbmFtZV0gfHwgW107XG4gICAgICAgICAgY29uc3QgZHVwZUNoZWNrU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIGlmICghZGF0YS5ldmVyeSh2ID0+IGNhbkFkZFRvQXJyYXkoYXJyLCB2LCBkdXBlQ2hlY2tTZXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFkZCBkdXBsaWNhdGUgZGF0YSB0byBhcnJheScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgbWFpbkRhdGFbbmFtZV0gPSBhcnIuY29uY2F0KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93Rm9yVXBkYXRlTWFrZXIodHlwZU5hbWUsIG5hbWUsIGV4cGVjdGVkLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjYW5BZGQobWFpbkRhdGEsIGRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgYWRkIGR1cGxpY2F0ZSBkYXRhIHRvICR7dHlwZU5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBtYWluRGF0YVtuYW1lXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnRzLnVwZGF0ZUdsb2JhbCA9IHVwZGF0ZU1ha2VyKCdnbG9iYWwnKTtcbmV4cG9ydHMudXBkYXRlSW5wdXQgPSB1cGRhdGVNYWtlcignaW5wdXQnKTtcbmV4cG9ydHMudXBkYXRlT3V0cHV0ID0gdXBkYXRlTWFrZXIoJ291dHB1dCcpO1xuZnVuY3Rpb24gYWRkSW5wdXRBdHRyaWJ1dGVzKGlucHV0cywgZGF0YSkge1xuICBjb25zdCBpbmRleCA9IGlucHV0cy5sZW5ndGggLSAxO1xuICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQoaW5wdXRzLCBpbmRleCk7XG4gIGV4cG9ydHMudXBkYXRlSW5wdXQoZGF0YSwgaW5wdXQpO1xufVxuZXhwb3J0cy5hZGRJbnB1dEF0dHJpYnV0ZXMgPSBhZGRJbnB1dEF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBhZGRPdXRwdXRBdHRyaWJ1dGVzKG91dHB1dHMsIGRhdGEpIHtcbiAgY29uc3QgaW5kZXggPSBvdXRwdXRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IG91dHB1dCA9IGNoZWNrRm9yT3V0cHV0KG91dHB1dHMsIGluZGV4KTtcbiAgZXhwb3J0cy51cGRhdGVPdXRwdXQoZGF0YSwgb3V0cHV0KTtcbn1cbmV4cG9ydHMuYWRkT3V0cHV0QXR0cmlidXRlcyA9IGFkZE91dHB1dEF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBkZWZhdWx0VmVyc2lvblNldHRlcih2ZXJzaW9uLCB0eEJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0eEJ1ZikgfHwgdHhCdWYubGVuZ3RoIDwgNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2V0IFZlcnNpb246IEludmFsaWQgVHJhbnNhY3Rpb24nKTtcbiAgfVxuICB0eEJ1Zi53cml0ZVVJbnQzMkxFKHZlcnNpb24sIDApO1xuICByZXR1cm4gdHhCdWY7XG59XG5leHBvcnRzLmRlZmF1bHRWZXJzaW9uU2V0dGVyID0gZGVmYXVsdFZlcnNpb25TZXR0ZXI7XG5mdW5jdGlvbiBkZWZhdWx0TG9ja3RpbWVTZXR0ZXIobG9ja3RpbWUsIHR4QnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHR4QnVmKSB8fCB0eEJ1Zi5sZW5ndGggPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgTG9ja3RpbWU6IEludmFsaWQgVHJhbnNhY3Rpb24nKTtcbiAgfVxuICB0eEJ1Zi53cml0ZVVJbnQzMkxFKGxvY2t0aW1lLCB0eEJ1Zi5sZW5ndGggLSA0KTtcbiAgcmV0dXJuIHR4QnVmO1xufVxuZXhwb3J0cy5kZWZhdWx0TG9ja3RpbWVTZXR0ZXIgPSBkZWZhdWx0TG9ja3RpbWVTZXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b091dHB1dFNjcmlwdCA9XG4gIGV4cG9ydHMuZnJvbU91dHB1dFNjcmlwdCA9XG4gIGV4cG9ydHMudG9CZWNoMzIgPVxuICBleHBvcnRzLnRvQmFzZTU4Q2hlY2sgPVxuICBleHBvcnRzLmZyb21CZWNoMzIgPVxuICBleHBvcnRzLmZyb21CYXNlNThDaGVjayA9XG4gICAgdm9pZCAwO1xuY29uc3QgbmV0d29ya3MgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfTUFYX1NJWkUgPSA0MDtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfTUlOX1NJWkUgPSAyO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NQVhfVkVSU0lPTiA9IDE2O1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiA9IDI7XG5jb25zdCBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRiA9IDB4NTA7XG5jb25zdCBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fV0FSTklORyA9XG4gICdXQVJOSU5HOiBTZW5kaW5nIHRvIGEgZnV0dXJlIHNlZ3dpdCB2ZXJzaW9uIGFkZHJlc3MgY2FuIGxlYWQgdG8gbG9zcyBvZiBmdW5kcy4gJyArXG4gICdFbmQgdXNlcnMgTVVTVCBiZSB3YXJuZWQgY2FyZWZ1bGx5IGluIHRoZSBHVUkgYW5kIGFza2VkIGlmIHRoZXkgd2lzaCB0byBwcm9jZWVkICcgK1xuICAnd2l0aCBjYXV0aW9uLiBXYWxsZXRzIHNob3VsZCB2ZXJpZnkgdGhlIHNlZ3dpdCB2ZXJzaW9uIGZyb20gdGhlIG91dHB1dCBvZiBmcm9tQmVjaDMyLCAnICtcbiAgJ3RoZW4gZGVjaWRlIHdoZW4gaXQgaXMgc2FmZSB0byB1c2Ugd2hpY2ggdmVyc2lvbiBvZiBzZWd3aXQuJztcbmZ1bmN0aW9uIF90b0Z1dHVyZVNlZ3dpdEFkZHJlc3Mob3V0cHV0LCBuZXR3b3JrKSB7XG4gIGNvbnN0IGRhdGEgPSBvdXRwdXQuc2xpY2UoMik7XG4gIGlmIChcbiAgICBkYXRhLmxlbmd0aCA8IEZVVFVSRV9TRUdXSVRfTUlOX1NJWkUgfHxcbiAgICBkYXRhLmxlbmd0aCA+IEZVVFVSRV9TRUdXSVRfTUFYX1NJWkVcbiAgKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvZ3JhbSBsZW5ndGggZm9yIHNlZ3dpdCBhZGRyZXNzJyk7XG4gIGNvbnN0IHZlcnNpb24gPSBvdXRwdXRbMF0gLSBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRjtcbiAgaWYgKFxuICAgIHZlcnNpb24gPCBGVVRVUkVfU0VHV0lUX01JTl9WRVJTSU9OIHx8XG4gICAgdmVyc2lvbiA+IEZVVFVSRV9TRUdXSVRfTUFYX1ZFUlNJT05cbiAgKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgaWYgKG91dHB1dFsxXSAhPT0gZGF0YS5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY3JpcHQgZm9yIHNlZ3dpdCBhZGRyZXNzJyk7XG4gIGNvbnNvbGUud2FybihGVVRVUkVfU0VHV0lUX1ZFUlNJT05fV0FSTklORyk7XG4gIHJldHVybiB0b0JlY2gzMihkYXRhLCB2ZXJzaW9uLCBuZXR3b3JrLmJlY2gzMik7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcykge1xuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oYnM1OGNoZWNrLmRlY29kZShhZGRyZXNzKSk7XG4gIC8vIFRPRE86IDQuMC4wLCBtb3ZlIHRvIFwidG9PdXRwdXRTY3JpcHRcIlxuICBpZiAocGF5bG9hZC5sZW5ndGggPCAyMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihhZGRyZXNzICsgJyBpcyB0b28gc2hvcnQnKTtcbiAgaWYgKHBheWxvYWQubGVuZ3RoID4gMjEpIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIGxvbmcnKTtcbiAgY29uc3QgdmVyc2lvbiA9IHBheWxvYWQucmVhZFVpbnQ4KDApO1xuICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgcmV0dXJuIHsgdmVyc2lvbiwgaGFzaCB9O1xufVxuZXhwb3J0cy5mcm9tQmFzZTU4Q2hlY2sgPSBmcm9tQmFzZTU4Q2hlY2s7XG5mdW5jdGlvbiBmcm9tQmVjaDMyKGFkZHJlc3MpIHtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IHZlcnNpb247XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHJlc3VsdCkge1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGJlY2gzMl8xLmJlY2gzMm0uZGVjb2RlKGFkZHJlc3MpO1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBiZWNoMzJfMS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcy5zbGljZSgxKSk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbixcbiAgICBwcmVmaXg6IHJlc3VsdC5wcmVmaXgsXG4gICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gIH07XG59XG5leHBvcnRzLmZyb21CZWNoMzIgPSBmcm9tQmVjaDMyO1xuZnVuY3Rpb24gdG9CYXNlNThDaGVjayhoYXNoLCB2ZXJzaW9uKSB7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAgKDAsIHR5cGVzXzEudHVwbGUpKHR5cGVzXzEuSGFzaDE2MGJpdCwgdHlwZXNfMS5VSW50OCksXG4gICAgYXJndW1lbnRzLFxuICApO1xuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIxKTtcbiAgcGF5bG9hZC53cml0ZVVJbnQ4KHZlcnNpb24sIDApO1xuICBoYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKHBheWxvYWQpO1xufVxuZXhwb3J0cy50b0Jhc2U1OENoZWNrID0gdG9CYXNlNThDaGVjaztcbmZ1bmN0aW9uIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIHByZWZpeCkge1xuICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMFxuICAgID8gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzKVxuICAgIDogYmVjaDMyXzEuYmVjaDMybS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5leHBvcnRzLnRvQmVjaDMyID0gdG9CZWNoMzI7XG5mdW5jdGlvbiBmcm9tT3V0cHV0U2NyaXB0KG91dHB1dCwgbmV0d29yaykge1xuICAvLyBUT0RPOiBOZXR3b3JrXG4gIG5ldHdvcmsgPSBuZXR3b3JrIHx8IG5ldHdvcmtzLmJpdGNvaW47XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAycGtoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyc2goeyBvdXRwdXQsIG5ldHdvcmsgfSkuYWRkcmVzcztcbiAgfSBjYXRjaCAoZSkge31cbiAgdHJ5IHtcbiAgICByZXR1cm4gcGF5bWVudHMucDJ3cGtoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyd3NoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAydHIoeyBvdXRwdXQsIG5ldHdvcmsgfSkuYWRkcmVzcztcbiAgfSBjYXRjaCAoZSkge31cbiAgdHJ5IHtcbiAgICByZXR1cm4gX3RvRnV0dXJlU2Vnd2l0QWRkcmVzcyhvdXRwdXQsIG5ldHdvcmspO1xuICB9IGNhdGNoIChlKSB7fVxuICB0aHJvdyBuZXcgRXJyb3IoYnNjcmlwdC50b0FTTShvdXRwdXQpICsgJyBoYXMgbm8gbWF0Y2hpbmcgQWRkcmVzcycpO1xufVxuZXhwb3J0cy5mcm9tT3V0cHV0U2NyaXB0ID0gZnJvbU91dHB1dFNjcmlwdDtcbmZ1bmN0aW9uIHRvT3V0cHV0U2NyaXB0KGFkZHJlc3MsIG5ldHdvcmspIHtcbiAgbmV0d29yayA9IG5ldHdvcmsgfHwgbmV0d29ya3MuYml0Y29pbjtcbiAgbGV0IGRlY29kZUJhc2U1ODtcbiAgbGV0IGRlY29kZUJlY2gzMjtcbiAgdHJ5IHtcbiAgICBkZWNvZGVCYXNlNTggPSBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGlmIChkZWNvZGVCYXNlNTgpIHtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IGhhc2g6IGRlY29kZUJhc2U1OC5oYXNoIH0pLm91dHB1dDtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgaGFzaDogZGVjb2RlQmFzZTU4Lmhhc2ggfSkub3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVCZWNoMzIgPSBmcm9tQmVjaDMyKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGRlY29kZUJlY2gzMikge1xuICAgICAgaWYgKGRlY29kZUJlY2gzMi5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArICcgaGFzIGFuIGludmFsaWQgcHJlZml4Jyk7XG4gICAgICBpZiAoZGVjb2RlQmVjaDMyLnZlcnNpb24gPT09IDApIHtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMjApXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IGhhc2g6IGRlY29kZUJlY2gzMi5kYXRhIH0pLm91dHB1dDtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMzIpXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3NoKHsgaGFzaDogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBpZiAoZGVjb2RlQmVjaDMyLmRhdGEubGVuZ3RoID09PSAzMilcbiAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ0cih7IHB1YmtleTogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gPj0gRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiAmJlxuICAgICAgICBkZWNvZGVCZWNoMzIudmVyc2lvbiA8PSBGVVRVUkVfU0VHV0lUX01BWF9WRVJTSU9OICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA+PSBGVVRVUkVfU0VHV0lUX01JTl9TSVpFICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA8PSBGVVRVUkVfU0VHV0lUX01BWF9TSVpFXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gKyBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRixcbiAgICAgICAgICBkZWNvZGVCZWNoMzIuZGF0YSxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgbm8gbWF0Y2hpbmcgU2NyaXB0Jyk7XG59XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID0gdG9PdXRwdXRTY3JpcHQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBSZWZlcmVuY2UgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2lcbi8vIEZvcm1hdDogMHgzMCBbdG90YWwtbGVuZ3RoXSAweDAyIFtSLWxlbmd0aF0gW1JdIDB4MDIgW1MtbGVuZ3RoXSBbU11cbi8vIE5PVEU6IFNJR0hBU0ggYnl0ZSBpZ25vcmVkIEFORCByZXN0cmljdGVkLCB0cnVuY2F0ZSBiZWZvcmUgdXNlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuY2hlY2sgPSB2b2lkIDA7XG5mdW5jdGlvbiBjaGVjayhidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCA4KSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXIubGVuZ3RoID4gNzIpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlclswXSAhPT0gMHgzMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmZmVyWzFdICE9PSBidWZmZXIubGVuZ3RoIC0gMikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmZmVyWzJdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGxlblIgPSBidWZmZXJbM107XG4gIGlmIChsZW5SID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICg1ICsgbGVuUiA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbNCArIGxlblJdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGxlblMgPSBidWZmZXJbNSArIGxlblJdO1xuICBpZiAobGVuUyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoNiArIGxlblIgKyBsZW5TICE9PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbNF0gJiAweDgwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChsZW5SID4gMSAmJiBidWZmZXJbNF0gPT09IDB4MDAgJiYgIShidWZmZXJbNV0gJiAweDgwKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmZmVyW2xlblIgKyA2XSAmIDB4ODApIHJldHVybiBmYWxzZTtcbiAgaWYgKGxlblMgPiAxICYmIGJ1ZmZlcltsZW5SICsgNl0gPT09IDB4MDAgJiYgIShidWZmZXJbbGVuUiArIDddICYgMHg4MCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCA4KSB0aHJvdyBuZXcgRXJyb3IoJ0RFUiBzZXF1ZW5jZSBsZW5ndGggaXMgdG9vIHNob3J0Jyk7XG4gIGlmIChidWZmZXIubGVuZ3RoID4gNzIpIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyB0b28gbG9uZycpO1xuICBpZiAoYnVmZmVyWzBdICE9PSAweDMwKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIERFUiBzZXF1ZW5jZScpO1xuICBpZiAoYnVmZmVyWzFdICE9PSBidWZmZXIubGVuZ3RoIC0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFUiBzZXF1ZW5jZSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICBpZiAoYnVmZmVyWzJdICE9PSAweDAyKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIERFUiBpbnRlZ2VyJyk7XG4gIGNvbnN0IGxlblIgPSBidWZmZXJbM107XG4gIGlmIChsZW5SID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHplcm8nKTtcbiAgaWYgKDUgKyBsZW5SID49IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIGludGVnZXIgKDIpJyk7XG4gIGNvbnN0IGxlblMgPSBidWZmZXJbNSArIGxlblJdO1xuICBpZiAobGVuUyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB6ZXJvJyk7XG4gIGlmICg2ICsgbGVuUiArIGxlblMgIT09IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgaW52YWxpZCcpO1xuICBpZiAoYnVmZmVyWzRdICYgMHg4MCkgdGhyb3cgbmV3IEVycm9yKCdSIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIGlmIChsZW5SID4gMSAmJiBidWZmZXJbNF0gPT09IDB4MDAgJiYgIShidWZmZXJbNV0gJiAweDgwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MCkgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIGlmIChsZW5TID4gMSAmJiBidWZmZXJbbGVuUiArIDZdID09PSAweDAwICYmICEoYnVmZmVyW2xlblIgKyA3XSAmIDB4ODApKVxuICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgLy8gbm9uLUJJUDY2IC0gZXh0cmFjdCBSLCBTIHZhbHVlc1xuICByZXR1cm4ge1xuICAgIHI6IGJ1ZmZlci5zbGljZSg0LCA0ICsgbGVuUiksXG4gICAgczogYnVmZmVyLnNsaWNlKDYgKyBsZW5SKSxcbiAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLypcbiAqIEV4cGVjdHMgciBhbmQgcyB0byBiZSBwb3NpdGl2ZSBERVIgaW50ZWdlcnMuXG4gKlxuICogVGhlIERFUiBmb3JtYXQgdXNlcyB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgYXMgYSBzaWduIGJpdCAoJiAweDgwKS5cbiAqIElmIHRoZSBzaWduaWZpY2FudCBiaXQgaXMgc2V0IEFORCB0aGUgaW50ZWdlciBpcyBwb3NpdGl2ZSwgYSAweDAwIGlzIHByZXBlbmRlZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIDAgPT4gICAgIDB4MDBcbiAqICAgICAgMSA9PiAgICAgMHgwMVxuICogICAgIC0xID0+ICAgICAweGZmXG4gKiAgICAxMjcgPT4gICAgIDB4N2ZcbiAqICAgLTEyNyA9PiAgICAgMHg4MVxuICogICAgMTI4ID0+ICAgMHgwMDgwXG4gKiAgIC0xMjggPT4gICAgIDB4ODBcbiAqICAgIDI1NSA9PiAgIDB4MDBmZlxuICogICAtMjU1ID0+ICAgMHhmZjAxXG4gKiAgMTYzMDAgPT4gICAweDNmYWNcbiAqIC0xNjMwMCA9PiAgIDB4YzA1NFxuICogIDYyMzAwID0+IDB4MDBmMzVjXG4gKiAtNjIzMDAgPT4gMHhmZjBjYTRcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHIsIHMpIHtcbiAgY29uc3QgbGVuUiA9IHIubGVuZ3RoO1xuICBjb25zdCBsZW5TID0gcy5sZW5ndGg7XG4gIGlmIChsZW5SID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHplcm8nKTtcbiAgaWYgKGxlblMgPT09IDApIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgemVybycpO1xuICBpZiAobGVuUiA+IDMzKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gIGlmIChsZW5TID4gMzMpIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgaWYgKHJbMF0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKHNbMF0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1MgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKGxlblIgPiAxICYmIHJbMF0gPT09IDB4MDAgJiYgIShyWzFdICYgMHg4MCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICBpZiAobGVuUyA+IDEgJiYgc1swXSA9PT0gMHgwMCAmJiAhKHNbMV0gJiAweDgwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1MgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2ICsgbGVuUiArIGxlblMpO1xuICAvLyAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuICBzaWduYXR1cmVbMF0gPSAweDMwO1xuICBzaWduYXR1cmVbMV0gPSBzaWduYXR1cmUubGVuZ3RoIC0gMjtcbiAgc2lnbmF0dXJlWzJdID0gMHgwMjtcbiAgc2lnbmF0dXJlWzNdID0gci5sZW5ndGg7XG4gIHIuY29weShzaWduYXR1cmUsIDQpO1xuICBzaWduYXR1cmVbNCArIGxlblJdID0gMHgwMjtcbiAgc2lnbmF0dXJlWzUgKyBsZW5SXSA9IHMubGVuZ3RoO1xuICBzLmNvcHkoc2lnbmF0dXJlLCA2ICsgbGVuUik7XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2NrID0gdm9pZCAwO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuY29uc3QgbWVya2xlXzEgPSByZXF1aXJlKCcuL21lcmtsZScpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuY29uc3QgZXJyb3JNZXJrbGVOb1R4ZXMgPSBuZXcgVHlwZUVycm9yKFxuICAnQ2Fubm90IGNvbXB1dGUgbWVya2xlIHJvb3QgZm9yIHplcm8gdHJhbnNhY3Rpb25zJyxcbik7XG5jb25zdCBlcnJvcldpdG5lc3NOb3RTZWd3aXQgPSBuZXcgVHlwZUVycm9yKFxuICAnQ2Fubm90IGNvbXB1dGUgd2l0bmVzcyBjb21taXQgZm9yIG5vbi1zZWd3aXQgYmxvY2snLFxuKTtcbmNsYXNzIEJsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLnByZXZIYXNoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVya2xlUm9vdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IDA7XG4gICAgdGhpcy53aXRuZXNzQ29tbWl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYml0cyA9IDA7XG4gICAgdGhpcy5ub25jZSA9IDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA4MCkgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgdG9vIHNtYWxsICg8IDgwIGJ5dGVzKScpO1xuICAgIGNvbnN0IGJ1ZmZlclJlYWRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlclJlYWRlcihidWZmZXIpO1xuICAgIGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKCk7XG4gICAgYmxvY2sudmVyc2lvbiA9IGJ1ZmZlclJlYWRlci5yZWFkSW50MzIoKTtcbiAgICBibG9jay5wcmV2SGFzaCA9IGJ1ZmZlclJlYWRlci5yZWFkU2xpY2UoMzIpO1xuICAgIGJsb2NrLm1lcmtsZVJvb3QgPSBidWZmZXJSZWFkZXIucmVhZFNsaWNlKDMyKTtcbiAgICBibG9jay50aW1lc3RhbXAgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQzMigpO1xuICAgIGJsb2NrLmJpdHMgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQzMigpO1xuICAgIGJsb2NrLm5vbmNlID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gODApIHJldHVybiBibG9jaztcbiAgICBjb25zdCByZWFkVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB0eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihcbiAgICAgICAgYnVmZmVyUmVhZGVyLmJ1ZmZlci5zbGljZShidWZmZXJSZWFkZXIub2Zmc2V0KSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG4gICAgICBidWZmZXJSZWFkZXIub2Zmc2V0ICs9IHR4LmJ5dGVMZW5ndGgoKTtcbiAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IG5UcmFuc2FjdGlvbnMgPSBidWZmZXJSZWFkZXIucmVhZFZhckludCgpO1xuICAgIGJsb2NrLnRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblRyYW5zYWN0aW9uczsgKytpKSB7XG4gICAgICBjb25zdCB0eCA9IHJlYWRUcmFuc2FjdGlvbigpO1xuICAgICAgYmxvY2sudHJhbnNhY3Rpb25zLnB1c2godHgpO1xuICAgIH1cbiAgICBjb25zdCB3aXRuZXNzQ29tbWl0ID0gYmxvY2suZ2V0V2l0bmVzc0NvbW1pdCgpO1xuICAgIC8vIFRoaXMgQmxvY2sgY29udGFpbnMgYSB3aXRuZXNzIGNvbW1pdFxuICAgIGlmICh3aXRuZXNzQ29tbWl0KSBibG9jay53aXRuZXNzQ29tbWl0ID0gd2l0bmVzc0NvbW1pdDtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cbiAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgcmV0dXJuIEJsb2NrLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oaGV4LCAnaGV4JykpO1xuICB9XG4gIHN0YXRpYyBjYWxjdWxhdGVUYXJnZXQoYml0cykge1xuICAgIGNvbnN0IGV4cG9uZW50ID0gKChiaXRzICYgMHhmZjAwMDAwMCkgPj4gMjQpIC0gMztcbiAgICBjb25zdCBtYW50aXNzYSA9IGJpdHMgJiAweDAwN2ZmZmZmO1xuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgdGFyZ2V0LndyaXRlVUludEJFKG1hbnRpc3NhLCAyOSAtIGV4cG9uZW50LCAzKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHN0YXRpYyBjYWxjdWxhdGVNZXJrbGVSb290KHRyYW5zYWN0aW9ucywgZm9yV2l0bmVzcykge1xuICAgIHR5cGVmb3JjZShbeyBnZXRIYXNoOiB0eXBlcy5GdW5jdGlvbiB9XSwgdHJhbnNhY3Rpb25zKTtcbiAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgaWYgKGZvcldpdG5lc3MgJiYgIXR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0cmFuc2FjdGlvbnMpKVxuICAgICAgdGhyb3cgZXJyb3JXaXRuZXNzTm90U2Vnd2l0O1xuICAgIGNvbnN0IGhhc2hlcyA9IHRyYW5zYWN0aW9ucy5tYXAodHJhbnNhY3Rpb24gPT5cbiAgICAgIHRyYW5zYWN0aW9uLmdldEhhc2goZm9yV2l0bmVzcyksXG4gICAgKTtcbiAgICBjb25zdCByb290SGFzaCA9ICgwLCBtZXJrbGVfMS5mYXN0TWVya2xlUm9vdCkoaGFzaGVzLCBiY3J5cHRvLmhhc2gyNTYpO1xuICAgIHJldHVybiBmb3JXaXRuZXNzXG4gICAgICA/IGJjcnlwdG8uaGFzaDI1NihcbiAgICAgICAgICBCdWZmZXIuY29uY2F0KFtyb290SGFzaCwgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzWzBdXSksXG4gICAgICAgIClcbiAgICAgIDogcm9vdEhhc2g7XG4gIH1cbiAgZ2V0V2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0aGlzLnRyYW5zYWN0aW9ucykpIHJldHVybiBudWxsO1xuICAgIC8vIFRoZSBtZXJrbGUgcm9vdCBmb3IgdGhlIHdpdG5lc3MgZGF0YSBpcyBpbiBhbiBPUF9SRVRVUk4gb3V0cHV0LlxuICAgIC8vIFRoZXJlIGlzIG5vIHJ1bGUgZm9yIHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0LCBzbyB1c2UgZmlsdGVyIHRvIGZpbmQgaXQuXG4gICAgLy8gVGhlIHJvb3QgaXMgcHJlcGVuZGVkIHdpdGggMHhhYTIxYTllZCBzbyBjaGVjayBmb3IgMHg2YTI0YWEyMWE5ZWRcbiAgICAvLyBJZiBtdWx0aXBsZSBjb21taXRzIGFyZSBmb3VuZCwgdGhlIG91dHB1dCB3aXRoIGhpZ2hlc3QgaW5kZXggaXMgYXNzdW1lZC5cbiAgICBjb25zdCB3aXRuZXNzQ29tbWl0cyA9IHRoaXMudHJhbnNhY3Rpb25zWzBdLm91dHNcbiAgICAgIC5maWx0ZXIob3V0ID0+XG4gICAgICAgIG91dC5zY3JpcHQuc2xpY2UoMCwgNikuZXF1YWxzKEJ1ZmZlci5mcm9tKCc2YTI0YWEyMWE5ZWQnLCAnaGV4JykpLFxuICAgICAgKVxuICAgICAgLm1hcChvdXQgPT4gb3V0LnNjcmlwdC5zbGljZSg2LCAzOCkpO1xuICAgIGlmICh3aXRuZXNzQ29tbWl0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIC8vIFVzZSB0aGUgY29tbWl0IHdpdGggdGhlIGhpZ2hlc3Qgb3V0cHV0IChzaG91bGQgb25seSBiZSBvbmUgdGhvdWdoKVxuICAgIGNvbnN0IHJlc3VsdCA9IHdpdG5lc3NDb21taXRzW3dpdG5lc3NDb21taXRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIEJ1ZmZlciAmJiByZXN1bHQubGVuZ3RoID09PSAzMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLndpdG5lc3NDb21taXQgaW5zdGFuY2VvZiBCdWZmZXIgJiZcbiAgICAgIHRoaXMud2l0bmVzc0NvbW1pdC5sZW5ndGggPT09IDMyXG4gICAgKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZ2V0V2l0bmVzc0NvbW1pdCgpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzV2l0bmVzcygpIHtcbiAgICByZXR1cm4gYW55VHhIYXNXaXRuZXNzKHRoaXMudHJhbnNhY3Rpb25zKTtcbiAgfVxuICB3ZWlnaHQoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSwgZmFsc2UpO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5ieXRlTGVuZ3RoKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm4gYmFzZSAqIDMgKyB0b3RhbDtcbiAgfVxuICBieXRlTGVuZ3RoKGhlYWRlcnNPbmx5LCBhbGxvd1dpdG5lc3MgPSB0cnVlKSB7XG4gICAgaWYgKGhlYWRlcnNPbmx5IHx8ICF0aGlzLnRyYW5zYWN0aW9ucykgcmV0dXJuIDgwO1xuICAgIHJldHVybiAoXG4gICAgICA4MCArXG4gICAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoKSArXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucy5yZWR1Y2UoKGEsIHgpID0+IGEgKyB4LmJ5dGVMZW5ndGgoYWxsb3dXaXRuZXNzKSwgMClcbiAgICApO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1Nih0aGlzLnRvQnVmZmVyKHRydWUpKTtcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikodGhpcy5nZXRIYXNoKCkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICBnZXRVVENEYXRlKCkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTsgLy8gZXBvY2hcbiAgICBkYXRlLnNldFVUQ1NlY29uZHModGhpcy50aW1lc3RhbXApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIC8vIFRPRE86IGJ1ZmZlciwgb2Zmc2V0IGNvbXBhdGliaWxpdHlcbiAgdG9CdWZmZXIoaGVhZGVyc09ubHkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5ieXRlTGVuZ3RoKGhlYWRlcnNPbmx5KSk7XG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKGJ1ZmZlcik7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0aGlzLnByZXZIYXNoKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0aGlzLm1lcmtsZVJvb3QpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLnRpbWVzdGFtcCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMuYml0cyk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMubm9uY2UpO1xuICAgIGlmIChoZWFkZXJzT25seSB8fCAhdGhpcy50cmFuc2FjdGlvbnMpIHJldHVybiBidWZmZXI7XG4gICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kZShcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGJ1ZmZlcldyaXRlci5vZmZzZXQsXG4gICAgKTtcbiAgICBidWZmZXJXcml0ZXIub2Zmc2V0ICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGUuYnl0ZXM7XG4gICAgdGhpcy50cmFuc2FjdGlvbnMuZm9yRWFjaCh0eCA9PiB7XG4gICAgICBjb25zdCB0eFNpemUgPSB0eC5ieXRlTGVuZ3RoKCk7IC8vIFRPRE86IGV4dHJhY3QgZnJvbSB0b0J1ZmZlcj9cbiAgICAgIHR4LnRvQnVmZmVyKGJ1ZmZlciwgYnVmZmVyV3JpdGVyLm9mZnNldCk7XG4gICAgICBidWZmZXJXcml0ZXIub2Zmc2V0ICs9IHR4U2l6ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHRvSGV4KGhlYWRlcnNPbmx5KSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoaGVhZGVyc09ubHkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICBjaGVja1R4Um9vdHMoKSB7XG4gICAgLy8gSWYgdGhlIEJsb2NrIGhhcyBzZWd3aXQgdHJhbnNhY3Rpb25zIGJ1dCBubyB3aXRuZXNzIGNvbW1pdCxcbiAgICAvLyB0aGVyZSdzIG5vIHdheSBpdCBjYW4gYmUgdmFsaWQsIHNvIGZhaWwgdGhlIGNoZWNrLlxuICAgIGNvbnN0IGhhc1dpdG5lc3NDb21taXQgPSB0aGlzLmhhc1dpdG5lc3NDb21taXQoKTtcbiAgICBpZiAoIWhhc1dpdG5lc3NDb21taXQgJiYgdGhpcy5oYXNXaXRuZXNzKCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fX2NoZWNrTWVya2xlUm9vdCgpICYmXG4gICAgICAoaGFzV2l0bmVzc0NvbW1pdCA/IHRoaXMuX19jaGVja1dpdG5lc3NDb21taXQoKSA6IHRydWUpXG4gICAgKTtcbiAgfVxuICBjaGVja1Byb29mT2ZXb3JrKCkge1xuICAgIGNvbnN0IGhhc2ggPSAoMCwgYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKSh0aGlzLmdldEhhc2goKSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gQmxvY2suY2FsY3VsYXRlVGFyZ2V0KHRoaXMuYml0cyk7XG4gICAgcmV0dXJuIGhhc2guY29tcGFyZSh0YXJnZXQpIDw9IDA7XG4gIH1cbiAgX19jaGVja01lcmtsZVJvb3QoKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9ucykgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgY29uc3QgYWN0dWFsTWVya2xlUm9vdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QodGhpcy50cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm1lcmtsZVJvb3QuY29tcGFyZShhY3R1YWxNZXJrbGVSb290KSA9PT0gMDtcbiAgfVxuICBfX2NoZWNrV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb25zKSB0aHJvdyBlcnJvck1lcmtsZU5vVHhlcztcbiAgICBpZiAoIXRoaXMuaGFzV2l0bmVzc0NvbW1pdCgpKSB0aHJvdyBlcnJvcldpdG5lc3NOb3RTZWd3aXQ7XG4gICAgY29uc3QgYWN0dWFsV2l0bmVzc0NvbW1pdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QoXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucyxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy53aXRuZXNzQ29tbWl0LmNvbXBhcmUoYWN0dWFsV2l0bmVzc0NvbW1pdCkgPT09IDA7XG4gIH1cbn1cbmV4cG9ydHMuQmxvY2sgPSBCbG9jaztcbmZ1bmN0aW9uIHR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0cmFuc2FjdGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICB0cmFuc2FjdGlvbnMgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXS5pbnMgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdLndpdG5lc3MubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gYW55VHhIYXNXaXRuZXNzKHRyYW5zYWN0aW9ucykge1xuICByZXR1cm4gKFxuICAgIHRyYW5zYWN0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgdHJhbnNhY3Rpb25zLnNvbWUoXG4gICAgICB0eCA9PlxuICAgICAgICB0eXBlb2YgdHggPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR4LmlucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgICAgIHR4Lmlucy5zb21lKFxuICAgICAgICAgIGlucHV0ID0+XG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3MubGVuZ3RoID4gMCxcbiAgICAgICAgKSxcbiAgICApXG4gICk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWZmZXJSZWFkZXIgPVxuICBleHBvcnRzLkJ1ZmZlcldyaXRlciA9XG4gIGV4cG9ydHMuY2xvbmVCdWZmZXIgPVxuICBleHBvcnRzLnJldmVyc2VCdWZmZXIgPVxuICBleHBvcnRzLndyaXRlVUludDY0TEUgPVxuICBleHBvcnRzLnJlYWRVSW50NjRMRSA9XG4gIGV4cG9ydHMudmFydWludCA9XG4gICAgdm9pZCAwO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCB2YXJ1aW50ID0gcmVxdWlyZSgndmFydWludC1iaXRjb2luJyk7XG5leHBvcnRzLnZhcnVpbnQgPSB2YXJ1aW50O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDExMjdcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICBpZiAodmFsdWUgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgaWYgKHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIGIgKj0gMHgxMDAwMDAwMDA7XG4gIHZlcmlmdWludChiICsgYSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICB2ZXJpZnVpbnQodmFsdWUsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gIGJ1ZmZlci53cml0ZUludDMyTEUodmFsdWUgJiAtMSwgb2Zmc2V0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWx1ZSAvIDB4MTAwMDAwMDAwKSwgb2Zmc2V0ICsgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA4O1xufVxuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcbmZ1bmN0aW9uIHJldmVyc2VCdWZmZXIoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMSkgcmV0dXJuIGJ1ZmZlcjtcbiAgbGV0IGogPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgbGV0IHRtcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRtcCA9IGJ1ZmZlcltpXTtcbiAgICBidWZmZXJbaV0gPSBidWZmZXJbal07XG4gICAgYnVmZmVyW2pdID0gdG1wO1xuICAgIGotLTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gcmV2ZXJzZUJ1ZmZlcjtcbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlcikge1xuICBjb25zdCBjbG9uZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkoY2xvbmUpO1xuICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnRzLmNsb25lQnVmZmVyID0gY2xvbmVCdWZmZXI7XG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3Igc2VyaWFsaXphdGlvbiBvZiBiaXRjb2luIGRhdGEgdHlwZXMgaW50byBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLlxuICovXG5jbGFzcyBCdWZmZXJXcml0ZXIge1xuICBzdGF0aWMgd2l0aENhcGFjaXR5KHNpemUpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcihCdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlVJbnQzMiksIFtidWZmZXIsIG9mZnNldF0pO1xuICB9XG4gIHdyaXRlVUludDgoaSkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5idWZmZXIud3JpdGVVSW50OChpLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgd3JpdGVJbnQzMihpKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLmJ1ZmZlci53cml0ZUludDMyTEUoaSwgdGhpcy5vZmZzZXQpO1xuICB9XG4gIHdyaXRlVUludDMyKGkpIHtcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMuYnVmZmVyLndyaXRlVUludDMyTEUoaSwgdGhpcy5vZmZzZXQpO1xuICB9XG4gIHdyaXRlVUludDY0KGkpIHtcbiAgICB0aGlzLm9mZnNldCA9IHdyaXRlVUludDY0TEUodGhpcy5idWZmZXIsIGksIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVZhckludChpKSB7XG4gICAgdmFydWludC5lbmNvZGUoaSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCArPSB2YXJ1aW50LmVuY29kZS5ieXRlcztcbiAgfVxuICB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IHRoaXMub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBzbGljZSBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHRoaXMub2Zmc2V0ICs9IHNsaWNlLmNvcHkodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgdGhpcy53cml0ZVZhckludChzbGljZS5sZW5ndGgpO1xuICAgIHRoaXMud3JpdGVTbGljZShzbGljZSk7XG4gIH1cbiAgd3JpdGVWZWN0b3IodmVjdG9yKSB7XG4gICAgdGhpcy53cml0ZVZhckludCh2ZWN0b3IubGVuZ3RoKTtcbiAgICB2ZWN0b3IuZm9yRWFjaChidWYgPT4gdGhpcy53cml0ZVZhclNsaWNlKGJ1ZikpO1xuICB9XG4gIGVuZCgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSB0aGlzLm9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJ1ZmZlciBzaXplICR7dGhpcy5idWZmZXIubGVuZ3RofSwgb2Zmc2V0ICR7dGhpcy5vZmZzZXR9YCk7XG4gIH1cbn1cbmV4cG9ydHMuQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHJlYWRpbmcgb2YgYml0Y29pbiBkYXRhIHR5cGVzIGZyb20gYSBidWZmZXIuXG4gKi9cbmNsYXNzIEJ1ZmZlclJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlVJbnQzMiksIFtidWZmZXIsIG9mZnNldF0pO1xuICB9XG4gIHJlYWRVSW50OCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkSW50MzIoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZEludDMyTEUodGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkVUludDMyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlYWRVSW50NjQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVhZFVJbnQ2NExFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXQgKz0gODtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlYWRWYXJJbnQoKSB7XG4gICAgY29uc3QgdmkgPSB2YXJ1aW50LmRlY29kZSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IHZhcnVpbnQuZGVjb2RlLmJ5dGVzO1xuICAgIHJldHVybiB2aTtcbiAgfVxuICByZWFkU2xpY2Uobikge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCB0aGlzLm9mZnNldCArIG4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgc2xpY2Ugb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBuKTtcbiAgICB0aGlzLm9mZnNldCArPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVhZFZhclNsaWNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZSh0aGlzLnJlYWRWYXJJbnQoKSk7XG4gIH1cbiAgcmVhZFZlY3RvcigpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMucmVhZFZhckludCgpO1xuICAgIGNvbnN0IHZlY3RvciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykgdmVjdG9yLnB1c2godGhpcy5yZWFkVmFyU2xpY2UoKSk7XG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxufVxuZXhwb3J0cy5CdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50YWdnZWRIYXNoID1cbiAgZXhwb3J0cy5UQUdHRURfSEFTSF9QUkVGSVhFUyA9XG4gIGV4cG9ydHMuVEFHUyA9XG4gIGV4cG9ydHMuaGFzaDI1NiA9XG4gIGV4cG9ydHMuaGFzaDE2MCA9XG4gIGV4cG9ydHMuc2hhMjU2ID1cbiAgZXhwb3J0cy5zaGExID1cbiAgZXhwb3J0cy5yaXBlbWQxNjAgPVxuICAgIHZvaWQgMDtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnKTtcbmNvbnN0IHNoYTFfMSA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvc2hhMScpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKCdAbm9ibGUvaGFzaGVzL3NoYTI1NicpO1xuZnVuY3Rpb24gcmlwZW1kMTYwKGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKTtcbn1cbmV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xuZnVuY3Rpb24gc2hhMShidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzaGExXzEuc2hhMSkoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKTtcbn1cbmV4cG9ydHMuc2hhMSA9IHNoYTE7XG5mdW5jdGlvbiBzaGEyNTYoYnVmZmVyKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2hhMjU2XzEuc2hhMjU2KShVaW50OEFycmF5LmZyb20oYnVmZmVyKSkpO1xufVxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5mdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkoKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKSxcbiAgKTtcbn1cbmV4cG9ydHMuaGFzaDE2MCA9IGhhc2gxNjA7XG5mdW5jdGlvbiBoYXNoMjU2KGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKSxcbiAgKTtcbn1cbmV4cG9ydHMuaGFzaDI1NiA9IGhhc2gyNTY7XG5leHBvcnRzLlRBR1MgPSBbXG4gICdCSVAwMzQwL2NoYWxsZW5nZScsXG4gICdCSVAwMzQwL2F1eCcsXG4gICdCSVAwMzQwL25vbmNlJyxcbiAgJ1RhcExlYWYnLFxuICAnVGFwQnJhbmNoJyxcbiAgJ1RhcFNpZ2hhc2gnLFxuICAnVGFwVHdlYWsnLFxuICAnS2V5QWdnIGxpc3QnLFxuICAnS2V5QWdnIGNvZWZmaWNpZW50Jyxcbl07XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5leHBvcnRzLlRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge1xuICAnQklQMDM0MC9jaGFsbGVuZ2UnOiBCdWZmZXIuZnJvbShbXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gIF0pLFxuICAnQklQMDM0MC9hdXgnOiBCdWZmZXIuZnJvbShbXG4gICAgMjQxLCAyMzksIDc4LCA5NCwgMTkyLCA5OSwgMjAyLCAyMTgsIDEwOSwgMTQ4LCAyMDIsIDI1MCwgMTU3LCAxNTIsIDEyNiwgMTYwLFxuICAgIDEwNSwgMzgsIDg4LCA1NywgMjM2LCAxOTMsIDMxLCAxNTEsIDQ1LCAxMTksIDE2NSwgNDYsIDIxNiwgMTkzLCAyMDQsIDE0NCxcbiAgICAyNDEsIDIzOSwgNzgsIDk0LCAxOTIsIDk5LCAyMDIsIDIxOCwgMTA5LCAxNDgsIDIwMiwgMjUwLCAxNTcsIDE1MiwgMTI2LCAxNjAsXG4gICAgMTA1LCAzOCwgODgsIDU3LCAyMzYsIDE5MywgMzEsIDE1MSwgNDUsIDExOSwgMTY1LCA0NiwgMjE2LCAxOTMsIDIwNCwgMTQ0LFxuICBdKSxcbiAgJ0JJUDAzNDAvbm9uY2UnOiBCdWZmZXIuZnJvbShbXG4gICAgNywgNzMsIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LFxuICAgIDUyLCAyMTUsIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsIDcsIDczLFxuICAgIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LCA1MiwgMjE1LFxuICAgIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsXG4gIF0pLFxuICBUYXBMZWFmOiBCdWZmZXIuZnJvbShbXG4gICAgMTc0LCAyMzQsIDE0MywgMjIwLCA2NiwgOCwgMTUyLCA0OSwgNSwgMTE1LCA3NSwgODgsIDgsIDI5LCAzMCwgMzgsIDU2LCAyMTEsXG4gICAgOTUsIDI4LCAxODEsIDY0LCA4LCAyMTIsIDIxMSwgODcsIDIwMiwgMywgMTkwLCAxMjAsIDIzMywgMjM4LCAxNzQsIDIzNCwgMTQzLFxuICAgIDIyMCwgNjYsIDgsIDE1MiwgNDksIDUsIDExNSwgNzUsIDg4LCA4LCAyOSwgMzAsIDM4LCA1NiwgMjExLCA5NSwgMjgsIDE4MSxcbiAgICA2NCwgOCwgMjEyLCAyMTEsIDg3LCAyMDIsIDMsIDE5MCwgMTIwLCAyMzMsIDIzOCxcbiAgXSksXG4gIFRhcEJyYW5jaDogQnVmZmVyLmZyb20oW1xuICAgIDI1LCA2NSwgMTYxLCAyNDIsIDIyOSwgMTEwLCAxODUsIDk1LCAxNjIsIDE2OSwgMjQxLCAxNDgsIDE5MCwgOTIsIDEsIDI0NyxcbiAgICAzMywgMTExLCA1MSwgMjM3LCAxMzAsIDE3NiwgMTQ1LCA3MCwgNTIsIDE0NCwgMjA4LCA5MSwgMjQ1LCAyMiwgMTYwLCAyMSwgMjUsXG4gICAgNjUsIDE2MSwgMjQyLCAyMjksIDExMCwgMTg1LCA5NSwgMTYyLCAxNjksIDI0MSwgMTQ4LCAxOTAsIDkyLCAxLCAyNDcsIDMzLFxuICAgIDExMSwgNTEsIDIzNywgMTMwLCAxNzYsIDE0NSwgNzAsIDUyLCAxNDQsIDIwOCwgOTEsIDI0NSwgMjIsIDE2MCwgMjEsXG4gIF0pLFxuICBUYXBTaWdoYXNoOiBCdWZmZXIuZnJvbShbXG4gICAgMjQ0LCAxMCwgNzIsIDIyMywgNzUsIDQyLCAxMTIsIDIwMCwgMTgwLCAxNDYsIDc1LCAyNDIsIDEwMSwgNzAsIDk3LCAyMzcsIDYxLFxuICAgIDE0OSwgMjUzLCAxMDIsIDE2MywgMTksIDIzNSwgMTM1LCAzNSwgMTE3LCAxNTEsIDE5OCwgNDAsIDIyOCwgMTYwLCA0OSwgMjQ0LFxuICAgIDEwLCA3MiwgMjIzLCA3NSwgNDIsIDExMiwgMjAwLCAxODAsIDE0NiwgNzUsIDI0MiwgMTAxLCA3MCwgOTcsIDIzNywgNjEsIDE0OSxcbiAgICAyNTMsIDEwMiwgMTYzLCAxOSwgMjM1LCAxMzUsIDM1LCAxMTcsIDE1MSwgMTk4LCA0MCwgMjI4LCAxNjAsIDQ5LFxuICBdKSxcbiAgVGFwVHdlYWs6IEJ1ZmZlci5mcm9tKFtcbiAgICAyMzIsIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsXG4gICAgMTU2LCAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMywgMjMyLFxuICAgIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsIDE1NixcbiAgICAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMyxcbiAgXSksXG4gICdLZXlBZ2cgbGlzdCc6IEJ1ZmZlci5mcm9tKFtcbiAgICA3MiwgMjgsIDE1MSwgMjgsIDYwLCAxMSwgNzAsIDIxNSwgMjQwLCAxNzgsIDExNywgMTc0LCA4OSwgMTQxLCA3OCwgNDQsIDEyNixcbiAgICAyMTUsIDQ5LCAxNTYsIDg5LCA3NCwgOTIsIDExMCwgMTk5LCAxNTgsIDE2MCwgMjEyLCAxNTMsIDIsIDE0OCwgMjQwLCA3MiwgMjgsXG4gICAgMTUxLCAyOCwgNjAsIDExLCA3MCwgMjE1LCAyNDAsIDE3OCwgMTE3LCAxNzQsIDg5LCAxNDEsIDc4LCA0NCwgMTI2LCAyMTUsIDQ5LFxuICAgIDE1NiwgODksIDc0LCA5MiwgMTEwLCAxOTksIDE1OCwgMTYwLCAyMTIsIDE1MywgMiwgMTQ4LCAyNDAsXG4gIF0pLFxuICAnS2V5QWdnIGNvZWZmaWNpZW50JzogQnVmZmVyLmZyb20oW1xuICAgIDE5MSwgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCxcbiAgICAxMzAsIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LCAxOTEsXG4gICAgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCwgMTMwLFxuICAgIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LFxuICBdKSxcbn07XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHByZWZpeCwgZGF0YSkge1xuICByZXR1cm4gc2hhMjU2KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuVEFHR0VEX0hBU0hfUFJFRklYRVNbcHJlZml4XSwgZGF0YV0pKTtcbn1cbmV4cG9ydHMudGFnZ2VkSGFzaCA9IHRhZ2dlZEhhc2g7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFY2NMaWIgPSBleHBvcnRzLmluaXRFY2NMaWIgPSB2b2lkIDA7XG5jb25zdCBfRUNDTElCX0NBQ0hFID0ge307XG5mdW5jdGlvbiBpbml0RWNjTGliKGVjY0xpYikge1xuICBpZiAoIWVjY0xpYikge1xuICAgIC8vIGFsbG93IGNsZWFyaW5nIHRoZSBsaWJyYXJ5XG4gICAgX0VDQ0xJQl9DQUNIRS5lY2NMaWIgPSBlY2NMaWI7XG4gIH0gZWxzZSBpZiAoZWNjTGliICE9PSBfRUNDTElCX0NBQ0hFLmVjY0xpYikge1xuICAgIC8vIG5ldyBpbnN0YW5jZSwgdmVyaWZ5IGl0XG4gICAgdmVyaWZ5RWNjKGVjY0xpYik7XG4gICAgX0VDQ0xJQl9DQUNIRS5lY2NMaWIgPSBlY2NMaWI7XG4gIH1cbn1cbmV4cG9ydHMuaW5pdEVjY0xpYiA9IGluaXRFY2NMaWI7XG5mdW5jdGlvbiBnZXRFY2NMaWIoKSB7XG4gIGlmICghX0VDQ0xJQl9DQUNIRS5lY2NMaWIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ05vIEVDQyBMaWJyYXJ5IHByb3ZpZGVkLiBZb3UgbXVzdCBjYWxsIGluaXRFY2NMaWIoKSB3aXRoIGEgdmFsaWQgVGlueVNlY3AyNTZrMUludGVyZmFjZSBpbnN0YW5jZScsXG4gICAgKTtcbiAgcmV0dXJuIF9FQ0NMSUJfQ0FDSEUuZWNjTGliO1xufVxuZXhwb3J0cy5nZXRFY2NMaWIgPSBnZXRFY2NMaWI7XG5jb25zdCBoID0gaGV4ID0+IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuZnVuY3Rpb24gdmVyaWZ5RWNjKGVjYykge1xuICBhc3NlcnQodHlwZW9mIGVjYy5pc1hPbmx5UG9pbnQgPT09ICdmdW5jdGlvbicpO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZWZmZmZjMmUnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgIWVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgICFlY2MuaXNYT25seVBvaW50KFxuICAgICAgaCgnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgICksXG4gICk7XG4gIGFzc2VydCh0eXBlb2YgZWNjLnhPbmx5UG9pbnRBZGRUd2VhayA9PT0gJ2Z1bmN0aW9uJyk7XG4gIHR3ZWFrQWRkVmVjdG9ycy5mb3JFYWNoKHQgPT4ge1xuICAgIGNvbnN0IHIgPSBlY2MueE9ubHlQb2ludEFkZFR3ZWFrKGgodC5wdWJrZXkpLCBoKHQudHdlYWspKTtcbiAgICBpZiAodC5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGFzc2VydChyID09PSBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHIgIT09IG51bGwpO1xuICAgICAgYXNzZXJ0KHIucGFyaXR5ID09PSB0LnBhcml0eSk7XG4gICAgICBhc3NlcnQoQnVmZmVyLmZyb20oci54T25seVB1YmtleSkuZXF1YWxzKGgodC5yZXN1bHQpKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydChib29sKSB7XG4gIGlmICghYm9vbCkgdGhyb3cgbmV3IEVycm9yKCdlY2MgbGlicmFyeSBpbnZhbGlkJyk7XG59XG5jb25zdCB0d2Vha0FkZFZlY3RvcnMgPSBbXG4gIHtcbiAgICBwdWJrZXk6ICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICB0d2VhazogJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDAnLFxuICAgIHBhcml0eTogLTEsXG4gICAgcmVzdWx0OiBudWxsLFxuICB9LFxuICB7XG4gICAgcHVia2V5OiAnMTYxN2QzOGVkOGQ4NjU3ZGE0ZDQ3NjFlODA1N2JjMzk2ZWE5ZTRiOWQyOTc3NmQ0YmUwOTYwMTZkYmQyNTA5YicsXG4gICAgdHdlYWs6ICdhODM5N2E5MzVmMGRmY2ViYTZiYTk2MThmNjQ1MWVmNGQ4MDYzN2FiZjRlNmFmMjY2OWZiYzlkZTZhOGZkMmFjJyxcbiAgICBwYXJpdHk6IDEsXG4gICAgcmVzdWx0OiAnZTQ3OGY5OWRhYjkxMDUyYWIzOWEzM2VhMzVmZDVlNmU0OTMzZjRkMjgwMjNjZDU5N2M5YTFmNjc2MDM0NmFkZicsXG4gIH0sXG4gIHtcbiAgICBwdWJrZXk6ICcyYzBiN2NmOTUzMjRhMDdkMDUzOThiMjQwMTc0ZGMwYzJiZTQ0NGQ5NmIxNTlhYTZjN2Y3YjFlNjY4NjgwOTkxJyxcbiAgICB0d2VhazogJzgyM2MzY2QyMTQyNzQ0YjA3NWE4N2VhZGU3ZTFiODY3OGJhMzA4ZDU2NjIyNmEwMDU2Y2EyYjdhNzZmODZiNDcnLFxuICAgIHBhcml0eTogMCxcbiAgICByZXN1bHQ6ICc5NTM0ZjhkYzhjNmRlZGEyZGMwMDc2NTU5ODFjNzhiNDljNWQ5NmM3NzhmYmYzNjM0NjJhMTFlYzlkZmQ5NDhjJyxcbiAgfSxcbl07XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0RWNjTGliID1cbiAgZXhwb3J0cy5UcmFuc2FjdGlvbiA9XG4gIGV4cG9ydHMub3Bjb2RlcyA9XG4gIGV4cG9ydHMuUHNidCA9XG4gIGV4cG9ydHMuQmxvY2sgPVxuICBleHBvcnRzLnNjcmlwdCA9XG4gIGV4cG9ydHMucGF5bWVudHMgPVxuICBleHBvcnRzLm5ldHdvcmtzID1cbiAgZXhwb3J0cy5jcnlwdG8gPVxuICBleHBvcnRzLmFkZHJlc3MgPVxuICAgIHZvaWQgMDtcbmNvbnN0IGFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbmV4cG9ydHMuYWRkcmVzcyA9IGFkZHJlc3M7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuZXhwb3J0cy5jcnlwdG8gPSBjcnlwdG87XG5jb25zdCBuZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmV4cG9ydHMubmV0d29ya3MgPSBuZXR3b3JrcztcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuZXhwb3J0cy5wYXltZW50cyA9IHBheW1lbnRzO1xuY29uc3Qgc2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmV4cG9ydHMuc2NyaXB0ID0gc2NyaXB0O1xudmFyIGJsb2NrXzEgPSByZXF1aXJlKCcuL2Jsb2NrJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Jsb2NrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmxvY2tfMS5CbG9jaztcbiAgfSxcbn0pO1xudmFyIHBzYnRfMSA9IHJlcXVpcmUoJy4vcHNidCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQc2J0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHNidF8xLlBzYnQ7XG4gIH0sXG59KTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoJy4vb3BzJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ29wY29kZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcHNfMS5PUFM7XG4gIH0sXG59KTtcbnZhciB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdUcmFuc2FjdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb247XG4gIH0sXG59KTtcbnZhciBlY2NfbGliXzEgPSByZXF1aXJlKCcuL2VjY19saWInKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaW5pdEVjY0xpYicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVjY19saWJfMS5pbml0RWNjTGliO1xuICB9LFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mYXN0TWVya2xlUm9vdCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZhc3RNZXJrbGVSb290KHZhbHVlcywgZGlnZXN0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWVzIEFycmF5Jyk7XG4gIGlmICh0eXBlb2YgZGlnZXN0Rm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBkaWdlc3QgRnVuY3Rpb24nKTtcbiAgbGV0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdHMgPSB2YWx1ZXMuY29uY2F0KCk7XG4gIHdoaWxlIChsZW5ndGggPiAxKSB7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIsICsraikge1xuICAgICAgY29uc3QgbGVmdCA9IHJlc3VsdHNbaV07XG4gICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBsZW5ndGggPyBsZWZ0IDogcmVzdWx0c1tpICsgMV07XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKTtcbiAgICAgIHJlc3VsdHNbal0gPSBkaWdlc3RGbihkYXRhKTtcbiAgICB9XG4gICAgbGVuZ3RoID0gajtcbiAgfVxuICByZXR1cm4gcmVzdWx0c1swXTtcbn1cbmV4cG9ydHMuZmFzdE1lcmtsZVJvb3QgPSBmYXN0TWVya2xlUm9vdDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRlc3RuZXQgPSBleHBvcnRzLnJlZ3Rlc3QgPSBleHBvcnRzLmJpdGNvaW4gPSB2b2lkIDA7XG5leHBvcnRzLmJpdGNvaW4gPSB7XG4gIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgYmVjaDMyOiAnYmMnLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogMHgwNDg4YjIxZSxcbiAgICBwcml2YXRlOiAweDA0ODhhZGU0LFxuICB9LFxuICBwdWJLZXlIYXNoOiAweDAwLFxuICBzY3JpcHRIYXNoOiAweDA1LFxuICB3aWY6IDB4ODAsXG59O1xuZXhwb3J0cy5yZWd0ZXN0ID0ge1xuICBtZXNzYWdlUHJlZml4OiAnXFx4MThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicsXG4gIGJlY2gzMjogJ2JjcnQnLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogMHgwNDM1ODdjZixcbiAgICBwcml2YXRlOiAweDA0MzU4Mzk0LFxuICB9LFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB3aWY6IDB4ZWYsXG59O1xuZXhwb3J0cy50ZXN0bmV0ID0ge1xuICBtZXNzYWdlUHJlZml4OiAnXFx4MThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicsXG4gIGJlY2gzMjogJ3RiJyxcbiAgYmlwMzI6IHtcbiAgICBwdWJsaWM6IDB4MDQzNTg3Y2YsXG4gICAgcHJpdmF0ZTogMHgwNDM1ODM5NCxcbiAgfSxcbiAgcHViS2V5SGFzaDogMHg2ZixcbiAgc2NyaXB0SGFzaDogMHhjNCxcbiAgd2lmOiAweGVmLFxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFVkVSU0VfT1BTID0gZXhwb3J0cy5PUFMgPSB2b2lkIDA7XG5jb25zdCBPUFMgPSB7XG4gIE9QX0ZBTFNFOiAwLFxuICBPUF8wOiAwLFxuICBPUF9QVVNIREFUQTE6IDc2LFxuICBPUF9QVVNIREFUQTI6IDc3LFxuICBPUF9QVVNIREFUQTQ6IDc4LFxuICBPUF8xTkVHQVRFOiA3OSxcbiAgT1BfUkVTRVJWRUQ6IDgwLFxuICBPUF9UUlVFOiA4MSxcbiAgT1BfMTogODEsXG4gIE9QXzI6IDgyLFxuICBPUF8zOiA4MyxcbiAgT1BfNDogODQsXG4gIE9QXzU6IDg1LFxuICBPUF82OiA4NixcbiAgT1BfNzogODcsXG4gIE9QXzg6IDg4LFxuICBPUF85OiA4OSxcbiAgT1BfMTA6IDkwLFxuICBPUF8xMTogOTEsXG4gIE9QXzEyOiA5MixcbiAgT1BfMTM6IDkzLFxuICBPUF8xNDogOTQsXG4gIE9QXzE1OiA5NSxcbiAgT1BfMTY6IDk2LFxuICBPUF9OT1A6IDk3LFxuICBPUF9WRVI6IDk4LFxuICBPUF9JRjogOTksXG4gIE9QX05PVElGOiAxMDAsXG4gIE9QX1ZFUklGOiAxMDEsXG4gIE9QX1ZFUk5PVElGOiAxMDIsXG4gIE9QX0VMU0U6IDEwMyxcbiAgT1BfRU5ESUY6IDEwNCxcbiAgT1BfVkVSSUZZOiAxMDUsXG4gIE9QX1JFVFVSTjogMTA2LFxuICBPUF9UT0FMVFNUQUNLOiAxMDcsXG4gIE9QX0ZST01BTFRTVEFDSzogMTA4LFxuICBPUF8yRFJPUDogMTA5LFxuICBPUF8yRFVQOiAxMTAsXG4gIE9QXzNEVVA6IDExMSxcbiAgT1BfMk9WRVI6IDExMixcbiAgT1BfMlJPVDogMTEzLFxuICBPUF8yU1dBUDogMTE0LFxuICBPUF9JRkRVUDogMTE1LFxuICBPUF9ERVBUSDogMTE2LFxuICBPUF9EUk9QOiAxMTcsXG4gIE9QX0RVUDogMTE4LFxuICBPUF9OSVA6IDExOSxcbiAgT1BfT1ZFUjogMTIwLFxuICBPUF9QSUNLOiAxMjEsXG4gIE9QX1JPTEw6IDEyMixcbiAgT1BfUk9UOiAxMjMsXG4gIE9QX1NXQVA6IDEyNCxcbiAgT1BfVFVDSzogMTI1LFxuICBPUF9DQVQ6IDEyNixcbiAgT1BfU1VCU1RSOiAxMjcsXG4gIE9QX0xFRlQ6IDEyOCxcbiAgT1BfUklHSFQ6IDEyOSxcbiAgT1BfU0laRTogMTMwLFxuICBPUF9JTlZFUlQ6IDEzMSxcbiAgT1BfQU5EOiAxMzIsXG4gIE9QX09SOiAxMzMsXG4gIE9QX1hPUjogMTM0LFxuICBPUF9FUVVBTDogMTM1LFxuICBPUF9FUVVBTFZFUklGWTogMTM2LFxuICBPUF9SRVNFUlZFRDE6IDEzNyxcbiAgT1BfUkVTRVJWRUQyOiAxMzgsXG4gIE9QXzFBREQ6IDEzOSxcbiAgT1BfMVNVQjogMTQwLFxuICBPUF8yTVVMOiAxNDEsXG4gIE9QXzJESVY6IDE0MixcbiAgT1BfTkVHQVRFOiAxNDMsXG4gIE9QX0FCUzogMTQ0LFxuICBPUF9OT1Q6IDE0NSxcbiAgT1BfME5PVEVRVUFMOiAxNDYsXG4gIE9QX0FERDogMTQ3LFxuICBPUF9TVUI6IDE0OCxcbiAgT1BfTVVMOiAxNDksXG4gIE9QX0RJVjogMTUwLFxuICBPUF9NT0Q6IDE1MSxcbiAgT1BfTFNISUZUOiAxNTIsXG4gIE9QX1JTSElGVDogMTUzLFxuICBPUF9CT09MQU5EOiAxNTQsXG4gIE9QX0JPT0xPUjogMTU1LFxuICBPUF9OVU1FUVVBTDogMTU2LFxuICBPUF9OVU1FUVVBTFZFUklGWTogMTU3LFxuICBPUF9OVU1OT1RFUVVBTDogMTU4LFxuICBPUF9MRVNTVEhBTjogMTU5LFxuICBPUF9HUkVBVEVSVEhBTjogMTYwLFxuICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcbiAgT1BfR1JFQVRFUlRIQU5PUkVRVUFMOiAxNjIsXG4gIE9QX01JTjogMTYzLFxuICBPUF9NQVg6IDE2NCxcbiAgT1BfV0lUSElOOiAxNjUsXG4gIE9QX1JJUEVNRDE2MDogMTY2LFxuICBPUF9TSEExOiAxNjcsXG4gIE9QX1NIQTI1NjogMTY4LFxuICBPUF9IQVNIMTYwOiAxNjksXG4gIE9QX0hBU0gyNTY6IDE3MCxcbiAgT1BfQ09ERVNFUEFSQVRPUjogMTcxLFxuICBPUF9DSEVDS1NJRzogMTcyLFxuICBPUF9DSEVDS1NJR1ZFUklGWTogMTczLFxuICBPUF9DSEVDS01VTFRJU0lHOiAxNzQsXG4gIE9QX0NIRUNLTVVMVElTSUdWRVJJRlk6IDE3NSxcbiAgT1BfTk9QMTogMTc2LFxuICBPUF9OT1AyOiAxNzcsXG4gIE9QX0NIRUNLTE9DS1RJTUVWRVJJRlk6IDE3NyxcbiAgT1BfTk9QMzogMTc4LFxuICBPUF9DSEVDS1NFUVVFTkNFVkVSSUZZOiAxNzgsXG4gIE9QX05PUDQ6IDE3OSxcbiAgT1BfTk9QNTogMTgwLFxuICBPUF9OT1A2OiAxODEsXG4gIE9QX05PUDc6IDE4MixcbiAgT1BfTk9QODogMTgzLFxuICBPUF9OT1A5OiAxODQsXG4gIE9QX05PUDEwOiAxODUsXG4gIE9QX0NIRUNLU0lHQUREOiAxODYsXG4gIE9QX1BVQktFWUhBU0g6IDI1MyxcbiAgT1BfUFVCS0VZOiAyNTQsXG4gIE9QX0lOVkFMSURPUENPREU6IDI1NSxcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbmNvbnN0IFJFVkVSU0VfT1BTID0ge307XG5leHBvcnRzLlJFVkVSU0VfT1BTID0gUkVWRVJTRV9PUFM7XG5mb3IgKGNvbnN0IG9wIG9mIE9iamVjdC5rZXlzKE9QUykpIHtcbiAgY29uc3QgY29kZSA9IE9QU1tvcF07XG4gIFJFVkVSU0VfT1BTW2NvZGVdID0gb3A7XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50d2Vha0tleSA9XG4gIGV4cG9ydHMudGFwVHdlYWtIYXNoID1cbiAgZXhwb3J0cy50YXBsZWFmSGFzaCA9XG4gIGV4cG9ydHMuZmluZFNjcmlwdFBhdGggPVxuICBleHBvcnRzLnRvSGFzaFRyZWUgPVxuICBleHBvcnRzLnJvb3RIYXNoRnJvbVBhdGggPVxuICBleHBvcnRzLk1BWF9UQVBUUkVFX0RFUFRIID1cbiAgZXhwb3J0cy5MRUFGX1ZFUlNJT05fVEFQU0NSSVBUID1cbiAgICB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuY29uc3QgZWNjX2xpYl8xID0gcmVxdWlyZSgnLi4vZWNjX2xpYicpO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4uL2NyeXB0bycpO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4uL2J1ZmZlcnV0aWxzJyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmV4cG9ydHMuTEVBRl9WRVJTSU9OX1RBUFNDUklQVCA9IDB4YzA7XG5leHBvcnRzLk1BWF9UQVBUUkVFX0RFUFRIID0gMTI4O1xuY29uc3QgaXNIYXNoQnJhbmNoID0gaHQgPT4gJ2xlZnQnIGluIGh0ICYmICdyaWdodCcgaW4gaHQ7XG5mdW5jdGlvbiByb290SGFzaEZyb21QYXRoKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpIHtcbiAgaWYgKGNvbnRyb2xCbG9jay5sZW5ndGggPCAzMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFRoZSBjb250cm9sLWJsb2NrIGxlbmd0aCBpcyB0b28gc21hbGwuIEdvdCAke2NvbnRyb2xCbG9jay5sZW5ndGh9LCBleHBlY3RlZCBtaW4gMzMuYCxcbiAgICApO1xuICBjb25zdCBtID0gKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgLyAzMjtcbiAgbGV0IGtqID0gbGVhZkhhc2g7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgY29uc3QgZWogPSBjb250cm9sQmxvY2suc2xpY2UoMzMgKyAzMiAqIGosIDY1ICsgMzIgKiBqKTtcbiAgICBpZiAoa2ouY29tcGFyZShlaikgPCAwKSB7XG4gICAgICBraiA9IHRhcEJyYW5jaEhhc2goa2osIGVqKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2ogPSB0YXBCcmFuY2hIYXNoKGVqLCBraik7XG4gICAgfVxuICB9XG4gIHJldHVybiBrajtcbn1cbmV4cG9ydHMucm9vdEhhc2hGcm9tUGF0aCA9IHJvb3RIYXNoRnJvbVBhdGg7XG4vKipcbiAqIEJ1aWxkIGEgaGFzaCB0cmVlIG9mIG1lcmtsZSBub2RlcyBmcm9tIHRoZSBzY3JpcHRzIGJpbmFyeSB0cmVlLlxuICogQHBhcmFtIHNjcmlwdFRyZWUgLSB0aGUgdHJlZSBvZiBzY3JpcHRzIHRvIHBhaXJ3aXNlIGhhc2guXG4gKi9cbmZ1bmN0aW9uIHRvSGFzaFRyZWUoc2NyaXB0VHJlZSkge1xuICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKShzY3JpcHRUcmVlKSlcbiAgICByZXR1cm4geyBoYXNoOiB0YXBsZWFmSGFzaChzY3JpcHRUcmVlKSB9O1xuICBjb25zdCBoYXNoZXMgPSBbdG9IYXNoVHJlZShzY3JpcHRUcmVlWzBdKSwgdG9IYXNoVHJlZShzY3JpcHRUcmVlWzFdKV07XG4gIGhhc2hlcy5zb3J0KChhLCBiKSA9PiBhLmhhc2guY29tcGFyZShiLmhhc2gpKTtcbiAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGhhc2hlcztcbiAgcmV0dXJuIHtcbiAgICBoYXNoOiB0YXBCcmFuY2hIYXNoKGxlZnQuaGFzaCwgcmlnaHQuaGFzaCksXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgfTtcbn1cbmV4cG9ydHMudG9IYXNoVHJlZSA9IHRvSGFzaFRyZWU7XG4vKipcbiAqIEdpdmVuIGEgSGFzaFRyZWUsIGZpbmRzIHRoZSBwYXRoIGZyb20gYSBwYXJ0aWN1bGFyIGhhc2ggdG8gdGhlIHJvb3QuXG4gKiBAcGFyYW0gbm9kZSAtIHRoZSByb290IG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0gaGFzaCAtIHRoZSBoYXNoIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm5zIC0gYXJyYXkgb2Ygc2libGluZyBoYXNoZXMsIGZyb20gbGVhZiAoaW5jbHVzaXZlKSB0byByb290XG4gKiAoZXhjbHVzaXZlKSBuZWVkZWQgdG8gcHJvdmUgaW5jbHVzaW9uIG9mIHRoZSBzcGVjaWZpZWQgaGFzaC4gdW5kZWZpbmVkIGlmIG5vXG4gKiBwYXRoIGlzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZpbmRTY3JpcHRQYXRoKG5vZGUsIGhhc2gpIHtcbiAgaWYgKGlzSGFzaEJyYW5jaChub2RlKSkge1xuICAgIGNvbnN0IGxlZnRQYXRoID0gZmluZFNjcmlwdFBhdGgobm9kZS5sZWZ0LCBoYXNoKTtcbiAgICBpZiAobGVmdFBhdGggIT09IHVuZGVmaW5lZCkgcmV0dXJuIFsuLi5sZWZ0UGF0aCwgbm9kZS5yaWdodC5oYXNoXTtcbiAgICBjb25zdCByaWdodFBhdGggPSBmaW5kU2NyaXB0UGF0aChub2RlLnJpZ2h0LCBoYXNoKTtcbiAgICBpZiAocmlnaHRQYXRoICE9PSB1bmRlZmluZWQpIHJldHVybiBbLi4ucmlnaHRQYXRoLCBub2RlLmxlZnQuaGFzaF07XG4gIH0gZWxzZSBpZiAobm9kZS5oYXNoLmVxdWFscyhoYXNoKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5maW5kU2NyaXB0UGF0aCA9IGZpbmRTY3JpcHRQYXRoO1xuZnVuY3Rpb24gdGFwbGVhZkhhc2gobGVhZikge1xuICBjb25zdCB2ZXJzaW9uID0gbGVhZi52ZXJzaW9uIHx8IGV4cG9ydHMuTEVBRl9WRVJTSU9OX1RBUFNDUklQVDtcbiAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaChcbiAgICAnVGFwTGVhZicsXG4gICAgYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbXG4gICAgICBidWZmZXJfMS5CdWZmZXIuZnJvbShbdmVyc2lvbl0pLFxuICAgICAgc2VyaWFsaXplU2NyaXB0KGxlYWYub3V0cHV0KSxcbiAgICBdKSxcbiAgKTtcbn1cbmV4cG9ydHMudGFwbGVhZkhhc2ggPSB0YXBsZWFmSGFzaDtcbmZ1bmN0aW9uIHRhcFR3ZWFrSGFzaChwdWJLZXksIGgpIHtcbiAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaChcbiAgICAnVGFwVHdlYWsnLFxuICAgIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoaCA/IFtwdWJLZXksIGhdIDogW3B1YktleV0pLFxuICApO1xufVxuZXhwb3J0cy50YXBUd2Vha0hhc2ggPSB0YXBUd2Vha0hhc2g7XG5mdW5jdGlvbiB0d2Vha0tleShwdWJLZXksIGgpIHtcbiAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIocHViS2V5KSkgcmV0dXJuIG51bGw7XG4gIGlmIChwdWJLZXkubGVuZ3RoICE9PSAzMikgcmV0dXJuIG51bGw7XG4gIGlmIChoICYmIGgubGVuZ3RoICE9PSAzMikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHR3ZWFrSGFzaCA9IHRhcFR3ZWFrSGFzaChwdWJLZXksIGgpO1xuICBjb25zdCByZXMgPSAoMCwgZWNjX2xpYl8xLmdldEVjY0xpYikoKS54T25seVBvaW50QWRkVHdlYWsocHViS2V5LCB0d2Vha0hhc2gpO1xuICBpZiAoIXJlcyB8fCByZXMueE9ubHlQdWJrZXkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHBhcml0eTogcmVzLnBhcml0eSxcbiAgICB4OiBidWZmZXJfMS5CdWZmZXIuZnJvbShyZXMueE9ubHlQdWJrZXkpLFxuICB9O1xufVxuZXhwb3J0cy50d2Vha0tleSA9IHR3ZWFrS2V5O1xuZnVuY3Rpb24gdGFwQnJhbmNoSGFzaChhLCBiKSB7XG4gIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goJ1RhcEJyYW5jaCcsIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2EsIGJdKSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTY3JpcHQocykge1xuICBjb25zdCB2YXJpbnRMZW4gPSBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgocy5sZW5ndGgpO1xuICBjb25zdCBidWZmZXIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2NVbnNhZmUodmFyaW50TGVuKTsgLy8gYmV0dGVyXG4gIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGUocy5sZW5ndGgsIGJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtidWZmZXIsIHNdKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyZGF0YSA9IHZvaWQgMDtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgfSk7XG59XG4vLyBvdXRwdXQ6IE9QX1JFVFVSTiAuLi5cbmZ1bmN0aW9uIHAyZGF0YShhLCBvcHRzKSB7XG4gIGlmICghYS5kYXRhICYmICFhLm91dHB1dCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgIGRhdGE6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICApLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdlbWJlZCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmRhdGEpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfUkVUVVJOXS5jb25jYXQoYS5kYXRhKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2RhdGEnLCAoKSA9PiB7XG4gICAgaWYgKCFhLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCkuc2xpY2UoMSk7XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCk7XG4gICAgICBpZiAoY2h1bmtzWzBdICE9PSBPUFMuT1BfUkVUVVJOKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFjaHVua3Muc2xpY2UoMSkuZXZlcnkodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChhLmRhdGEgJiYgIXN0YWNrc0VxdWFsKGEuZGF0YSwgby5kYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJkYXRhID0gcDJkYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ0ciA9XG4gIGV4cG9ydHMucDJ3c2ggPVxuICBleHBvcnRzLnAyd3BraCA9XG4gIGV4cG9ydHMucDJzaCA9XG4gIGV4cG9ydHMucDJwa2ggPVxuICBleHBvcnRzLnAycGsgPVxuICBleHBvcnRzLnAybXMgPVxuICBleHBvcnRzLmVtYmVkID1cbiAgICB2b2lkIDA7XG5jb25zdCBlbWJlZF8xID0gcmVxdWlyZSgnLi9lbWJlZCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdlbWJlZCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVtYmVkXzEucDJkYXRhO1xuICB9LFxufSk7XG5jb25zdCBwMm1zXzEgPSByZXF1aXJlKCcuL3AybXMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJtcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAybXNfMS5wMm1zO1xuICB9LFxufSk7XG5jb25zdCBwMnBrXzEgPSByZXF1aXJlKCcuL3AycGsnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJwaycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAycGtfMS5wMnBrO1xuICB9LFxufSk7XG5jb25zdCBwMnBraF8xID0gcmVxdWlyZSgnLi9wMnBraCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMnBraCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAycGtoXzEucDJwa2g7XG4gIH0sXG59KTtcbmNvbnN0IHAyc2hfMSA9IHJlcXVpcmUoJy4vcDJzaCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMnNoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJzaF8xLnAyc2g7XG4gIH0sXG59KTtcbmNvbnN0IHAyd3BraF8xID0gcmVxdWlyZSgnLi9wMndwa2gnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJ3cGtoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJ3cGtoXzEucDJ3cGtoO1xuICB9LFxufSk7XG5jb25zdCBwMndzaF8xID0gcmVxdWlyZSgnLi9wMndzaCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMndzaCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAyd3NoXzEucDJ3c2g7XG4gIH0sXG59KTtcbmNvbnN0IHAydHJfMSA9IHJlcXVpcmUoJy4vcDJ0cicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMnRyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJ0cl8xLnAydHI7XG4gIH0sXG59KTtcbi8vIFRPRE9cbi8vIHdpdG5lc3MgY29tbWl0bWVudFxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsdWUgPSBleHBvcnRzLnByb3AgPSB2b2lkIDA7XG5mdW5jdGlvbiBwcm9wKG9iamVjdCwgbmFtZSwgZikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgX3ZhbHVlID0gZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpc1tuYW1lXSA9IF92YWx1ZTtcbiAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgfSxcbiAgICBzZXQoX3ZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG59XG5leHBvcnRzLnByb3AgPSBwcm9wO1xuZnVuY3Rpb24gdmFsdWUoZikge1xuICBsZXQgX3ZhbHVlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIF92YWx1ZTtcbiAgICBfdmFsdWUgPSBmKCk7XG4gICAgcmV0dXJuIF92YWx1ZTtcbiAgfTtcbn1cbmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAybXMgPSB2b2lkIDA7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5jb25zdCBPUF9JTlRfQkFTRSA9IE9QUy5PUF9SRVNFUlZFRDsgLy8gT1BfMSAtIDFcbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgfSk7XG59XG4vLyBpbnB1dDogT1BfMCBbc2lnbmF0dXJlcyAuLi5dXG4vLyBvdXRwdXQ6IG0gW3B1YktleXMgLi4uXSBuIE9QX0NIRUNLTVVMVElTSUdcbmZ1bmN0aW9uIHAybXMoYSwgb3B0cykge1xuICBpZiAoXG4gICAgIWEuaW5wdXQgJiZcbiAgICAhYS5vdXRwdXQgJiZcbiAgICAhKGEucHVia2V5cyAmJiBhLm0gIT09IHVuZGVmaW5lZCkgJiZcbiAgICAhYS5zaWduYXR1cmVzXG4gIClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgZnVuY3Rpb24gaXNBY2NlcHRhYmxlU2lnbmF0dXJlKHgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSh4KSB8fFxuICAgICAgKG9wdHMuYWxsb3dJbmNvbXBsZXRlICYmIHggPT09IE9QUy5PUF8wKSAhPT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIpLFxuICAgICAgbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgIHB1YmtleXM6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICApLFxuICAgICAgc2lnbmF0dXJlczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YoaXNBY2NlcHRhYmxlU2lnbmF0dXJlKSxcbiAgICAgICksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gIGxldCBjaHVua3MgPSBbXTtcbiAgbGV0IGRlY29kZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVjb2RlKG91dHB1dCkge1xuICAgIGlmIChkZWNvZGVkKSByZXR1cm47XG4gICAgZGVjb2RlZCA9IHRydWU7XG4gICAgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUob3V0cHV0KTtcbiAgICBvLm0gPSBjaHVua3NbMF0gLSBPUF9JTlRfQkFTRTtcbiAgICBvLm4gPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdIC0gT1BfSU5UX0JBU0U7XG4gICAgby5wdWJrZXlzID0gY2h1bmtzLnNsaWNlKDEsIC0yKTtcbiAgfVxuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEubSkgcmV0dXJuO1xuICAgIGlmICghby5uKSByZXR1cm47XG4gICAgaWYgKCFhLnB1YmtleXMpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFxuICAgICAgW10uY29uY2F0KFxuICAgICAgICBPUF9JTlRfQkFTRSArIGEubSxcbiAgICAgICAgYS5wdWJrZXlzLFxuICAgICAgICBPUF9JTlRfQkFTRSArIG8ubixcbiAgICAgICAgT1BTLk9QX0NIRUNLTVVMVElTSUcsXG4gICAgICApLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ20nLCAoKSA9PiB7XG4gICAgaWYgKCFvLm91dHB1dCkgcmV0dXJuO1xuICAgIGRlY29kZShvLm91dHB1dCk7XG4gICAgcmV0dXJuIG8ubTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbicsICgpID0+IHtcbiAgICBpZiAoIW8ucHVia2V5cykgcmV0dXJuO1xuICAgIHJldHVybiBvLnB1YmtleXMubGVuZ3RoO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXlzJywgKCkgPT4ge1xuICAgIGlmICghYS5vdXRwdXQpIHJldHVybjtcbiAgICBkZWNvZGUoYS5vdXRwdXQpO1xuICAgIHJldHVybiBvLnB1YmtleXM7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZXMnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpLnNsaWNlKDEpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEuc2lnbmF0dXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wXS5jb25jYXQoYS5zaWduYXR1cmVzKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICduYW1lJywgKCkgPT4ge1xuICAgIGlmICghby5tIHx8ICFvLm4pIHJldHVybjtcbiAgICByZXR1cm4gYHAybXMoJHtvLm19IG9mICR7by5ufSlgO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgZGVjb2RlKGEub3V0cHV0KTtcbiAgICAgIGlmICghdHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKGNodW5rc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIXR5cGVzXzEudHlwZWZvcmNlLk51bWJlcihjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdICE9PSBPUFMuT1BfQ0hFQ0tNVUxUSVNJRylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChvLm0gPD0gMCB8fCBvLm4gPiAxNiB8fCBvLm0gPiBvLm4gfHwgby5uICE9PSBjaHVua3MubGVuZ3RoIC0gMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghby5wdWJrZXlzLmV2ZXJ5KHggPT4gKDAsIHR5cGVzXzEuaXNQb2ludCkoeCkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gby5tKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5uICE9PSB1bmRlZmluZWQgJiYgYS5uICE9PSBvLm4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ24gbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChhLnB1YmtleXMgJiYgIXN0YWNrc0VxdWFsKGEucHVia2V5cywgby5wdWJrZXlzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5cyBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXlzKSB7XG4gICAgICBpZiAoYS5uICE9PSB1bmRlZmluZWQgJiYgYS5uICE9PSBhLnB1YmtleXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgY291bnQgbWlzbWF0Y2gnKTtcbiAgICAgIG8ubiA9IGEucHVia2V5cy5sZW5ndGg7XG4gICAgICBpZiAoby5uIDwgby5tKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgY291bnQgY2Fubm90IGJlIGxlc3MgdGhhbiBtJyk7XG4gICAgfVxuICAgIGlmIChhLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChhLnNpZ25hdHVyZXMubGVuZ3RoIDwgby5tKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIHNpZ25hdHVyZXMgcHJvdmlkZWQnKTtcbiAgICAgIGlmIChhLnNpZ25hdHVyZXMubGVuZ3RoID4gby5tKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb28gbWFueSBzaWduYXR1cmVzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGlmIChhLmlucHV0KSB7XG4gICAgICBpZiAoYS5pbnB1dFswXSAhPT0gT1BTLk9QXzApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChcbiAgICAgICAgby5zaWduYXR1cmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAhby5zaWduYXR1cmVzLmV2ZXJ5KGlzQWNjZXB0YWJsZVNpZ25hdHVyZSlcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlKHMpJyk7XG4gICAgICBpZiAoYS5zaWduYXR1cmVzICYmICFzdGFja3NFcXVhbChhLnNpZ25hdHVyZXMsIG8uc2lnbmF0dXJlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gYS5zaWduYXR1cmVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIGNvdW50IG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMm1zID0gcDJtcztcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAycGsgPSB2b2lkIDA7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG4vLyBpbnB1dDoge3NpZ25hdHVyZX1cbi8vIG91dHB1dDoge3B1YktleX0gT1BfQ0hFQ0tTSUdcbmZ1bmN0aW9uIHAycGsoYSwgb3B0cykge1xuICBpZiAoIWEuaW5wdXQgJiYgIWEub3V0cHV0ICYmICFhLnB1YmtleSAmJiAhYS5pbnB1dCAmJiAhYS5zaWduYXR1cmUpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgIHB1YmtleTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1BvaW50KSxcbiAgICAgIHNpZ25hdHVyZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9jaHVua3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gIH0pO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ3AycGsnLCBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghYS5wdWJrZXkpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnB1YmtleSwgT1BTLk9QX0NIRUNLU0lHXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoIWEub3V0cHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDEsIC0xKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmICghYS5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBfY2h1bmtzKClbMF07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghYS5zaWduYXR1cmUpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnNpZ25hdHVyZV0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChhLm91dHB1dFthLm91dHB1dC5sZW5ndGggLSAxXSAhPT0gT1BTLk9QX0NIRUNLU0lHKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShvLnB1YmtleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBwdWJrZXkgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoby5wdWJrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKGEuc2lnbmF0dXJlKSB7XG4gICAgICBpZiAoYS5pbnB1dCAmJiAhYS5pbnB1dC5lcXVhbHMoby5pbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgaWYgKF9jaHVua3MoKS5sZW5ndGggIT09IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShvLnNpZ25hdHVyZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJwayA9IHAycGs7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBraCA9IHZvaWQgMDtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuLy8gaW5wdXQ6IHtzaWduYXR1cmV9IHtwdWJrZXl9XG4vLyBvdXRwdXQ6IE9QX0RVUCBPUF9IQVNIMTYwIHtoYXNoMTYwKHB1YmtleSl9IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG5mdW5jdGlvbiBwMnBraChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnB1YmtleSAmJiAhYS5pbnB1dClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgIGhhc2g6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjApKSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyNSkpLFxuICAgICAgcHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLmlzUG9pbnQpLFxuICAgICAgc2lnbmF0dXJlOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oYnM1OGNoZWNrLmRlY29kZShhLmFkZHJlc3MpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gcGF5bG9hZC5yZWFkVUludDgoMCk7XG4gICAgY29uc3QgaGFzaCA9IHBheWxvYWQuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHsgdmVyc2lvbiwgaGFzaCB9O1xuICB9KTtcbiAgY29uc3QgX2NodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLmlucHV0KTtcbiAgfSk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuYW1lOiAncDJwa2gnLCBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChuZXR3b3JrLnB1YktleUhhc2gsIDApO1xuICAgIG8uaGFzaC5jb3B5KHBheWxvYWQsIDEpO1xuICAgIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKHBheWxvYWQpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDMsIDIzKTtcbiAgICBpZiAoYS5hZGRyZXNzKSByZXR1cm4gX2FkZHJlc3MoKS5oYXNoO1xuICAgIGlmIChhLnB1YmtleSB8fCBvLnB1YmtleSkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSB8fCBvLnB1YmtleSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW1xuICAgICAgT1BTLk9QX0RVUCxcbiAgICAgIE9QUy5PUF9IQVNIMTYwLFxuICAgICAgby5oYXNoLFxuICAgICAgT1BTLk9QX0VRVUFMVkVSSUZZLFxuICAgICAgT1BTLk9QX0NIRUNLU0lHLFxuICAgIF0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9jaHVua3MoKVsxXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmICghYS5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBfY2h1bmtzKClbMF07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghYS5wdWJrZXkpIHJldHVybjtcbiAgICBpZiAoIWEuc2lnbmF0dXJlKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbYS5zaWduYXR1cmUsIGEucHVia2V5XSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmhhc2gubGVuZ3RoICE9PSAyMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDI1IHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfRFVQIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSBPUFMuT1BfSEFTSDE2MCB8fFxuICAgICAgICBhLm91dHB1dFsyXSAhPT0gMHgxNCB8fFxuICAgICAgICBhLm91dHB1dFsyM10gIT09IE9QUy5PUF9FUVVBTFZFUklGWSB8fFxuICAgICAgICBhLm91dHB1dFsyNF0gIT09IE9QUy5PUF9DSEVDS1NJR1xuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgaGFzaDIgPSBhLm91dHB1dC5zbGljZSgzLCAyMyk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXkpIHtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBwa2g7XG4gICAgfVxuICAgIGlmIChhLmlucHV0KSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBfY2h1bmtzKCk7XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCAhPT0gMikgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGNodW5rc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShjaHVua3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBwdWJrZXknKTtcbiAgICAgIGlmIChhLnNpZ25hdHVyZSAmJiAhYS5zaWduYXR1cmUuZXF1YWxzKGNodW5rc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoY2h1bmtzWzFdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICBjb25zdCBwa2ggPSBiY3J5cHRvLmhhc2gxNjAoY2h1bmtzWzFdKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKHBraCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAycGtoID0gcDJwa2g7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnNoID0gdm9pZCAwO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4uL2NyeXB0bycpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGEuZXZlcnkoKHgsIGkpID0+IHtcbiAgICByZXR1cm4geC5lcXVhbHMoYltpXSk7XG4gIH0pO1xufVxuLy8gaW5wdXQ6IFtyZWRlZW1TY3JpcHRTaWcgLi4uXSB7cmVkZWVtU2NyaXB0fVxuLy8gd2l0bmVzczogPD8+XG4vLyBvdXRwdXQ6IE9QX0hBU0gxNjAge2hhc2gxNjAocmVkZWVtU2NyaXB0KX0gT1BfRVFVQUxcbmZ1bmN0aW9uIHAyc2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEuaW5wdXQpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDIwKSksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjMpKSxcbiAgICAgIHJlZGVlbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoe1xuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBsZXQgbmV0d29yayA9IGEubmV0d29yaztcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IChhLnJlZGVlbSAmJiBhLnJlZGVlbS5uZXR3b3JrKSB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIH1cbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcykpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgX3JlZGVlbSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICBuZXR3b3JrLFxuICAgICAgb3V0cHV0OiBsYXN0Q2h1bmsgPT09IE9QUy5PUF9GQUxTRSA/IEJ1ZmZlci5mcm9tKFtdKSA6IGxhc3RDaHVuayxcbiAgICAgIGlucHV0OiBic2NyaXB0LmNvbXBpbGUoY2h1bmtzLnNsaWNlKDAsIC0xKSksXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3MgfHwgW10sXG4gICAgfTtcbiAgfSk7XG4gIC8vIG91dHB1dCBkZXBlbmRlbnRzXG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChvLm5ldHdvcmsuc2NyaXB0SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgb2YgbGVhc3QgZWZmb3J0XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChvLnJlZGVlbS5vdXRwdXQpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfSEFTSDE2MCwgby5oYXNoLCBPUFMuT1BfRVFVQUxdKTtcbiAgfSk7XG4gIC8vIGlucHV0IGRlcGVuZGVudHNcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9yZWRlZW0oKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnJlZGVlbSB8fCAhYS5yZWRlZW0uaW5wdXQgfHwgIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBbXS5jb25jYXQoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0uaW5wdXQpLCBhLnJlZGVlbS5vdXRwdXQpLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLndpdG5lc3MpIHJldHVybiBvLnJlZGVlbS53aXRuZXNzO1xuICAgIGlmIChvLmlucHV0KSByZXR1cm4gW107XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMnNoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQgJiYgby5yZWRlZW0ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgbmFtZVBhcnRzLnB1c2goby5yZWRlZW0ubmFtZSk7XG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gIH0pO1xuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmhhc2gubGVuZ3RoICE9PSAyMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDIzIHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfSEFTSDE2MCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgxNCB8fFxuICAgICAgICBhLm91dHB1dFsyMl0gIT09IE9QUy5PUF9FUVVBTFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgaGFzaDIgPSBhLm91dHB1dC5zbGljZSgyLCAyMik7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgIH1cbiAgICAvLyBpbmxpbmVkIHRvIHByZXZlbnQgJ25vLWlubmVyLWRlY2xhcmF0aW9ucycgZmFpbGluZ1xuICAgIGNvbnN0IGNoZWNrUmVkZWVtID0gcmVkZWVtID0+IHtcbiAgICAgIC8vIGlzIHRoZSByZWRlZW0gb3V0cHV0IGVtcHR5L2ludmFsaWQ/XG4gICAgICBpZiAocmVkZWVtLm91dHB1dCkge1xuICAgICAgICBjb25zdCBkZWNvbXBpbGUgPSBic2NyaXB0LmRlY29tcGlsZShyZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgaWYgKCFkZWNvbXBpbGUgfHwgZGVjb21waWxlLmxlbmd0aCA8IDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCB0b28gc2hvcnQnKTtcbiAgICAgICAgaWYgKHJlZGVlbS5vdXRwdXQuYnl0ZUxlbmd0aCA+IDUyMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ1JlZGVlbS5vdXRwdXQgdW5zcGVuZGFibGUgaWYgbGFyZ2VyIHRoYW4gNTIwIGJ5dGVzJyxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoYnNjcmlwdC5jb3VudE5vblB1c2hPbmx5T1BzKGRlY29tcGlsZSkgPiAyMDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSZWRlZW0ub3V0cHV0IHVuc3BlbmRhYmxlIHdpdGggbW9yZSB0aGFuIDIwMSBub24tcHVzaCBvcHMnLFxuICAgICAgICAgICk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5oYXNoMTYwKHJlZGVlbS5vdXRwdXQpO1xuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZW0uaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaGFzSW5wdXQgPSByZWRlZW0uaW5wdXQubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzcyA9IHJlZGVlbS53aXRuZXNzICYmIHJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaGFzSW5wdXQgJiYgIWhhc1dpdG5lc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtcHR5IGlucHV0Jyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCAmJiBoYXNXaXRuZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGFuZCB3aXRuZXNzIHByb3ZpZGVkJyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHJpY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLmlucHV0KTtcbiAgICAgICAgICBpZiAoIWJzY3JpcHQuaXNQdXNoT25seShyaWNodW5rcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24gcHVzaC1vbmx5IHNjcmlwdFNpZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoX3JlZGVlbSgpLm91dHB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNoZWNrUmVkZWVtKF9yZWRlZW0oKSk7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLm5ldHdvcmsgJiYgYS5yZWRlZW0ubmV0d29yayAhPT0gbmV0d29yaylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVkZWVtID0gX3JlZGVlbSgpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHJlZGVlbS5vdXRwdXQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFhLnJlZGVlbS5pbnB1dC5lcXVhbHMocmVkZWVtLmlucHV0KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0uaW5wdXQgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrUmVkZWVtKGEucmVkZWVtKTtcbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgaWYgKFxuICAgICAgICBhLnJlZGVlbSAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICFzdGFja3NFcXVhbChhLnJlZGVlbS53aXRuZXNzLCBhLndpdG5lc3MpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS53aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnNoID0gcDJzaDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAydHIgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGVjY19saWJfMSA9IHJlcXVpcmUoJy4uL2VjY19saWInKTtcbmNvbnN0IGJpcDM0MV8xID0gcmVxdWlyZSgnLi9iaXAzNDEnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IFRBUFJPT1RfV0lUTkVTU19WRVJTSU9OID0gMHgwMTtcbmNvbnN0IEFOTkVYX1BSRUZJWCA9IDB4NTA7XG5mdW5jdGlvbiBwMnRyKGEsIG9wdHMpIHtcbiAgaWYgKFxuICAgICFhLmFkZHJlc3MgJiZcbiAgICAhYS5vdXRwdXQgJiZcbiAgICAhYS5wdWJrZXkgJiZcbiAgICAhYS5pbnRlcm5hbFB1YmtleSAmJlxuICAgICEoYS53aXRuZXNzICYmIGEud2l0bmVzcy5sZW5ndGggPiAxKVxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDApKSxcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzQpKSxcbiAgICAgIGludGVybmFsUHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKSksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKSksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzIpKSxcbiAgICAgIHNpZ25hdHVyZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFueU9mKFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oNjQpLFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oNjUpLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICApLFxuICAgICAgc2NyaXB0VHJlZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1RhcHRyZWUpLFxuICAgICAgcmVkZWVtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh7XG4gICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgcmVkZWVtVmVyc2lvbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICApLFxuICAgICAgfSksXG4gICAgICByZWRlZW1WZXJzaW9uOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBiZWNoMzJfMS5iZWNoMzJtLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZXN1bHQud29yZHMuc2hpZnQoKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyXzEuYmVjaDMybS5mcm9tV29yZHMocmVzdWx0LndvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbixcbiAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgIGRhdGE6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgIH07XG4gIH0pO1xuICAvLyByZW1vdmUgYW5uZXggaWYgcHJlc2VudCwgaWdub3JlZCBieSB0YXByb290XG4gIGNvbnN0IF93aXRuZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgaWYgKCFhLndpdG5lc3MgfHwgIWEud2l0bmVzcy5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoXG4gICAgICBhLndpdG5lc3MubGVuZ3RoID49IDIgJiZcbiAgICAgIGEud2l0bmVzc1thLndpdG5lc3MubGVuZ3RoIC0gMV1bMF0gPT09IEFOTkVYX1BSRUZJWFxuICAgICkge1xuICAgICAgcmV0dXJuIGEud2l0bmVzcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBhLndpdG5lc3Muc2xpY2UoKTtcbiAgfSk7XG4gIGNvbnN0IF9oYXNoVHJlZSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGlmIChhLnNjcmlwdFRyZWUpIHJldHVybiAoMCwgYmlwMzQxXzEudG9IYXNoVHJlZSkoYS5zY3JpcHRUcmVlKTtcbiAgICBpZiAoYS5oYXNoKSByZXR1cm4geyBoYXNoOiBhLmhhc2ggfTtcbiAgICByZXR1cm47XG4gIH0pO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ3AydHInLCBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8ucHVia2V5KSByZXR1cm47XG4gICAgY29uc3Qgd29yZHMgPSBiZWNoMzJfMS5iZWNoMzJtLnRvV29yZHMoby5wdWJrZXkpO1xuICAgIHdvcmRzLnVuc2hpZnQoVEFQUk9PVF9XSVRORVNTX1ZFUlNJT04pO1xuICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzJtLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGNvbnN0IGhhc2hUcmVlID0gX2hhc2hUcmVlKCk7XG4gICAgaWYgKGhhc2hUcmVlKSByZXR1cm4gaGFzaFRyZWUuaGFzaDtcbiAgICBjb25zdCB3ID0gX3dpdG5lc3MoKTtcbiAgICBpZiAodyAmJiB3Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xCbG9jayA9IHdbdy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxlYWZWZXJzaW9uID0gY29udHJvbEJsb2NrWzBdICYgdHlwZXNfMS5UQVBMRUFGX1ZFUlNJT05fTUFTSztcbiAgICAgIGNvbnN0IHNjcmlwdCA9IHdbdy5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICB2ZXJzaW9uOiBsZWFmVmVyc2lvbixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgwLCBiaXAzNDFfMS5yb290SGFzaEZyb21QYXRoKShjb250cm9sQmxvY2ssIGxlYWZIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8ucHVia2V5KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QXzEsIG8ucHVia2V5XSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3JlZGVlbVZlcnNpb24nLCAoKSA9PiB7XG4gICAgaWYgKGEucmVkZWVtVmVyc2lvbikgcmV0dXJuIGEucmVkZWVtVmVyc2lvbjtcbiAgICBpZiAoXG4gICAgICBhLnJlZGVlbSAmJlxuICAgICAgYS5yZWRlZW0ucmVkZWVtVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhLnJlZGVlbS5yZWRlZW1WZXJzaW9uICE9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm4gYS5yZWRlZW0ucmVkZWVtVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIGJpcDM0MV8xLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQ7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3JlZGVlbScsICgpID0+IHtcbiAgICBjb25zdCB3aXRuZXNzID0gX3dpdG5lc3MoKTsgLy8gd2l0bmVzcyB3aXRob3V0IGFubmV4XG4gICAgaWYgKCF3aXRuZXNzIHx8IHdpdG5lc3MubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXQ6IHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAyXSxcbiAgICAgIHdpdG5lc3M6IHdpdG5lc3Muc2xpY2UoMCwgLTIpLFxuICAgICAgcmVkZWVtVmVyc2lvbjpcbiAgICAgICAgd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDFdWzBdICYgdHlwZXNfMS5UQVBMRUFGX1ZFUlNJT05fTUFTSyxcbiAgICB9O1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgaWYgKGEucHVia2V5KSByZXR1cm4gYS5wdWJrZXk7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgaWYgKGEuYWRkcmVzcykgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICBpZiAoby5pbnRlcm5hbFB1YmtleSkge1xuICAgICAgY29uc3QgdHdlYWtlZEtleSA9ICgwLCBiaXAzNDFfMS50d2Vha0tleSkoby5pbnRlcm5hbFB1YmtleSwgby5oYXNoKTtcbiAgICAgIGlmICh0d2Vha2VkS2V5KSByZXR1cm4gdHdlYWtlZEtleS54O1xuICAgIH1cbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW50ZXJuYWxQdWJrZXknLCAoKSA9PiB7XG4gICAgaWYgKGEuaW50ZXJuYWxQdWJrZXkpIHJldHVybiBhLmludGVybmFsUHVia2V5O1xuICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpO1xuICAgIGlmICh3aXRuZXNzICYmIHdpdG5lc3MubGVuZ3RoID4gMSlcbiAgICAgIHJldHVybiB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV0uc2xpY2UoMSwgMzMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaWYgKGEuc2lnbmF0dXJlKSByZXR1cm4gYS5zaWduYXR1cmU7XG4gICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7IC8vIHdpdG5lc3Mgd2l0aG91dCBhbm5leFxuICAgIGlmICghd2l0bmVzcyB8fCB3aXRuZXNzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xuICAgIHJldHVybiB3aXRuZXNzWzBdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmIChhLndpdG5lc3MpIHJldHVybiBhLndpdG5lc3M7XG4gICAgY29uc3QgaGFzaFRyZWUgPSBfaGFzaFRyZWUoKTtcbiAgICBpZiAoaGFzaFRyZWUgJiYgYS5yZWRlZW0gJiYgYS5yZWRlZW0ub3V0cHV0ICYmIGEuaW50ZXJuYWxQdWJrZXkpIHtcbiAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgIG91dHB1dDogYS5yZWRlZW0ub3V0cHV0LFxuICAgICAgICB2ZXJzaW9uOiBvLnJlZGVlbVZlcnNpb24sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhdGggPSAoMCwgYmlwMzQxXzEuZmluZFNjcmlwdFBhdGgpKGhhc2hUcmVlLCBsZWFmSGFzaCk7XG4gICAgICBpZiAoIXBhdGgpIHJldHVybjtcbiAgICAgIGNvbnN0IG91dHB1dEtleSA9ICgwLCBiaXAzNDFfMS50d2Vha0tleSkoYS5pbnRlcm5hbFB1YmtleSwgaGFzaFRyZWUuaGFzaCk7XG4gICAgICBpZiAoIW91dHB1dEtleSkgcmV0dXJuO1xuICAgICAgY29uc3QgY29udHJvbEJvY2sgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFxuICAgICAgICBbXG4gICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oW28ucmVkZWVtVmVyc2lvbiB8IG91dHB1dEtleS5wYXJpdHldKSxcbiAgICAgICAgICBhLmludGVybmFsUHVia2V5LFxuICAgICAgICBdLmNvbmNhdChwYXRoKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gW2EucmVkZWVtLm91dHB1dCwgY29udHJvbEJvY2tdO1xuICAgIH1cbiAgICBpZiAoYS5zaWduYXR1cmUpIHJldHVybiBbYS5zaWduYXR1cmVdO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBwdWJrZXkgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKG5ldHdvcmsgJiYgbmV0d29yay5iZWNoMzIgIT09IF9hZGRyZXNzKCkucHJlZml4KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHByZWZpeCBvciBOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSBUQVBST09UX1dJVE5FU1NfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIGRhdGEnKTtcbiAgICAgIHB1YmtleSA9IF9hZGRyZXNzKCkuZGF0YTtcbiAgICB9XG4gICAgaWYgKGEucHVia2V5KSB7XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCA+IDAgJiYgIXB1YmtleS5lcXVhbHMoYS5wdWJrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgcHVia2V5ID0gYS5wdWJrZXk7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDM0IHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfMSB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgyMFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKHB1YmtleS5sZW5ndGggPiAwICYmICFwdWJrZXkuZXF1YWxzKGEub3V0cHV0LnNsaWNlKDIpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICBlbHNlIHB1YmtleSA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAoYS5pbnRlcm5hbFB1YmtleSkge1xuICAgICAgY29uc3QgdHdlYWtlZEtleSA9ICgwLCBiaXAzNDFfMS50d2Vha0tleSkoYS5pbnRlcm5hbFB1YmtleSwgby5oYXNoKTtcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoID4gMCAmJiAhcHVia2V5LmVxdWFscyh0d2Vha2VkS2V5LngpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgcHVia2V5ID0gdHdlYWtlZEtleS54O1xuICAgIH1cbiAgICBpZiAocHVia2V5ICYmIHB1YmtleS5sZW5ndGgpIHtcbiAgICAgIGlmICghKDAsIGVjY19saWJfMS5nZXRFY2NMaWIpKCkuaXNYT25seVBvaW50KHB1YmtleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHVia2V5IGZvciBwMnRyJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hUcmVlID0gX2hhc2hUcmVlKCk7XG4gICAgaWYgKGEuaGFzaCAmJiBoYXNoVHJlZSkge1xuICAgICAgaWYgKCFhLmhhc2guZXF1YWxzKGhhc2hUcmVlLmhhc2gpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSAmJiBhLnJlZGVlbS5vdXRwdXQgJiYgaGFzaFRyZWUpIHtcbiAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgIG91dHB1dDogYS5yZWRlZW0ub3V0cHV0LFxuICAgICAgICB2ZXJzaW9uOiBvLnJlZGVlbVZlcnNpb24sXG4gICAgICB9KTtcbiAgICAgIGlmICghKDAsIGJpcDM0MV8xLmZpbmRTY3JpcHRQYXRoKShoYXNoVHJlZSwgbGVhZkhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0gc2NyaXB0IG5vdCBpbiB0cmVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpO1xuICAgIC8vIGNvbXBhcmUgdGhlIHByb3ZpZGVkIHJlZGVlbSBkYXRhIHdpdGggdGhlIG9uZSBjb21wdXRlZCBmcm9tIHdpdG5lc3NcbiAgICBpZiAoYS5yZWRlZW0gJiYgby5yZWRlZW0pIHtcbiAgICAgIGlmIChhLnJlZGVlbS5yZWRlZW1WZXJzaW9uKSB7XG4gICAgICAgIGlmIChhLnJlZGVlbS5yZWRlZW1WZXJzaW9uICE9PSBvLnJlZGVlbS5yZWRlZW1WZXJzaW9uKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5yZWRlZW1WZXJzaW9uIGFuZCB3aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgICB9XG4gICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0KSB7XG4gICAgICAgIGlmIChic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5vdXRwdXQpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0ub3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgLy8gb3V0cHV0IHJlZGVlbSBpcyBjb25zdHJ1Y3RlZCBmcm9tIHRoZSB3aXRuZXNzXG4gICAgICAgIGlmIChvLnJlZGVlbS5vdXRwdXQgJiYgIWEucmVkZWVtLm91dHB1dC5lcXVhbHMoby5yZWRlZW0ub3V0cHV0KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0ub3V0cHV0IGFuZCB3aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgICB9XG4gICAgICBpZiAoYS5yZWRlZW0ud2l0bmVzcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgby5yZWRlZW0ud2l0bmVzcyAmJlxuICAgICAgICAgICFzdGFja3NFcXVhbChhLnJlZGVlbS53aXRuZXNzLCBvLnJlZGVlbS53aXRuZXNzKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLndpdG5lc3MgYW5kIHdpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpdG5lc3MgJiYgd2l0bmVzcy5sZW5ndGgpIHtcbiAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBrZXkgc3BlbmRpbmdcbiAgICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMod2l0bmVzc1swXSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzY3JpcHQgcGF0aCBzcGVuZGluZ1xuICAgICAgICBjb25zdCBjb250cm9sQmxvY2sgPSB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjb250cm9sQmxvY2subGVuZ3RoIDwgMzMpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggaXMgdG9vIHNtYWxsLiBHb3QgJHtjb250cm9sQmxvY2subGVuZ3RofSwgZXhwZWN0ZWQgbWluIDMzLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKChjb250cm9sQmxvY2subGVuZ3RoIC0gMzMpICUgMzIgIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggb2YgJHtjb250cm9sQmxvY2subGVuZ3RofSBpcyBpbmNvcnJlY3QhYCxcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBtID0gKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgLyAzMjtcbiAgICAgICAgaWYgKG0gPiAxMjgpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgc2NyaXB0IHBhdGggaXMgdG9vIGxvbmcuIEdvdCAke219LCBleHBlY3RlZCBtYXggMTI4LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxQdWJrZXkgPSBjb250cm9sQmxvY2suc2xpY2UoMSwgMzMpO1xuICAgICAgICBpZiAoYS5pbnRlcm5hbFB1YmtleSAmJiAhYS5pbnRlcm5hbFB1YmtleS5lcXVhbHMoaW50ZXJuYWxQdWJrZXkpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGVybmFsIHB1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgICBpZiAoISgwLCBlY2NfbGliXzEuZ2V0RWNjTGliKSgpLmlzWE9ubHlQb2ludChpbnRlcm5hbFB1YmtleSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbnRlcm5hbFB1YmtleSBmb3IgcDJ0ciB3aXRuZXNzJyk7XG4gICAgICAgIGNvbnN0IGxlYWZWZXJzaW9uID0gY29udHJvbEJsb2NrWzBdICYgdHlwZXNfMS5UQVBMRUFGX1ZFUlNJT05fTUFTSztcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDJdO1xuICAgICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICAgIHZlcnNpb246IGxlYWZWZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzaCA9ICgwLCBiaXAzNDFfMS5yb290SGFzaEZyb21QYXRoKShjb250cm9sQmxvY2ssIGxlYWZIYXNoKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0S2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShpbnRlcm5hbFB1YmtleSwgaGFzaCk7XG4gICAgICAgIGlmICghb3V0cHV0S2V5KVxuICAgICAgICAgIC8vIHRvZG86IG5lZWRzIHRlc3QgZGF0YVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3V0cHV0S2V5IGZvciBwMnRyIHdpdG5lc3MnKTtcbiAgICAgICAgaWYgKHB1YmtleS5sZW5ndGggJiYgIXB1YmtleS5lcXVhbHMob3V0cHV0S2V5LngpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCBmb3IgcDJ0ciB3aXRuZXNzJyk7XG4gICAgICAgIGlmIChvdXRwdXRLZXkucGFyaXR5ICE9PSAoY29udHJvbEJsb2NrWzBdICYgMSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFyaXR5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnRyID0gcDJ0cjtcbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMndwa2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuLy8gd2l0bmVzczoge3NpZ25hdHVyZX0ge3B1YktleX1cbi8vIGlucHV0OiA8PlxuLy8gb3V0cHV0OiBPUF8wIHtwdWJLZXlIYXNofVxuZnVuY3Rpb24gcDJ3cGtoKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmFkZHJlc3MgJiYgIWEuaGFzaCAmJiAhYS5vdXRwdXQgJiYgIWEucHVia2V5ICYmICFhLndpdG5lc3MpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgIGhhc2g6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjApKSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDApKSxcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjIpKSxcbiAgICAgIHB1YmtleTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1BvaW50KSxcbiAgICAgIHNpZ25hdHVyZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSksXG4gICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZXN1bHQud29yZHMuc2hpZnQoKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyXzEuYmVjaDMyLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgcHJlZml4OiByZXN1bHQucHJlZml4LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuYW1lOiAncDJ3cGtoJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKG8uaGFzaCk7XG4gICAgd29yZHMudW5zaGlmdCgweDAwKTtcbiAgICByZXR1cm4gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIsIDIyKTtcbiAgICBpZiAoYS5hZGRyZXNzKSByZXR1cm4gX2FkZHJlc3MoKS5kYXRhO1xuICAgIGlmIChhLnB1YmtleSB8fCBvLnB1YmtleSkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSB8fCBvLnB1YmtleSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wLCBvLmhhc2hdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgIGlmIChhLnB1YmtleSkgcmV0dXJuIGEucHVia2V5O1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIGEud2l0bmVzc1sxXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIGEud2l0bmVzc1swXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghYS5wdWJrZXkpIHJldHVybjtcbiAgICBpZiAoIWEuc2lnbmF0dXJlKSByZXR1cm47XG4gICAgcmV0dXJuIFthLnNpZ25hdHVyZSwgYS5wdWJrZXldO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChuZXR3b3JrICYmIG5ldHdvcmsuYmVjaDMyICE9PSBfYWRkcmVzcygpLnByZWZpeClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAyMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIGRhdGEnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmRhdGE7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMjIgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8wIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSAweDE0XG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLm91dHB1dC5zbGljZSgyKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXkpIHtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBwa2g7XG4gICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKGEucHVia2V5KSB8fCBhLnB1YmtleS5sZW5ndGggIT09IDMzKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHB1YmtleSBmb3IgcDJ3cGtoJyk7XG4gICAgfVxuICAgIGlmIChhLndpdG5lc3MpIHtcbiAgICAgIGlmIChhLndpdG5lc3MubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShhLndpdG5lc3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShhLndpdG5lc3NbMV0pIHx8IGEud2l0bmVzc1sxXS5sZW5ndGggIT09IDMzKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGhhcyBpbnZhbGlkIHB1YmtleScpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMoYS53aXRuZXNzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5wdWJrZXkgJiYgIWEucHVia2V5LmVxdWFscyhhLndpdG5lc3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLndpdG5lc3NbMV0pO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJ3cGtoID0gcDJ3cGtoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ3c2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuZnVuY3Rpb24gc3RhY2tzRXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBhLmV2ZXJ5KCh4LCBpKSA9PiB7XG4gICAgcmV0dXJuIHguZXF1YWxzKGJbaV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KGNodW5rKSB7XG4gIGlmIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgY2h1bmsubGVuZ3RoID09PSA2NSAmJlxuICAgIGNodW5rWzBdID09PSAweDA0ICYmXG4gICAgKDAsIHR5cGVzXzEuaXNQb2ludCkoY2h1bmspXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLy8gaW5wdXQ6IDw+XG4vLyB3aXRuZXNzOiBbcmVkZWVtU2NyaXB0U2lnIC4uLl0ge3JlZGVlbVNjcmlwdH1cbi8vIG91dHB1dDogT1BfMCB7c2hhMjU2KHJlZGVlbVNjcmlwdCl9XG5mdW5jdGlvbiBwMndzaChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnJlZGVlbSAmJiAhYS53aXRuZXNzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBhZGRyZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDM0KSksXG4gICAgICByZWRlZW06IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHtcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICApLFxuICAgICAgfSksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigwKSksXG4gICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZXN1bHQud29yZHMuc2hpZnQoKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyXzEuYmVjaDMyLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgcHJlZml4OiByZXN1bHQucHJlZml4LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IF9yY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLmlucHV0KTtcbiAgfSk7XG4gIGxldCBuZXR3b3JrID0gYS5uZXR3b3JrO1xuICBpZiAoIW5ldHdvcmspIHtcbiAgICBuZXR3b3JrID0gKGEucmVkZWVtICYmIGEucmVkZWVtLm5ldHdvcmspIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgfVxuICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyXzEuYmVjaDMyLnRvV29yZHMoby5oYXNoKTtcbiAgICB3b3Jkcy51bnNoaWZ0KDB4MDApO1xuICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKG5ldHdvcmsuYmVjaDMyLCB3b3Jkcyk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgaWYgKGEuYWRkcmVzcykgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICBpZiAoby5yZWRlZW0gJiYgby5yZWRlZW0ub3V0cHV0KSByZXR1cm4gYmNyeXB0by5zaGEyNTYoby5yZWRlZW0ub3V0cHV0KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QXzAsIG8uaGFzaF0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBhLndpdG5lc3NbYS53aXRuZXNzLmxlbmd0aCAtIDFdLFxuICAgICAgaW5wdXQ6IEVNUFRZX0JVRkZFUixcbiAgICAgIHdpdG5lc3M6IGEud2l0bmVzcy5zbGljZSgwLCAtMSksXG4gICAgfTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIC8vIHRyYW5zZm9ybSByZWRlZW0gaW5wdXQgdG8gd2l0bmVzcyBzdGFjaz9cbiAgICBpZiAoXG4gICAgICBhLnJlZGVlbSAmJlxuICAgICAgYS5yZWRlZW0uaW5wdXQgJiZcbiAgICAgIGEucmVkZWVtLmlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgIGEucmVkZWVtLm91dHB1dCAmJlxuICAgICAgYS5yZWRlZW0ub3V0cHV0Lmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gYnNjcmlwdC50b1N0YWNrKF9yY2h1bmtzKCkpO1xuICAgICAgLy8gYXNzaWduLCBhbmQgYmxhbmsgdGhlIGV4aXN0aW5nIGlucHV0XG4gICAgICBvLnJlZGVlbSA9IE9iamVjdC5hc3NpZ24oeyB3aXRuZXNzOiBzdGFjayB9LCBhLnJlZGVlbSk7XG4gICAgICBvLnJlZGVlbS5pbnB1dCA9IEVNUFRZX0JVRkZFUjtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoc3RhY2ssIGEucmVkZWVtLm91dHB1dCk7XG4gICAgfVxuICAgIGlmICghYS5yZWRlZW0pIHJldHVybjtcbiAgICBpZiAoIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIGlmICghYS5yZWRlZW0ud2l0bmVzcykgcmV0dXJuO1xuICAgIHJldHVybiBbXS5jb25jYXQoYS5yZWRlZW0ud2l0bmVzcywgYS5yZWRlZW0ub3V0cHV0KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbmFtZScsICgpID0+IHtcbiAgICBjb25zdCBuYW1lUGFydHMgPSBbJ3Ayd3NoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQgJiYgby5yZWRlZW0ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgbmFtZVBhcnRzLnB1c2goby5yZWRlZW0ubmFtZSk7XG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKF9hZGRyZXNzKCkucHJlZml4ICE9PSBuZXR3b3JrLmJlY2gzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIGRhdGEnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmRhdGE7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMzQgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8wIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSAweDIwXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICB9XG4gICAgaWYgKGEucmVkZWVtKSB7XG4gICAgICBpZiAoYS5yZWRlZW0ubmV0d29yayAmJiBhLnJlZGVlbS5uZXR3b3JrICE9PSBuZXR3b3JrKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICAvLyBpcyB0aGVyZSB0d28gcmVkZWVtIHNvdXJjZXM/XG4gICAgICBpZiAoXG4gICAgICAgIGEucmVkZWVtLmlucHV0ICYmXG4gICAgICAgIGEucmVkZWVtLmlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgYS5yZWRlZW0ud2l0bmVzcyAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDBcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQW1iaWd1b3VzIHdpdG5lc3Mgc291cmNlJyk7XG4gICAgICAvLyBpcyB0aGUgcmVkZWVtIG91dHB1dCBub24tZW1wdHkvdmFsaWQ/XG4gICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IGRlY29tcGlsZSA9IGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLm91dHB1dCk7XG4gICAgICAgIGlmICghZGVjb21waWxlIHx8IGRlY29tcGlsZS5sZW5ndGggPCAxKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0LmJ5dGVMZW5ndGggPiAzNjAwKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnUmVkZWVtLm91dHB1dCB1bnNwZW5kYWJsZSBpZiBsYXJnZXIgdGhhbiAzNjAwIGJ5dGVzJyxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoYnNjcmlwdC5jb3VudE5vblB1c2hPbmx5T1BzKGRlY29tcGlsZSkgPiAyMDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSZWRlZW0ub3V0cHV0IHVuc3BlbmRhYmxlIHdpdGggbW9yZSB0aGFuIDIwMSBub24tcHVzaCBvcHMnLFxuICAgICAgICAgICk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5zaGEyNTYoYS5yZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgZWxzZSBoYXNoID0gaGFzaDI7XG4gICAgICB9XG4gICAgICBpZiAoYS5yZWRlZW0uaW5wdXQgJiYgIWJzY3JpcHQuaXNQdXNoT25seShfcmNodW5rcygpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uIHB1c2gtb25seSBzY3JpcHRTaWcnKTtcbiAgICAgIGlmIChcbiAgICAgICAgYS53aXRuZXNzICYmXG4gICAgICAgIGEucmVkZWVtLndpdG5lc3MgJiZcbiAgICAgICAgIXN0YWNrc0VxdWFsKGEud2l0bmVzcywgYS5yZWRlZW0ud2l0bmVzcylcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhbmQgcmVkZWVtLndpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChcbiAgICAgICAgKGEucmVkZWVtLmlucHV0ICYmIF9yY2h1bmtzKCkuc29tZShjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleSkpIHx8XG4gICAgICAgIChhLnJlZGVlbS5vdXRwdXQgJiZcbiAgICAgICAgICAoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0ub3V0cHV0KSB8fCBbXSkuc29tZShcbiAgICAgICAgICAgIGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5LFxuICAgICAgICAgICkpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAncmVkZWVtLmlucHV0IG9yIHJlZGVlbS5vdXRwdXQgY29udGFpbnMgdW5jb21wcmVzc2VkIHB1YmtleScsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhLndpdG5lc3MgJiYgYS53aXRuZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHdTY3JpcHQgPSBhLndpdG5lc3NbYS53aXRuZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGEucmVkZWVtICYmIGEucmVkZWVtLm91dHB1dCAmJiAhYS5yZWRlZW0ub3V0cHV0LmVxdWFscyh3U2NyaXB0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhbmQgcmVkZWVtLm91dHB1dCBtaXNtYXRjaCcpO1xuICAgICAgaWYgKFxuICAgICAgICBhLndpdG5lc3Muc29tZShjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleSkgfHxcbiAgICAgICAgKGJzY3JpcHQuZGVjb21waWxlKHdTY3JpcHQpIHx8IFtdKS5zb21lKGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGNvbnRhaW5zIHVuY29tcHJlc3NlZCBwdWJrZXknKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyd3NoID0gcDJ3c2g7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qc2J0ID0gdm9pZCAwO1xuY29uc3QgYmlwMTc0XzEgPSByZXF1aXJlKCdiaXAxNzQnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCdiaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdmFyaW50Jyk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZSgnYmlwMTc0L3NyYy9saWIvdXRpbHMnKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcbmNvbnN0IGJpcDM0MV8xID0gcmVxdWlyZSgnLi9wYXltZW50cy9iaXAzNDEnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IGJpcDM3MV8xID0gcmVxdWlyZSgnLi9wc2J0L2JpcDM3MScpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKCcuL3BzYnQvcHNidHV0aWxzJyk7XG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgZGVmYXVsdCBhcmd1bWVudHMgZm9yIGEgUHNidCBpbnN0YW5jZS5cbiAqL1xuY29uc3QgREVGQVVMVF9PUFRTID0ge1xuICAvKipcbiAgICogQSBiaXRjb2luanMgTmV0d29yayBvYmplY3QuIFRoaXMgaXMgb25seSB1c2VkIGlmIHlvdSBwYXNzIGFuIGBhZGRyZXNzYFxuICAgKiBwYXJhbWV0ZXIgdG8gYWRkT3V0cHV0LiBPdGhlcndpc2UgaXQgaXMgbm90IG5lZWRlZCBhbmQgY2FuIGJlIGxlZnQgZGVmYXVsdC5cbiAgICovXG4gIG5ldHdvcms6IG5ldHdvcmtzXzEuYml0Y29pbixcbiAgLyoqXG4gICAqIFdoZW4gZXh0cmFjdFRyYW5zYWN0aW9uIGlzIGNhbGxlZCwgdGhlIGZlZSByYXRlIGlzIGNoZWNrZWQuXG4gICAqIFRISVMgSVMgTk9UIFRPIEJFIFJFTElFRCBPTi5cbiAgICogSXQgaXMgb25seSBoZXJlIGFzIGEgbGFzdCBkaXRjaCBlZmZvcnQgdG8gcHJldmVudCBzZW5kaW5nIGEgNTAwIEJUQyBmZWUgZXRjLlxuICAgKi9cbiAgbWF4aW11bUZlZVJhdGU6IDUwMDAsIC8vIHNhdG9zaGkgcGVyIGJ5dGVcbn07XG4vKipcbiAqIFBzYnQgY2xhc3MgY2FuIHBhcnNlIGFuZCBnZW5lcmF0ZSBhIFBTQlQgYmluYXJ5IGJhc2VkIG9mZiBvZiB0aGUgQklQMTc0LlxuICogVGhlcmUgYXJlIDYgcm9sZXMgdGhhdCB0aGlzIGNsYXNzIGZ1bGZpbGxzLiAoRXhwbGFpbmVkIGluIEJJUDE3NClcbiAqXG4gKiBDcmVhdG9yOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYG5ldyBQc2J0KClgXG4gKiBVcGRhdGVyOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYHBzYnQuYWRkSW5wdXQoaW5wdXQpYCwgYHBzYnQuYWRkSW5wdXRzKGlucHV0cylgLFxuICogICBgcHNidC5hZGRPdXRwdXQob3V0cHV0KWAsIGBwc2J0LmFkZE91dHB1dHMob3V0cHV0cylgIHdoZW4geW91IGFyZSBsb29raW5nIHRvXG4gKiAgIGFkZCBuZXcgaW5wdXRzIGFuZCBvdXRwdXRzIHRvIHRoZSBQU0JULCBhbmQgYHBzYnQudXBkYXRlR2xvYmFsKGl0ZW1PYmplY3QpYCxcbiAqICAgYHBzYnQudXBkYXRlSW5wdXQoaXRlbU9iamVjdClgLCBgcHNidC51cGRhdGVPdXRwdXQoaXRlbU9iamVjdClgXG4gKiAgIGFkZElucHV0IHJlcXVpcmVzIGhhc2g6IEJ1ZmZlciB8IHN0cmluZzsgYW5kIGluZGV4OiBudW1iZXI7IGFzIGF0dHJpYnV0ZXNcbiAqICAgYW5kIGNhbiBhbHNvIGluY2x1ZGUgYW55IGF0dHJpYnV0ZXMgdGhhdCBhcmUgdXNlZCBpbiB1cGRhdGVJbnB1dCBtZXRob2QuXG4gKiAgIGFkZE91dHB1dCByZXF1aXJlcyBzY3JpcHQ6IEJ1ZmZlcjsgYW5kIHZhbHVlOiBudW1iZXI7IGFuZCBsaWtld2lzZSBjYW4gaW5jbHVkZVxuICogICBkYXRhIGZvciB1cGRhdGVPdXRwdXQuXG4gKiAgIEZvciBhIGxpc3Qgb2Ygd2hhdCBhdHRyaWJ1dGVzIHNob3VsZCBiZSB3aGF0IHR5cGVzLiBDaGVjayB0aGUgYmlwMTc0IGxpYnJhcnkuXG4gKiAgIEFsc28sIGNoZWNrIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0cyBmb3Igc29tZSBleGFtcGxlcyBvZiB1c2FnZS5cbiAqIFNpZ25lcjogVGhlcmUgYXJlIGEgZmV3IG1ldGhvZHMuIHNpZ25BbGxJbnB1dHMgYW5kIHNpZ25BbGxJbnB1dHNBc3luYywgd2hpY2ggd2lsbCBzZWFyY2ggYWxsIGlucHV0XG4gKiAgIGluZm9ybWF0aW9uIGZvciB5b3VyIHB1YmtleSBvciBwdWJrZXloYXNoLCBhbmQgb25seSBzaWduIGlucHV0cyB3aGVyZSBpdCBmaW5kc1xuICogICB5b3VyIGluZm8uIE9yIHlvdSBjYW4gZXhwbGljaXRseSBzaWduIGEgc3BlY2lmaWMgaW5wdXQgd2l0aCBzaWduSW5wdXQgYW5kXG4gKiAgIHNpZ25JbnB1dEFzeW5jLiBGb3IgdGhlIGFzeW5jIG1ldGhvZHMgeW91IGNhbiBjcmVhdGUgYSBTaWduZXJBc3luYyBvYmplY3RcbiAqICAgYW5kIHVzZSBzb21ldGhpbmcgbGlrZSBhIGhhcmR3YXJlIHdhbGxldCB0byBzaWduIHdpdGguIChZb3UgbXVzdCBpbXBsZW1lbnQgdGhpcylcbiAqIENvbWJpbmVyOiBwc2J0cyBjYW4gYmUgY29tYmluZWQgZWFzaWx5IHdpdGggYHBzYnQuY29tYmluZShwc2J0MiwgcHNidDMsIHBzYnQ0IC4uLilgXG4gKiAgIHRoZSBwc2J0IGNhbGxpbmcgY29tYmluZSB3aWxsIGFsd2F5cyBoYXZlIHByZWNlZGVuY2Ugd2hlbiBhIGNvbmZsaWN0IG9jY3Vycy5cbiAqICAgQ29tYmluZSBjaGVja3MgaWYgdGhlIGludGVybmFsIGJpdGNvaW4gdHJhbnNhY3Rpb24gaXMgdGhlIHNhbWUsIHNvIGJlIHN1cmUgdGhhdFxuICogICBhbGwgc2VxdWVuY2VzLCB2ZXJzaW9uLCBsb2NrdGltZSwgZXRjLiBhcmUgdGhlIHNhbWUgYmVmb3JlIGNvbWJpbmluZy5cbiAqIElucHV0IEZpbmFsaXplcjogVGhpcyByb2xlIGlzIGZhaXJseSBpbXBvcnRhbnQuIE5vdCBvbmx5IGRvZXMgaXQgbmVlZCB0byBjb25zdHJ1Y3RcbiAqICAgdGhlIGlucHV0IHNjcmlwdFNpZ3MgYW5kIHdpdG5lc3NlcywgYnV0IGl0IFNIT1VMRCB2ZXJpZnkgdGhlIHNpZ25hdHVyZXMgZXRjLlxuICogICBCZWZvcmUgcnVubmluZyBgcHNidC5maW5hbGl6ZUFsbElucHV0cygpYCBwbGVhc2UgcnVuIGBwc2J0LnZhbGlkYXRlU2lnbmF0dXJlc09mQWxsSW5wdXRzKClgXG4gKiAgIFJ1bm5pbmcgYW55IGZpbmFsaXplIG1ldGhvZCB3aWxsIGRlbGV0ZSBhbnkgZGF0YSBpbiB0aGUgaW5wdXQocykgdGhhdCBhcmUgbm8gbG9uZ2VyXG4gKiAgIG5lZWRlZCBkdWUgdG8gdGhlIGZpbmFsaXplZCBzY3JpcHRzIGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uLlxuICogVHJhbnNhY3Rpb24gRXh0cmFjdG9yOiBUaGlzIHJvbGUgd2lsbCBwZXJmb3JtIHNvbWUgY2hlY2tzIGJlZm9yZSByZXR1cm5pbmcgYVxuICogICBUcmFuc2FjdGlvbiBvYmplY3QuIFN1Y2ggYXMgZmVlIHJhdGUgbm90IGJlaW5nIGxhcmdlciB0aGFuIG1heGltdW1GZWVSYXRlIGV0Yy5cbiAqL1xuY2xhc3MgUHNidCB7XG4gIHN0YXRpYyBmcm9tQmFzZTY0KGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgb3B0cyk7XG4gIH1cbiAgc3RhdGljIGZyb21IZXgoZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCBvcHRzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHBzYnRCYXNlID0gYmlwMTc0XzEuUHNidC5mcm9tQnVmZmVyKGJ1ZmZlciwgdHJhbnNhY3Rpb25Gcm9tQnVmZmVyKTtcbiAgICBjb25zdCBwc2J0ID0gbmV3IFBzYnQob3B0cywgcHNidEJhc2UpO1xuICAgIGNoZWNrVHhGb3JEdXBlSW5zKHBzYnQuX19DQUNIRS5fX1RYLCBwc2J0Ll9fQ0FDSEUpO1xuICAgIHJldHVybiBwc2J0O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSwgZGF0YSA9IG5ldyBiaXAxNzRfMS5Qc2J0KG5ldyBQc2J0VHJhbnNhY3Rpb24oKSkpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUUywgb3B0cyk7XG4gICAgdGhpcy5fX0NBQ0hFID0ge1xuICAgICAgX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFOiBbXSxcbiAgICAgIF9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEU6IFtdLFxuICAgICAgX19UWF9JTl9DQUNIRToge30sXG4gICAgICBfX1RYOiB0aGlzLmRhdGEuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudHgsXG4gICAgICAvLyBQc2J0J3MgcHJlZGVjZXNvciAoVHJhbnNhY3Rpb25CdWlsZGVyIC0gbm93IHJlbW92ZWQpIGJlaGF2aW9yXG4gICAgICAvLyB3YXMgdG8gbm90IGNvbmZpcm0gaW5wdXQgdmFsdWVzICBiZWZvcmUgc2lnbmluZy5cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGhpZ2hseSBlbmNvdXJhZ2UgcGVvcGxlIHRvIGdldFxuICAgICAgLy8gdGhlIGZ1bGwgcGFyZW50IHRyYW5zYWN0aW9uIHRvIHZlcmlmeSB2YWx1ZXMsIHRoZSBhYmlsaXR5IHRvXG4gICAgICAvLyBzaWduIG5vbi1zZWd3aXQgaW5wdXRzIHdpdGhvdXQgdGhlIGZ1bGwgdHJhbnNhY3Rpb24gd2FzIG9mdGVuXG4gICAgICAvLyByZXF1ZXN0ZWQuIFNvIHRoZSBvbmx5IHdheSB0byBhY3RpdmF0ZSBpcyB0byB1c2UgQHRzLWlnbm9yZS5cbiAgICAgIC8vIFdlIHdpbGwgZGlzYWJsZSBleHBvcnRpbmcgdGhlIFBzYnQgd2hlbiB1bnNhZmUgc2lnbiBpcyBhY3RpdmUuXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIG5vdCBCSVAxNzQgY29tcGxpYW50LlxuICAgICAgX19VTlNBRkVfU0lHTl9OT05TRUdXSVQ6IGZhbHNlLFxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoID09PSAwKSB0aGlzLnNldFZlcnNpb24oMik7XG4gICAgLy8gTWFrZSBkYXRhIGhpZGRlbiB3aGVuIGVudW1lcmF0aW5nXG4gICAgY29uc3QgZHBldyA9IChvYmosIGF0dHIsIGVudW1lcmFibGUsIHdyaXRhYmxlKSA9PlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgYXR0ciwge1xuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZSxcbiAgICAgIH0pO1xuICAgIGRwZXcodGhpcywgJ19fQ0FDSEUnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZHBldyh0aGlzLCAnb3B0cycsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICBnZXQgaW5wdXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLnZlcnNpb247XG4gIH1cbiAgc2V0IHZlcnNpb24odmVyc2lvbikge1xuICAgIHRoaXMuc2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgfVxuICBnZXQgbG9ja3RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLmxvY2t0aW1lO1xuICB9XG4gIHNldCBsb2NrdGltZShsb2NrdGltZSkge1xuICAgIHRoaXMuc2V0TG9ja3RpbWUobG9ja3RpbWUpO1xuICB9XG4gIGdldCB0eElucHV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFguaW5zLm1hcChpbnB1dCA9PiAoe1xuICAgICAgaGFzaDogKDAsIGJ1ZmZlcnV0aWxzXzEuY2xvbmVCdWZmZXIpKGlucHV0Lmhhc2gpLFxuICAgICAgaW5kZXg6IGlucHV0LmluZGV4LFxuICAgICAgc2VxdWVuY2U6IGlucHV0LnNlcXVlbmNlLFxuICAgIH0pKTtcbiAgfVxuICBnZXQgdHhPdXRwdXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9fQ0FDSEUuX19UWC5vdXRzLm1hcChvdXRwdXQgPT4ge1xuICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICB0cnkge1xuICAgICAgICBhZGRyZXNzID0gKDAsIGFkZHJlc3NfMS5mcm9tT3V0cHV0U2NyaXB0KShcbiAgICAgICAgICBvdXRwdXQuc2NyaXB0LFxuICAgICAgICAgIHRoaXMub3B0cy5uZXR3b3JrLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogKDAsIGJ1ZmZlcnV0aWxzXzEuY2xvbmVCdWZmZXIpKG91dHB1dC5zY3JpcHQpLFxuICAgICAgICB2YWx1ZTogb3V0cHV0LnZhbHVlLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb21iaW5lKC4uLnRob3NlKSB7XG4gICAgdGhpcy5kYXRhLmNvbWJpbmUoLi4udGhvc2UubWFwKG8gPT4gby5kYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgY2xvbmluZ1xuICAgIGNvbnN0IHJlcyA9IFBzYnQuZnJvbUJ1ZmZlcih0aGlzLmRhdGEudG9CdWZmZXIoKSk7XG4gICAgcmVzLm9wdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0cykpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgc2V0TWF4aW11bUZlZVJhdGUoc2F0b3NoaVBlckJ5dGUpIHtcbiAgICBjaGVjazMyQml0KHNhdG9zaGlQZXJCeXRlKTsgLy8gNDIuOSBCVEMgcGVyIGJ5dGUgSVMgZXhjZXNzaXZlLi4uIHNvIHRocm93XG4gICAgdGhpcy5vcHRzLm1heGltdW1GZWVSYXRlID0gc2F0b3NoaVBlckJ5dGU7XG4gIH1cbiAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgY2hlY2szMkJpdCh2ZXJzaW9uKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ3NldFZlcnNpb24nKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIGMuX19UWC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldExvY2t0aW1lKGxvY2t0aW1lKSB7XG4gICAgY2hlY2szMkJpdChsb2NrdGltZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRMb2NrdGltZScpO1xuICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgYy5fX1RYLmxvY2t0aW1lID0gbG9ja3RpbWU7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRJbnB1dFNlcXVlbmNlKGlucHV0SW5kZXgsIHNlcXVlbmNlKSB7XG4gICAgY2hlY2szMkJpdChzZXF1ZW5jZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRJbnB1dFNlcXVlbmNlJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoYy5fX1RYLmlucy5sZW5ndGggPD0gaW5wdXRJbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpbmRleCB0b28gaGlnaCcpO1xuICAgIH1cbiAgICBjLl9fVFguaW5zW2lucHV0SW5kZXhdLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dHMoaW5wdXREYXRhcykge1xuICAgIGlucHV0RGF0YXMuZm9yRWFjaChpbnB1dERhdGEgPT4gdGhpcy5hZGRJbnB1dChpbnB1dERhdGEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dChpbnB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIWlucHV0RGF0YSB8fFxuICAgICAgaW5wdXREYXRhLmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXREYXRhLmluZGV4ID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LmFkZElucHV0LiBgICtcbiAgICAgICAgICBgUmVxdWlyZXMgc2luZ2xlIG9iamVjdCB3aXRoIGF0IGxlYXN0IFtoYXNoXSBhbmQgW2luZGV4XWAsXG4gICAgICApO1xuICAgIH1cbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290SW5wdXRGaWVsZHMpKGlucHV0RGF0YSwgaW5wdXREYXRhLCAnYWRkSW5wdXQnKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZElucHV0Jyk7XG4gICAgaWYgKGlucHV0RGF0YS53aXRuZXNzU2NyaXB0KSBjaGVja0ludmFsaWRQMldTSChpbnB1dERhdGEud2l0bmVzc1NjcmlwdCk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICB0aGlzLmRhdGEuYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICBjb25zdCB0eEluID0gYy5fX1RYLmluc1tjLl9fVFguaW5zLmxlbmd0aCAtIDFdO1xuICAgIGNoZWNrVHhJbnB1dENhY2hlKGMsIHR4SW4pO1xuICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUodGhpcy5fX0NBQ0hFLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgfVxuICAgIGMuX19GRUUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0cyhvdXRwdXREYXRhcykge1xuICAgIG91dHB1dERhdGFzLmZvckVhY2gob3V0cHV0RGF0YSA9PiB0aGlzLmFkZE91dHB1dChvdXRwdXREYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIW91dHB1dERhdGEgfHxcbiAgICAgIG91dHB1dERhdGEudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKG91dHB1dERhdGEuYWRkcmVzcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dERhdGEuc2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC5hZGRPdXRwdXQuIGAgK1xuICAgICAgICAgIGBSZXF1aXJlcyBzaW5nbGUgb2JqZWN0IHdpdGggYXQgbGVhc3QgW3NjcmlwdCBvciBhZGRyZXNzXSBhbmQgW3ZhbHVlXWAsXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZE91dHB1dCcpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gb3V0cHV0RGF0YTtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7IG5ldHdvcmsgfSA9IHRoaXMub3B0cztcbiAgICAgIGNvbnN0IHNjcmlwdCA9ICgwLCBhZGRyZXNzXzEudG9PdXRwdXRTY3JpcHQpKGFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgb3V0cHV0RGF0YSA9IE9iamVjdC5hc3NpZ24ob3V0cHV0RGF0YSwgeyBzY3JpcHQgfSk7XG4gICAgfVxuICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMpKG91dHB1dERhdGEsIG91dHB1dERhdGEsICdhZGRPdXRwdXQnKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIHRoaXMuZGF0YS5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICBjLl9fRkVFX1JBVEUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBleHRyYWN0VHJhbnNhY3Rpb24oZGlzYWJsZUZlZUNoZWNrKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSkgdGhyb3cgbmV3IEVycm9yKCdOb3QgZmluYWxpemVkJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoIWRpc2FibGVGZWVDaGVjaykge1xuICAgICAgY2hlY2tGZWVzKHRoaXMsIGMsIHRoaXMub3B0cyk7XG4gICAgfVxuICAgIGlmIChjLl9fRVhUUkFDVEVEX1RYKSByZXR1cm4gYy5fX0VYVFJBQ1RFRF9UWDtcbiAgICBjb25zdCB0eCA9IGMuX19UWC5jbG9uZSgpO1xuICAgIGlucHV0RmluYWxpemVHZXRBbXRzKHRoaXMuZGF0YS5pbnB1dHMsIHR4LCBjLCB0cnVlKTtcbiAgICByZXR1cm4gdHg7XG4gIH1cbiAgZ2V0RmVlUmF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0VHhDYWNoZVZhbHVlKFxuICAgICAgJ19fRkVFX1JBVEUnLFxuICAgICAgJ2ZlZSByYXRlJyxcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgKTtcbiAgfVxuICBnZXRGZWUoKSB7XG4gICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZSgnX19GRUUnLCAnZmVlJywgdGhpcy5kYXRhLmlucHV0cywgdGhpcy5fX0NBQ0hFKTtcbiAgfVxuICBmaW5hbGl6ZUFsbElucHV0cygpIHtcbiAgICAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCAwKTsgLy8gbWFraW5nIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmVcbiAgICByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkuZm9yRWFjaChpZHggPT4gdGhpcy5maW5hbGl6ZUlucHV0KGlkeCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbmFsaXplSW5wdXQoaW5wdXRJbmRleCwgZmluYWxTY3JpcHRzRnVuYykge1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBmaW5hbFNjcmlwdHNGdW5jLFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5fZmluYWxpemVJbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgZmluYWxTY3JpcHRzRnVuYyk7XG4gIH1cbiAgZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgZmluYWxTY3JpcHRzRnVuYyA9IGJpcDM3MV8xLnRhcFNjcmlwdEZpbmFsaXplcixcbiAgKSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LFxuICAgICAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgICAgIGZpbmFsU2NyaXB0c0Z1bmMsXG4gICAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmFsaXplIGlucHV0ICMke2lucHV0SW5kZXh9LiBOb3QgVGFwcm9vdC5gKTtcbiAgfVxuICBfZmluYWxpemVJbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgZmluYWxTY3JpcHRzRnVuYyA9IGdldEZpbmFsU2NyaXB0cykge1xuICAgIGNvbnN0IHsgc2NyaXB0LCBpc1AyU0gsIGlzUDJXU0gsIGlzU2Vnd2l0IH0gPSBnZXRTY3JpcHRGcm9tSW5wdXQoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgKTtcbiAgICBpZiAoIXNjcmlwdCkgdGhyb3cgbmV3IEVycm9yKGBObyBzY3JpcHQgZm91bmQgZm9yIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgY2hlY2tQYXJ0aWFsU2lnU2lnaGFzaGVzKGlucHV0KTtcbiAgICBjb25zdCB7IGZpbmFsU2NyaXB0U2lnLCBmaW5hbFNjcmlwdFdpdG5lc3MgfSA9IGZpbmFsU2NyaXB0c0Z1bmMoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICBzY3JpcHQsXG4gICAgICBpc1NlZ3dpdCxcbiAgICAgIGlzUDJTSCxcbiAgICAgIGlzUDJXU0gsXG4gICAgKTtcbiAgICBpZiAoZmluYWxTY3JpcHRTaWcpIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0U2lnIH0pO1xuICAgIGlmIChmaW5hbFNjcmlwdFdpdG5lc3MpXG4gICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgaWYgKCFmaW5hbFNjcmlwdFNpZyAmJiAhZmluYWxTY3JpcHRXaXRuZXNzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGVycm9yIGZpbmFsaXppbmcgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgZmluYWxTY3JpcHRzRnVuYyA9IGJpcDM3MV8xLnRhcFNjcmlwdEZpbmFsaXplcixcbiAgKSB7XG4gICAgaWYgKCFpbnB1dC53aXRuZXNzVXR4bylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBmaW5hbGl6ZSBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTWlzc2luZyB3aXRobmVzcyB1dHhvLmAsXG4gICAgICApO1xuICAgIC8vIENoZWNrIGtleSBzcGVuZCBmaXJzdC4gSW5jcmVhc2VkIHByaXZhY3kgYW5kIHJlZHVjZWQgYmxvY2sgc3BhY2UuXG4gICAgaWYgKGlucHV0LnRhcEtleVNpZykge1xuICAgICAgY29uc3QgcGF5bWVudCA9IHBheW1lbnRzLnAydHIoe1xuICAgICAgICBvdXRwdXQ6IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgICAgc2lnbmF0dXJlOiBpbnB1dC50YXBLZXlTaWcsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZpbmFsU2NyaXB0V2l0bmVzcyA9ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKFxuICAgICAgICBwYXltZW50LndpdG5lc3MsXG4gICAgICApO1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9ID0gZmluYWxTY3JpcHRzRnVuYyhcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSxcbiAgICAgICk7XG4gICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldElucHV0VHlwZShpbnB1dEluZGV4KSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBzY3JpcHQgPSBnZXRTY3JpcHRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgdGhpcy5fX0NBQ0hFKTtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICAgICAgc2NyaXB0LFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgICdpbnB1dCcsXG4gICAgICBpbnB1dC5yZWRlZW1TY3JpcHQgfHwgcmVkZWVtRnJvbUZpbmFsU2NyaXB0U2lnKGlucHV0LmZpbmFsU2NyaXB0U2lnKSxcbiAgICAgIGlucHV0LndpdG5lc3NTY3JpcHQgfHxcbiAgICAgICAgcmVkZWVtRnJvbUZpbmFsV2l0bmVzc1NjcmlwdChpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpLFxuICAgICk7XG4gICAgY29uc3QgdHlwZSA9IHJlc3VsdC50eXBlID09PSAncmF3JyA/ICcnIDogcmVzdWx0LnR5cGUgKyAnLSc7XG4gICAgY29uc3QgbWFpblR5cGUgPSBjbGFzc2lmeVNjcmlwdChyZXN1bHQubWVhbmluZ2Z1bFNjcmlwdCk7XG4gICAgcmV0dXJuIHR5cGUgKyBtYWluVHlwZTtcbiAgfVxuICBpbnB1dEhhc1B1YmtleShpbnB1dEluZGV4LCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIHJldHVybiBwdWJrZXlJbklucHV0KHB1YmtleSwgaW5wdXQsIGlucHV0SW5kZXgsIHRoaXMuX19DQUNIRSk7XG4gIH1cbiAgaW5wdXRIYXNIREtleShpbnB1dEluZGV4LCByb290KSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBkZXJpdmF0aW9uSXNNaW5lID0gYmlwMzJEZXJpdmF0aW9uSXNNaW5lKHJvb3QpO1xuICAgIHJldHVybiAoXG4gICAgICAhIWlucHV0LmJpcDMyRGVyaXZhdGlvbiAmJiBpbnB1dC5iaXAzMkRlcml2YXRpb24uc29tZShkZXJpdmF0aW9uSXNNaW5lKVxuICAgICk7XG4gIH1cbiAgb3V0cHV0SGFzUHVia2V5KG91dHB1dEluZGV4LCBwdWJrZXkpIHtcbiAgICBjb25zdCBvdXRwdXQgPSAoMCwgdXRpbHNfMS5jaGVja0Zvck91dHB1dCkodGhpcy5kYXRhLm91dHB1dHMsIG91dHB1dEluZGV4KTtcbiAgICByZXR1cm4gcHVia2V5SW5PdXRwdXQocHVia2V5LCBvdXRwdXQsIG91dHB1dEluZGV4LCB0aGlzLl9fQ0FDSEUpO1xuICB9XG4gIG91dHB1dEhhc0hES2V5KG91dHB1dEluZGV4LCByb290KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JPdXRwdXQpKHRoaXMuZGF0YS5vdXRwdXRzLCBvdXRwdXRJbmRleCk7XG4gICAgY29uc3QgZGVyaXZhdGlvbklzTWluZSA9IGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KTtcbiAgICByZXR1cm4gKFxuICAgICAgISFvdXRwdXQuYmlwMzJEZXJpdmF0aW9uICYmIG91dHB1dC5iaXAzMkRlcml2YXRpb24uc29tZShkZXJpdmF0aW9uSXNNaW5lKVxuICAgICk7XG4gIH1cbiAgdmFsaWRhdGVTaWduYXR1cmVzT2ZBbGxJbnB1dHModmFsaWRhdG9yKSB7XG4gICAgKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgY29uc3QgcmVzdWx0cyA9IHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKS5tYXAoaWR4ID0+XG4gICAgICB0aGlzLnZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaWR4LCB2YWxpZGF0b3IpLFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChmaW5hbCwgcmVzKSA9PiByZXMgPT09IHRydWUgJiYgZmluYWwsIHRydWUpO1xuICB9XG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTaWduYXR1cmVzT2ZUYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHZhbGlkYXRvcixcbiAgICAgICAgcHVia2V5LFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSk7XG4gIH1cbiAgX3ZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgY29uc3QgcGFydGlhbFNpZyA9IChpbnB1dCB8fCB7fSkucGFydGlhbFNpZztcbiAgICBpZiAoIWlucHV0IHx8ICFwYXJ0aWFsU2lnIHx8IHBhcnRpYWxTaWcubGVuZ3RoIDwgMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZScpO1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHZhbGlkYXRvciBmdW5jdGlvbiB0byB2YWxpZGF0ZSBzaWduYXR1cmVzJyk7XG4gICAgY29uc3QgbXlTaWdzID0gcHVia2V5XG4gICAgICA/IHBhcnRpYWxTaWcuZmlsdGVyKHNpZyA9PiBzaWcucHVia2V5LmVxdWFscyhwdWJrZXkpKVxuICAgICAgOiBwYXJ0aWFsU2lnO1xuICAgIGlmIChteVNpZ3MubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIGZvciB0aGlzIHB1YmtleScpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgaGFzaENhY2hlO1xuICAgIGxldCBzY3JpcHRDYWNoZTtcbiAgICBsZXQgc2lnaGFzaENhY2hlO1xuICAgIGZvciAoY29uc3QgcFNpZyBvZiBteVNpZ3MpIHtcbiAgICAgIGNvbnN0IHNpZyA9IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwU2lnLnNpZ25hdHVyZSk7XG4gICAgICBjb25zdCB7IGhhc2gsIHNjcmlwdCB9ID1cbiAgICAgICAgc2lnaGFzaENhY2hlICE9PSBzaWcuaGFzaFR5cGVcbiAgICAgICAgICA/IGdldEhhc2hGb3JTaWcoXG4gICAgICAgICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGlucHV0LCB7IHNpZ2hhc2hUeXBlOiBzaWcuaGFzaFR5cGUgfSksXG4gICAgICAgICAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHsgaGFzaDogaGFzaENhY2hlLCBzY3JpcHQ6IHNjcmlwdENhY2hlIH07XG4gICAgICBzaWdoYXNoQ2FjaGUgPSBzaWcuaGFzaFR5cGU7XG4gICAgICBoYXNoQ2FjaGUgPSBoYXNoO1xuICAgICAgc2NyaXB0Q2FjaGUgPSBzY3JpcHQ7XG4gICAgICBjaGVja1NjcmlwdEZvclB1YmtleShwU2lnLnB1YmtleSwgc2NyaXB0LCAndmVyaWZ5Jyk7XG4gICAgICByZXN1bHRzLnB1c2godmFsaWRhdG9yKHBTaWcucHVia2V5LCBoYXNoLCBzaWcuc2lnbmF0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlcyA9PiByZXMgPT09IHRydWUpO1xuICB9XG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIHZhbGlkYXRvciwgcHVia2V5KSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHRhcEtleVNpZyA9IChpbnB1dCB8fCB7fSkudGFwS2V5U2lnO1xuICAgIGNvbnN0IHRhcFNjcmlwdFNpZyA9IChpbnB1dCB8fCB7fSkudGFwU2NyaXB0U2lnO1xuICAgIGlmICghaW5wdXQgJiYgIXRhcEtleVNpZyAmJiAhKHRhcFNjcmlwdFNpZyAmJiAhdGFwU2NyaXB0U2lnLmxlbmd0aCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgdG8gdmFsaWRhdGUnKTtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCB2YWxpZGF0b3IgZnVuY3Rpb24gdG8gdmFsaWRhdGUgc2lnbmF0dXJlcycpO1xuICAgIHB1YmtleSA9IHB1YmtleSAmJiAoMCwgYmlwMzcxXzEudG9YT25seSkocHVia2V5KTtcbiAgICBjb25zdCBhbGxIYXNoc2VzID0gcHVia2V5XG4gICAgICA/IGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICAgIClcbiAgICAgIDogZ2V0QWxsVGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgICApO1xuICAgIGlmICghYWxsSGFzaHNlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICBjb25zdCB0YXBLZXlIYXNoID0gYWxsSGFzaHNlcy5maW5kKGggPT4gIWgubGVhZkhhc2gpO1xuICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0Q291bnQgPSAwO1xuICAgIGlmICh0YXBLZXlTaWcgJiYgdGFwS2V5SGFzaCkge1xuICAgICAgY29uc3QgaXNWYWxpZFRhcGtleVNpZyA9IHZhbGlkYXRvcihcbiAgICAgICAgdGFwS2V5SGFzaC5wdWJrZXksXG4gICAgICAgIHRhcEtleUhhc2guaGFzaCxcbiAgICAgICAgdHJpbVRhcHJvb3RTaWcodGFwS2V5U2lnKSxcbiAgICAgICk7XG4gICAgICBpZiAoIWlzVmFsaWRUYXBrZXlTaWcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhbGlkYXRpb25SZXN1bHRDb3VudCsrO1xuICAgIH1cbiAgICBpZiAodGFwU2NyaXB0U2lnKSB7XG4gICAgICBmb3IgKGNvbnN0IHRhcFNpZyBvZiB0YXBTY3JpcHRTaWcpIHtcbiAgICAgICAgY29uc3QgdGFwU2lnSGFzaCA9IGFsbEhhc2hzZXMuZmluZChoID0+IHRhcFNpZy5wdWJrZXkuZXF1YWxzKGgucHVia2V5KSk7XG4gICAgICAgIGlmICh0YXBTaWdIYXNoKSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZFRhcFNjcmlwdFNpZyA9IHZhbGlkYXRvcihcbiAgICAgICAgICAgIHRhcFNpZy5wdWJrZXksXG4gICAgICAgICAgICB0YXBTaWdIYXNoLmhhc2gsXG4gICAgICAgICAgICB0cmltVGFwcm9vdFNpZyh0YXBTaWcuc2lnbmF0dXJlKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNWYWxpZFRhcFNjcmlwdFNpZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0Q291bnQgPiAwO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNIRChcbiAgICBoZEtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zaWduSW5wdXRIRChpLCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0cy5ldmVyeSh2ID0+IHYgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dHMgd2VyZSBzaWduZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2lnbkFsbElucHV0c0hEQXN5bmMoXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5zaWduSW5wdXRIREFzeW5jKGksIGhkS2V5UGFpciwgc2lnaGFzaFR5cGVzKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHNpZ25JbnB1dEhEKFxuICAgIGlucHV0SW5kZXgsXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgdGhpcy5kYXRhLmlucHV0cywgaGRLZXlQYWlyKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHRoaXMuc2lnbklucHV0KGlucHV0SW5kZXgsIHNpZ25lciwgc2lnaGFzaFR5cGVzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2lnbklucHV0SERBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGhkS2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduZXJzID0gZ2V0U2lnbmVyc0Zyb21IRChpbnB1dEluZGV4LCB0aGlzLmRhdGEuaW5wdXRzLCBoZEtleVBhaXIpO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBzaWduZXJzLm1hcChzaWduZXIgPT5cbiAgICAgICAgdGhpcy5zaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBzaWduZXIsIHNpZ2hhc2hUeXBlcyksXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBzaWduQWxsSW5wdXRzKGtleVBhaXIsIHNpZ2hhc2hUeXBlcykge1xuICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAvLyBUT0RPOiBBZGQgYSBwdWJrZXkvcHVia2V5aGFzaCBjYWNoZSB0byBlYWNoIGlucHV0XG4gICAgLy8gYXMgaW5wdXQgaW5mb3JtYXRpb24gaXMgYWRkZWQsIHRoZW4gZXZlbnR1YWxseVxuICAgIC8vIG9wdGltaXplIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNpZ25JbnB1dChpLCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNBc3luYyhrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICAvLyBUT0RPOiBBZGQgYSBwdWJrZXkvcHVia2V5aGFzaCBjYWNoZSB0byBlYWNoIGlucHV0XG4gICAgICAvLyBhcyBpbnB1dCBpbmZvcm1hdGlvbiBpcyBhZGRlZCwgdGhlbiBldmVudHVhbGx5XG4gICAgICAvLyBvcHRpbWl6ZSB0aGlzIG1ldGhvZC5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtpXSBvZiB0aGlzLmRhdGEuaW5wdXRzLmVudHJpZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIHRoaXMuc2lnbklucHV0QXN5bmMoaSwga2V5UGFpciwgc2lnaGFzaFR5cGVzKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHNpZ25JbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAga2V5UGFpcixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzaWdoYXNoVHlwZXMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2lnbklucHV0KGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gIH1cbiAgc2lnblRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCB0YXBMZWFmSGFzaFRvU2lnbiwgc2lnaGFzaFR5cGVzKSB7XG4gICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBrZXlQYWlyLFxuICAgICAgICB0YXBMZWFmSGFzaFRvU2lnbixcbiAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICMke2lucHV0SW5kZXh9IGlzIG5vdCBvZiB0eXBlIFRhcHJvb3QuYCk7XG4gIH1cbiAgX3NpZ25JbnB1dChcbiAgICBpbnB1dEluZGV4LFxuICAgIGtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGtleVBhaXIucHVibGljS2V5LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICk7XG4gICAgY29uc3QgcGFydGlhbFNpZyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlOiBic2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoa2V5UGFpci5zaWduKGhhc2gpLCBzaWdoYXNoVHlwZSksXG4gICAgICB9LFxuICAgIF07XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgcGFydGlhbFNpZyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfc2lnblRhcHJvb3RJbnB1dChcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVF0sXG4gICkge1xuICAgIGNvbnN0IGhhc2hlc0ZvclNpZyA9IHRoaXMuY2hlY2tUYXByb290SGFzaGVzRm9yU2lnKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAga2V5UGFpcixcbiAgICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIGNvbnN0IHRhcEtleVNpZyA9IGhhc2hlc0ZvclNpZ1xuICAgICAgLmZpbHRlcihoID0+ICFoLmxlYWZIYXNoKVxuICAgICAgLm1hcChoID0+XG4gICAgICAgICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICBrZXlQYWlyLnNpZ25TY2hub3JyKGguaGFzaCksXG4gICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUsXG4gICAgICAgICksXG4gICAgICApWzBdO1xuICAgIGNvbnN0IHRhcFNjcmlwdFNpZyA9IGhhc2hlc0ZvclNpZ1xuICAgICAgLmZpbHRlcihoID0+ICEhaC5sZWFmSGFzaClcbiAgICAgIC5tYXAoaCA9PiAoe1xuICAgICAgICBwdWJrZXk6ICgwLCBiaXAzNzFfMS50b1hPbmx5KShrZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgIHNpZ25hdHVyZTogKDAsIGJpcDM3MV8xLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUpKFxuICAgICAgICAgIGtleVBhaXIuc2lnblNjaG5vcnIoaC5oYXNoKSxcbiAgICAgICAgICBpbnB1dC5zaWdoYXNoVHlwZSxcbiAgICAgICAgKSxcbiAgICAgICAgbGVhZkhhc2g6IGgubGVhZkhhc2gsXG4gICAgICB9KSk7XG4gICAgaWYgKHRhcEtleVNpZykge1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgdGFwS2V5U2lnIH0pO1xuICAgIH1cbiAgICBpZiAodGFwU2NyaXB0U2lnLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgdGFwU2NyaXB0U2lnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0QXN5bmMoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBrZXlQYWlyLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzaWdoYXNoVHlwZXMsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5fc2lnbklucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgc2lnaGFzaFR5cGVzKTtcbiAgICB9KTtcbiAgfVxuICBzaWduVGFwcm9vdElucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgdGFwTGVhZkhhc2gsIHNpZ2hhc2hUeXBlcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXRBc3luYyhcbiAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGtleVBhaXIsXG4gICAgICAgICAgdGFwTGVhZkhhc2gsXG4gICAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBpcyBub3Qgb2YgdHlwZSBUYXByb290LmApO1xuICAgIH0pO1xuICB9XG4gIF9zaWduSW5wdXRBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGtleVBhaXIucHVibGljS2V5LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlQYWlyLnNpZ24oaGFzaCkpLnRoZW4oc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpYWxTaWcgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5LFxuICAgICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKHNpZ25hdHVyZSwgc2lnaGFzaFR5cGUpLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHBhcnRpYWxTaWcgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX3NpZ25UYXByb290SW5wdXRBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2gsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXSxcbiAgKSB7XG4gICAgY29uc3QgaGFzaGVzRm9yU2lnID0gdGhpcy5jaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICBrZXlQYWlyLFxuICAgICAgdGFwTGVhZkhhc2gsXG4gICAgICBzaWdoYXNoVHlwZXMsXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmVQcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHRhcEtleUhhc2ggPSBoYXNoZXNGb3JTaWcuZmlsdGVyKGggPT4gIWgubGVhZkhhc2gpWzBdO1xuICAgIGlmICh0YXBLZXlIYXNoKSB7XG4gICAgICBjb25zdCB0YXBLZXlTaWdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBrZXlQYWlyLnNpZ25TY2hub3JyKHRhcEtleUhhc2guaGFzaCksXG4gICAgICApLnRoZW4oc2lnID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXBLZXlTaWc6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgIGlucHV0LnNpZ2hhc2hUeXBlLFxuICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHNpZ25hdHVyZVByb21pc2VzLnB1c2godGFwS2V5U2lnUHJvbWlzZSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcFNjcmlwdEhhc2hlcyA9IGhhc2hlc0ZvclNpZy5maWx0ZXIoaCA9PiAhIWgubGVhZkhhc2gpO1xuICAgIGlmICh0YXBTY3JpcHRIYXNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0YXBTY3JpcHRTaWdQcm9taXNlcyA9IHRhcFNjcmlwdEhhc2hlcy5tYXAodHNoID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlQYWlyLnNpZ25TY2hub3JyKHRzaC5oYXNoKSkudGhlbihcbiAgICAgICAgICBzaWduYXR1cmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFwU2NyaXB0U2lnID0gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHVia2V5OiAoMCwgYmlwMzcxXzEudG9YT25seSkoa2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogKDAsIGJpcDM3MV8xLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUpKFxuICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsZWFmSGFzaDogdHNoLmxlYWZIYXNoLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhcFNjcmlwdFNpZyB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHNpZ25hdHVyZVByb21pc2VzLnB1c2goLi4udGFwU2NyaXB0U2lnUHJvbWlzZXMpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2lnbmF0dXJlUHJvbWlzZXMpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXN1bHRzLmZvckVhY2godiA9PiB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdikpO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrVGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYWlyLnNpZ25TY2hub3JyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTmVlZCBTY2hub3JyIFNpZ25lciB0byBzaWduIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uYCxcbiAgICAgICk7XG4gICAgY29uc3QgaGFzaGVzRm9yU2lnID0gZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBpbnB1dCxcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIGlmICghaGFzaGVzRm9yU2lnIHx8ICFoYXNoZXNGb3JTaWcubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2FuIG5vdCBzaWduIGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fSB3aXRoIHRoZSBrZXkgJHtrZXlQYWlyLnB1YmxpY0tleS50b1N0cmluZyhcbiAgICAgICAgICAnaGV4JyxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICByZXR1cm4gaGFzaGVzRm9yU2lnO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIGNoZWNrQ2FjaGUodGhpcy5fX0NBQ0hFKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRvQnVmZmVyKCk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgY2hlY2tDYWNoZSh0aGlzLl9fQ0FDSEUpO1xuICAgIHJldHVybiB0aGlzLmRhdGEudG9IZXgoKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICBjaGVja0NhY2hlKHRoaXMuX19DQUNIRSk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50b0Jhc2U2NCgpO1xuICB9XG4gIHVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKSB7XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGRhdGVJbnB1dChpbnB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgaWYgKHVwZGF0ZURhdGEud2l0bmVzc1NjcmlwdCkgY2hlY2tJbnZhbGlkUDJXU0godXBkYXRlRGF0YS53aXRuZXNzU2NyaXB0KTtcbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290SW5wdXRGaWVsZHMpKFxuICAgICAgdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XSxcbiAgICAgIHVwZGF0ZURhdGEsXG4gICAgICAndXBkYXRlSW5wdXQnLFxuICAgICk7XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpO1xuICAgIGlmICh1cGRhdGVEYXRhLm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBhZGROb25XaXRuZXNzVHhDYWNoZShcbiAgICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgICB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdLFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0RGF0YSA9IHRoaXMuZGF0YS5vdXRwdXRzW291dHB1dEluZGV4XTtcbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290T3V0cHV0RmllbGRzKShcbiAgICAgIG91dHB1dERhdGEsXG4gICAgICB1cGRhdGVEYXRhLFxuICAgICAgJ3VwZGF0ZU91dHB1dCcsXG4gICAgKTtcbiAgICB0aGlzLmRhdGEudXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb0dsb2JhbChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpIHtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZXhwb3J0cy5Qc2J0ID0gUHNidDtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgdG8gcGFzcyB0byB0aGUgYmlwMTc0IGJhc2UgY2xhc3MncyBmcm9tQnVmZmVyLlxuICogSXQgdGFrZXMgdGhlIFwidHJhbnNhY3Rpb24gYnVmZmVyXCIgcG9ydGlvbiBvZiB0aGUgcHNidCBidWZmZXIgYW5kIHJldHVybnMgYVxuICogVHJhbnNhY3Rpb24gKEZyb20gdGhlIGJpcDE3NCBsaWJyYXJ5KSBpbnRlcmZhY2UuXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uRnJvbUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgUHNidFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgVHJhbnNhY3Rpb24gaW50ZXJmYWNlIGZyb20gYmlwMTc0IGxpYnJhcnkuXG4gKiBJdCBjb250YWlucyBhIGJpdGNvaW5qcy1saWIgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICovXG5jbGFzcyBQc2J0VHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihidWZmZXIgPSBCdWZmZXIuZnJvbShbMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pKSB7XG4gICAgdGhpcy50eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgIGNoZWNrVHhFbXB0eSh0aGlzLnR4KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICBnZXRJbnB1dE91dHB1dENvdW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRDb3VudDogdGhpcy50eC5pbnMubGVuZ3RoLFxuICAgICAgb3V0cHV0Q291bnQ6IHRoaXMudHgub3V0cy5sZW5ndGgsXG4gICAgfTtcbiAgfVxuICBhZGRJbnB1dChpbnB1dCkge1xuICAgIGlmIChcbiAgICAgIGlucHV0Lmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXQuaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQuaGFzaCkgJiYgdHlwZW9mIGlucHV0Lmhhc2ggIT09ICdzdHJpbmcnKSB8fFxuICAgICAgdHlwZW9mIGlucHV0LmluZGV4ICE9PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgaW5wdXQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPVxuICAgICAgdHlwZW9mIGlucHV0Lmhhc2ggPT09ICdzdHJpbmcnXG4gICAgICAgID8gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCwgJ2hleCcpKVxuICAgICAgICA6IGlucHV0Lmhhc2g7XG4gICAgdGhpcy50eC5hZGRJbnB1dChoYXNoLCBpbnB1dC5pbmRleCwgaW5wdXQuc2VxdWVuY2UpO1xuICB9XG4gIGFkZE91dHB1dChvdXRwdXQpIHtcbiAgICBpZiAoXG4gICAgICBvdXRwdXQuc2NyaXB0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG91dHB1dC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhQnVmZmVyLmlzQnVmZmVyKG91dHB1dC5zY3JpcHQpIHx8XG4gICAgICB0eXBlb2Ygb3V0cHV0LnZhbHVlICE9PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgb3V0cHV0LicpO1xuICAgIH1cbiAgICB0aGlzLnR4LmFkZE91dHB1dChvdXRwdXQuc2NyaXB0LCBvdXRwdXQudmFsdWUpO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnR4LnRvQnVmZmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbkZpbmFsaXplKGlucHV0LCBzY3JpcHQsIHNjcmlwdFR5cGUpIHtcbiAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgY2FzZSAncHVia2V5JzpcbiAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICBjYXNlICd3aXRuZXNzcHVia2V5aGFzaCc6XG4gICAgICByZXR1cm4gaGFzU2lncygxLCBpbnB1dC5wYXJ0aWFsU2lnKTtcbiAgICBjYXNlICdtdWx0aXNpZyc6XG4gICAgICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIGhhc1NpZ3MocDJtcy5tLCBpbnB1dC5wYXJ0aWFsU2lnLCBwMm1zLnB1YmtleXMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ2FjaGUoY2FjaGUpIHtcbiAgaWYgKGNhY2hlLl9fVU5TQUZFX1NJR05fTk9OU0VHV0lUICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEJJUDE3NCBjb21wbGlhbnQsIGNhbiBub3QgZXhwb3J0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1NpZ3MobmVlZGVkU2lncywgcGFydGlhbFNpZywgcHVia2V5cykge1xuICBpZiAoIXBhcnRpYWxTaWcpIHJldHVybiBmYWxzZTtcbiAgbGV0IHNpZ3M7XG4gIGlmIChwdWJrZXlzKSB7XG4gICAgc2lncyA9IHB1YmtleXNcbiAgICAgIC5tYXAocGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGNvbXByZXNzUHVia2V5KHBrZXkpO1xuICAgICAgICByZXR1cm4gcGFydGlhbFNpZy5maW5kKHBTaWcgPT4gcFNpZy5wdWJrZXkuZXF1YWxzKHB1YmtleSkpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIodiA9PiAhIXYpO1xuICB9IGVsc2Uge1xuICAgIHNpZ3MgPSBwYXJ0aWFsU2lnO1xuICB9XG4gIGlmIChzaWdzLmxlbmd0aCA+IG5lZWRlZFNpZ3MpIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgc2lnbmF0dXJlcycpO1xuICByZXR1cm4gc2lncy5sZW5ndGggPT09IG5lZWRlZFNpZ3M7XG59XG5mdW5jdGlvbiBpc0ZpbmFsaXplZChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dC5maW5hbFNjcmlwdFNpZyB8fCAhIWlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcztcbn1cbmZ1bmN0aW9uIGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KSB7XG4gIHJldHVybiBkID0+IHtcbiAgICBpZiAoIWQubWFzdGVyRmluZ2VycHJpbnQuZXF1YWxzKHJvb3QuZmluZ2VycHJpbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFyb290LmRlcml2ZVBhdGgoZC5wYXRoKS5wdWJsaWNLZXkuZXF1YWxzKGQucHVia2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gY2hlY2szMkJpdChudW0pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8XG4gICAgbnVtICE9PSBNYXRoLmZsb29yKG51bSkgfHxcbiAgICBudW0gPiAweGZmZmZmZmZmIHx8XG4gICAgbnVtIDwgMFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgMzIgYml0IGludGVnZXInKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tGZWVzKHBzYnQsIGNhY2hlLCBvcHRzKSB7XG4gIGNvbnN0IGZlZVJhdGUgPSBjYWNoZS5fX0ZFRV9SQVRFIHx8IHBzYnQuZ2V0RmVlUmF0ZSgpO1xuICBjb25zdCB2c2l6ZSA9IGNhY2hlLl9fRVhUUkFDVEVEX1RYLnZpcnR1YWxTaXplKCk7XG4gIGNvbnN0IHNhdG9zaGlzID0gZmVlUmF0ZSAqIHZzaXplO1xuICBpZiAoZmVlUmF0ZSA+PSBvcHRzLm1heGltdW1GZWVSYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFdhcm5pbmc6IFlvdSBhcmUgcGF5aW5nIGFyb3VuZCAkeyhzYXRvc2hpcyAvIDFlOCkudG9GaXhlZCg4KX0gaW4gYCArXG4gICAgICAgIGBmZWVzLCB3aGljaCBpcyAke2ZlZVJhdGV9IHNhdG9zaGkgcGVyIGJ5dGUgZm9yIGEgdHJhbnNhY3Rpb24gYCArXG4gICAgICAgIGB3aXRoIGEgVlNpemUgb2YgJHt2c2l6ZX0gYnl0ZXMgKHNlZ3dpdCBjb3VudGVkIGFzIDAuMjUgYnl0ZSBwZXIgYCArXG4gICAgICAgIGBieXRlKS4gVXNlIHNldE1heGltdW1GZWVSYXRlIG1ldGhvZCB0byByYWlzZSB5b3VyIHRocmVzaG9sZCwgb3IgYCArXG4gICAgICAgIGBwYXNzIHRydWUgdG8gdGhlIGZpcnN0IGFyZyBvZiBleHRyYWN0VHJhbnNhY3Rpb24uYCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcoaW5wdXRzLCBhY3Rpb24pIHtcbiAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgIGNvbnN0IHRocm93cyA9ICgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpXG4gICAgICA/ICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MpKGlucHV0LCBhY3Rpb24pXG4gICAgICA6ICgwLCBwc2J0dXRpbHNfMS5jaGVja0lucHV0Rm9yU2lnKShpbnB1dCwgYWN0aW9uKTtcbiAgICBpZiAodGhyb3dzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IG1vZGlmeSB0cmFuc2FjdGlvbiwgc2lnbmF0dXJlcyBleGlzdC4nKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1BhcnRpYWxTaWdTaWdoYXNoZXMoaW5wdXQpIHtcbiAgaWYgKCFpbnB1dC5zaWdoYXNoVHlwZSB8fCAhaW5wdXQucGFydGlhbFNpZykgcmV0dXJuO1xuICBjb25zdCB7IHBhcnRpYWxTaWcsIHNpZ2hhc2hUeXBlIH0gPSBpbnB1dDtcbiAgcGFydGlhbFNpZy5mb3JFYWNoKHBTaWcgPT4ge1xuICAgIGNvbnN0IHsgaGFzaFR5cGUgfSA9IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwU2lnLnNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ2hhc2hUeXBlICE9PSBoYXNoVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduYXR1cmUgc2lnaGFzaCBkb2VzIG5vdCBtYXRjaCBpbnB1dCBzaWdoYXNoIHR5cGUnKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTY3JpcHRGb3JQdWJrZXkocHVia2V5LCBzY3JpcHQsIGFjdGlvbikge1xuICBpZiAoISgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBzY3JpcHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgJHthY3Rpb259IGZvciB0aGlzIGlucHV0IHdpdGggdGhlIGtleSAke3B1YmtleS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1R4RW1wdHkodHgpIHtcbiAgY29uc3QgaXNFbXB0eSA9IHR4Lmlucy5ldmVyeShcbiAgICBpbnB1dCA9PlxuICAgICAgaW5wdXQuc2NyaXB0ICYmXG4gICAgICBpbnB1dC5zY3JpcHQubGVuZ3RoID09PSAwICYmXG4gICAgICBpbnB1dC53aXRuZXNzICYmXG4gICAgICBpbnB1dC53aXRuZXNzLmxlbmd0aCA9PT0gMCxcbiAgKTtcbiAgaWYgKCFpc0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IFRyYW5zYWN0aW9uIFNjcmlwdFNpZ3MgYXJlIG5vdCBlbXB0eScpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1R4Rm9yRHVwZUlucyh0eCwgY2FjaGUpIHtcbiAgdHguaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgIGNoZWNrVHhJbnB1dENhY2hlKGNhY2hlLCBpbnB1dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tUeElucHV0Q2FjaGUoY2FjaGUsIGlucHV0KSB7XG4gIGNvbnN0IGtleSA9XG4gICAgKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCkpLnRvU3RyaW5nKCdoZXgnKSArXG4gICAgJzonICtcbiAgICBpbnB1dC5pbmRleDtcbiAgaWYgKGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSkgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgaW5wdXQgZGV0ZWN0ZWQuJyk7XG4gIGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSA9IDE7XG59XG5mdW5jdGlvbiBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50LCBwYXltZW50U2NyaXB0TmFtZSkge1xuICByZXR1cm4gKGlucHV0SW5kZXgsIHNjcmlwdFB1YktleSwgcmVkZWVtU2NyaXB0LCBpb1R5cGUpID0+IHtcbiAgICBjb25zdCByZWRlZW1TY3JpcHRPdXRwdXQgPSBwYXltZW50KHtcbiAgICAgIHJlZGVlbTogeyBvdXRwdXQ6IHJlZGVlbVNjcmlwdCB9LFxuICAgIH0pLm91dHB1dDtcbiAgICBpZiAoIXNjcmlwdFB1YktleS5lcXVhbHMocmVkZWVtU2NyaXB0T3V0cHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtwYXltZW50U2NyaXB0TmFtZX0gZm9yICR7aW9UeXBlfSAjJHtpbnB1dEluZGV4fSBkb2Vzbid0IG1hdGNoIHRoZSBzY3JpcHRQdWJLZXkgaW4gdGhlIHByZXZvdXRgLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjaGVja1JlZGVlbVNjcmlwdCA9IHNjcmlwdENoZWNrZXJGYWN0b3J5KHBheW1lbnRzLnAyc2gsICdSZWRlZW0gc2NyaXB0Jyk7XG5jb25zdCBjaGVja1dpdG5lc3NTY3JpcHQgPSBzY3JpcHRDaGVja2VyRmFjdG9yeShcbiAgcGF5bWVudHMucDJ3c2gsXG4gICdXaXRuZXNzIHNjcmlwdCcsXG4pO1xuZnVuY3Rpb24gZ2V0VHhDYWNoZVZhbHVlKGtleSwgbmFtZSwgaW5wdXRzLCBjKSB7XG4gIGlmICghaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBTQlQgbXVzdCBiZSBmaW5hbGl6ZWQgdG8gY2FsY3VsYXRlICR7bmFtZX1gKTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFX1JBVEUnICYmIGMuX19GRUVfUkFURSkgcmV0dXJuIGMuX19GRUVfUkFURTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFJyAmJiBjLl9fRkVFKSByZXR1cm4gYy5fX0ZFRTtcbiAgbGV0IHR4O1xuICBsZXQgbXVzdEZpbmFsaXplID0gdHJ1ZTtcbiAgaWYgKGMuX19FWFRSQUNURURfVFgpIHtcbiAgICB0eCA9IGMuX19FWFRSQUNURURfVFg7XG4gICAgbXVzdEZpbmFsaXplID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdHggPSBjLl9fVFguY2xvbmUoKTtcbiAgfVxuICBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjLCBtdXN0RmluYWxpemUpO1xuICBpZiAoa2V5ID09PSAnX19GRUVfUkFURScpIHJldHVybiBjLl9fRkVFX1JBVEU7XG4gIGVsc2UgaWYgKGtleSA9PT0gJ19fRkVFJykgcmV0dXJuIGMuX19GRUU7XG59XG5mdW5jdGlvbiBnZXRGaW5hbFNjcmlwdHMoaW5wdXRJbmRleCwgaW5wdXQsIHNjcmlwdCwgaXNTZWd3aXQsIGlzUDJTSCwgaXNQMldTSCkge1xuICBjb25zdCBzY3JpcHRUeXBlID0gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KTtcbiAgaWYgKCFjYW5GaW5hbGl6ZShpbnB1dCwgc2NyaXB0LCBzY3JpcHRUeXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZmluYWxpemUgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgcmV0dXJuIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gICAgc2NyaXB0LFxuICAgIHNjcmlwdFR5cGUsXG4gICAgaW5wdXQucGFydGlhbFNpZyxcbiAgICBpc1NlZ3dpdCxcbiAgICBpc1AyU0gsXG4gICAgaXNQMldTSCxcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gIHNjcmlwdCxcbiAgc2NyaXB0VHlwZSxcbiAgcGFydGlhbFNpZyxcbiAgaXNTZWd3aXQsXG4gIGlzUDJTSCxcbiAgaXNQMldTSCxcbikge1xuICBsZXQgZmluYWxTY3JpcHRTaWc7XG4gIGxldCBmaW5hbFNjcmlwdFdpdG5lc3M7XG4gIC8vIFdvdywgdGhlIHBheW1lbnRzIEFQSSBpcyB2ZXJ5IGhhbmR5XG4gIGNvbnN0IHBheW1lbnQgPSBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZyk7XG4gIGNvbnN0IHAyd3NoID0gIWlzUDJXU0ggPyBudWxsIDogcGF5bWVudHMucDJ3c2goeyByZWRlZW06IHBheW1lbnQgfSk7XG4gIGNvbnN0IHAyc2ggPSAhaXNQMlNIID8gbnVsbCA6IHBheW1lbnRzLnAyc2goeyByZWRlZW06IHAyd3NoIHx8IHBheW1lbnQgfSk7XG4gIGlmIChpc1NlZ3dpdCkge1xuICAgIGlmIChwMndzaCkge1xuICAgICAgZmluYWxTY3JpcHRXaXRuZXNzID0gKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykoXG4gICAgICAgIHAyd3NoLndpdG5lc3MsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbFNjcmlwdFdpdG5lc3MgPSAoMCwgcHNidHV0aWxzXzEud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKShcbiAgICAgICAgcGF5bWVudC53aXRuZXNzLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxTY3JpcHRTaWcgPSBwYXltZW50LmlucHV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsU2NyaXB0U2lnLFxuICAgIGZpbmFsU2NyaXB0V2l0bmVzcyxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhc2hBbmRTaWdoYXNoVHlwZShcbiAgaW5wdXRzLFxuICBpbnB1dEluZGV4LFxuICBwdWJrZXksXG4gIGNhY2hlLFxuICBzaWdoYXNoVHlwZXMsXG4pIHtcbiAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KShpbnB1dHMsIGlucHV0SW5kZXgpO1xuICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlLCBzY3JpcHQgfSA9IGdldEhhc2hGb3JTaWcoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICBjYWNoZSxcbiAgICBmYWxzZSxcbiAgICBzaWdoYXNoVHlwZXMsXG4gICk7XG4gIGNoZWNrU2NyaXB0Rm9yUHVia2V5KHB1YmtleSwgc2NyaXB0LCAnc2lnbicpO1xuICByZXR1cm4ge1xuICAgIGhhc2gsXG4gICAgc2lnaGFzaFR5cGUsXG4gIH07XG59XG5mdW5jdGlvbiBnZXRIYXNoRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSwgZm9yVmFsaWRhdGUsIHNpZ2hhc2hUeXBlcykge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3Qgc2lnaGFzaFR5cGUgPVxuICAgIGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gIGNoZWNrU2lnaGFzaFR5cGVBbGxvd2VkKHNpZ2hhc2hUeXBlLCBzaWdoYXNoVHlwZXMpO1xuICBsZXQgaGFzaDtcbiAgbGV0IHByZXZvdXQ7XG4gIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKFxuICAgICAgY2FjaGUsXG4gICAgICBpbnB1dCxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgKTtcbiAgICBjb25zdCBwcmV2b3V0SGFzaCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmhhc2g7XG4gICAgY29uc3QgdXR4b0hhc2ggPSBub25XaXRuZXNzVXR4b1R4LmdldEhhc2goKTtcbiAgICAvLyBJZiBhIG5vbi13aXRuZXNzIFVUWE8gaXMgcHJvdmlkZWQsIGl0cyBoYXNoIG11c3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0XG4gICAgaWYgKCFwcmV2b3V0SGFzaC5lcXVhbHModXR4b0hhc2gpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24td2l0bmVzcyBVVFhPIGhhc2ggZm9yIGlucHV0ICMke2lucHV0SW5kZXh9IGRvZXNuJ3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZvdXRJbmRleCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmluZGV4O1xuICAgIHByZXZvdXQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XTtcbiAgfSBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgIHByZXZvdXQgPSBpbnB1dC53aXRuZXNzVXR4bztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYSBVdHhvIGlucHV0IGl0ZW0gZm9yIHNpZ25pbmcnKTtcbiAgfVxuICBjb25zdCB7IG1lYW5pbmdmdWxTY3JpcHQsIHR5cGUgfSA9IGdldE1lYW5pbmdmdWxTY3JpcHQoXG4gICAgcHJldm91dC5zY3JpcHQsXG4gICAgaW5wdXRJbmRleCxcbiAgICAnaW5wdXQnLFxuICAgIGlucHV0LnJlZGVlbVNjcmlwdCxcbiAgICBpbnB1dC53aXRuZXNzU2NyaXB0LFxuICApO1xuICBpZiAoWydwMnNoLXAyd3NoJywgJ3Ayd3NoJ10uaW5kZXhPZih0eXBlKSA+PSAwKSB7XG4gICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBtZWFuaW5nZnVsU2NyaXB0LFxuICAgICAgcHJldm91dC52YWx1ZSxcbiAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShtZWFuaW5nZnVsU2NyaXB0KSkge1xuICAgIC8vIFAyV1BLSCB1c2VzIHRoZSBQMlBLSCB0ZW1wbGF0ZSBmb3IgcHJldm91dFNjcmlwdCB3aGVuIHNpZ25pbmdcbiAgICBjb25zdCBzaWduaW5nU2NyaXB0ID0gcGF5bWVudHMucDJwa2goe1xuICAgICAgaGFzaDogbWVhbmluZ2Z1bFNjcmlwdC5zbGljZSgyKSxcbiAgICB9KS5vdXRwdXQ7XG4gICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBzaWduaW5nU2NyaXB0LFxuICAgICAgcHJldm91dC52YWx1ZSxcbiAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uLXNlZ3dpdFxuICAgIGlmIChcbiAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGNhY2hlLl9fVU5TQUZFX1NJR05fTk9OU0VHV0lUID09PSBmYWxzZVxuICAgIClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYElucHV0ICMke2lucHV0SW5kZXh9IGhhcyB3aXRuZXNzVXR4byBidXQgbm9uLXNlZ3dpdCBzY3JpcHQ6IGAgK1xuICAgICAgICAgIGAke21lYW5pbmdmdWxTY3JpcHQudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICApO1xuICAgIGlmICghZm9yVmFsaWRhdGUgJiYgY2FjaGUuX19VTlNBRkVfU0lHTl9OT05TRUdXSVQgIT09IGZhbHNlKVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2FybmluZzogU2lnbmluZyBub24tc2Vnd2l0IGlucHV0cyB3aXRob3V0IHRoZSBmdWxsIHBhcmVudCB0cmFuc2FjdGlvbiAnICtcbiAgICAgICAgICAnbWVhbnMgdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCBhIG1pbmVyIGNvdWxkIGZlZWQgeW91IGluY29ycmVjdCBpbmZvcm1hdGlvbiAnICtcbiAgICAgICAgICBcInRvIHRyaWNrIHlvdSBpbnRvIHBheWluZyBsYXJnZSBmZWVzLiBUaGlzIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIFBzYnQncyBwcmVkZWNlc29yIFwiICtcbiAgICAgICAgICAnKFRyYW5zYWN0aW9uQnVpbGRlciAtIG5vdyByZW1vdmVkKSB3aGVuIHNpZ25pbmcgbm9uLXNlZ3dpdCBzY3JpcHRzLiBZb3UgYXJlIG5vdCAnICtcbiAgICAgICAgICAnYWJsZSB0byBleHBvcnQgdGhpcyBQc2J0IHdpdGggdG9CdWZmZXJ8dG9CYXNlNjR8dG9IZXggc2luY2UgaXQgaXMgbm90ICcgK1xuICAgICAgICAgICdCSVAxNzQgY29tcGxpYW50LlxcbioqKioqKioqKioqKioqKioqKioqKlxcblBST0NFRUQgV0lUSCBDQVVUSU9OIVxcbicgK1xuICAgICAgICAgICcqKioqKioqKioqKioqKioqKioqKionLFxuICAgICAgKTtcbiAgICBoYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yU2lnbmF0dXJlKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIG1lYW5pbmdmdWxTY3JpcHQsXG4gICAgICBzaWdoYXNoVHlwZSxcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NyaXB0OiBtZWFuaW5nZnVsU2NyaXB0LFxuICAgIHNpZ2hhc2hUeXBlLFxuICAgIGhhc2gsXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGxUYXByb290SGFzaGVzRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBpbnB1dHMsIGNhY2hlKSB7XG4gIGNvbnN0IGFsbFB1YmxpY0tleXMgPSBbXTtcbiAgaWYgKGlucHV0LnRhcEludGVybmFsS2V5KSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0UHJldm91dFRhcHJvb3RLZXkoaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBhbGxQdWJsaWNLZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0LnRhcFNjcmlwdFNpZykge1xuICAgIGNvbnN0IHRhcFNjcmlwdFB1YmtleXMgPSBpbnB1dC50YXBTY3JpcHRTaWcubWFwKHRzcyA9PiB0c3MucHVia2V5KTtcbiAgICBhbGxQdWJsaWNLZXlzLnB1c2goLi4udGFwU2NyaXB0UHVia2V5cyk7XG4gIH1cbiAgY29uc3QgYWxsSGFzaGVzID0gYWxsUHVibGljS2V5cy5tYXAocHViaWNLZXkgPT5cbiAgICBnZXRUYXByb290SGFzaGVzRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBpbnB1dHMsIHB1YmljS2V5LCBjYWNoZSksXG4gICk7XG4gIHJldHVybiBhbGxIYXNoZXMuZmxhdCgpO1xufVxuZnVuY3Rpb24gZ2V0UHJldm91dFRhcHJvb3RLZXkoaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gIGNvbnN0IHsgc2NyaXB0IH0gPSBnZXRTY3JpcHRBbmRBbW91bnRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpO1xuICByZXR1cm4gKDAsIHBzYnR1dGlsc18xLmlzUDJUUikoc2NyaXB0KSA/IHNjcmlwdC5zdWJhcnJheSgyLCAzNCkgOiBudWxsO1xufVxuZnVuY3Rpb24gdHJpbVRhcHJvb3RTaWcoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBzaWduYXR1cmUubGVuZ3RoID09PSA2NCA/IHNpZ25hdHVyZSA6IHNpZ25hdHVyZS5zdWJhcnJheSgwLCA2NCk7XG59XG5mdW5jdGlvbiBnZXRUYXByb290SGFzaGVzRm9yU2lnKFxuICBpbnB1dEluZGV4LFxuICBpbnB1dCxcbiAgaW5wdXRzLFxuICBwdWJrZXksXG4gIGNhY2hlLFxuICB0YXBMZWFmSGFzaFRvU2lnbixcbiAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbikge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3Qgc2lnaGFzaFR5cGUgPVxuICAgIGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUO1xuICBjaGVja1NpZ2hhc2hUeXBlQWxsb3dlZChzaWdoYXNoVHlwZSwgYWxsb3dlZFNpZ2hhc2hUeXBlcyk7XG4gIGNvbnN0IHByZXZPdXRzID0gaW5wdXRzLm1hcCgoaSwgaW5kZXgpID0+XG4gICAgZ2V0U2NyaXB0QW5kQW1vdW50RnJvbVV0eG8oaW5kZXgsIGksIGNhY2hlKSxcbiAgKTtcbiAgY29uc3Qgc2lnbmluZ1NjcmlwdHMgPSBwcmV2T3V0cy5tYXAobyA9PiBvLnNjcmlwdCk7XG4gIGNvbnN0IHZhbHVlcyA9IHByZXZPdXRzLm1hcChvID0+IG8udmFsdWUpO1xuICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgaWYgKGlucHV0LnRhcEludGVybmFsS2V5ICYmICF0YXBMZWFmSGFzaFRvU2lnbikge1xuICAgIGNvbnN0IG91dHB1dEtleSA9XG4gICAgICBnZXRQcmV2b3V0VGFwcm9vdEtleShpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpIHx8IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoKDAsIGJpcDM3MV8xLnRvWE9ubHkpKHB1YmtleSkuZXF1YWxzKG91dHB1dEtleSkpIHtcbiAgICAgIGNvbnN0IHRhcEtleUhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JXaXRuZXNzVjEoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHNpZ25pbmdTY3JpcHRzLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICAgKTtcbiAgICAgIGhhc2hlcy5wdXNoKHsgcHVia2V5LCBoYXNoOiB0YXBLZXlIYXNoIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCB0YXBMZWFmSGFzaGVzID0gKGlucHV0LnRhcExlYWZTY3JpcHQgfHwgW10pXG4gICAgLmZpbHRlcih0YXBMZWFmID0+ICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCB0YXBMZWFmLnNjcmlwdCkpXG4gICAgLm1hcCh0YXBMZWFmID0+IHtcbiAgICAgIGNvbnN0IGhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgb3V0cHV0OiB0YXBMZWFmLnNjcmlwdCxcbiAgICAgICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBoYXNoIH0sIHRhcExlYWYpO1xuICAgIH0pXG4gICAgLmZpbHRlcihcbiAgICAgIHRhcExlYWYgPT4gIXRhcExlYWZIYXNoVG9TaWduIHx8IHRhcExlYWZIYXNoVG9TaWduLmVxdWFscyh0YXBMZWFmLmhhc2gpLFxuICAgIClcbiAgICAubWFwKHRhcExlYWYgPT4ge1xuICAgICAgY29uc3QgdGFwU2NyaXB0SGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMShcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgc2lnbmluZ1NjcmlwdHMsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQsXG4gICAgICAgIHRhcExlYWYuaGFzaCxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGhhc2g6IHRhcFNjcmlwdEhhc2gsXG4gICAgICAgIGxlYWZIYXNoOiB0YXBMZWFmLmhhc2gsXG4gICAgICB9O1xuICAgIH0pO1xuICByZXR1cm4gaGFzaGVzLmNvbmNhdCh0YXBMZWFmSGFzaGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnaGFzaFR5cGVBbGxvd2VkKHNpZ2hhc2hUeXBlLCBzaWdoYXNoVHlwZXMpIHtcbiAgaWYgKHNpZ2hhc2hUeXBlcyAmJiBzaWdoYXNoVHlwZXMuaW5kZXhPZihzaWdoYXNoVHlwZSkgPCAwKSB7XG4gICAgY29uc3Qgc3RyID0gc2lnaGFzaFR5cGVUb1N0cmluZyhzaWdoYXNoVHlwZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFNpZ2hhc2ggdHlwZSBpcyBub3QgYWxsb3dlZC4gUmV0cnkgdGhlIHNpZ24gbWV0aG9kIHBhc3NpbmcgdGhlIGAgK1xuICAgICAgICBgc2lnaGFzaFR5cGVzIGFycmF5IG9mIHdoaXRlbGlzdGVkIHR5cGVzLiBTaWdoYXNoIHR5cGU6ICR7c3RyfWAsXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGF5bWVudChzY3JpcHQsIHNjcmlwdFR5cGUsIHBhcnRpYWxTaWcpIHtcbiAgbGV0IHBheW1lbnQ7XG4gIHN3aXRjaCAoc2NyaXB0VHlwZSkge1xuICAgIGNhc2UgJ211bHRpc2lnJzpcbiAgICAgIGNvbnN0IHNpZ3MgPSBnZXRTb3J0ZWRTaWdzKHNjcmlwdCwgcGFydGlhbFNpZyk7XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJtcyh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBzaWduYXR1cmVzOiBzaWdzLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwdWJrZXknOlxuICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAycGsoe1xuICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgc2lnbmF0dXJlOiBwYXJ0aWFsU2lnWzBdLnNpZ25hdHVyZSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHVia2V5aGFzaCc6XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJwa2goe1xuICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgcHVia2V5OiBwYXJ0aWFsU2lnWzBdLnB1YmtleSxcbiAgICAgICAgc2lnbmF0dXJlOiBwYXJ0aWFsU2lnWzBdLnNpZ25hdHVyZSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2l0bmVzc3B1YmtleWhhc2gnOlxuICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAyd3BraCh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBwdWJrZXk6IHBhcnRpYWxTaWdbMF0ucHVia2V5LFxuICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcGF5bWVudDtcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdEZyb21JbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpIHtcbiAgY29uc3QgdW5zaWduZWRUeCA9IGNhY2hlLl9fVFg7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICBzY3JpcHQ6IG51bGwsXG4gICAgaXNTZWd3aXQ6IGZhbHNlLFxuICAgIGlzUDJTSDogZmFsc2UsXG4gICAgaXNQMldTSDogZmFsc2UsXG4gIH07XG4gIHJlcy5pc1AyU0ggPSAhIWlucHV0LnJlZGVlbVNjcmlwdDtcbiAgcmVzLmlzUDJXU0ggPSAhIWlucHV0LndpdG5lc3NTY3JpcHQ7XG4gIGlmIChpbnB1dC53aXRuZXNzU2NyaXB0KSB7XG4gICAgcmVzLnNjcmlwdCA9IGlucHV0LndpdG5lc3NTY3JpcHQ7XG4gIH0gZWxzZSBpZiAoaW5wdXQucmVkZWVtU2NyaXB0KSB7XG4gICAgcmVzLnNjcmlwdCA9IGlucHV0LnJlZGVlbVNjcmlwdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8pIHtcbiAgICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldm91dEluZGV4ID0gdW5zaWduZWRUeC5pbnNbaW5wdXRJbmRleF0uaW5kZXg7XG4gICAgICByZXMuc2NyaXB0ID0gbm9uV2l0bmVzc1V0eG9UeC5vdXRzW3ByZXZvdXRJbmRleF0uc2NyaXB0O1xuICAgIH0gZWxzZSBpZiAoaW5wdXQud2l0bmVzc1V0eG8pIHtcbiAgICAgIHJlcy5zY3JpcHQgPSBpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQ7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC53aXRuZXNzU2NyaXB0IHx8ICgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkocmVzLnNjcmlwdCkpIHtcbiAgICByZXMuaXNTZWd3aXQgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRTaWduZXJzRnJvbUhEKGlucHV0SW5kZXgsIGlucHV0cywgaGRLZXlQYWlyKSB7XG4gIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkoaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgaWYgKCFpbnB1dC5iaXAzMkRlcml2YXRpb24gfHwgaW5wdXQuYmlwMzJEZXJpdmF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBiaXAzMkRlcml2YXRpb24gdG8gc2lnbiB3aXRoIEhEJyk7XG4gIH1cbiAgY29uc3QgbXlEZXJpdmF0aW9ucyA9IGlucHV0LmJpcDMyRGVyaXZhdGlvblxuICAgIC5tYXAoYmlwRHYgPT4ge1xuICAgICAgaWYgKGJpcER2Lm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhoZEtleVBhaXIuZmluZ2VycHJpbnQpKSB7XG4gICAgICAgIHJldHVybiBiaXBEdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIodiA9PiAhIXYpO1xuICBpZiAobXlEZXJpdmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnTmVlZCBvbmUgYmlwMzJEZXJpdmF0aW9uIG1hc3RlckZpbmdlcnByaW50IHRvIG1hdGNoIHRoZSBIRFNpZ25lciBmaW5nZXJwcmludCcsXG4gICAgKTtcbiAgfVxuICBjb25zdCBzaWduZXJzID0gbXlEZXJpdmF0aW9ucy5tYXAoYmlwRHYgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBoZEtleVBhaXIuZGVyaXZlUGF0aChiaXBEdi5wYXRoKTtcbiAgICBpZiAoIWJpcER2LnB1YmtleS5lcXVhbHMobm9kZS5wdWJsaWNLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmtleSBkaWQgbm90IG1hdGNoIGJpcDMyRGVyaXZhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG4gIHJldHVybiBzaWduZXJzO1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkU2lncyhzY3JpcHQsIHBhcnRpYWxTaWcpIHtcbiAgY29uc3QgcDJtcyA9IHBheW1lbnRzLnAybXMoeyBvdXRwdXQ6IHNjcmlwdCB9KTtcbiAgLy8gZm9yIGVhY2ggcHVia2V5IGluIG9yZGVyIG9mIHAybXMgc2NyaXB0XG4gIHJldHVybiBwMm1zLnB1YmtleXNcbiAgICAubWFwKHBrID0+IHtcbiAgICAgIC8vIGZpbHRlciBwYXJ0aWFsU2lnIGFycmF5IGJ5IHB1YmtleSBiZWluZyBlcXVhbFxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcGFydGlhbFNpZy5maWx0ZXIocHMgPT4ge1xuICAgICAgICAgIHJldHVybiBwcy5wdWJrZXkuZXF1YWxzKHBrKTtcbiAgICAgICAgfSlbMF0gfHwge31cbiAgICAgICkuc2lnbmF0dXJlO1xuICAgICAgLy8gQW55IHB1YmtleSB3aXRob3V0IGEgbWF0Y2ggd2lsbCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAvLyB0aGlzIGxhc3QgZmlsdGVyIHJlbW92ZXMgYWxsIHRoZSB1bmRlZmluZWQgaXRlbXMgaW4gdGhlIGFycmF5LlxuICAgIH0pXG4gICAgLmZpbHRlcih2ID0+ICEhdik7XG59XG5mdW5jdGlvbiBzY3JpcHRXaXRuZXNzVG9XaXRuZXNzU3RhY2soYnVmZmVyKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmdW5jdGlvbiByZWFkU2xpY2Uobikge1xuICAgIG9mZnNldCArPSBuO1xuICAgIHJldHVybiBidWZmZXIuc2xpY2Uob2Zmc2V0IC0gbiwgb2Zmc2V0KTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVmFySW50KCkge1xuICAgIGNvbnN0IHZpID0gdmFydWludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB2YXJ1aW50LmRlY29kZS5ieXRlcztcbiAgICByZXR1cm4gdmk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFZhclNsaWNlKCkge1xuICAgIHJldHVybiByZWFkU2xpY2UocmVhZFZhckludCgpKTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVmVjdG9yKCkge1xuICAgIGNvbnN0IGNvdW50ID0gcmVhZFZhckludCgpO1xuICAgIGNvbnN0IHZlY3RvciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykgdmVjdG9yLnB1c2gocmVhZFZhclNsaWNlKCkpO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbiAgcmV0dXJuIHJlYWRWZWN0b3IoKTtcbn1cbmZ1bmN0aW9uIHNpZ2hhc2hUeXBlVG9TdHJpbmcoc2lnaGFzaFR5cGUpIHtcbiAgbGV0IHRleHQgPVxuICAgIHNpZ2hhc2hUeXBlICYgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWVxuICAgICAgPyAnU0lHSEFTSF9BTllPTkVDQU5QQVkgfCAnXG4gICAgICA6ICcnO1xuICBjb25zdCBzaWdNb2QgPSBzaWdoYXNoVHlwZSAmIDB4MWY7XG4gIHN3aXRjaCAoc2lnTW9kKSB7XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMOlxuICAgICAgdGV4dCArPSAnU0lHSEFTSF9BTEwnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFOlxuICAgICAgdGV4dCArPSAnU0lHSEFTSF9TSU5HTEUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORTpcbiAgICAgIHRleHQgKz0gJ1NJR0hBU0hfTk9ORSc7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGFkZE5vbldpdG5lc3NUeENhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCkge1xuICBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW2lucHV0SW5kZXhdID0gaW5wdXQubm9uV2l0bmVzc1V0eG87XG4gIGNvbnN0IHR4ID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tQnVmZmVyKGlucHV0Lm5vbldpdG5lc3NVdHhvKTtcbiAgY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFW2lucHV0SW5kZXhdID0gdHg7XG4gIGNvbnN0IHNlbGYgPSBjYWNoZTtcbiAgY29uc3Qgc2VsZkluZGV4ID0gaW5wdXRJbmRleDtcbiAgZGVsZXRlIGlucHV0Lm5vbldpdG5lc3NVdHhvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdub25XaXRuZXNzVXR4bycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdO1xuICAgICAgY29uc3QgdHhDYWNoZSA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFW3NlbGZJbmRleF07XG4gICAgICBpZiAoYnVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZiA9IHR4Q2FjaGUudG9CdWZmZXIoKTtcbiAgICAgICAgc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW3NlbGZJbmRleF0gPSBuZXdCdWY7XG4gICAgICAgIHJldHVybiBuZXdCdWY7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQoZGF0YSkge1xuICAgICAgc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW3NlbGZJbmRleF0gPSBkYXRhO1xuICAgIH0sXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5wdXRGaW5hbGl6ZUdldEFtdHMoaW5wdXRzLCB0eCwgY2FjaGUsIG11c3RGaW5hbGl6ZSkge1xuICBsZXQgaW5wdXRBbW91bnQgPSAwO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgIGlmIChtdXN0RmluYWxpemUgJiYgaW5wdXQuZmluYWxTY3JpcHRTaWcpXG4gICAgICB0eC5pbnNbaWR4XS5zY3JpcHQgPSBpbnB1dC5maW5hbFNjcmlwdFNpZztcbiAgICBpZiAobXVzdEZpbmFsaXplICYmIGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcykge1xuICAgICAgdHguaW5zW2lkeF0ud2l0bmVzcyA9IHNjcmlwdFdpdG5lc3NUb1dpdG5lc3NTdGFjayhcbiAgICAgICAgaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICBpbnB1dEFtb3VudCArPSBpbnB1dC53aXRuZXNzVXR4by52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBjb25zdCBud1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShjYWNoZSwgaW5wdXQsIGlkeCk7XG4gICAgICBjb25zdCB2b3V0ID0gdHguaW5zW2lkeF0uaW5kZXg7XG4gICAgICBjb25zdCBvdXQgPSBud1R4Lm91dHNbdm91dF07XG4gICAgICBpbnB1dEFtb3VudCArPSBvdXQudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0cHV0QW1vdW50ID0gdHgub3V0cy5yZWR1Y2UoKHRvdGFsLCBvKSA9PiB0b3RhbCArIG8udmFsdWUsIDApO1xuICBjb25zdCBmZWUgPSBpbnB1dEFtb3VudCAtIG91dHB1dEFtb3VudDtcbiAgaWYgKGZlZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dHMgYXJlIHNwZW5kaW5nIG1vcmUgdGhhbiBJbnB1dHMnKTtcbiAgfVxuICBjb25zdCBieXRlcyA9IHR4LnZpcnR1YWxTaXplKCk7XG4gIGNhY2hlLl9fRkVFID0gZmVlO1xuICBjYWNoZS5fX0VYVFJBQ1RFRF9UWCA9IHR4O1xuICBjYWNoZS5fX0ZFRV9SQVRFID0gTWF0aC5mbG9vcihmZWUgLyBieXRlcyk7XG59XG5mdW5jdGlvbiBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCkge1xuICBjb25zdCBjID0gY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFO1xuICBpZiAoIWNbaW5wdXRJbmRleF0pIHtcbiAgICBhZGROb25XaXRuZXNzVHhDYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpO1xuICB9XG4gIHJldHVybiBjW2lucHV0SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gIGNvbnN0IHsgc2NyaXB0IH0gPSBnZXRTY3JpcHRBbmRBbW91bnRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpO1xuICByZXR1cm4gc2NyaXB0O1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0QW5kQW1vdW50RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gIGlmIChpbnB1dC53aXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdDogaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0LFxuICAgICAgdmFsdWU6IGlucHV0LndpdG5lc3NVdHhvLnZhbHVlLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKFxuICAgICAgY2FjaGUsXG4gICAgICBpbnB1dCxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgKTtcbiAgICBjb25zdCBvID0gbm9uV2l0bmVzc1V0eG9UeC5vdXRzW2NhY2hlLl9fVFguaW5zW2lucHV0SW5kZXhdLmluZGV4XTtcbiAgICByZXR1cm4geyBzY3JpcHQ6IG8uc2NyaXB0LCB2YWx1ZTogby52YWx1ZSB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgcHVia2V5IGluIGlucHV0IHdpdGhvdXQgVXR4byBkYXRhXCIpO1xuICB9XG59XG5mdW5jdGlvbiBwdWJrZXlJbklucHV0KHB1YmtleSwgaW5wdXQsIGlucHV0SW5kZXgsIGNhY2hlKSB7XG4gIGNvbnN0IHNjcmlwdCA9IGdldFNjcmlwdEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSk7XG4gIGNvbnN0IHsgbWVhbmluZ2Z1bFNjcmlwdCB9ID0gZ2V0TWVhbmluZ2Z1bFNjcmlwdChcbiAgICBzY3JpcHQsXG4gICAgaW5wdXRJbmRleCxcbiAgICAnaW5wdXQnLFxuICAgIGlucHV0LnJlZGVlbVNjcmlwdCxcbiAgICBpbnB1dC53aXRuZXNzU2NyaXB0LFxuICApO1xuICByZXR1cm4gKDAsIHBzYnR1dGlsc18xLnB1YmtleUluU2NyaXB0KShwdWJrZXksIG1lYW5pbmdmdWxTY3JpcHQpO1xufVxuZnVuY3Rpb24gcHVia2V5SW5PdXRwdXQocHVia2V5LCBvdXRwdXQsIG91dHB1dEluZGV4LCBjYWNoZSkge1xuICBjb25zdCBzY3JpcHQgPSBjYWNoZS5fX1RYLm91dHNbb3V0cHV0SW5kZXhdLnNjcmlwdDtcbiAgY29uc3QgeyBtZWFuaW5nZnVsU2NyaXB0IH0gPSBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICAgIHNjcmlwdCxcbiAgICBvdXRwdXRJbmRleCxcbiAgICAnb3V0cHV0JyxcbiAgICBvdXRwdXQucmVkZWVtU2NyaXB0LFxuICAgIG91dHB1dC53aXRuZXNzU2NyaXB0LFxuICApO1xuICByZXR1cm4gKDAsIHBzYnR1dGlsc18xLnB1YmtleUluU2NyaXB0KShwdWJrZXksIG1lYW5pbmdmdWxTY3JpcHQpO1xufVxuZnVuY3Rpb24gcmVkZWVtRnJvbUZpbmFsU2NyaXB0U2lnKGZpbmFsU2NyaXB0KSB7XG4gIGlmICghZmluYWxTY3JpcHQpIHJldHVybjtcbiAgY29uc3QgZGVjb21wID0gYnNjcmlwdC5kZWNvbXBpbGUoZmluYWxTY3JpcHQpO1xuICBpZiAoIWRlY29tcCkgcmV0dXJuO1xuICBjb25zdCBsYXN0SXRlbSA9IGRlY29tcFtkZWNvbXAubGVuZ3RoIC0gMV07XG4gIGlmIChcbiAgICAhQnVmZmVyLmlzQnVmZmVyKGxhc3RJdGVtKSB8fFxuICAgIGlzUHVia2V5TGlrZShsYXN0SXRlbSkgfHxcbiAgICBpc1NpZ0xpa2UobGFzdEl0ZW0pXG4gIClcbiAgICByZXR1cm47XG4gIGNvbnN0IHNEZWNvbXAgPSBic2NyaXB0LmRlY29tcGlsZShsYXN0SXRlbSk7XG4gIGlmICghc0RlY29tcCkgcmV0dXJuO1xuICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiByZWRlZW1Gcm9tRmluYWxXaXRuZXNzU2NyaXB0KGZpbmFsU2NyaXB0KSB7XG4gIGlmICghZmluYWxTY3JpcHQpIHJldHVybjtcbiAgY29uc3QgZGVjb21wID0gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKGZpbmFsU2NyaXB0KTtcbiAgY29uc3QgbGFzdEl0ZW0gPSBkZWNvbXBbZGVjb21wLmxlbmd0aCAtIDFdO1xuICBpZiAoaXNQdWJrZXlMaWtlKGxhc3RJdGVtKSkgcmV0dXJuO1xuICBjb25zdCBzRGVjb21wID0gYnNjcmlwdC5kZWNvbXBpbGUobGFzdEl0ZW0pO1xuICBpZiAoIXNEZWNvbXApIHJldHVybjtcbiAgcmV0dXJuIGxhc3RJdGVtO1xufVxuZnVuY3Rpb24gY29tcHJlc3NQdWJrZXkocHVia2V5KSB7XG4gIGlmIChwdWJrZXkubGVuZ3RoID09PSA2NSkge1xuICAgIGNvbnN0IHBhcml0eSA9IHB1YmtleVs2NF0gJiAxO1xuICAgIGNvbnN0IG5ld0tleSA9IHB1YmtleS5zbGljZSgwLCAzMyk7XG4gICAgbmV3S2V5WzBdID0gMiB8IHBhcml0eTtcbiAgICByZXR1cm4gbmV3S2V5O1xuICB9XG4gIHJldHVybiBwdWJrZXkuc2xpY2UoKTtcbn1cbmZ1bmN0aW9uIGlzUHVia2V5TGlrZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi5sZW5ndGggPT09IDMzICYmIGJzY3JpcHQuaXNDYW5vbmljYWxQdWJLZXkoYnVmKTtcbn1cbmZ1bmN0aW9uIGlzU2lnTGlrZShidWYpIHtcbiAgcmV0dXJuIGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYnVmKTtcbn1cbmZ1bmN0aW9uIGdldE1lYW5pbmdmdWxTY3JpcHQoXG4gIHNjcmlwdCxcbiAgaW5kZXgsXG4gIGlvVHlwZSxcbiAgcmVkZWVtU2NyaXB0LFxuICB3aXRuZXNzU2NyaXB0LFxuKSB7XG4gIGNvbnN0IGlzUDJTSCA9ICgwLCBwc2J0dXRpbHNfMS5pc1AyU0hTY3JpcHQpKHNjcmlwdCk7XG4gIGNvbnN0IGlzUDJTSFAyV1NIID1cbiAgICBpc1AyU0ggJiYgcmVkZWVtU2NyaXB0ICYmICgwLCBwc2J0dXRpbHNfMS5pc1AyV1NIU2NyaXB0KShyZWRlZW1TY3JpcHQpO1xuICBjb25zdCBpc1AyV1NIID0gKDAsIHBzYnR1dGlsc18xLmlzUDJXU0hTY3JpcHQpKHNjcmlwdCk7XG4gIGlmIChpc1AyU0ggJiYgcmVkZWVtU2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY3JpcHRQdWJrZXkgaXMgUDJTSCBidXQgcmVkZWVtU2NyaXB0IG1pc3NpbmcnKTtcbiAgaWYgKChpc1AyV1NIIHx8IGlzUDJTSFAyV1NIKSAmJiB3aXRuZXNzU2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3NjcmlwdFB1YmtleSBvciByZWRlZW1TY3JpcHQgaXMgUDJXU0ggYnV0IHdpdG5lc3NTY3JpcHQgbWlzc2luZycsXG4gICAgKTtcbiAgbGV0IG1lYW5pbmdmdWxTY3JpcHQ7XG4gIGlmIChpc1AyU0hQMldTSCkge1xuICAgIG1lYW5pbmdmdWxTY3JpcHQgPSB3aXRuZXNzU2NyaXB0O1xuICAgIGNoZWNrUmVkZWVtU2NyaXB0KGluZGV4LCBzY3JpcHQsIHJlZGVlbVNjcmlwdCwgaW9UeXBlKTtcbiAgICBjaGVja1dpdG5lc3NTY3JpcHQoaW5kZXgsIHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCwgaW9UeXBlKTtcbiAgICBjaGVja0ludmFsaWRQMldTSChtZWFuaW5nZnVsU2NyaXB0KTtcbiAgfSBlbHNlIGlmIChpc1AyV1NIKSB7XG4gICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHdpdG5lc3NTY3JpcHQ7XG4gICAgY2hlY2tXaXRuZXNzU2NyaXB0KGluZGV4LCBzY3JpcHQsIHdpdG5lc3NTY3JpcHQsIGlvVHlwZSk7XG4gICAgY2hlY2tJbnZhbGlkUDJXU0gobWVhbmluZ2Z1bFNjcmlwdCk7XG4gIH0gZWxzZSBpZiAoaXNQMlNIKSB7XG4gICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHJlZGVlbVNjcmlwdDtcbiAgICBjaGVja1JlZGVlbVNjcmlwdChpbmRleCwgc2NyaXB0LCByZWRlZW1TY3JpcHQsIGlvVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHNjcmlwdDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lYW5pbmdmdWxTY3JpcHQsXG4gICAgdHlwZTogaXNQMlNIUDJXU0hcbiAgICAgID8gJ3Ayc2gtcDJ3c2gnXG4gICAgICA6IGlzUDJTSFxuICAgICAgPyAncDJzaCdcbiAgICAgIDogaXNQMldTSFxuICAgICAgPyAncDJ3c2gnXG4gICAgICA6ICdyYXcnLFxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tJbnZhbGlkUDJXU0goc2NyaXB0KSB7XG4gIGlmIChcbiAgICAoMCwgcHNidHV0aWxzXzEuaXNQMldQS0gpKHNjcmlwdCkgfHxcbiAgICAoMCwgcHNidHV0aWxzXzEuaXNQMlNIU2NyaXB0KShzY3JpcHQpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignUDJXUEtIIG9yIFAyU0ggY2FuIG5vdCBiZSBjb250YWluZWQgd2l0aGluIFAyV1NIJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYXNzaWZ5U2NyaXB0KHNjcmlwdCkge1xuICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShzY3JpcHQpKSByZXR1cm4gJ3dpdG5lc3NwdWJrZXloYXNoJztcbiAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyUEtIKShzY3JpcHQpKSByZXR1cm4gJ3B1YmtleWhhc2gnO1xuICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJNUykoc2NyaXB0KSkgcmV0dXJuICdtdWx0aXNpZyc7XG4gIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMlBLKShzY3JpcHQpKSByZXR1cm4gJ3B1YmtleSc7XG4gIHJldHVybiAnbm9uc3RhbmRhcmQnO1xufVxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICByZXR1cm4gWy4uLkFycmF5KG4pLmtleXMoKV07XG59XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MgPVxuICBleHBvcnRzLnRhcFRyZWVGcm9tTGlzdCA9XG4gIGV4cG9ydHMudGFwVHJlZVRvTGlzdCA9XG4gIGV4cG9ydHMudHdlYWtJbnRlcm5hbFB1YktleSA9XG4gIGV4cG9ydHMuY2hlY2tUYXByb290T3V0cHV0RmllbGRzID1cbiAgZXhwb3J0cy5jaGVja1RhcHJvb3RJbnB1dEZpZWxkcyA9XG4gIGV4cG9ydHMuaXNUYXByb290T3V0cHV0ID1cbiAgZXhwb3J0cy5pc1RhcHJvb3RJbnB1dCA9XG4gIGV4cG9ydHMuc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZSA9XG4gIGV4cG9ydHMudGFwU2NyaXB0RmluYWxpemVyID1cbiAgZXhwb3J0cy50b1hPbmx5ID1cbiAgICB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKCcuL3BzYnR1dGlscycpO1xuY29uc3QgYmlwMzQxXzEgPSByZXF1aXJlKCcuLi9wYXltZW50cy9iaXAzNDEnKTtcbmNvbnN0IHBheW1lbnRzXzEgPSByZXF1aXJlKCcuLi9wYXltZW50cycpO1xuY29uc3QgcHNidHV0aWxzXzIgPSByZXF1aXJlKCcuL3BzYnR1dGlscycpO1xuY29uc3QgdG9YT25seSA9IHB1YktleSA9PiAocHViS2V5Lmxlbmd0aCA9PT0gMzIgPyBwdWJLZXkgOiBwdWJLZXkuc2xpY2UoMSwgMzMpKTtcbmV4cG9ydHMudG9YT25seSA9IHRvWE9ubHk7XG4vKipcbiAqIERlZmF1bHQgdGFwc2NyaXB0IGZpbmFsaXplci4gSXQgc2VhcmNoZXMgZm9yIHRoZSBgdGFwTGVhZkhhc2hUb0ZpbmFsaXplYCBpZiBwcm92aWRlZC5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHNlYXJjaCBmb3IgdGhlIHRhcGxlYWYgdGhhdCBoYXMgYXQgbGVhc3Qgb25lIHNpZ25hdHVyZSBhbmQgaGFzIHRoZSBzaG9ydGVzdCBwYXRoLlxuICogQHBhcmFtIGlucHV0SW5kZXggdGhlIHBvc2l0aW9uIG9mIHRoZSBQU0JUIGlucHV0LlxuICogQHBhcmFtIGlucHV0IHRoZSBQU0JUIGlucHV0LlxuICogQHBhcmFtIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSBvcHRpb25hbCwgaWYgcHJvdmlkZWQgdGhlIGZpbmFsaXplciB3aWxsIHNlYXJjaCBmb3IgYSB0YXBsZWFmIHRoYXQgaGFzIHRoaXMgaGFzaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgd2lsbCB0cnkgdG8gYnVpbGQgdGhlIGZpbmFsU2NyaXB0V2l0bmVzcy5cbiAqIEByZXR1cm5zIHRoZSBmaW5hbFNjcmlwdFdpdG5lc3Mgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBubyB0YXBsZWFmIGZvdW5kLlxuICovXG5mdW5jdGlvbiB0YXBTY3JpcHRGaW5hbGl6ZXIoaW5wdXRJbmRleCwgaW5wdXQsIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSkge1xuICBjb25zdCB0YXBMZWFmID0gZmluZFRhcExlYWZUb0ZpbmFsaXplKFxuICAgIGlucHV0LFxuICAgIGlucHV0SW5kZXgsXG4gICAgdGFwTGVhZkhhc2hUb0ZpbmFsaXplLFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IHNpZ3MgPSBzb3J0U2lnbmF0dXJlcyhpbnB1dCwgdGFwTGVhZik7XG4gICAgY29uc3Qgd2l0bmVzcyA9IHNpZ3MuY29uY2F0KHRhcExlYWYuc2NyaXB0KS5jb25jYXQodGFwTGVhZi5jb250cm9sQmxvY2spO1xuICAgIHJldHVybiB7XG4gICAgICBmaW5hbFNjcmlwdFdpdG5lc3M6ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKHdpdG5lc3MpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBmaW5hbGl6ZSB0YXByb290IGlucHV0ICMke2lucHV0SW5kZXh9OiAke2Vycn1gKTtcbiAgfVxufVxuZXhwb3J0cy50YXBTY3JpcHRGaW5hbGl6ZXIgPSB0YXBTY3JpcHRGaW5hbGl6ZXI7XG5mdW5jdGlvbiBzZXJpYWxpemVUYXByb290U2lnbmF0dXJlKHNpZywgc2lnaGFzaFR5cGUpIHtcbiAgY29uc3Qgc2lnaGFzaFR5cGVCeXRlID0gc2lnaGFzaFR5cGVcbiAgICA/IEJ1ZmZlci5mcm9tKFtzaWdoYXNoVHlwZV0pXG4gICAgOiBCdWZmZXIuZnJvbShbXSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaWcsIHNpZ2hhc2hUeXBlQnl0ZV0pO1xufVxuZXhwb3J0cy5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlID0gc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZTtcbmZ1bmN0aW9uIGlzVGFwcm9vdElucHV0KGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQgJiZcbiAgICAhIShcbiAgICAgIGlucHV0LnRhcEludGVybmFsS2V5IHx8XG4gICAgICBpbnB1dC50YXBNZXJrbGVSb290IHx8XG4gICAgICAoaW5wdXQudGFwTGVhZlNjcmlwdCAmJiBpbnB1dC50YXBMZWFmU2NyaXB0Lmxlbmd0aCkgfHxcbiAgICAgIChpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gJiYgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uLmxlbmd0aCkgfHxcbiAgICAgIChpbnB1dC53aXRuZXNzVXR4byAmJiAoMCwgcHNidHV0aWxzXzEuaXNQMlRSKShpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQpKVxuICAgIClcbiAgKTtcbn1cbmV4cG9ydHMuaXNUYXByb290SW5wdXQgPSBpc1RhcHJvb3RJbnB1dDtcbmZ1bmN0aW9uIGlzVGFwcm9vdE91dHB1dChvdXRwdXQsIHNjcmlwdCkge1xuICByZXR1cm4gKFxuICAgIG91dHB1dCAmJlxuICAgICEhKFxuICAgICAgb3V0cHV0LnRhcEludGVybmFsS2V5IHx8XG4gICAgICBvdXRwdXQudGFwVHJlZSB8fFxuICAgICAgKG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24gJiYgb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5sZW5ndGgpIHx8XG4gICAgICAoc2NyaXB0ICYmICgwLCBwc2J0dXRpbHNfMS5pc1AyVFIpKHNjcmlwdCkpXG4gICAgKVxuICApO1xufVxuZXhwb3J0cy5pc1RhcHJvb3RPdXRwdXQgPSBpc1RhcHJvb3RPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZpZWxkcyhpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKSB7XG4gIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdElucHV0RmllbGRzKGlucHV0RGF0YSwgbmV3SW5wdXREYXRhLCBhY3Rpb24pO1xuICBjaGVja0lmVGFwTGVhZkluVHJlZShpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKTtcbn1cbmV4cG9ydHMuY2hlY2tUYXByb290SW5wdXRGaWVsZHMgPSBjaGVja1RhcHJvb3RJbnB1dEZpZWxkcztcbmZ1bmN0aW9uIGNoZWNrVGFwcm9vdE91dHB1dEZpZWxkcyhvdXRwdXREYXRhLCBuZXdPdXRwdXREYXRhLCBhY3Rpb24pIHtcbiAgY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290T3V0cHV0RmllbGRzKG91dHB1dERhdGEsIG5ld091dHB1dERhdGEsIGFjdGlvbik7XG4gIGNoZWNrVGFwcm9vdFNjcmlwdFB1YmtleShvdXRwdXREYXRhLCBuZXdPdXRwdXREYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2tUYXByb290T3V0cHV0RmllbGRzID0gY2hlY2tUYXByb290T3V0cHV0RmllbGRzO1xuZnVuY3Rpb24gY2hlY2tUYXByb290U2NyaXB0UHVia2V5KG91dHB1dERhdGEsIG5ld091dHB1dERhdGEpIHtcbiAgaWYgKCFuZXdPdXRwdXREYXRhLnRhcFRyZWUgJiYgIW5ld091dHB1dERhdGEudGFwSW50ZXJuYWxLZXkpIHJldHVybjtcbiAgY29uc3QgdGFwSW50ZXJuYWxLZXkgPVxuICAgIG5ld091dHB1dERhdGEudGFwSW50ZXJuYWxLZXkgfHwgb3V0cHV0RGF0YS50YXBJbnRlcm5hbEtleTtcbiAgY29uc3QgdGFwVHJlZSA9IG5ld091dHB1dERhdGEudGFwVHJlZSB8fCBvdXRwdXREYXRhLnRhcFRyZWU7XG4gIGlmICh0YXBJbnRlcm5hbEtleSkge1xuICAgIGNvbnN0IHsgc2NyaXB0OiBzY3JpcHRQdWJrZXkgfSA9IG91dHB1dERhdGE7XG4gICAgY29uc3Qgc2NyaXB0ID0gZ2V0VGFwcm9vdFNjcmlwUHVia2V5KHRhcEludGVybmFsS2V5LCB0YXBUcmVlKTtcbiAgICBpZiAoc2NyaXB0UHVia2V5ICYmICFzY3JpcHRQdWJrZXkuZXF1YWxzKHNjcmlwdCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBvdXRwdXQuIFNjcmlwdCBvciBhZGRyZXNzIG1pc3NtYXRjaC4nKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFwcm9vdFNjcmlwUHVia2V5KHRhcEludGVybmFsS2V5LCB0YXBUcmVlKSB7XG4gIGNvbnN0IHNjcmlwdFRyZWUgPSB0YXBUcmVlICYmIHRhcFRyZWVGcm9tTGlzdCh0YXBUcmVlLmxlYXZlcyk7XG4gIGNvbnN0IHsgb3V0cHV0IH0gPSAoMCwgcGF5bWVudHNfMS5wMnRyKSh7XG4gICAgaW50ZXJuYWxQdWJrZXk6IHRhcEludGVybmFsS2V5LFxuICAgIHNjcmlwdFRyZWUsXG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gdHdlYWtJbnRlcm5hbFB1YktleShpbnB1dEluZGV4LCBpbnB1dCkge1xuICBjb25zdCB0YXBJbnRlcm5hbEtleSA9IGlucHV0LnRhcEludGVybmFsS2V5O1xuICBjb25zdCBvdXRwdXRLZXkgPVxuICAgIHRhcEludGVybmFsS2V5ICYmXG4gICAgKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KSh0YXBJbnRlcm5hbEtleSwgaW5wdXQudGFwTWVya2xlUm9vdCk7XG4gIGlmICghb3V0cHV0S2V5KVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgdHdlYWsgdGFwIGludGVybmFsIGtleSBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0uIFB1YmxpYyBrZXk6ICR7XG4gICAgICAgIHRhcEludGVybmFsS2V5ICYmIHRhcEludGVybmFsS2V5LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfWAsXG4gICAgKTtcbiAgcmV0dXJuIG91dHB1dEtleS54O1xufVxuZXhwb3J0cy50d2Vha0ludGVybmFsUHViS2V5ID0gdHdlYWtJbnRlcm5hbFB1YktleTtcbi8qKlxuICogQ29udmVydCBhIGJpbmFyeSB0cmVlIHRvIGEgQklQMzcxIHR5cGUgbGlzdC4gRWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGlzIChhY2NvcmRpbmcgdG8gQklQMzcxKTpcbiAqIE9uZSBvciBtb3JlIHR1cGxlcyByZXByZXNlbnRpbmcgdGhlIGRlcHRoLCBsZWFmIHZlcnNpb24sIGFuZCBzY3JpcHQgZm9yIGEgbGVhZiBpbiB0aGUgVGFwcm9vdCB0cmVlLFxuICogYWxsb3dpbmcgdGhlIGVudGlyZSB0cmVlIHRvIGJlIHJlY29uc3RydWN0ZWQuIFRoZSB0dXBsZXMgbXVzdCBiZSBpbiBkZXB0aCBmaXJzdCBzZWFyY2ggb3JkZXIgc28gdGhhdFxuICogdGhlIHRyZWUgaXMgY29ycmVjdGx5IHJlY29uc3RydWN0ZWQuXG4gKiBAcGFyYW0gdHJlZSB0aGUgYmluYXJ5IHRhcCB0cmVlXG4gKiBAcmV0dXJucyBhIGxpc3Qgb2YgQklQIDM3MSB0YXBsZWF2ZXNcbiAqL1xuZnVuY3Rpb24gdGFwVHJlZVRvTGlzdCh0cmVlKSB7XG4gIGlmICghKDAsIHR5cGVzXzEuaXNUYXB0cmVlKSh0cmVlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNvbnZlcnQgdGFwdHJlZSB0byB0YXBsZWFmIGxpc3QuIEV4cGVjdGluZyBhIHRhcHJlZSBzdHJ1Y3R1cmUuJyxcbiAgICApO1xuICByZXR1cm4gX3RhcFRyZWVUb0xpc3QodHJlZSk7XG59XG5leHBvcnRzLnRhcFRyZWVUb0xpc3QgPSB0YXBUcmVlVG9MaXN0O1xuLyoqXG4gKiBDb252ZXJ0IGEgQklQMzcxIFRhcExlYWYgbGlzdCB0byBhIFRhcFRyZWUgKGJpbmFyeSkuXG4gKiBAcGFyYW0gbGVhdmVzIGEgbGlzdCBvZiB0YXBsZWF2ZXMgd2hlcmUgZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGlzIChhY2NvcmRpbmcgdG8gQklQMzcxKTpcbiAqIE9uZSBvciBtb3JlIHR1cGxlcyByZXByZXNlbnRpbmcgdGhlIGRlcHRoLCBsZWFmIHZlcnNpb24sIGFuZCBzY3JpcHQgZm9yIGEgbGVhZiBpbiB0aGUgVGFwcm9vdCB0cmVlLFxuICogYWxsb3dpbmcgdGhlIGVudGlyZSB0cmVlIHRvIGJlIHJlY29uc3RydWN0ZWQuIFRoZSB0dXBsZXMgbXVzdCBiZSBpbiBkZXB0aCBmaXJzdCBzZWFyY2ggb3JkZXIgc28gdGhhdFxuICogdGhlIHRyZWUgaXMgY29ycmVjdGx5IHJlY29uc3RydWN0ZWQuXG4gKiBAcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyB0YXB0cmVlLCBvciB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSB0cmVlIGNhbm5vdCBiZSByZWNvbnN0cnVjdGVkXG4gKi9cbmZ1bmN0aW9uIHRhcFRyZWVGcm9tTGlzdChsZWF2ZXMgPSBbXSkge1xuICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSAmJiBsZWF2ZXNbMF0uZGVwdGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogbGVhdmVzWzBdLnNjcmlwdCxcbiAgICAgIHZlcnNpb246IGxlYXZlc1swXS5sZWFmVmVyc2lvbixcbiAgICB9O1xuICByZXR1cm4gaW5zdGVydExlYXZlc0luVHJlZShsZWF2ZXMpO1xufVxuZXhwb3J0cy50YXBUcmVlRnJvbUxpc3QgPSB0YXBUcmVlRnJvbUxpc3Q7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MoaW5wdXQsIGFjdGlvbikge1xuICBjb25zdCBzaWdzID0gZXh0cmFjdFRhcHJvb3RTaWdzKGlucHV0KTtcbiAgcmV0dXJuIHNpZ3Muc29tZShzaWcgPT5cbiAgICAoMCwgcHNidHV0aWxzXzIuc2lnbmF0dXJlQmxvY2tzQWN0aW9uKShzaWcsIGRlY29kZVNjaG5vcnJTaWduYXR1cmUsIGFjdGlvbiksXG4gICk7XG59XG5leHBvcnRzLmNoZWNrVGFwcm9vdElucHV0Rm9yU2lncyA9IGNoZWNrVGFwcm9vdElucHV0Rm9yU2lncztcbmZ1bmN0aW9uIGRlY29kZVNjaG5vcnJTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBzaWduYXR1cmUuc2xpY2UoMCwgNjQpLFxuICAgIGhhc2hUeXBlOlxuICAgICAgc2lnbmF0dXJlLnNsaWNlKDY0KVswXSB8fCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCxcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUYXByb290U2lncyhpbnB1dCkge1xuICBjb25zdCBzaWdzID0gW107XG4gIGlmIChpbnB1dC50YXBLZXlTaWcpIHNpZ3MucHVzaChpbnB1dC50YXBLZXlTaWcpO1xuICBpZiAoaW5wdXQudGFwU2NyaXB0U2lnKVxuICAgIHNpZ3MucHVzaCguLi5pbnB1dC50YXBTY3JpcHRTaWcubWFwKHMgPT4gcy5zaWduYXR1cmUpKTtcbiAgaWYgKCFzaWdzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpbmFsVGFwS2V5U2lnID0gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyk7XG4gICAgaWYgKGZpbmFsVGFwS2V5U2lnKSBzaWdzLnB1c2goZmluYWxUYXBLZXlTaWcpO1xuICB9XG4gIHJldHVybiBzaWdzO1xufVxuZnVuY3Rpb24gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGZpbmFsU2NyaXB0V2l0bmVzcykge1xuICBpZiAoIWZpbmFsU2NyaXB0V2l0bmVzcykgcmV0dXJuO1xuICBjb25zdCB3aXRuZXNzID0gZmluYWxTY3JpcHRXaXRuZXNzLnNsaWNlKDIpO1xuICAvLyB0b2RvOiBhZGQgc2Nobm9yciBzaWduYXR1cmUgdmFsaWRhdGlvblxuICBpZiAod2l0bmVzcy5sZW5ndGggPT09IDY0IHx8IHdpdG5lc3MubGVuZ3RoID09PSA2NSkgcmV0dXJuIHdpdG5lc3M7XG59XG5mdW5jdGlvbiBfdGFwVHJlZVRvTGlzdCh0cmVlLCBsZWF2ZXMgPSBbXSwgZGVwdGggPSAwKSB7XG4gIGlmIChkZXB0aCA+IGJpcDM0MV8xLk1BWF9UQVBUUkVFX0RFUFRIKVxuICAgIHRocm93IG5ldyBFcnJvcignTWF4IHRhcHRyZWUgZGVwdGggZXhjZWVkZWQuJyk7XG4gIGlmICghdHJlZSkgcmV0dXJuIFtdO1xuICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKSh0cmVlKSkge1xuICAgIGxlYXZlcy5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbGVhZlZlcnNpb246IHRyZWUudmVyc2lvbiB8fCBiaXAzNDFfMS5MRUFGX1ZFUlNJT05fVEFQU0NSSVBULFxuICAgICAgc2NyaXB0OiB0cmVlLm91dHB1dCxcbiAgICB9KTtcbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG4gIGlmICh0cmVlWzBdKSBfdGFwVHJlZVRvTGlzdCh0cmVlWzBdLCBsZWF2ZXMsIGRlcHRoICsgMSk7XG4gIGlmICh0cmVlWzFdKSBfdGFwVHJlZVRvTGlzdCh0cmVlWzFdLCBsZWF2ZXMsIGRlcHRoICsgMSk7XG4gIHJldHVybiBsZWF2ZXM7XG59XG5mdW5jdGlvbiBpbnN0ZXJ0TGVhdmVzSW5UcmVlKGxlYXZlcykge1xuICBsZXQgdHJlZTtcbiAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xuICAgIHRyZWUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlKTtcbiAgICBpZiAoIXRyZWUpIHRocm93IG5ldyBFcnJvcihgTm8gcm9vbSBsZWZ0IHRvIGluc2VydCB0YXBsZWFmIGluIHRyZWVgKTtcbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGluc3RlcnRMZWFmSW5UcmVlKGxlYWYsIHRyZWUsIGRlcHRoID0gMCkge1xuICBpZiAoZGVwdGggPiBiaXAzNDFfMS5NQVhfVEFQVFJFRV9ERVBUSClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heCB0YXB0cmVlIGRlcHRoIGV4Y2VlZGVkLicpO1xuICBpZiAobGVhZi5kZXB0aCA9PT0gZGVwdGgpIHtcbiAgICBpZiAoIXRyZWUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXQ6IGxlYWYuc2NyaXB0LFxuICAgICAgICB2ZXJzaW9uOiBsZWFmLmxlYWZWZXJzaW9uLFxuICAgICAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCgwLCB0eXBlc18xLmlzVGFwbGVhZikodHJlZSkpIHJldHVybjtcbiAgY29uc3QgbGVmdFNpZGUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlICYmIHRyZWVbMF0sIGRlcHRoICsgMSk7XG4gIGlmIChsZWZ0U2lkZSkgcmV0dXJuIFtsZWZ0U2lkZSwgdHJlZSAmJiB0cmVlWzFdXTtcbiAgY29uc3QgcmlnaHRTaWRlID0gaW5zdGVydExlYWZJblRyZWUobGVhZiwgdHJlZSAmJiB0cmVlWzFdLCBkZXB0aCArIDEpO1xuICBpZiAocmlnaHRTaWRlKSByZXR1cm4gW3RyZWUgJiYgdHJlZVswXSwgcmlnaHRTaWRlXTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdElucHV0RmllbGRzKFxuICBpbnB1dERhdGEsXG4gIG5ld0lucHV0RGF0YSxcbiAgYWN0aW9uLFxuKSB7XG4gIGNvbnN0IGlzQmFkVGFwcm9vdFVwZGF0ZSA9XG4gICAgaXNUYXByb290SW5wdXQoaW5wdXREYXRhKSAmJiBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSA9XG4gICAgaGFzTm9uVGFwcm9vdEZpZWxkcyhpbnB1dERhdGEpICYmIGlzVGFwcm9vdElucHV0KG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGhhc01peGVkRmllbGRzID1cbiAgICBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgIGlzVGFwcm9vdElucHV0KG5ld0lucHV0RGF0YSkgJiZcbiAgICBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7IC8vIHRvZG86IGJhZD8gdXNlICE9PT1cbiAgaWYgKGlzQmFkVGFwcm9vdFVwZGF0ZSB8fCBpc0JhZE5vblRhcHJvb3RVcGRhdGUgfHwgaGFzTWl4ZWRGaWVsZHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gYCArXG4gICAgICAgIGBDYW5ub3QgdXNlIGJvdGggdGFwcm9vdCBhbmQgbm9uLXRhcHJvb3QgZmllbGRzLmAsXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdE91dHB1dEZpZWxkcyhcbiAgaW5wdXREYXRhLFxuICBuZXdJbnB1dERhdGEsXG4gIGFjdGlvbixcbikge1xuICBjb25zdCBpc0JhZFRhcHJvb3RVcGRhdGUgPVxuICAgIGlzVGFwcm9vdE91dHB1dChpbnB1dERhdGEpICYmIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTtcbiAgY29uc3QgaXNCYWROb25UYXByb290VXBkYXRlID1cbiAgICBoYXNOb25UYXByb290RmllbGRzKGlucHV0RGF0YSkgJiYgaXNUYXByb290T3V0cHV0KG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGhhc01peGVkRmllbGRzID1cbiAgICBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgIGlzVGFwcm9vdE91dHB1dChuZXdJbnB1dERhdGEpICYmXG4gICAgaGFzTm9uVGFwcm9vdEZpZWxkcyhuZXdJbnB1dERhdGEpO1xuICBpZiAoaXNCYWRUYXByb290VXBkYXRlIHx8IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSB8fCBoYXNNaXhlZEZpZWxkcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuJHthY3Rpb259LiBgICtcbiAgICAgICAgYENhbm5vdCB1c2UgYm90aCB0YXByb290IGFuZCBub24tdGFwcm9vdCBmaWVsZHMuYCxcbiAgICApO1xufVxuZnVuY3Rpb24gY2hlY2tJZlRhcExlYWZJblRyZWUoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbikge1xuICBpZiAobmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpIHtcbiAgICBjb25zdCBuZXdMZWFmc0luVHJlZSA9IChuZXdJbnB1dERhdGEudGFwTGVhZlNjcmlwdCB8fCBbXSkuZXZlcnkobCA9PlxuICAgICAgaXNUYXBMZWFmSW5UcmVlKGwsIG5ld0lucHV0RGF0YS50YXBNZXJrbGVSb290KSxcbiAgICApO1xuICAgIGNvbnN0IG9sZExlYWZzSW5UcmVlID0gKGlucHV0RGF0YS50YXBMZWFmU2NyaXB0IHx8IFtdKS5ldmVyeShsID0+XG4gICAgICBpc1RhcExlYWZJblRyZWUobCwgbmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpLFxuICAgICk7XG4gICAgaWYgKCFuZXdMZWFmc0luVHJlZSB8fCAhb2xkTGVhZnNJblRyZWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC4ke2FjdGlvbn0uIFRhcGxlYWYgbm90IHBhcnQgb2YgdGFwdHJlZS5gLFxuICAgICAgKTtcbiAgfSBlbHNlIGlmIChpbnB1dERhdGEudGFwTWVya2xlUm9vdCkge1xuICAgIGNvbnN0IG5ld0xlYWZzSW5UcmVlID0gKG5ld0lucHV0RGF0YS50YXBMZWFmU2NyaXB0IHx8IFtdKS5ldmVyeShsID0+XG4gICAgICBpc1RhcExlYWZJblRyZWUobCwgaW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpLFxuICAgICk7XG4gICAgaWYgKCFuZXdMZWFmc0luVHJlZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gVGFwbGVhZiBub3QgcGFydCBvZiB0YXB0cmVlLmAsXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1RhcExlYWZJblRyZWUodGFwTGVhZiwgbWVya2xlUm9vdCkge1xuICBpZiAoIW1lcmtsZVJvb3QpIHJldHVybiB0cnVlO1xuICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgIG91dHB1dDogdGFwTGVhZi5zY3JpcHQsXG4gICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgfSk7XG4gIGNvbnN0IHJvb3RIYXNoID0gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKFxuICAgIHRhcExlYWYuY29udHJvbEJsb2NrLFxuICAgIGxlYWZIYXNoLFxuICApO1xuICByZXR1cm4gcm9vdEhhc2guZXF1YWxzKG1lcmtsZVJvb3QpO1xufVxuZnVuY3Rpb24gc29ydFNpZ25hdHVyZXMoaW5wdXQsIHRhcExlYWYpIHtcbiAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgIHZlcnNpb246IHRhcExlYWYubGVhZlZlcnNpb24sXG4gIH0pO1xuICByZXR1cm4gKGlucHV0LnRhcFNjcmlwdFNpZyB8fCBbXSlcbiAgICAuZmlsdGVyKHRzcyA9PiB0c3MubGVhZkhhc2guZXF1YWxzKGxlYWZIYXNoKSlcbiAgICAubWFwKHRzcyA9PiBhZGRQdWJrZXlQb3NpdGlvbkluU2NyaXB0KHRhcExlYWYuc2NyaXB0LCB0c3MpKVxuICAgIC5zb3J0KCh0MSwgdDIpID0+IHQyLnBvc2l0aW9uSW5TY3JpcHQgLSB0MS5wb3NpdGlvbkluU2NyaXB0KVxuICAgIC5tYXAodCA9PiB0LnNpZ25hdHVyZSk7XG59XG5mdW5jdGlvbiBhZGRQdWJrZXlQb3NpdGlvbkluU2NyaXB0KHNjcmlwdCwgdHNzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIHBvc2l0aW9uSW5TY3JpcHQ6ICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlQb3NpdGlvbkluU2NyaXB0KShcbiAgICAgICAgdHNzLnB1YmtleSxcbiAgICAgICAgc2NyaXB0LFxuICAgICAgKSxcbiAgICB9LFxuICAgIHRzcyxcbiAgKTtcbn1cbi8qKlxuICogRmluZCB0YXBsZWFmIGJ5IGhhc2gsIG9yIGdldCB0aGUgc2lnbmVkIHRhcGxlYWYgd2l0aCB0aGUgc2hvcnRlc3QgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZmluZFRhcExlYWZUb0ZpbmFsaXplKGlucHV0LCBpbnB1dEluZGV4LCBsZWFmSGFzaFRvRmluYWxpemUpIHtcbiAgaWYgKCFpbnB1dC50YXBTY3JpcHRTaWcgfHwgIWlucHV0LnRhcFNjcmlwdFNpZy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgZmluYWxpemUgdGFwcm9vdCBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTm8gdGFwbGVhZiBzY3JpcHQgc2lnbmF0dXJlIHByb3ZpZGVkLmAsXG4gICAgKTtcbiAgY29uc3QgdGFwTGVhZiA9IChpbnB1dC50YXBMZWFmU2NyaXB0IHx8IFtdKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhLmNvbnRyb2xCbG9jay5sZW5ndGggLSBiLmNvbnRyb2xCbG9jay5sZW5ndGgpXG4gICAgLmZpbmQobGVhZiA9PlxuICAgICAgY2FuRmluYWxpemVMZWFmKGxlYWYsIGlucHV0LnRhcFNjcmlwdFNpZywgbGVhZkhhc2hUb0ZpbmFsaXplKSxcbiAgICApO1xuICBpZiAoIXRhcExlYWYpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgZmluYWxpemUgdGFwcm9vdCBpbnB1dCAjJHtpbnB1dEluZGV4fS4gU2lnbmF0dXJlIGZvciB0YXBsZWFmIHNjcmlwdCBub3QgZm91bmQuYCxcbiAgICApO1xuICByZXR1cm4gdGFwTGVhZjtcbn1cbmZ1bmN0aW9uIGNhbkZpbmFsaXplTGVhZihsZWFmLCB0YXBTY3JpcHRTaWcsIGhhc2gpIHtcbiAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICBvdXRwdXQ6IGxlYWYuc2NyaXB0LFxuICAgIHZlcnNpb246IGxlYWYubGVhZlZlcnNpb24sXG4gIH0pO1xuICBjb25zdCB3aGl0ZUxpc3RlZEhhc2ggPSAhaGFzaCB8fCBoYXNoLmVxdWFscyhsZWFmSGFzaCk7XG4gIHJldHVybiAoXG4gICAgd2hpdGVMaXN0ZWRIYXNoICYmXG4gICAgdGFwU2NyaXB0U2lnLmZpbmQodHNzID0+IHRzcy5sZWFmSGFzaC5lcXVhbHMobGVhZkhhc2gpKSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5mdW5jdGlvbiBoYXNOb25UYXByb290RmllbGRzKGlvKSB7XG4gIHJldHVybiAoXG4gICAgaW8gJiZcbiAgICAhIShcbiAgICAgIGlvLnJlZGVlbVNjcmlwdCB8fFxuICAgICAgaW8ud2l0bmVzc1NjcmlwdCB8fFxuICAgICAgKGlvLmJpcDMyRGVyaXZhdGlvbiAmJiBpby5iaXAzMkRlcml2YXRpb24ubGVuZ3RoKVxuICAgIClcbiAgKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpZ25hdHVyZUJsb2Nrc0FjdGlvbiA9XG4gIGV4cG9ydHMuY2hlY2tJbnB1dEZvclNpZyA9XG4gIGV4cG9ydHMucHVia2V5SW5TY3JpcHQgPVxuICBleHBvcnRzLnB1YmtleVBvc2l0aW9uSW5TY3JpcHQgPVxuICBleHBvcnRzLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcyA9XG4gIGV4cG9ydHMuaXNQMlRSID1cbiAgZXhwb3J0cy5pc1AyU0hTY3JpcHQgPVxuICBleHBvcnRzLmlzUDJXU0hTY3JpcHQgPVxuICBleHBvcnRzLmlzUDJXUEtIID1cbiAgZXhwb3J0cy5pc1AyUEtIID1cbiAgZXhwb3J0cy5pc1AyUEsgPVxuICBleHBvcnRzLmlzUDJNUyA9XG4gICAgdm9pZCAwO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJ2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci92YXJpbnQnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi4vcGF5bWVudHMnKTtcbmZ1bmN0aW9uIGlzUGF5bWVudEZhY3RvcnkocGF5bWVudCkge1xuICByZXR1cm4gc2NyaXB0ID0+IHtcbiAgICB0cnkge1xuICAgICAgcGF5bWVudCh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0cy5pc1AyTVMgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAybXMpO1xuZXhwb3J0cy5pc1AyUEsgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAycGspO1xuZXhwb3J0cy5pc1AyUEtIID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMnBraCk7XG5leHBvcnRzLmlzUDJXUEtIID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMndwa2gpO1xuZXhwb3J0cy5pc1AyV1NIU2NyaXB0ID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMndzaCk7XG5leHBvcnRzLmlzUDJTSFNjcmlwdCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJzaCk7XG5leHBvcnRzLmlzUDJUUiA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ0cik7XG5mdW5jdGlvbiB3aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3Mod2l0bmVzcykge1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICBmdW5jdGlvbiB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShzbGljZSldKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhckludChpKSB7XG4gICAgY29uc3QgY3VycmVudExlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgdmFyaW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChpKTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIEJ1ZmZlci5hbGxvY1Vuc2FmZSh2YXJpbnRMZW4pXSk7XG4gICAgdmFydWludC5lbmNvZGUoaSwgYnVmZmVyLCBjdXJyZW50TGVuKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgd3JpdGVWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICB3cml0ZVNsaWNlKHNsaWNlKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZlY3Rvcih2ZWN0b3IpIHtcbiAgICB3cml0ZVZhckludCh2ZWN0b3IubGVuZ3RoKTtcbiAgICB2ZWN0b3IuZm9yRWFjaCh3cml0ZVZhclNsaWNlKTtcbiAgfVxuICB3cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzID0gd2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzO1xuZnVuY3Rpb24gcHVia2V5UG9zaXRpb25JblNjcmlwdChwdWJrZXksIHNjcmlwdCkge1xuICBjb25zdCBwdWJrZXlIYXNoID0gKDAsIGNyeXB0b18xLmhhc2gxNjApKHB1YmtleSk7XG4gIGNvbnN0IHB1YmtleVhPbmx5ID0gcHVia2V5LnNsaWNlKDEsIDMzKTsgLy8gc2xpY2UgYmVmb3JlIGNhbGxpbmc/XG4gIGNvbnN0IGRlY29tcGlsZWQgPSBic2NyaXB0LmRlY29tcGlsZShzY3JpcHQpO1xuICBpZiAoZGVjb21waWxlZCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHNjcmlwdCBlcnJvcicpO1xuICByZXR1cm4gZGVjb21waWxlZC5maW5kSW5kZXgoZWxlbWVudCA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoXG4gICAgICBlbGVtZW50LmVxdWFscyhwdWJrZXkpIHx8XG4gICAgICBlbGVtZW50LmVxdWFscyhwdWJrZXlIYXNoKSB8fFxuICAgICAgZWxlbWVudC5lcXVhbHMocHVia2V5WE9ubHkpXG4gICAgKTtcbiAgfSk7XG59XG5leHBvcnRzLnB1YmtleVBvc2l0aW9uSW5TY3JpcHQgPSBwdWJrZXlQb3NpdGlvbkluU2NyaXB0O1xuZnVuY3Rpb24gcHVia2V5SW5TY3JpcHQocHVia2V5LCBzY3JpcHQpIHtcbiAgcmV0dXJuIHB1YmtleVBvc2l0aW9uSW5TY3JpcHQocHVia2V5LCBzY3JpcHQpICE9PSAtMTtcbn1cbmV4cG9ydHMucHVia2V5SW5TY3JpcHQgPSBwdWJrZXlJblNjcmlwdDtcbmZ1bmN0aW9uIGNoZWNrSW5wdXRGb3JTaWcoaW5wdXQsIGFjdGlvbikge1xuICBjb25zdCBwU2lncyA9IGV4dHJhY3RQYXJ0aWFsU2lncyhpbnB1dCk7XG4gIHJldHVybiBwU2lncy5zb21lKHBTaWcgPT5cbiAgICBzaWduYXR1cmVCbG9ja3NBY3Rpb24ocFNpZywgYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlLCBhY3Rpb24pLFxuICApO1xufVxuZXhwb3J0cy5jaGVja0lucHV0Rm9yU2lnID0gY2hlY2tJbnB1dEZvclNpZztcbmZ1bmN0aW9uIHNpZ25hdHVyZUJsb2Nrc0FjdGlvbihzaWduYXR1cmUsIHNpZ25hdHVyZURlY29kZUZuLCBhY3Rpb24pIHtcbiAgY29uc3QgeyBoYXNoVHlwZSB9ID0gc2lnbmF0dXJlRGVjb2RlRm4oc2lnbmF0dXJlKTtcbiAgY29uc3Qgd2hpdGVsaXN0ID0gW107XG4gIGNvbnN0IGlzQW55b25lQ2FuUGF5ID1cbiAgICBoYXNoVHlwZSAmIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVk7XG4gIGlmIChpc0FueW9uZUNhblBheSkgd2hpdGVsaXN0LnB1c2goJ2FkZElucHV0Jyk7XG4gIGNvbnN0IGhhc2hNb2QgPSBoYXNoVHlwZSAmIDB4MWY7XG4gIHN3aXRjaCAoaGFzaE1vZCkge1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRTpcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FOlxuICAgICAgd2hpdGVsaXN0LnB1c2goJ2FkZE91dHB1dCcpO1xuICAgICAgd2hpdGVsaXN0LnB1c2goJ3NldElucHV0U2VxdWVuY2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICh3aGl0ZWxpc3QuaW5kZXhPZihhY3Rpb24pID09PSAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2lnbmF0dXJlQmxvY2tzQWN0aW9uID0gc2lnbmF0dXJlQmxvY2tzQWN0aW9uO1xuZnVuY3Rpb24gZXh0cmFjdFBhcnRpYWxTaWdzKGlucHV0KSB7XG4gIGxldCBwU2lncyA9IFtdO1xuICBpZiAoKGlucHV0LnBhcnRpYWxTaWcgfHwgW10pLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICghaW5wdXQuZmluYWxTY3JpcHRTaWcgJiYgIWlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcykgcmV0dXJuIFtdO1xuICAgIHBTaWdzID0gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIHBTaWdzID0gaW5wdXQucGFydGlhbFNpZztcbiAgfVxuICByZXR1cm4gcFNpZ3MubWFwKHAgPT4gcC5zaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpIHtcbiAgY29uc3Qgc2NyaXB0SXRlbXMgPSAhaW5wdXQuZmluYWxTY3JpcHRTaWdcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFNpZykgfHwgW107XG4gIGNvbnN0IHdpdG5lc3NJdGVtcyA9ICFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3NcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpIHx8IFtdO1xuICByZXR1cm4gc2NyaXB0SXRlbXNcbiAgICAuY29uY2F0KHdpdG5lc3NJdGVtcylcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSAmJiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGl0ZW0pO1xuICAgIH0pXG4gICAgLm1hcChzaWcgPT4gKHsgc2lnbmF0dXJlOiBzaWcgfSkpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gdm9pZCAwO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKCcuL29wcycpO1xuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGgoaSkge1xuICByZXR1cm4gaSA8IG9wc18xLk9QUy5PUF9QVVNIREFUQTEgPyAxIDogaSA8PSAweGZmID8gMiA6IGkgPD0gMHhmZmZmID8gMyA6IDU7XG59XG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGg7XG5mdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBudW0sIG9mZnNldCkge1xuICBjb25zdCBzaXplID0gZW5jb2RpbmdMZW5ndGgobnVtKTtcbiAgLy8gfjYgYml0XG4gIGlmIChzaXplID09PSAxKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgobnVtLCBvZmZzZXQpO1xuICAgIC8vIDggYml0XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wc18xLk9QUy5PUF9QVVNIREFUQTEsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDgobnVtLCBvZmZzZXQgKyAxKTtcbiAgICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChzaXplID09PSAzKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgob3BzXzEuT1BTLk9QX1BVU0hEQVRBMiwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MTZMRShudW0sIG9mZnNldCArIDEpO1xuICAgIC8vIDMyIGJpdFxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wc18xLk9QUy5PUF9QVVNIREFUQTQsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtLCBvZmZzZXQgKyAxKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNvbnN0IG9wY29kZSA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgbGV0IG51bTtcbiAgbGV0IHNpemU7XG4gIC8vIH42IGJpdFxuICBpZiAob3Bjb2RlIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgIG51bSA9IG9wY29kZTtcbiAgICBzaXplID0gMTtcbiAgICAvLyA4IGJpdFxuICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgIGlmIChvZmZzZXQgKyAyID4gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgbnVtID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAxKTtcbiAgICBzaXplID0gMjtcbiAgICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTIpIHtcbiAgICBpZiAob2Zmc2V0ICsgMyA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIG51bSA9IGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSk7XG4gICAgc2l6ZSA9IDM7XG4gICAgLy8gMzIgYml0XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDUgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBpZiAob3Bjb2RlICE9PSBvcHNfMS5PUFMuT1BfUFVTSERBVEE0KSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3Bjb2RlJyk7XG4gICAgbnVtID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKTtcbiAgICBzaXplID0gNTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wY29kZSxcbiAgICBudW1iZXI6IG51bSxcbiAgICBzaXplLFxuICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmUgPVxuICBleHBvcnRzLm51bWJlciA9XG4gIGV4cG9ydHMuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUgPVxuICBleHBvcnRzLmlzRGVmaW5lZEhhc2hUeXBlID1cbiAgZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9XG4gIGV4cG9ydHMudG9TdGFjayA9XG4gIGV4cG9ydHMuZnJvbUFTTSA9XG4gIGV4cG9ydHMudG9BU00gPVxuICBleHBvcnRzLmRlY29tcGlsZSA9XG4gIGV4cG9ydHMuY29tcGlsZSA9XG4gIGV4cG9ydHMuY291bnROb25QdXNoT25seU9QcyA9XG4gIGV4cG9ydHMuaXNQdXNoT25seSA9XG4gIGV4cG9ydHMuT1BTID1cbiAgICB2b2lkIDA7XG5jb25zdCBiaXA2NiA9IHJlcXVpcmUoJy4vYmlwNjYnKTtcbmNvbnN0IG9wc18xID0gcmVxdWlyZSgnLi9vcHMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnT1BTJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb3BzXzEuT1BTO1xuICB9LFxufSk7XG5jb25zdCBwdXNoZGF0YSA9IHJlcXVpcmUoJy4vcHVzaF9kYXRhJyk7XG5jb25zdCBzY3JpcHROdW1iZXIgPSByZXF1aXJlKCcuL3NjcmlwdF9udW1iZXInKTtcbmNvbnN0IHNjcmlwdFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2NyaXB0X3NpZ25hdHVyZScpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCBPUF9JTlRfQkFTRSA9IG9wc18xLk9QUy5PUF9SRVNFUlZFRDsgLy8gT1BfMSAtIDFcbmZ1bmN0aW9uIGlzT1BJbnQodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlcy5OdW1iZXIodmFsdWUpICYmXG4gICAgKHZhbHVlID09PSBvcHNfMS5PUFMuT1BfMCB8fFxuICAgICAgKHZhbHVlID49IG9wc18xLk9QUy5PUF8xICYmIHZhbHVlIDw9IG9wc18xLk9QUy5PUF8xNikgfHxcbiAgICAgIHZhbHVlID09PSBvcHNfMS5PUFMuT1BfMU5FR0FURSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUHVzaE9ubHlDaHVuayh2YWx1ZSkge1xuICByZXR1cm4gdHlwZXMuQnVmZmVyKHZhbHVlKSB8fCBpc09QSW50KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUHVzaE9ubHkodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVzLkFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc1B1c2hPbmx5Q2h1bmspO1xufVxuZXhwb3J0cy5pc1B1c2hPbmx5ID0gaXNQdXNoT25seTtcbmZ1bmN0aW9uIGNvdW50Tm9uUHVzaE9ubHlPUHModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmxlbmd0aCAtIHZhbHVlLmZpbHRlcihpc1B1c2hPbmx5Q2h1bmspLmxlbmd0aDtcbn1cbmV4cG9ydHMuY291bnROb25QdXNoT25seU9QcyA9IGNvdW50Tm9uUHVzaE9ubHlPUHM7XG5mdW5jdGlvbiBhc01pbmltYWxPUChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiBvcHNfMS5PUFMuT1BfMDtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDEpIHJldHVybjtcbiAgaWYgKGJ1ZmZlclswXSA+PSAxICYmIGJ1ZmZlclswXSA8PSAxNikgcmV0dXJuIE9QX0lOVF9CQVNFICsgYnVmZmVyWzBdO1xuICBpZiAoYnVmZmVyWzBdID09PSAweDgxKSByZXR1cm4gb3BzXzEuT1BTLk9QXzFORUdBVEU7XG59XG5mdW5jdGlvbiBjaHVua3NJc0J1ZmZlcihidWYpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWYpO1xufVxuZnVuY3Rpb24gY2h1bmtzSXNBcnJheShidWYpIHtcbiAgcmV0dXJuIHR5cGVzLkFycmF5KGJ1Zik7XG59XG5mdW5jdGlvbiBzaW5nbGVDaHVua0lzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5mdW5jdGlvbiBjb21waWxlKGNodW5rcykge1xuICAvLyBUT0RPOiByZW1vdmUgbWVcbiAgaWYgKGNodW5rc0lzQnVmZmVyKGNodW5rcykpIHJldHVybiBjaHVua3M7XG4gIHR5cGVmb3JjZSh0eXBlcy5BcnJheSwgY2h1bmtzKTtcbiAgY29uc3QgYnVmZmVyU2l6ZSA9IGNodW5rcy5yZWR1Y2UoKGFjY3VtLCBjaHVuaykgPT4ge1xuICAgIC8vIGRhdGEgY2h1bmtcbiAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIC8vIGFkaGVyZSB0byBCSVA2Mi4zLCBtaW5pbWFsIHB1c2ggcG9saWN5XG4gICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSAxICYmIGFzTWluaW1hbE9QKGNodW5rKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhY2N1bSArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW0gKyBwdXNoZGF0YS5lbmNvZGluZ0xlbmd0aChjaHVuay5sZW5ndGgpICsgY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBvcGNvZGVcbiAgICByZXR1cm4gYWNjdW0gKyAxO1xuICB9LCAwLjApO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmZmVyU2l6ZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjaHVua3MuZm9yRWFjaChjaHVuayA9PiB7XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKGNodW5rKSkge1xuICAgICAgLy8gYWRoZXJlIHRvIEJJUDYyLjMsIG1pbmltYWwgcHVzaCBwb2xpY3lcbiAgICAgIGNvbnN0IG9wY29kZSA9IGFzTWluaW1hbE9QKGNodW5rKTtcbiAgICAgIGlmIChvcGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OChvcGNvZGUsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gcHVzaGRhdGEuZW5jb2RlKGJ1ZmZlciwgY2h1bmsubGVuZ3RoLCBvZmZzZXQpO1xuICAgICAgY2h1bmsuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgLy8gb3Bjb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICB9KTtcbiAgaWYgKG9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGVjb2RlIGNodW5rcycpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmZ1bmN0aW9uIGRlY29tcGlsZShidWZmZXIpIHtcbiAgLy8gVE9ETzogcmVtb3ZlIG1lXG4gIGlmIChjaHVua3NJc0FycmF5KGJ1ZmZlcikpIHJldHVybiBidWZmZXI7XG4gIHR5cGVmb3JjZSh0eXBlcy5CdWZmZXIsIGJ1ZmZlcik7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IG9wY29kZSA9IGJ1ZmZlcltpXTtcbiAgICAvLyBkYXRhIGNodW5rXG4gICAgaWYgKG9wY29kZSA+IG9wc18xLk9QUy5PUF8wICYmIG9wY29kZSA8PSBvcHNfMS5PUFMuT1BfUFVTSERBVEE0KSB7XG4gICAgICBjb25zdCBkID0gcHVzaGRhdGEuZGVjb2RlKGJ1ZmZlciwgaSk7XG4gICAgICAvLyBkaWQgcmVhZGluZyBhIHB1c2hEYXRhSW50IGZhaWw/XG4gICAgICBpZiAoZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBpICs9IGQuc2l6ZTtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCB0b28gbXVjaCBkYXRhP1xuICAgICAgaWYgKGkgKyBkLm51bWJlciA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zbGljZShpLCBpICsgZC5udW1iZXIpO1xuICAgICAgaSArPSBkLm51bWJlcjtcbiAgICAgIC8vIGRlY29tcGlsZSBtaW5pbWFsbHlcbiAgICAgIGNvbnN0IG9wID0gYXNNaW5pbWFsT1AoZGF0YSk7XG4gICAgICBpZiAob3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaHVua3MucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua3MucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIG9wY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua3MucHVzaChvcGNvZGUpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuZXhwb3J0cy5kZWNvbXBpbGUgPSBkZWNvbXBpbGU7XG5mdW5jdGlvbiB0b0FTTShjaHVua3MpIHtcbiAgaWYgKGNodW5rc0lzQnVmZmVyKGNodW5rcykpIHtcbiAgICBjaHVua3MgPSBkZWNvbXBpbGUoY2h1bmtzKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzXG4gICAgLm1hcChjaHVuayA9PiB7XG4gICAgICAvLyBkYXRhP1xuICAgICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgIGNvbnN0IG9wID0gYXNNaW5pbWFsT1AoY2h1bmspO1xuICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNodW5rLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgY2h1bmsgPSBvcDtcbiAgICAgIH1cbiAgICAgIC8vIG9wY29kZSFcbiAgICAgIHJldHVybiBvcHNfMS5SRVZFUlNFX09QU1tjaHVua107XG4gICAgfSlcbiAgICAuam9pbignICcpO1xufVxuZXhwb3J0cy50b0FTTSA9IHRvQVNNO1xuZnVuY3Rpb24gZnJvbUFTTShhc20pIHtcbiAgdHlwZWZvcmNlKHR5cGVzLlN0cmluZywgYXNtKTtcbiAgcmV0dXJuIGNvbXBpbGUoXG4gICAgYXNtLnNwbGl0KCcgJykubWFwKGNodW5rU3RyID0+IHtcbiAgICAgIC8vIG9wY29kZT9cbiAgICAgIGlmIChvcHNfMS5PUFNbY2h1bmtTdHJdICE9PSB1bmRlZmluZWQpIHJldHVybiBvcHNfMS5PUFNbY2h1bmtTdHJdO1xuICAgICAgdHlwZWZvcmNlKHR5cGVzLkhleCwgY2h1bmtTdHIpO1xuICAgICAgLy8gZGF0YSFcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjaHVua1N0ciwgJ2hleCcpO1xuICAgIH0pLFxuICApO1xufVxuZXhwb3J0cy5mcm9tQVNNID0gZnJvbUFTTTtcbmZ1bmN0aW9uIHRvU3RhY2soY2h1bmtzKSB7XG4gIGNodW5rcyA9IGRlY29tcGlsZShjaHVua3MpO1xuICB0eXBlZm9yY2UoaXNQdXNoT25seSwgY2h1bmtzKTtcbiAgcmV0dXJuIGNodW5rcy5tYXAob3AgPT4ge1xuICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKG9wKSkgcmV0dXJuIG9wO1xuICAgIGlmIChvcCA9PT0gb3BzXzEuT1BTLk9QXzApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgcmV0dXJuIHNjcmlwdE51bWJlci5lbmNvZGUob3AgLSBPUF9JTlRfQkFTRSk7XG4gIH0pO1xufVxuZXhwb3J0cy50b1N0YWNrID0gdG9TdGFjaztcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsUHViS2V5KGJ1ZmZlcikge1xuICByZXR1cm4gdHlwZXMuaXNQb2ludChidWZmZXIpO1xufVxuZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9IGlzQ2Fub25pY2FsUHViS2V5O1xuZnVuY3Rpb24gaXNEZWZpbmVkSGFzaFR5cGUoaGFzaFR5cGUpIHtcbiAgY29uc3QgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuICAvLyByZXR1cm4gaGFzaFR5cGVNb2QgPiBTSUdIQVNIX0FMTCAmJiBoYXNoVHlwZU1vZCA8IFNJR0hBU0hfU0lOR0xFXG4gIHJldHVybiBoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0O1xufVxuZXhwb3J0cy5pc0RlZmluZWRIYXNoVHlwZSA9IGlzRGVmaW5lZEhhc2hUeXBlO1xuZnVuY3Rpb24gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYnVmZmVyKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc0RlZmluZWRIYXNoVHlwZShidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYmlwNjYuY2hlY2soYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG59XG5leHBvcnRzLmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlID0gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmU7XG5leHBvcnRzLm51bWJlciA9IHNjcmlwdE51bWJlcjtcbmV4cG9ydHMuc2lnbmF0dXJlID0gc2NyaXB0U2lnbmF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBtYXhMZW5ndGgsIG1pbmltYWwpIHtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDQ7XG4gIG1pbmltYWwgPSBtaW5pbWFsID09PSB1bmRlZmluZWQgPyB0cnVlIDogbWluaW1hbDtcbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjcmlwdCBudW1iZXIgb3ZlcmZsb3cnKTtcbiAgaWYgKG1pbmltYWwpIHtcbiAgICBpZiAoKGJ1ZmZlcltsZW5ndGggLSAxXSAmIDB4N2YpID09PSAwKSB7XG4gICAgICBpZiAobGVuZ3RoIDw9IDEgfHwgKGJ1ZmZlcltsZW5ndGggLSAyXSAmIDB4ODApID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1taW5pbWFsbHkgZW5jb2RlZCBzY3JpcHQgbnVtYmVyJyk7XG4gICAgfVxuICB9XG4gIC8vIDQwLWJpdFxuICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgY29uc3QgYSA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMCk7XG4gICAgY29uc3QgYiA9IGJ1ZmZlci5yZWFkVUludDgoNCk7XG4gICAgaWYgKGIgJiAweDgwKSByZXR1cm4gLSgoYiAmIH4weDgwKSAqIDB4MTAwMDAwMDAwICsgYSk7XG4gICAgcmV0dXJuIGIgKiAweDEwMDAwMDAwMCArIGE7XG4gIH1cbiAgLy8gMzItYml0IC8gMjQtYml0IC8gMTYtYml0IC8gOC1iaXRcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHQgfD0gYnVmZmVyW2ldIDw8ICg4ICogaSk7XG4gIH1cbiAgaWYgKGJ1ZmZlcltsZW5ndGggLSAxXSAmIDB4ODApXG4gICAgcmV0dXJuIC0ocmVzdWx0ICYgfigweDgwIDw8ICg4ICogKGxlbmd0aCAtIDEpKSkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBzY3JpcHROdW1TaXplKGkpIHtcbiAgcmV0dXJuIGkgPiAweDdmZmZmZmZmXG4gICAgPyA1XG4gICAgOiBpID4gMHg3ZmZmZmZcbiAgICA/IDRcbiAgICA6IGkgPiAweDdmZmZcbiAgICA/IDNcbiAgICA6IGkgPiAweDdmXG4gICAgPyAyXG4gICAgOiBpID4gMHgwMFxuICAgID8gMVxuICAgIDogMDtcbn1cbmZ1bmN0aW9uIGVuY29kZShfbnVtYmVyKSB7XG4gIGxldCB2YWx1ZSA9IE1hdGguYWJzKF9udW1iZXIpO1xuICBjb25zdCBzaXplID0gc2NyaXB0TnVtU2l6ZSh2YWx1ZSk7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgY29uc3QgbmVnYXRpdmUgPSBfbnVtYmVyIDwgMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWx1ZSAmIDB4ZmYsIGkpO1xuICAgIHZhbHVlID4+PSA4O1xuICB9XG4gIGlmIChidWZmZXJbc2l6ZSAtIDFdICYgMHg4MCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG5lZ2F0aXZlID8gMHg4MCA6IDB4MDAsIHNpemUgLSAxKTtcbiAgfSBlbHNlIGlmIChuZWdhdGl2ZSkge1xuICAgIGJ1ZmZlcltzaXplIC0gMV0gfD0gMHg4MDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IGJpcDY2ID0gcmVxdWlyZSgnLi9iaXA2NicpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCBaRVJPID0gQnVmZmVyLmFsbG9jKDEsIDApO1xuZnVuY3Rpb24gdG9ERVIoeCkge1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlICh4W2ldID09PSAwKSArK2k7XG4gIGlmIChpID09PSB4Lmxlbmd0aCkgcmV0dXJuIFpFUk87XG4gIHggPSB4LnNsaWNlKGkpO1xuICBpZiAoeFswXSAmIDB4ODApIHJldHVybiBCdWZmZXIuY29uY2F0KFtaRVJPLCB4XSwgMSArIHgubGVuZ3RoKTtcbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBmcm9tREVSKHgpIHtcbiAgaWYgKHhbMF0gPT09IDB4MDApIHggPSB4LnNsaWNlKDEpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICBjb25zdCBic3RhcnQgPSBNYXRoLm1heCgwLCAzMiAtIHgubGVuZ3RoKTtcbiAgeC5jb3B5KGJ1ZmZlciwgYnN0YXJ0KTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8vIEJJUDYyOiAxIGJ5dGUgaGFzaFR5cGUgZmxhZyAob25seSAweDAxLCAweDAyLCAweDAzLCAweDgxLCAweDgyIGFuZCAweDgzIGFyZSBhbGxvd2VkKVxuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuICBjb25zdCBoYXNoVHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICBjb25zdCBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4ODA7XG4gIGlmIChoYXNoVHlwZU1vZCA8PSAwIHx8IGhhc2hUeXBlTW9kID49IDQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2hUeXBlICcgKyBoYXNoVHlwZSk7XG4gIGNvbnN0IGRlY29kZWQgPSBiaXA2Ni5kZWNvZGUoYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG4gIGNvbnN0IHIgPSBmcm9tREVSKGRlY29kZWQucik7XG4gIGNvbnN0IHMgPSBmcm9tREVSKGRlY29kZWQucyk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW3IsIHNdLCA2NCk7XG4gIHJldHVybiB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHNpZ25hdHVyZSwgaGFzaFR5cGUpIHtcbiAgdHlwZWZvcmNlKFxuICAgIHtcbiAgICAgIHNpZ25hdHVyZTogdHlwZXMuQnVmZmVyTig2NCksXG4gICAgICBoYXNoVHlwZTogdHlwZXMuVUludDgsXG4gICAgfSxcbiAgICB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfSxcbiAgKTtcbiAgY29uc3QgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuICBpZiAoaGFzaFR5cGVNb2QgPD0gMCB8fCBoYXNoVHlwZU1vZCA+PSA0KVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICBjb25zdCBoYXNoVHlwZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG4gIGNvbnN0IHIgPSB0b0RFUihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKTtcbiAgY29uc3QgcyA9IHRvREVSKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2JpcDY2LmVuY29kZShyLCBzKSwgaGFzaFR5cGVCdWZmZXJdKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZSgnLi9idWZmZXJ1dGlscycpO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuZnVuY3Rpb24gdmFyU2xpY2VTaXplKHNvbWVTY3JpcHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gc29tZVNjcmlwdC5sZW5ndGg7XG4gIHJldHVybiBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobGVuZ3RoKSArIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHZlY3RvclNpemUoc29tZVZlY3Rvcikge1xuICBjb25zdCBsZW5ndGggPSBzb21lVmVjdG9yLmxlbmd0aDtcbiAgcmV0dXJuIChcbiAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobGVuZ3RoKSArXG4gICAgc29tZVZlY3Rvci5yZWR1Y2UoKHN1bSwgd2l0bmVzcykgPT4ge1xuICAgICAgcmV0dXJuIHN1bSArIHZhclNsaWNlU2l6ZSh3aXRuZXNzKTtcbiAgICB9LCAwKVxuICApO1xufVxuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuY29uc3QgRU1QVFlfV0lUTkVTUyA9IFtdO1xuY29uc3QgWkVSTyA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICdoZXgnLFxuKTtcbmNvbnN0IE9ORSA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICdoZXgnLFxuKTtcbmNvbnN0IFZBTFVFX1VJTlQ2NF9NQVggPSBCdWZmZXIuZnJvbSgnZmZmZmZmZmZmZmZmZmZmZicsICdoZXgnKTtcbmNvbnN0IEJMQU5LX09VVFBVVCA9IHtcbiAgc2NyaXB0OiBFTVBUWV9CVUZGRVIsXG4gIHZhbHVlQnVmZmVyOiBWQUxVRV9VSU5UNjRfTUFYLFxufTtcbmZ1bmN0aW9uIGlzT3V0cHV0KG91dCkge1xuICByZXR1cm4gb3V0LnZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5sb2NrdGltZSA9IDA7XG4gICAgdGhpcy5pbnMgPSBbXTtcbiAgICB0aGlzLm91dHMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIF9OT19TVFJJQ1QpIHtcbiAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHR4LnZlcnNpb24gPSBidWZmZXJSZWFkZXIucmVhZEludDMyKCk7XG4gICAgY29uc3QgbWFya2VyID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIGNvbnN0IGZsYWcgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQ4KCk7XG4gICAgbGV0IGhhc1dpdG5lc3NlcyA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcmtlciA9PT0gVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSICYmXG4gICAgICBmbGFnID09PSBUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHXG4gICAgKSB7XG4gICAgICBoYXNXaXRuZXNzZXMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJSZWFkZXIub2Zmc2V0IC09IDI7XG4gICAgfVxuICAgIGNvbnN0IHZpbkxlbiA9IGJ1ZmZlclJlYWRlci5yZWFkVmFySW50KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aW5MZW47ICsraSkge1xuICAgICAgdHguaW5zLnB1c2goe1xuICAgICAgICBoYXNoOiBidWZmZXJSZWFkZXIucmVhZFNsaWNlKDMyKSxcbiAgICAgICAgaW5kZXg6IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCksXG4gICAgICAgIHNjcmlwdDogYnVmZmVyUmVhZGVyLnJlYWRWYXJTbGljZSgpLFxuICAgICAgICBzZXF1ZW5jZTogYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKSxcbiAgICAgICAgd2l0bmVzczogRU1QVFlfV0lUTkVTUyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2b3V0TGVuID0gYnVmZmVyUmVhZGVyLnJlYWRWYXJJbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZvdXRMZW47ICsraSkge1xuICAgICAgdHgub3V0cy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGJ1ZmZlclJlYWRlci5yZWFkVUludDY0KCksXG4gICAgICAgIHNjcmlwdDogYnVmZmVyUmVhZGVyLnJlYWRWYXJTbGljZSgpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXNXaXRuZXNzZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmluTGVuOyArK2kpIHtcbiAgICAgICAgdHguaW5zW2ldLndpdG5lc3MgPSBidWZmZXJSZWFkZXIucmVhZFZlY3RvcigpO1xuICAgICAgfVxuICAgICAgLy8gd2FzIHRoaXMgcG9pbnRsZXNzP1xuICAgICAgaWYgKCF0eC5oYXNXaXRuZXNzZXMoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgc3VwZXJmbHVvdXMgd2l0bmVzcyBkYXRhJyk7XG4gICAgfVxuICAgIHR4LmxvY2t0aW1lID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBpZiAoX05PX1NUUklDVCkgcmV0dXJuIHR4O1xuICAgIGlmIChidWZmZXJSZWFkZXIub2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgdW5leHBlY3RlZCBkYXRhJyk7XG4gICAgcmV0dXJuIHR4O1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpLCBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGlzQ29pbmJhc2VIYXNoKGJ1ZmZlcikge1xuICAgIHR5cGVmb3JjZSh0eXBlcy5IYXNoMjU2Yml0LCBidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgaWYgKGJ1ZmZlcltpXSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0NvaW5iYXNlKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlucy5sZW5ndGggPT09IDEgJiYgVHJhbnNhY3Rpb24uaXNDb2luYmFzZUhhc2godGhpcy5pbnNbMF0uaGFzaClcbiAgICApO1xuICB9XG4gIGFkZElucHV0KGhhc2gsIGluZGV4LCBzZXF1ZW5jZSwgc2NyaXB0U2lnKSB7XG4gICAgdHlwZWZvcmNlKFxuICAgICAgdHlwZXMudHVwbGUoXG4gICAgICAgIHR5cGVzLkhhc2gyNTZiaXQsXG4gICAgICAgIHR5cGVzLlVJbnQzMixcbiAgICAgICAgdHlwZXMubWF5YmUodHlwZXMuVUludDMyKSxcbiAgICAgICAgdHlwZXMubWF5YmUodHlwZXMuQnVmZmVyKSxcbiAgICAgICksXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgICBpZiAodHlwZXMuTnVsbChzZXF1ZW5jZSkpIHtcbiAgICAgIHNlcXVlbmNlID0gVHJhbnNhY3Rpb24uREVGQVVMVF9TRVFVRU5DRTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBpbnB1dCdzIGluZGV4XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaW5zLnB1c2goe1xuICAgICAgICBoYXNoLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2NyaXB0OiBzY3JpcHRTaWcgfHwgRU1QVFlfQlVGRkVSLFxuICAgICAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgICAgIHdpdG5lc3M6IEVNUFRZX1dJVE5FU1MsXG4gICAgICB9KSAtIDFcbiAgICApO1xuICB9XG4gIGFkZE91dHB1dChzY3JpcHRQdWJLZXksIHZhbHVlKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkJ1ZmZlciwgdHlwZXMuU2F0b3NoaSksIGFyZ3VtZW50cyk7XG4gICAgLy8gQWRkIHRoZSBvdXRwdXQgYW5kIHJldHVybiB0aGUgb3V0cHV0J3MgaW5kZXhcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vdXRzLnB1c2goe1xuICAgICAgICBzY3JpcHQ6IHNjcmlwdFB1YktleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KSAtIDFcbiAgICApO1xuICB9XG4gIGhhc1dpdG5lc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnMuc29tZSh4ID0+IHtcbiAgICAgIHJldHVybiB4LndpdG5lc3MubGVuZ3RoICE9PSAwO1xuICAgIH0pO1xuICB9XG4gIHdlaWdodCgpIHtcbiAgICBjb25zdCBiYXNlID0gdGhpcy5ieXRlTGVuZ3RoKGZhbHNlKTtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuYnl0ZUxlbmd0aCh0cnVlKTtcbiAgICByZXR1cm4gYmFzZSAqIDMgKyB0b3RhbDtcbiAgfVxuICB2aXJ0dWFsU2l6ZSgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMud2VpZ2h0KCkgLyA0KTtcbiAgfVxuICBieXRlTGVuZ3RoKF9BTExPV19XSVRORVNTID0gdHJ1ZSkge1xuICAgIGNvbnN0IGhhc1dpdG5lc3NlcyA9IF9BTExPV19XSVRORVNTICYmIHRoaXMuaGFzV2l0bmVzc2VzKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIChoYXNXaXRuZXNzZXMgPyAxMCA6IDgpICtcbiAgICAgIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLmlucy5sZW5ndGgpICtcbiAgICAgIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLm91dHMubGVuZ3RoKSArXG4gICAgICB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIDQwICsgdmFyU2xpY2VTaXplKGlucHV0LnNjcmlwdCk7XG4gICAgICB9LCAwKSArXG4gICAgICB0aGlzLm91dHMucmVkdWNlKChzdW0sIG91dHB1dCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIH0sIDApICtcbiAgICAgIChoYXNXaXRuZXNzZXNcbiAgICAgICAgPyB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyB2ZWN0b3JTaXplKGlucHV0LndpdG5lc3MpO1xuICAgICAgICAgIH0sIDApXG4gICAgICAgIDogMClcbiAgICApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1R4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgbmV3VHgudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICBuZXdUeC5sb2NrdGltZSA9IHRoaXMubG9ja3RpbWU7XG4gICAgbmV3VHguaW5zID0gdGhpcy5pbnMubWFwKHR4SW4gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogdHhJbi5oYXNoLFxuICAgICAgICBpbmRleDogdHhJbi5pbmRleCxcbiAgICAgICAgc2NyaXB0OiB0eEluLnNjcmlwdCxcbiAgICAgICAgc2VxdWVuY2U6IHR4SW4uc2VxdWVuY2UsXG4gICAgICAgIHdpdG5lc3M6IHR4SW4ud2l0bmVzcyxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbmV3VHgub3V0cyA9IHRoaXMub3V0cy5tYXAodHhPdXQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0OiB0eE91dC5zY3JpcHQsXG4gICAgICAgIHZhbHVlOiB0eE91dC52YWx1ZSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1R4O1xuICB9XG4gIC8qKlxuICAgKiBIYXNoIHRyYW5zYWN0aW9uIGZvciBzaWduaW5nIGEgc3BlY2lmaWMgaW5wdXQuXG4gICAqXG4gICAqIEJpdGNvaW4gdXNlcyBhIGRpZmZlcmVudCBoYXNoIGZvciBlYWNoIHNpZ25lZCB0cmFuc2FjdGlvbiBpbnB1dC5cbiAgICogVGhpcyBtZXRob2QgY29waWVzIHRoZSB0cmFuc2FjdGlvbiwgbWFrZXMgdGhlIG5lY2Vzc2FyeSBjaGFuZ2VzIGJhc2VkIG9uIHRoZVxuICAgKiBoYXNoVHlwZSwgYW5kIHRoZW4gaGFzaGVzIHRoZSByZXN1bHQuXG4gICAqIFRoaXMgaGFzaCBjYW4gdGhlbiBiZSB1c2VkIHRvIHNpZ24gdGhlIHByb3ZpZGVkIHRyYW5zYWN0aW9uIGlucHV0LlxuICAgKi9cbiAgaGFzaEZvclNpZ25hdHVyZShpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCBoYXNoVHlwZSkge1xuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKHR5cGVzLlVJbnQzMiwgdHlwZXMuQnVmZmVyLCAvKiB0eXBlcy5VSW50OCAqLyB0eXBlcy5OdW1iZXIpLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL21hc3Rlci9zcmMvdGVzdC9zaWdoYXNoX3Rlc3RzLmNwcCNMMjlcbiAgICBpZiAoaW5JbmRleCA+PSB0aGlzLmlucy5sZW5ndGgpIHJldHVybiBPTkU7XG4gICAgLy8gaWdub3JlIE9QX0NPREVTRVBBUkFUT1JcbiAgICBjb25zdCBvdXJTY3JpcHQgPSBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBic2NyaXB0LmRlY29tcGlsZShwcmV2T3V0U2NyaXB0KS5maWx0ZXIoeCA9PiB7XG4gICAgICAgIHJldHVybiB4ICE9PSBzY3JpcHRfMS5PUFMuT1BfQ09ERVNFUEFSQVRPUjtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgY29uc3QgdHhUbXAgPSB0aGlzLmNsb25lKCk7XG4gICAgLy8gU0lHSEFTSF9OT05FOiBpZ25vcmUgYWxsIG91dHB1dHM/ICh3aWxkY2FyZCBwYXllZSlcbiAgICBpZiAoKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgdHhUbXAub3V0cyA9IFtdO1xuICAgICAgLy8gaWdub3JlIHNlcXVlbmNlIG51bWJlcnMgKGV4Y2VwdCBhdCBpbkluZGV4KVxuICAgICAgdHhUbXAuaW5zLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSBpbkluZGV4KSByZXR1cm47XG4gICAgICAgIGlucHV0LnNlcXVlbmNlID0gMDtcbiAgICAgIH0pO1xuICAgICAgLy8gU0lHSEFTSF9TSU5HTEU6IGlnbm9yZSBhbGwgb3V0cHV0cywgZXhjZXB0IGF0IHRoZSBzYW1lIGluZGV4P1xuICAgIH0gZWxzZSBpZiAoKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvbWFzdGVyL3NyYy90ZXN0L3NpZ2hhc2hfdGVzdHMuY3BwI0w2MFxuICAgICAgaWYgKGluSW5kZXggPj0gdGhpcy5vdXRzLmxlbmd0aCkgcmV0dXJuIE9ORTtcbiAgICAgIC8vIHRydW5jYXRlIG91dHB1dHMgYWZ0ZXJcbiAgICAgIHR4VG1wLm91dHMubGVuZ3RoID0gaW5JbmRleCArIDE7XG4gICAgICAvLyBcImJsYW5rXCIgb3V0cHV0cyBiZWZvcmVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5JbmRleDsgaSsrKSB7XG4gICAgICAgIHR4VG1wLm91dHNbaV0gPSBCTEFOS19PVVRQVVQ7XG4gICAgICB9XG4gICAgICAvLyBpZ25vcmUgc2VxdWVuY2UgbnVtYmVycyAoZXhjZXB0IGF0IGluSW5kZXgpXG4gICAgICB0eFRtcC5pbnMuZm9yRWFjaCgoaW5wdXQsIHkpID0+IHtcbiAgICAgICAgaWYgKHkgPT09IGluSW5kZXgpIHJldHVybjtcbiAgICAgICAgaW5wdXQuc2VxdWVuY2UgPSAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNJR0hBU0hfQU5ZT05FQ0FOUEFZOiBpZ25vcmUgaW5wdXRzIGVudGlyZWx5P1xuICAgIGlmIChoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgICB0eFRtcC5pbnMgPSBbdHhUbXAuaW5zW2luSW5kZXhdXTtcbiAgICAgIHR4VG1wLmluc1swXS5zY3JpcHQgPSBvdXJTY3JpcHQ7XG4gICAgICAvLyBTSUdIQVNIX0FMTDogb25seSBpZ25vcmUgaW5wdXQgc2NyaXB0c1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcImJsYW5rXCIgb3RoZXJzIGlucHV0IHNjcmlwdHNcbiAgICAgIHR4VG1wLmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgaW5wdXQuc2NyaXB0ID0gRU1QVFlfQlVGRkVSO1xuICAgICAgfSk7XG4gICAgICB0eFRtcC5pbnNbaW5JbmRleF0uc2NyaXB0ID0gb3VyU2NyaXB0O1xuICAgIH1cbiAgICAvLyBzZXJpYWxpemUgYW5kIGhhc2hcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhUbXAuYnl0ZUxlbmd0aChmYWxzZSkgKyA0KTtcbiAgICBidWZmZXIud3JpdGVJbnQzMkxFKGhhc2hUeXBlLCBidWZmZXIubGVuZ3RoIC0gNCk7XG4gICAgdHhUbXAuX190b0J1ZmZlcihidWZmZXIsIDAsIGZhbHNlKTtcbiAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KGJ1ZmZlcik7XG4gIH1cbiAgaGFzaEZvcldpdG5lc3NWMShpbkluZGV4LCBwcmV2T3V0U2NyaXB0cywgdmFsdWVzLCBoYXNoVHlwZSwgbGVhZkhhc2gsIGFubmV4KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MS5tZWRpYXdpa2kjY29tbW9uLXNpZ25hdHVyZS1tZXNzYWdlXG4gICAgdHlwZWZvcmNlKFxuICAgICAgdHlwZXMudHVwbGUoXG4gICAgICAgIHR5cGVzLlVJbnQzMixcbiAgICAgICAgdHlwZWZvcmNlLmFycmF5T2YodHlwZXMuQnVmZmVyKSxcbiAgICAgICAgdHlwZWZvcmNlLmFycmF5T2YodHlwZXMuU2F0b3NoaSksXG4gICAgICAgIHR5cGVzLlVJbnQzMixcbiAgICAgICksXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZXMubGVuZ3RoICE9PSB0aGlzLmlucy5sZW5ndGggfHxcbiAgICAgIHByZXZPdXRTY3JpcHRzLmxlbmd0aCAhPT0gdGhpcy5pbnMubGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3VwcGx5IHByZXZvdXQgc2NyaXB0IGFuZCB2YWx1ZSBmb3IgYWxsIGlucHV0cycpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRUeXBlID1cbiAgICAgIGhhc2hUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFRcbiAgICAgICAgPyBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTFxuICAgICAgICA6IGhhc2hUeXBlICYgVHJhbnNhY3Rpb24uU0lHSEFTSF9PVVRQVVRfTUFTSztcbiAgICBjb25zdCBpbnB1dFR5cGUgPSBoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfSU5QVVRfTUFTSztcbiAgICBjb25zdCBpc0FueW9uZUNhblBheSA9IGlucHV0VHlwZSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVk7XG4gICAgY29uc3QgaXNOb25lID0gb3V0cHV0VHlwZSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FO1xuICAgIGNvbnN0IGlzU2luZ2xlID0gb3V0cHV0VHlwZSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEU7XG4gICAgbGV0IGhhc2hQcmV2b3V0cyA9IEVNUFRZX0JVRkZFUjtcbiAgICBsZXQgaGFzaEFtb3VudHMgPSBFTVBUWV9CVUZGRVI7XG4gICAgbGV0IGhhc2hTY3JpcHRQdWJLZXlzID0gRU1QVFlfQlVGRkVSO1xuICAgIGxldCBoYXNoU2VxdWVuY2VzID0gRU1QVFlfQlVGRkVSO1xuICAgIGxldCBoYXNoT3V0cHV0cyA9IEVNUFRZX0JVRkZFUjtcbiAgICBpZiAoIWlzQW55b25lQ2FuUGF5KSB7XG4gICAgICBsZXQgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICAzNiAqIHRoaXMuaW5zLmxlbmd0aCxcbiAgICAgICk7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0eEluLmhhc2gpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hQcmV2b3V0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIDggKiB0aGlzLmlucy5sZW5ndGgsXG4gICAgICApO1xuICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4gYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KHZhbHVlKSk7XG4gICAgICBoYXNoQW1vdW50cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIHByZXZPdXRTY3JpcHRzLm1hcCh2YXJTbGljZVNpemUpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpLFxuICAgICAgKTtcbiAgICAgIHByZXZPdXRTY3JpcHRzLmZvckVhY2gocHJldk91dFNjcmlwdCA9PlxuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShwcmV2T3V0U2NyaXB0KSxcbiAgICAgICk7XG4gICAgICBoYXNoU2NyaXB0UHViS2V5cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIDQgKiB0aGlzLmlucy5sZW5ndGgsXG4gICAgICApO1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLnNlcXVlbmNlKSk7XG4gICAgICBoYXNoU2VxdWVuY2VzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICB9XG4gICAgaWYgKCEoaXNOb25lIHx8IGlzU2luZ2xlKSkge1xuICAgICAgY29uc3QgdHhPdXRzU2l6ZSA9IHRoaXMub3V0c1xuICAgICAgICAubWFwKG91dHB1dCA9PiA4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpKVxuICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhICsgYik7XG4gICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkodHhPdXRzU2l6ZSk7XG4gICAgICB0aGlzLm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQob3V0LnZhbHVlKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2Uob3V0LnNjcmlwdCk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICB9IGVsc2UgaWYgKGlzU2luZ2xlICYmIGluSW5kZXggPCB0aGlzLm91dHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHNbaW5JbmRleF07XG4gICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCksXG4gICAgICApO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dHB1dC52YWx1ZSk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlbmRUeXBlID0gKGxlYWZIYXNoID8gMiA6IDApICsgKGFubmV4ID8gMSA6IDApO1xuICAgIC8vIExlbmd0aCBjYWxjdWxhdGlvbiBmcm9tOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDEubWVkaWF3aWtpI2NpdGVfbm90ZS0xNFxuICAgIC8vIFdpdGggZXh0ZW5zaW9uIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0Mi5tZWRpYXdpa2kjc2lnbmF0dXJlLXZhbGlkYXRpb25cbiAgICBjb25zdCBzaWdNc2dTaXplID1cbiAgICAgIDE3NCAtXG4gICAgICAoaXNBbnlvbmVDYW5QYXkgPyA0OSA6IDApIC1cbiAgICAgIChpc05vbmUgPyAzMiA6IDApICtcbiAgICAgIChhbm5leCA/IDMyIDogMCkgK1xuICAgICAgKGxlYWZIYXNoID8gMzcgOiAwKTtcbiAgICBjb25zdCBzaWdNc2dXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoc2lnTXNnU2l6ZSk7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDgoaGFzaFR5cGUpO1xuICAgIC8vIFRyYW5zYWN0aW9uXG4gICAgc2lnTXNnV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaFByZXZvdXRzKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoQW1vdW50cyk7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaFNjcmlwdFB1YktleXMpO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hTZXF1ZW5jZXMpO1xuICAgIGlmICghKGlzTm9uZSB8fCBpc1NpbmdsZSkpIHtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICB9XG4gICAgLy8gSW5wdXRcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50OChzcGVuZFR5cGUpO1xuICAgIGlmIChpc0FueW9uZUNhblBheSkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmluc1tpbkluZGV4XTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGlucHV0Lmhhc2gpO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKGlucHV0LmluZGV4KTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ2NCh2YWx1ZXNbaW5JbmRleF0pO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVmFyU2xpY2UocHJldk91dFNjcmlwdHNbaW5JbmRleF0pO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKGlucHV0LnNlcXVlbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKGluSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoYW5uZXgpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgdmFyU2xpY2VTaXplKGFubmV4KSxcbiAgICAgICk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShhbm5leCk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpKTtcbiAgICB9XG4gICAgLy8gT3V0cHV0XG4gICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoT3V0cHV0cyk7XG4gICAgfVxuICAgIC8vIEJJUDM0MiBleHRlbnNpb25cbiAgICBpZiAobGVhZkhhc2gpIHtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGxlYWZIYXNoKTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ4KDApO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKDB4ZmZmZmZmZmYpO1xuICAgIH1cbiAgICAvLyBFeHRyYSB6ZXJvIGJ5dGUgYmVjYXVzZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQxLm1lZGlhd2lraSNjaXRlX25vdGUtMTlcbiAgICByZXR1cm4gYmNyeXB0by50YWdnZWRIYXNoKFxuICAgICAgJ1RhcFNpZ2hhc2gnLFxuICAgICAgQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4MDBdKSwgc2lnTXNnV3JpdGVyLmVuZCgpXSksXG4gICAgKTtcbiAgfVxuICBoYXNoRm9yV2l0bmVzc1YwKGluSW5kZXgsIHByZXZPdXRTY3JpcHQsIHZhbHVlLCBoYXNoVHlwZSkge1xuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKHR5cGVzLlVJbnQzMiwgdHlwZXMuQnVmZmVyLCB0eXBlcy5TYXRvc2hpLCB0eXBlcy5VSW50MzIpLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgbGV0IHRidWZmZXIgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgbGV0IGJ1ZmZlcldyaXRlcjtcbiAgICBsZXQgaGFzaE91dHB1dHMgPSBaRVJPO1xuICAgIGxldCBoYXNoUHJldm91dHMgPSBaRVJPO1xuICAgIGxldCBoYXNoU2VxdWVuY2UgPSBaRVJPO1xuICAgIGlmICghKGhhc2hUeXBlICYgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVkpKSB7XG4gICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDM2ICogdGhpcy5pbnMubGVuZ3RoKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4SW4uaGFzaCk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLmluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgaGFzaFByZXZvdXRzID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhKGhhc2hUeXBlICYgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVkpICYmXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkVcbiAgICApIHtcbiAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5zZXF1ZW5jZSk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hTZXF1ZW5jZSA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFICYmXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FXG4gICAgKSB7XG4gICAgICBjb25zdCB0eE91dHNTaXplID0gdGhpcy5vdXRzLnJlZHVjZSgoc3VtLCBvdXRwdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhPdXRzU2l6ZSk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICB0aGlzLm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQob3V0LnZhbHVlKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2Uob3V0LnNjcmlwdCk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgIGluSW5kZXggPCB0aGlzLm91dHMubGVuZ3RoXG4gICAgKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHNbaW5JbmRleF07XG4gICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCkpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dHB1dC52YWx1ZSk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH1cbiAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE1NiArIHZhclNsaWNlU2l6ZShwcmV2T3V0U2NyaXB0KSk7XG4gICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnNbaW5JbmRleF07XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShoYXNoUHJldm91dHMpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hTZXF1ZW5jZSk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoaW5wdXQuaGFzaCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKGlucHV0LmluZGV4KTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShwcmV2T3V0U2NyaXB0KTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQodmFsdWUpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMihpbnB1dC5zZXF1ZW5jZSk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoaGFzaE91dHB1dHMpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLmxvY2t0aW1lKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIoaGFzaFR5cGUpO1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gIH1cbiAgZ2V0SGFzaChmb3JXaXRuZXNzKSB7XG4gICAgLy8gd3R4aWQgZm9yIGNvaW5iYXNlIGlzIGFsd2F5cyAzMiBieXRlcyBvZiAweDAwXG4gICAgaWYgKGZvcldpdG5lc3MgJiYgdGhpcy5pc0NvaW5iYXNlKCkpIHJldHVybiBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGhpcy5fX3RvQnVmZmVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmb3JXaXRuZXNzKSk7XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgLy8gdHJhbnNhY3Rpb24gaGFzaCdzIGFyZSBkaXNwbGF5ZWQgaW4gcmV2ZXJzZSBvcmRlclxuICAgIHJldHVybiAoMCwgYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKSh0aGlzLmdldEhhc2goZmFsc2UpKS50b1N0cmluZyhcbiAgICAgICdoZXgnLFxuICAgICk7XG4gIH1cbiAgdG9CdWZmZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX190b0J1ZmZlcihidWZmZXIsIGluaXRpYWxPZmZzZXQsIHRydWUpO1xuICB9XG4gIHRvSGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbiAgc2V0SW5wdXRTY3JpcHQoaW5kZXgsIHNjcmlwdFNpZykge1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5OdW1iZXIsIHR5cGVzLkJ1ZmZlciksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbnNbaW5kZXhdLnNjcmlwdCA9IHNjcmlwdFNpZztcbiAgfVxuICBzZXRXaXRuZXNzKGluZGV4LCB3aXRuZXNzKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLk51bWJlciwgW3R5cGVzLkJ1ZmZlcl0pLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5zW2luZGV4XS53aXRuZXNzID0gd2l0bmVzcztcbiAgfVxuICBfX3RvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCwgX0FMTE9XX1dJVE5FU1MgPSBmYWxzZSkge1xuICAgIGlmICghYnVmZmVyKSBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5ieXRlTGVuZ3RoKF9BTExPV19XSVRORVNTKSk7XG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKFxuICAgICAgYnVmZmVyLFxuICAgICAgaW5pdGlhbE9mZnNldCB8fCAwLFxuICAgICk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICBjb25zdCBoYXNXaXRuZXNzZXMgPSBfQUxMT1dfV0lUTkVTUyAmJiB0aGlzLmhhc1dpdG5lc3NlcygpO1xuICAgIGlmIChoYXNXaXRuZXNzZXMpIHtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ4KFRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX01BUktFUik7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50OChUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHKTtcbiAgICB9XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVmFySW50KHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IHtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4SW4uaGFzaCk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZSh0eEluLnNjcmlwdCk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5zZXF1ZW5jZSk7XG4gICAgfSk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVmFySW50KHRoaXMub3V0cy5sZW5ndGgpO1xuICAgIHRoaXMub3V0cy5mb3JFYWNoKHR4T3V0ID0+IHtcbiAgICAgIGlmIChpc091dHB1dCh0eE91dCkpIHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KHR4T3V0LnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4T3V0LnZhbHVlQnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKHR4T3V0LnNjcmlwdCk7XG4gICAgfSk7XG4gICAgaWYgKGhhc1dpdG5lc3Nlcykge1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZlY3RvcihpbnB1dC53aXRuZXNzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgLy8gYXZvaWQgc2xpY2luZyB1bmxlc3MgbmVjZXNzYXJ5XG4gICAgaWYgKGluaXRpYWxPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoaW5pdGlhbE9mZnNldCwgYnVmZmVyV3JpdGVyLm9mZnNldCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuVHJhbnNhY3Rpb24uREVGQVVMVF9TRVFVRU5DRSA9IDB4ZmZmZmZmZmY7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQgPSAweDAwO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwgPSAweDAxO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FID0gMHgwMjtcblRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFID0gMHgwMztcblRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZID0gMHg4MDtcblRyYW5zYWN0aW9uLlNJR0hBU0hfT1VUUFVUX01BU0sgPSAweDAzO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9JTlBVVF9NQVNLID0gMHg4MDtcblRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX01BUktFUiA9IDB4MDA7XG5UcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHID0gMHgwMTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZU9mID1cbiAgZXhwb3J0cy5OdWxsID1cbiAgZXhwb3J0cy5CdWZmZXJOID1cbiAgZXhwb3J0cy5GdW5jdGlvbiA9XG4gIGV4cG9ydHMuVUludDMyID1cbiAgZXhwb3J0cy5VSW50OCA9XG4gIGV4cG9ydHMudHVwbGUgPVxuICBleHBvcnRzLm1heWJlID1cbiAgZXhwb3J0cy5IZXggPVxuICBleHBvcnRzLkJ1ZmZlciA9XG4gIGV4cG9ydHMuU3RyaW5nID1cbiAgZXhwb3J0cy5Cb29sZWFuID1cbiAgZXhwb3J0cy5BcnJheSA9XG4gIGV4cG9ydHMuTnVtYmVyID1cbiAgZXhwb3J0cy5IYXNoMjU2Yml0ID1cbiAgZXhwb3J0cy5IYXNoMTYwYml0ID1cbiAgZXhwb3J0cy5CdWZmZXIyNTZiaXQgPVxuICBleHBvcnRzLmlzVGFwdHJlZSA9XG4gIGV4cG9ydHMuaXNUYXBsZWFmID1cbiAgZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSyA9XG4gIGV4cG9ydHMuTmV0d29yayA9XG4gIGV4cG9ydHMuRUNQb2ludCA9XG4gIGV4cG9ydHMuU2F0b3NoaSA9XG4gIGV4cG9ydHMuU2lnbmVyID1cbiAgZXhwb3J0cy5CSVAzMlBhdGggPVxuICBleHBvcnRzLlVJbnQzMSA9XG4gIGV4cG9ydHMuaXNQb2ludCA9XG4gIGV4cG9ydHMudHlwZWZvcmNlID1cbiAgICB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuZXhwb3J0cy50eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IFpFUk8zMiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzMiwgMCk7XG5jb25zdCBFQ19QID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oXG4gICdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyxcbiAgJ2hleCcsXG4pO1xuZnVuY3Rpb24gaXNQb2ludChwKSB7XG4gIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHApKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwLmxlbmd0aCA8IDMzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHQgPSBwWzBdO1xuICBjb25zdCB4ID0gcC5zbGljZSgxLCAzMyk7XG4gIGlmICh4LmNvbXBhcmUoWkVSTzMyKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5jb21wYXJlKEVDX1ApID49IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKCh0ID09PSAweDAyIHx8IHQgPT09IDB4MDMpICYmIHAubGVuZ3RoID09PSAzMykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHkgPSBwLnNsaWNlKDMzKTtcbiAgaWYgKHkuY29tcGFyZShaRVJPMzIpID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh5LmNvbXBhcmUoRUNfUCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodCA9PT0gMHgwNCAmJiBwLmxlbmd0aCA9PT0gNjUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuY29uc3QgVUlOVDMxX01BWCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG5mdW5jdGlvbiBVSW50MzEodmFsdWUpIHtcbiAgcmV0dXJuIGV4cG9ydHMudHlwZWZvcmNlLlVJbnQzMih2YWx1ZSkgJiYgdmFsdWUgPD0gVUlOVDMxX01BWDtcbn1cbmV4cG9ydHMuVUludDMxID0gVUludDMxO1xuZnVuY3Rpb24gQklQMzJQYXRoKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgZXhwb3J0cy50eXBlZm9yY2UuU3RyaW5nKHZhbHVlKSAmJiAhIXZhbHVlLm1hdGNoKC9eKG1cXC8pPyhcXGQrJz9cXC8pKlxcZCsnPyQvKVxuICApO1xufVxuZXhwb3J0cy5CSVAzMlBhdGggPSBCSVAzMlBhdGg7XG5CSVAzMlBhdGgudG9KU09OID0gKCkgPT4ge1xuICByZXR1cm4gJ0JJUDMyIGRlcml2YXRpb24gcGF0aCc7XG59O1xuZnVuY3Rpb24gU2lnbmVyKG9iaikge1xuICByZXR1cm4gKFxuICAgIChleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXIob2JqLnB1YmxpY0tleSkgfHxcbiAgICAgIHR5cGVvZiBvYmouZ2V0UHVibGljS2V5ID09PSAnZnVuY3Rpb24nKSAmJlxuICAgIHR5cGVvZiBvYmouc2lnbiA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuZXhwb3J0cy5TaWduZXIgPSBTaWduZXI7XG5jb25zdCBTQVRPU0hJX01BWCA9IDIxICogMWUxNDtcbmZ1bmN0aW9uIFNhdG9zaGkodmFsdWUpIHtcbiAgcmV0dXJuIGV4cG9ydHMudHlwZWZvcmNlLlVJbnQ1Myh2YWx1ZSkgJiYgdmFsdWUgPD0gU0FUT1NISV9NQVg7XG59XG5leHBvcnRzLlNhdG9zaGkgPSBTYXRvc2hpO1xuLy8gZXh0ZXJuYWwgZGVwZW5kZW50IHR5cGVzXG5leHBvcnRzLkVDUG9pbnQgPSBleHBvcnRzLnR5cGVmb3JjZS5xdWFja3NMaWtlKCdQb2ludCcpO1xuLy8gZXhwb3NlZCwgZXh0ZXJuYWwgQVBJXG5leHBvcnRzLk5ldHdvcmsgPSBleHBvcnRzLnR5cGVmb3JjZS5jb21waWxlKHtcbiAgbWVzc2FnZVByZWZpeDogZXhwb3J0cy50eXBlZm9yY2Uub25lT2YoXG4gICAgZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyLFxuICAgIGV4cG9ydHMudHlwZWZvcmNlLlN0cmluZyxcbiAgKSxcbiAgYmlwMzI6IHtcbiAgICBwdWJsaWM6IGV4cG9ydHMudHlwZWZvcmNlLlVJbnQzMixcbiAgICBwcml2YXRlOiBleHBvcnRzLnR5cGVmb3JjZS5VSW50MzIsXG4gIH0sXG4gIHB1YktleUhhc2g6IGV4cG9ydHMudHlwZWZvcmNlLlVJbnQ4LFxuICBzY3JpcHRIYXNoOiBleHBvcnRzLnR5cGVmb3JjZS5VSW50OCxcbiAgd2lmOiBleHBvcnRzLnR5cGVmb3JjZS5VSW50OCxcbn0pO1xuZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSyA9IDB4ZmU7XG5mdW5jdGlvbiBpc1RhcGxlYWYobykge1xuICBpZiAoIW8gfHwgISgnb3V0cHV0JyBpbiBvKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihvLm91dHB1dCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKG8udmVyc2lvbiAhPT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAoby52ZXJzaW9uICYgZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSykgPT09IG8udmVyc2lvbjtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVGFwbGVhZiA9IGlzVGFwbGVhZjtcbmZ1bmN0aW9uIGlzVGFwdHJlZShzY3JpcHRUcmVlKSB7XG4gIGlmICghKDAsIGV4cG9ydHMuQXJyYXkpKHNjcmlwdFRyZWUpKSByZXR1cm4gaXNUYXBsZWFmKHNjcmlwdFRyZWUpO1xuICBpZiAoc2NyaXB0VHJlZS5sZW5ndGggIT09IDIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNjcmlwdFRyZWUuZXZlcnkodCA9PiBpc1RhcHRyZWUodCkpO1xufVxuZXhwb3J0cy5pc1RhcHRyZWUgPSBpc1RhcHRyZWU7XG5leHBvcnRzLkJ1ZmZlcjI1NmJpdCA9IGV4cG9ydHMudHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuZXhwb3J0cy5IYXNoMTYwYml0ID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyTigyMCk7XG5leHBvcnRzLkhhc2gyNTZiaXQgPSBleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXJOKDMyKTtcbmV4cG9ydHMuTnVtYmVyID0gZXhwb3J0cy50eXBlZm9yY2UuTnVtYmVyO1xuZXhwb3J0cy5BcnJheSA9IGV4cG9ydHMudHlwZWZvcmNlLkFycmF5O1xuZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy50eXBlZm9yY2UuQm9vbGVhbjtcbmV4cG9ydHMuU3RyaW5nID0gZXhwb3J0cy50eXBlZm9yY2UuU3RyaW5nO1xuZXhwb3J0cy5CdWZmZXIgPSBleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXI7XG5leHBvcnRzLkhleCA9IGV4cG9ydHMudHlwZWZvcmNlLkhleDtcbmV4cG9ydHMubWF5YmUgPSBleHBvcnRzLnR5cGVmb3JjZS5tYXliZTtcbmV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnR5cGVmb3JjZS50dXBsZTtcbmV4cG9ydHMuVUludDggPSBleHBvcnRzLnR5cGVmb3JjZS5VSW50ODtcbmV4cG9ydHMuVUludDMyID0gZXhwb3J0cy50eXBlZm9yY2UuVUludDMyO1xuZXhwb3J0cy5GdW5jdGlvbiA9IGV4cG9ydHMudHlwZWZvcmNlLkZ1bmN0aW9uO1xuZXhwb3J0cy5CdWZmZXJOID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyTjtcbmV4cG9ydHMuTnVsbCA9IGV4cG9ydHMudHlwZWZvcmNlLk51bGw7XG5leHBvcnRzLm9uZU9mID0gZXhwb3J0cy50eXBlZm9yY2Uub25lT2Y7XG4iLCJjb25zdCBiYXNleCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNTggPSByZXF1aXJlKCdiczU4JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hlY2tzdW1Gbikge1xuICAvLyBFbmNvZGUgYSBidWZmZXIgYXMgYSBiYXNlNTgtY2hlY2sgZW5jb2RlZCBzdHJpbmdcbiAgZnVuY3Rpb24gZW5jb2RlIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRVOCA9IFVpbnQ4QXJyYXkuZnJvbShwYXlsb2FkKVxuICAgIHZhciBjaGVja3N1bSA9IGNoZWNrc3VtRm4ocGF5bG9hZFU4KVxuICAgIHZhciBsZW5ndGggPSBwYXlsb2FkVTgubGVuZ3RoICsgNFxuICAgIHZhciBib3RoID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIGJvdGguc2V0KHBheWxvYWRVOCwgMClcbiAgICBib3RoLnNldChjaGVja3N1bS5zdWJhcnJheSgwLCA0KSwgcGF5bG9hZFU4Lmxlbmd0aClcbiAgICByZXR1cm4gYmFzZTU4LmVuY29kZShib3RoLCBsZW5ndGgpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVSYXcgKGJ1ZmZlcikge1xuICAgIHZhciBwYXlsb2FkID0gYnVmZmVyLnNsaWNlKDAsIC00KVxuICAgIHZhciBjaGVja3N1bSA9IGJ1ZmZlci5zbGljZSgtNClcbiAgICB2YXIgbmV3Q2hlY2tzdW0gPSBjaGVja3N1bUZuKHBheWxvYWQpXG5cbiAgICBpZiAoY2hlY2tzdW1bMF0gXiBuZXdDaGVja3N1bVswXSB8XG4gICAgICAgIGNoZWNrc3VtWzFdIF4gbmV3Q2hlY2tzdW1bMV0gfFxuICAgICAgICBjaGVja3N1bVsyXSBeIG5ld0NoZWNrc3VtWzJdIHxcbiAgICAgICAgY2hlY2tzdW1bM10gXiBuZXdDaGVja3N1bVszXSkgcmV0dXJuXG5cbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgLy8gRGVjb2RlIGEgYmFzZTU4LWNoZWNrIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLCBubyByZXN1bHQgaWYgY2hlY2tzdW0gaXMgd3JvbmdcbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gYmFzZTU4LmRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKCFidWZmZXIpIHJldHVyblxuXG4gICAgcmV0dXJuIGRlY29kZVJhdyhidWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBiYXNlNTguZGVjb2RlKHN0cmluZylcbiAgICB2YXIgcGF5bG9hZCA9IGRlY29kZVJhdyhidWZmZXIsIGNoZWNrc3VtRm4pXG4gICAgaWYgKCFwYXlsb2FkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKVxuICAgIHJldHVybiBwYXlsb2FkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgeyBzaGEyNTYgfSA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JylcbnZhciBiczU4Y2hlY2tCYXNlID0gcmVxdWlyZSgnLi9iYXNlJylcblxuLy8gU0hBMjU2KFNIQTI1NihidWZmZXIpKVxuZnVuY3Rpb24gc2hhMjU2eDIgKGJ1ZmZlcikge1xuICByZXR1cm4gc2hhMjU2KHNoYTI1NihidWZmZXIpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJzNThjaGVja0Jhc2Uoc2hhMjU2eDIpXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiLyoqXHJcbiAqIERhcmsgUmVhZGVyIHY0LjkuNThcclxuICogaHR0cHM6Ly9kYXJrcmVhZGVyLm9yZy9cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICAgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgID8gZmFjdG9yeShleHBvcnRzKVxyXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWRcclxuICAgICAgICA/IGRlZmluZShbXCJleHBvcnRzXCJdLCBmYWN0b3J5KVxyXG4gICAgICAgIDogKChnbG9iYWwgPVxyXG4gICAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmKSxcclxuICAgICAgICAgIGZhY3RvcnkoKGdsb2JhbC5EYXJrUmVhZGVyID0ge30pKSk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfX2Fzc2lnbiA9XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24gfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUFxyXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvbmVcclxuICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmUocmVzdWx0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ZXAoXHJcbiAgICAgICAgICAgICAgICAoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogMCxcclxuICAgICAgICAgICAgICAgIHNlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRbMV07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdHJ5czogW10sXHJcbiAgICAgICAgICAgICAgICBvcHM6IFtdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGYsXHJcbiAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgIHQsXHJcbiAgICAgICAgICAgIGc7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgKGcgPSB7bmV4dDogdmVyYigwKSwgdGhyb3c6IHZlcmIoMSksIHJldHVybjogdmVyYigyKX0pLFxyXG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICAgIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgoZiA9IDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BbMF0gJiAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geVtcInJldHVyblwiXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9wWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geVtcInRocm93XCJdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkubmV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCh5ID0gMCksIHQpKSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoKHQgPSBfLnRyeXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BbMF0gPT09IDMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcCA9IFs2LCBlXTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZX07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsXHJcbiAgICAgICAgICAgIG0gPSBzICYmIG9bc10sXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhb307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgcyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLFxyXG4gICAgICAgICAgICByLFxyXG4gICAgICAgICAgICBhciA9IFtdLFxyXG4gICAgICAgICAgICBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxyXG4gICAgICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBlID0ge2Vycm9yOiBlcnJvcn07XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIE1lc3NhZ2VUeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfR0VUX0RBVEFcIl0gPSBcInVpLWdldC1kYXRhXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9TVUJTQ1JJQkVfVE9fQ0hBTkdFU1wiXSA9IFwidWktc3Vic2NyaWJlLXRvLWNoYW5nZXNcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIlVJX1VOU1VCU0NSSUJFX0ZST01fQ0hBTkdFU1wiXSA9XHJcbiAgICAgICAgICAgIFwidWktdW5zdWJzY3JpYmUtZnJvbS1jaGFuZ2VzXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9DSEFOR0VfU0VUVElOR1NcIl0gPSBcInVpLWNoYW5nZS1zZXR0aW5nc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfU0VUX1RIRU1FXCJdID0gXCJ1aS1zZXQtdGhlbWVcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIlVJX1NFVF9TSE9SVENVVFwiXSA9IFwidWktc2V0LXNob3J0Y3V0XCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9UT0dHTEVfQUNUSVZFX1RBQlwiXSA9IFwidWktdG9nZ2xlLWFjdGl2ZS10YWJcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIlVJX01BUktfTkVXU19BU19SRUFEXCJdID0gXCJ1aS1tYXJrLW5ld3MtYXMtcmVhZFwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfTUFSS19ORVdTX0FTX0RJU1BMQVlFRFwiXSA9IFwidWktbWFyay1uZXdzLWFzLWRpc3BsYXllZFwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfTE9BRF9DT05GSUdcIl0gPSBcInVpLWxvYWQtY29uZmlnXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9BUFBMWV9ERVZfRFlOQU1JQ19USEVNRV9GSVhFU1wiXSA9XHJcbiAgICAgICAgICAgIFwidWktYXBwbHktZGV2LWR5bmFtaWMtdGhlbWUtZml4ZXNcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIlVJX1JFU0VUX0RFVl9EWU5BTUlDX1RIRU1FX0ZJWEVTXCJdID1cclxuICAgICAgICAgICAgXCJ1aS1yZXNldC1kZXYtZHluYW1pYy10aGVtZS1maXhlc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfQVBQTFlfREVWX0lOVkVSU0lPTl9GSVhFU1wiXSA9XHJcbiAgICAgICAgICAgIFwidWktYXBwbHktZGV2LWludmVyc2lvbi1maXhlc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfUkVTRVRfREVWX0lOVkVSU0lPTl9GSVhFU1wiXSA9XHJcbiAgICAgICAgICAgIFwidWktcmVzZXQtZGV2LWludmVyc2lvbi1maXhlc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfQVBQTFlfREVWX1NUQVRJQ19USEVNRVNcIl0gPVxyXG4gICAgICAgICAgICBcInVpLWFwcGx5LWRldi1zdGF0aWMtdGhlbWVzXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9SRVNFVF9ERVZfU1RBVElDX1RIRU1FU1wiXSA9XHJcbiAgICAgICAgICAgIFwidWktcmVzZXQtZGV2LXN0YXRpYy10aGVtZXNcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIlVJX1NBVkVfRklMRVwiXSA9IFwidWktc2F2ZS1maWxlXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJVSV9SRVFVRVNUX0VYUE9SVF9DU1NcIl0gPSBcInVpLXJlcXVlc3QtZXhwb3J0LWNzc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiVUlfQ09MT1JfU0NIRU1FX0NIQU5HRVwiXSA9IFwidWktY29sb3Itc2NoZW1lLWNoYW5nZVwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfQ0hBTkdFU1wiXSA9IFwiYmctY2hhbmdlc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfQUREX0NTU19GSUxURVJcIl0gPSBcImJnLWFkZC1jc3MtZmlsdGVyXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJCR19BRERfU1RBVElDX1RIRU1FXCJdID0gXCJiZy1hZGQtc3RhdGljLXRoZW1lXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJCR19BRERfU1ZHX0ZJTFRFUlwiXSA9IFwiYmctYWRkLXN2Zy1maWx0ZXJcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkJHX0FERF9EWU5BTUlDX1RIRU1FXCJdID0gXCJiZy1hZGQtZHluYW1pYy10aGVtZVwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfRVhQT1JUX0NTU1wiXSA9IFwiYmctZXhwb3J0LWNzc1wiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfVU5TVVBQT1JURURfU0VOREVSXCJdID0gXCJiZy11bnN1cHBvcnRlZC1zZW5kZXJcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkJHX0NMRUFOX1VQXCJdID0gXCJiZy1jbGVhbi11cFwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfUkVMT0FEXCJdID0gXCJiZy1yZWxvYWRcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkJHX0ZFVENIX1JFU1BPTlNFXCJdID0gXCJiZy1mZXRjaC1yZXNwb25zZVwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQkdfVUlfVVBEQVRFXCJdID0gXCJiZy11aS11cGRhdGVcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkJHX0NTU19VUERBVEVcIl0gPSBcImJnLWNzcy11cGRhdGVcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkNTX0NPTE9SX1NDSEVNRV9DSEFOR0VcIl0gPSBcImNzLWNvbG9yLXNjaGVtZS1jaGFuZ2VcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkNTX0ZSQU1FX0NPTk5FQ1RcIl0gPSBcImNzLWZyYW1lLWNvbm5lY3RcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkNTX0ZSQU1FX0ZPUkdFVFwiXSA9IFwiY3MtZnJhbWUtZm9yZ2V0XCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJDU19GUkFNRV9GUkVFWkVcIl0gPSBcImNzLWZyYW1lLWZyZWV6ZVwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQ1NfRlJBTUVfUkVTVU1FXCJdID0gXCJjcy1mcmFtZS1yZXN1bWVcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkNTX0VYUE9SVF9DU1NfUkVTUE9OU0VcIl0gPSBcImNzLWV4cG9ydC1jc3MtcmVzcG9uc2VcIjtcclxuICAgICAgICBNZXNzYWdlVHlwZVtcIkNTX0ZFVENIXCJdID0gXCJjcy1mZXRjaFwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQ1NfREFSS19USEVNRV9ERVRFQ1RFRFwiXSA9IFwiY3MtZGFyay10aGVtZS1kZXRlY3RlZFwiO1xyXG4gICAgICAgIE1lc3NhZ2VUeXBlW1wiQ1NfREFSS19USEVNRV9OT1RfREVURUNURURcIl0gPVxyXG4gICAgICAgICAgICBcImNzLWRhcmstdGhlbWUtbm90LWRldGVjdGVkXCI7XHJcbiAgICAgICAgTWVzc2FnZVR5cGVbXCJDU19MT0dcIl0gPSBcImNzLWxvZ1wiO1xyXG4gICAgfSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcclxuXHJcbiAgICB2YXIgaXNOYXZpZ2F0b3JEZWZpbmVkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIjtcclxuICAgIHZhciB1c2VyQWdlbnQgPSBpc05hdmlnYXRvckRlZmluZWRcclxuICAgICAgICA/IG5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXHJcbiAgICAgICAgICBBcnJheS5pc0FycmF5KG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcylcclxuICAgICAgICAgICAgPyBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHNcclxuICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYnJhbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChicmFuZC5icmFuZC50b0xvd2VyQ2FzZSgpLCBcIiBcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGJyYW5kLnZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAuam9pbihcIiBcIilcclxuICAgICAgICAgICAgOiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKClcclxuICAgICAgICA6IFwic29tZSB1c2VyYWdlbnRcIjtcclxuICAgIHZhciBwbGF0Zm9ybSA9IGlzTmF2aWdhdG9yRGVmaW5lZFxyXG4gICAgICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiZcclxuICAgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5wbGF0Zm9ybSA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICA/IG5hdmlnYXRvci51c2VyQWdlbnREYXRhLnBsYXRmb3JtLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgOiBuYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIDogXCJzb21lIHBsYXRmb3JtXCI7XHJcbiAgICB2YXIgaXNDaHJvbWl1bSA9XHJcbiAgICAgICAgdXNlckFnZW50LmluY2x1ZGVzKFwiY2hyb21lXCIpIHx8IHVzZXJBZ2VudC5pbmNsdWRlcyhcImNocm9taXVtXCIpO1xyXG4gICAgdmFyIGlzVGh1bmRlcmJpcmQgPSB1c2VyQWdlbnQuaW5jbHVkZXMoXCJ0aHVuZGVyYmlyZFwiKTtcclxuICAgIHZhciBpc0ZpcmVmb3ggPVxyXG4gICAgICAgIHVzZXJBZ2VudC5pbmNsdWRlcyhcImZpcmVmb3hcIikgfHxcclxuICAgICAgICB1c2VyQWdlbnQuaW5jbHVkZXMoXCJsaWJyZXdvbGZcIikgfHxcclxuICAgICAgICBpc1RodW5kZXJiaXJkO1xyXG4gICAgdXNlckFnZW50LmluY2x1ZGVzKFwidml2YWxkaVwiKTtcclxuICAgIHVzZXJBZ2VudC5pbmNsdWRlcyhcInlhYnJvd3NlclwiKTtcclxuICAgIHVzZXJBZ2VudC5pbmNsdWRlcyhcIm9wclwiKSB8fCB1c2VyQWdlbnQuaW5jbHVkZXMoXCJvcGVyYVwiKTtcclxuICAgIHVzZXJBZ2VudC5pbmNsdWRlcyhcImVkZ1wiKTtcclxuICAgIHZhciBpc1NhZmFyaSA9IHVzZXJBZ2VudC5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhaXNDaHJvbWl1bTtcclxuICAgIHZhciBpc1dpbmRvd3MgPSBwbGF0Zm9ybS5zdGFydHNXaXRoKFwid2luXCIpO1xyXG4gICAgdmFyIGlzTWFjT1MgPSBwbGF0Zm9ybS5zdGFydHNXaXRoKFwibWFjXCIpO1xyXG4gICAgaXNOYXZpZ2F0b3JEZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnREYXRhXHJcbiAgICAgICAgPyBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5tb2JpbGVcclxuICAgICAgICA6IHVzZXJBZ2VudC5pbmNsdWRlcyhcIm1vYmlsZVwiKTtcclxuICAgIHZhciBpc1NoYWRvd0RvbVN1cHBvcnRlZCA9IHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICB2YXIgaXNNYXRjaE1lZGlhQ2hhbmdlRXZlbnRMaXN0ZW5lclN1cHBvcnRlZCA9XHJcbiAgICAgICAgdHlwZW9mIE1lZGlhUXVlcnlMaXN0ID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICB0eXBlb2YgTWVkaWFRdWVyeUxpc3QucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSB1c2VyQWdlbnQubWF0Y2goL2Nocm9tKD86ZXxpdW0pKD86XFwvfCApKFteIF0rKS8pO1xyXG4gICAgICAgIGlmIChtICYmIG1bMV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1bMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfSkoKTtcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSB1c2VyQWdlbnQubWF0Y2goLyg/OmZpcmVmb3h8bGlicmV3b2xmKSg/OlxcL3wgKShbXiBdKykvKTtcclxuICAgICAgICBpZiAobSAmJiBtWzFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0pKCk7XHJcbiAgICB2YXIgaXNEZWZpbmVkU2VsZWN0b3JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCI6ZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpO1xyXG4gICAgdmFyIGlzQ1NTQ29sb3JTY2hlbWVQcm9wU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yLXNjaGVtZTogZGFya1wiKTtcclxuICAgICAgICByZXR1cm4gZWwuc3R5bGUgJiYgZWwuc3R5bGUuY29sb3JTY2hlbWUgPT09IFwiZGFya1wiO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPS1Jlc3BvbnNlKHVybCwgbWltZVR5cGUsIG9yaWdpbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcImZvcmNlLWNhY2hlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IFwib21pdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVycmVyOiBvcmlnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJlZm94ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9PT0gXCJ0ZXh0L2Nzc1wiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwuc3RhcnRzV2l0aChcIm1vei1leHRlbnNpb246Ly9cIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5lbmRzV2l0aChcIi5jc3NcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KFwiQ29udGVudC1UeXBlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0YXJ0c1dpdGgobWltZVR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWltZSB0eXBlIG1pc21hdGNoIHdoZW4gbG9hZGluZyBcIi5jb25jYXQodXJsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHVybCwgXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIiBcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXNwb25zZS5zdGF0dXNUZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsb2FkQXNEYXRhVVJMKHVybCwgbWltZVR5cGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBnZXRPS1Jlc3BvbnNlKHVybCwgbWltZVR5cGUpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlYWRSZXNwb25zZUFzRGF0YVVSTChyZXNwb25zZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlYWRSZXNwb25zZUFzRGF0YVVSTChyZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJsb2IsIGRhdGFVUkw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzcG9uc2UuYmxvYigpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVUkwgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZGF0YVVSTF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0aHJvd0NPUlNFcnJvciA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFbWJlZGRlZCBEYXJrIFJlYWRlciBjYW5ub3QgYWNjZXNzIGEgY3Jvc3Mtb3JpZ2luIHJlc291cmNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT3ZlcnZpZXcgeW91ciBVUkxzIGFuZCBDT1JTIHBvbGljaWVzIG9yIHVzZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYERhcmtSZWFkZXIuc2V0RmV0Y2hNZXRob2QoZmV0Y2g6ICh1cmwpID0+IFByb21pc2U8UmVzcG9uc2U+KSlgLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU2VlIGlmIHVzaW5nIGBEYXJrUmVhZGVyLnNldEZldGNoTWV0aG9kKHdpbmRvdy5mZXRjaClgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiZWZvcmUgYERhcmtSZWFkZXIuZW5hYmxlKClgIHdvcmtzLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgZmV0Y2hlciA9IHRocm93Q09SU0Vycm9yO1xyXG4gICAgZnVuY3Rpb24gc2V0RmV0Y2hNZXRob2QkMShmZXRjaCkge1xyXG4gICAgICAgIGlmIChmZXRjaCkge1xyXG4gICAgICAgICAgICBmZXRjaGVyID0gZmV0Y2g7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZmV0Y2hlciA9IHRocm93Q09SU0Vycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNhbGxGZXRjaE1ldGhvZCh1cmwpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmV0Y2hlcih1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF3aW5kb3cuY2hyb21lKSB7XHJcbiAgICAgICAgd2luZG93LmNocm9tZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFjaHJvbWUucnVudGltZSkge1xyXG4gICAgICAgIGNocm9tZS5ydW50aW1lID0ge307XHJcbiAgICB9XHJcbiAgICB2YXIgbWVzc2FnZUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpZF8xLCBfYSwgdXJsLCByZXNwb25zZVR5cGUsIHJlc3BvbnNlLCB0ZXh0XzEsIGVycm9yXzE7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFyZ3NbMF0gJiYgYXJnc1swXS50eXBlID09PSBNZXNzYWdlVHlwZS5DU19GRVRDSCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF8xID0gYXJnc1swXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCA3LCAsIDhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYXJnc1swXS5kYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1cmwgPSBfYS51cmwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlVHlwZSA9IF9hLnJlc3BvbnNlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbEZldGNoTWV0aG9kKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlVHlwZSA9PT0gXCJkYXRhLXVybFwiKSkgcmV0dXJuIFszLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZWFkUmVzcG9uc2VBc0RhdGFVUkwocmVzcG9uc2UpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzcG9uc2UudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CR19GRVRDSF9SRVNQT05TRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XzEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQkdfRkVUQ0hfUkVTUE9OU0UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRfMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNZXNzYWdlTGlzdGVuZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBtZXNzYWdlTGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB2YXIgbmF0aXZlU2VuZE1lc3NhZ2VfMSA9IGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlO1xyXG4gICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICBuYXRpdmVTZW5kTWVzc2FnZV8xLmFwcGx5KGNocm9tZS5ydW50aW1lLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UpIHtcclxuICAgICAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UgPSB7fTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB2YXIgbmF0aXZlQWRkTGlzdGVuZXJfMSA9IGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcjtcclxuICAgICAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICBuYXRpdmVBZGRMaXN0ZW5lcl8xLmFwcGx5KGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGRNZXNzYWdlTGlzdGVuZXIoYXJnc1swXSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgVGhlbWVFbmdpbmU7XHJcbiAgICAoZnVuY3Rpb24gKFRoZW1lRW5naW5lKSB7XHJcbiAgICAgICAgVGhlbWVFbmdpbmVbXCJjc3NGaWx0ZXJcIl0gPSBcImNzc0ZpbHRlclwiO1xyXG4gICAgICAgIFRoZW1lRW5naW5lW1wic3ZnRmlsdGVyXCJdID0gXCJzdmdGaWx0ZXJcIjtcclxuICAgICAgICBUaGVtZUVuZ2luZVtcInN0YXRpY1RoZW1lXCJdID0gXCJzdGF0aWNUaGVtZVwiO1xyXG4gICAgICAgIFRoZW1lRW5naW5lW1wiZHluYW1pY1RoZW1lXCJdID0gXCJkeW5hbWljVGhlbWVcIjtcclxuICAgIH0pKFRoZW1lRW5naW5lIHx8IChUaGVtZUVuZ2luZSA9IHt9KSk7XHJcblxyXG4gICAgdmFyIEF1dG9tYXRpb25Nb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChBdXRvbWF0aW9uTW9kZSkge1xyXG4gICAgICAgIEF1dG9tYXRpb25Nb2RlW1wiTk9ORVwiXSA9IFwiXCI7XHJcbiAgICAgICAgQXV0b21hdGlvbk1vZGVbXCJUSU1FXCJdID0gXCJ0aW1lXCI7XHJcbiAgICAgICAgQXV0b21hdGlvbk1vZGVbXCJTWVNURU1cIl0gPSBcInN5c3RlbVwiO1xyXG4gICAgICAgIEF1dG9tYXRpb25Nb2RlW1wiTE9DQVRJT05cIl0gPSBcImxvY2F0aW9uXCI7XHJcbiAgICB9KShBdXRvbWF0aW9uTW9kZSB8fCAoQXV0b21hdGlvbk1vZGUgPSB7fSkpO1xyXG5cclxuICAgIHZhciBERUZBVUxUX0NPTE9SUyA9IHtcclxuICAgICAgICBkYXJrU2NoZW1lOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzE4MWExYlwiLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIiNlOGU2ZTNcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlnaHRTY2hlbWU6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjZGNkYWQ3XCIsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiIzE4MWExYlwiXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBERUZBVUxUX1RIRU1FID0ge1xyXG4gICAgICAgIG1vZGU6IDEsXHJcbiAgICAgICAgYnJpZ2h0bmVzczogMTAwLFxyXG4gICAgICAgIGNvbnRyYXN0OiAxMDAsXHJcbiAgICAgICAgZ3JheXNjYWxlOiAwLFxyXG4gICAgICAgIHNlcGlhOiAwLFxyXG4gICAgICAgIHVzZUZvbnQ6IGZhbHNlLFxyXG4gICAgICAgIGZvbnRGYW1pbHk6IGlzTWFjT1NcclxuICAgICAgICAgICAgPyBcIkhlbHZldGljYSBOZXVlXCJcclxuICAgICAgICAgICAgOiBpc1dpbmRvd3NcclxuICAgICAgICAgICAgPyBcIlNlZ29lIFVJXCJcclxuICAgICAgICAgICAgOiBcIk9wZW4gU2Fuc1wiLFxyXG4gICAgICAgIHRleHRTdHJva2U6IDAsXHJcbiAgICAgICAgZW5naW5lOiBUaGVtZUVuZ2luZS5keW5hbWljVGhlbWUsXHJcbiAgICAgICAgc3R5bGVzaGVldDogXCJcIixcclxuICAgICAgICBkYXJrU2NoZW1lQmFja2dyb3VuZENvbG9yOiBERUZBVUxUX0NPTE9SUy5kYXJrU2NoZW1lLmJhY2tncm91bmQsXHJcbiAgICAgICAgZGFya1NjaGVtZVRleHRDb2xvcjogREVGQVVMVF9DT0xPUlMuZGFya1NjaGVtZS50ZXh0LFxyXG4gICAgICAgIGxpZ2h0U2NoZW1lQmFja2dyb3VuZENvbG9yOiBERUZBVUxUX0NPTE9SUy5saWdodFNjaGVtZS5iYWNrZ3JvdW5kLFxyXG4gICAgICAgIGxpZ2h0U2NoZW1lVGV4dENvbG9yOiBERUZBVUxUX0NPTE9SUy5saWdodFNjaGVtZS50ZXh0LFxyXG4gICAgICAgIHNjcm9sbGJhckNvbG9yOiBpc01hY09TID8gXCJcIiA6IFwiYXV0b1wiLFxyXG4gICAgICAgIHNlbGVjdGlvbkNvbG9yOiBcImF1dG9cIixcclxuICAgICAgICBzdHlsZVN5c3RlbUNvbnRyb2xzOiAhaXNDU1NDb2xvclNjaGVtZVByb3BTdXBwb3J0ZWQsXHJcbiAgICAgICAgbGlnaHRDb2xvclNjaGVtZTogXCJEZWZhdWx0XCIsXHJcbiAgICAgICAgZGFya0NvbG9yU2NoZW1lOiBcIkRlZmF1bHRcIixcclxuICAgICAgICBpbW1lZGlhdGVNb2RpZnk6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgKHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGZldGNoTmV3czogdHJ1ZSxcclxuICAgICAgICB0aGVtZTogREVGQVVMVF9USEVNRSxcclxuICAgICAgICBwcmVzZXRzOiBbXSxcclxuICAgICAgICBjdXN0b21UaGVtZXM6IFtdLFxyXG4gICAgICAgIHNpdGVMaXN0OiBbXSxcclxuICAgICAgICBzaXRlTGlzdEVuYWJsZWQ6IFtdLFxyXG4gICAgICAgIGFwcGx5VG9MaXN0ZWRPbmx5OiBmYWxzZSxcclxuICAgICAgICBjaGFuZ2VCcm93c2VyVGhlbWU6IGZhbHNlLFxyXG4gICAgICAgIHN5bmNTZXR0aW5nczogdHJ1ZSxcclxuICAgICAgICBzeW5jU2l0ZXNGaXhlczogZmFsc2UsXHJcbiAgICAgICAgYXV0b21hdGlvbjoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogQXV0b21hdGlvbk1vZGUuTk9ORSxcclxuICAgICAgICAgICAgYmVoYXZpb3I6IFwiT25PZmZcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZToge1xyXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBcIjE4OjAwXCIsXHJcbiAgICAgICAgICAgIGRlYWN0aXZhdGlvbjogXCI5OjAwXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvY2F0aW9uOiB7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBudWxsLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXZpZXdOZXdEZXNpZ246IGZhbHNlLFxyXG4gICAgICAgIGVuYWJsZUZvclBERjogdHJ1ZSxcclxuICAgICAgICBlbmFibGVGb3JQcm90ZWN0ZWRQYWdlczogZmFsc2UsXHJcbiAgICAgICAgZW5hYmxlQ29udGV4dE1lbnVzOiBmYWxzZSxcclxuICAgICAgICBkZXRlY3REYXJrVGhlbWU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShpdGVtcykge1xyXG4gICAgICAgIHJldHVybiBpdGVtcy5sZW5ndGggIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goaXRlbXMsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGl0ZW1zKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGl0ZW1zW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtc18xID0gX192YWx1ZXMoaXRlbXMpLCBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAhaXRlbXNfMV8xLmRvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNfMV8xID0gaXRlbXNfMS5uZXh0KClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xyXG4gICAgICAgICAgICAgICAgZV8xID0ge2Vycm9yOiBlXzFfMX07XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtc18xXzEgJiYgIWl0ZW1zXzFfMS5kb25lICYmIChfYSA9IGl0ZW1zXzEucmV0dXJuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EuY2FsbChpdGVtc18xKTtcclxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaChhcnJheSwgYWRkaXRpb24pIHtcclxuICAgICAgICBmb3JFYWNoKGFkZGl0aW9uLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXkucHVzaChhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvQXJyYXkoaXRlbXMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2dJbmZvKCkge31cclxuICAgIGZ1bmN0aW9uIGxvZ1dhcm4oKSB7fVxyXG5cclxuICAgIGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZnJhbWVJZCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGxhc3RBcmdzO1xyXG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVJZCkge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGxhc3RBcmdzKSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobGFzdEFyZ3MpLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcclxuICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmcmFtZUlkID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRocm90dGxlZCwge2NhbmNlbDogY2FuY2VsfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBc3luY1Rhc2tzUXVldWUoKSB7XHJcbiAgICAgICAgdmFyIHRhc2tzID0gW107XHJcbiAgICAgICAgdmFyIGZyYW1lSWQgPSBudWxsO1xyXG4gICAgICAgIGZ1bmN0aW9uIHJ1blRhc2tzKCkge1xyXG4gICAgICAgICAgICB2YXIgdGFzaztcclxuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gdGFza3Muc2hpZnQoKSkpIHtcclxuICAgICAgICAgICAgICAgIHRhc2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFtZUlkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gYWRkKHRhc2spIHtcclxuICAgICAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcclxuICAgICAgICAgICAgaWYgKCFmcmFtZUlkKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1blRhc2tzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XHJcbiAgICAgICAgICAgIHRhc2tzLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XHJcbiAgICAgICAgICAgIGZyYW1lSWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge2FkZDogYWRkLCBjYW5jZWw6IGNhbmNlbH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RHVyYXRpb24odGltZSkge1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgaWYgKHRpbWUuc2Vjb25kcykge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiArPSB0aW1lLnNlY29uZHMgKiAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZS5taW51dGVzKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uICs9IHRpbWUubWludXRlcyAqIDYwICogMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbWUuaG91cnMpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gKz0gdGltZS5ob3VycyAqIDYwICogNjAgKiAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZS5kYXlzKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uICs9IHRpbWUuZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcclxuICAgICAgICBub2RlICYmIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3YXRjaEZvck5vZGVQb3NpdGlvbihub2RlLCBtb2RlLCBvblJlc3RvcmUpIHtcclxuICAgICAgICBpZiAob25SZXN0b3JlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgb25SZXN0b3JlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgTUFYX0FUVEVNUFRTX0NPVU5UID0gMTA7XHJcbiAgICAgICAgdmFyIFJFVFJZX1RJTUVPVVQgPSBnZXREdXJhdGlvbih7c2Vjb25kczogMn0pO1xyXG4gICAgICAgIHZhciBBVFRFTVBUU19JTlRFUlZBTCA9IGdldER1cmF0aW9uKHtzZWNvbmRzOiAxMH0pO1xyXG4gICAgICAgIHZhciBwcmV2U2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJVbmFibGUgdG8gd2F0Y2ggZm9yIG5vZGUgcG9zaXRpb246IHBhcmVudCBlbGVtZW50IG5vdCBmb3VuZFwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlID09PSBcInByZXYtc2libGluZ1wiICYmICFwcmV2U2libGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byB3YXRjaCBmb3Igbm9kZSBwb3NpdGlvbjogdGhlcmUgaXMgbm8gcHJldmlvdXMgc2libGluZ1wiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB2YXIgdGltZW91dElkID0gbnVsbDtcclxuICAgICAgICB2YXIgcmVzdG9yZSA9IHRocm90dGxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0dGVtcHRzKys7XHJcbiAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBub3c7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ZW1wdHMgPj0gTUFYX0FUVEVNUFRTX0NPVU5UKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93IC0gc3RhcnQgPCBBVFRFTVBUU19JTlRFUlZBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIFJFVFJZX1RJTUVPVVQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbm93O1xyXG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInBhcmVudFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcgJiYgcHJldlNpYmxpbmcucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJwcmV2LXNpYmxpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaWJsaW5nLnBhcmVudE5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFyZW50KHByZXZTaWJsaW5nLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoXHJcbiAgICAgICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPyBwcmV2U2libGluZy5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XHJcbiAgICAgICAgICAgIG9uUmVzdG9yZSAmJiBvblJlc3RvcmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChtb2RlID09PSBcInBhcmVudFwiICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgKG1vZGUgPT09IFwicHJldi1zaWJsaW5nXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnByZXZpb3VzU2libGluZyAhPT0gcHJldlNpYmxpbmcpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShwYXJlbnQsIHtjaGlsZExpc3Q6IHRydWV9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICByZXN0b3JlLmNhbmNlbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNraXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdXBkYXRlUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICBydW4oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJ1bigpO1xyXG4gICAgICAgIHJldHVybiB7cnVuOiBydW4sIHN0b3A6IHN0b3AsIHNraXA6IHNraXB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZVNoYWRvd0hvc3RzKHJvb3QsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHJvb3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XHJcbiAgICAgICAgICAgIGFjY2VwdE5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zaGFkb3dSb290ID09IG51bGxcclxuICAgICAgICAgICAgICAgICAgICA/IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVBcclxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgIHZhciBub2RlID0gcm9vdC5zaGFkb3dSb290ID8gd2Fsa2VyLmN1cnJlbnROb2RlIDogd2Fsa2VyLm5leHROb2RlKCk7XHJcbiAgICAgICAgICAgIG5vZGUgIT0gbnVsbDtcclxuICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhcInN1cmZpbmdrZXlzX2hpbnRzX2hvc3RcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKG5vZGUpO1xyXG4gICAgICAgICAgICBpdGVyYXRlU2hhZG93SG9zdHMobm9kZS5zaGFkb3dSb290LCBpdGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGlzRE9NUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIlxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc2V0SXNET01SZWFkeShuZXdGdW5jKSB7XHJcbiAgICAgICAgaXNET01SZWFkeSA9IG5ld0Z1bmM7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVhZHlTdGF0ZUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgIGZ1bmN0aW9uIGFkZERPTVJlYWR5TGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICBpc0RPTVJlYWR5KCkgPyBsaXN0ZW5lcigpIDogcmVhZHlTdGF0ZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlRE9NUmVhZHlMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHJlYWR5U3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzUmVhZHlTdGF0ZUNvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCI7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVhZHlTdGF0ZUNvbXBsZXRlTGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgZnVuY3Rpb24gYWRkUmVhZHlTdGF0ZUNvbXBsZXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICBpc1JlYWR5U3RhdGVDb21wbGV0ZSgpXHJcbiAgICAgICAgICAgID8gbGlzdGVuZXIoKVxyXG4gICAgICAgICAgICA6IHJlYWR5U3RhdGVDb21wbGV0ZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYW5SZWFkeVN0YXRlQ29tcGxldGVMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgcmVhZHlTdGF0ZUNvbXBsZXRlTGlzdGVuZXJzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRE9NUmVhZHkoKSkge1xyXG4gICAgICAgIHZhciBvblJlYWR5U3RhdGVDaGFuZ2VfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGlzRE9NUmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVhZHlTdGF0ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZWFkeVN0YXRlTGlzdGVuZXJzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFkeVN0YXRlQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVhZHlzdGF0ZWNoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlYWR5U3RhdGVDaGFuZ2VfMVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZUNvbXBsZXRlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGVDb21wbGV0ZUxpc3RlbmVycy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBvblJlYWR5U3RhdGVDaGFuZ2VfMSk7XHJcbiAgICB9XHJcbiAgICB2YXIgSFVHRV9NVVRBVElPTlNfQ09VTlQgPSAxMDAwO1xyXG4gICAgZnVuY3Rpb24gaXNIdWdlTXV0YXRpb24obXV0YXRpb25zKSB7XHJcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiBIVUdFX01VVEFUSU9OU19DT1VOVCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFkZGVkTm9kZXNDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWRkZWROb2Rlc0NvdW50ICs9IG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGFkZGVkTm9kZXNDb3VudCA+IEhVR0VfTVVUQVRJT05TX0NPVU5UKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50c1RyZWVPcGVyYXRpb25zKG11dGF0aW9ucykge1xyXG4gICAgICAgIHZhciBhZGRpdGlvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIGRlbGV0aW9ucyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB2YXIgbW92ZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgZm9yRWFjaChtLmFkZGVkTm9kZXMsIGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgbi5pc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5hZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3JFYWNoKG0ucmVtb3ZlZE5vZGVzLCBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZXMuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMuZGVsZXRlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucy5hZGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZHVwbGljYXRlQWRkaXRpb25zID0gW107XHJcbiAgICAgICAgdmFyIGR1cGxpY2F0ZURlbGV0aW9ucyA9IFtdO1xyXG4gICAgICAgIGFkZGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGRpdGlvbnMuaGFzKG5vZGUucGFyZW50RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUFkZGl0aW9ucy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGVsZXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKGRlbGV0aW9ucy5oYXMobm9kZS5wYXJlbnRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgZHVwbGljYXRlRGVsZXRpb25zLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkdXBsaWNhdGVBZGRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkaXRpb25zLmRlbGV0ZShub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkdXBsaWNhdGVEZWxldGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVsZXRpb25zLmRlbGV0ZShub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge2FkZGl0aW9uczogYWRkaXRpb25zLCBtb3ZlczogbW92ZXMsIGRlbGV0aW9uczogZGVsZXRpb25zfTtcclxuICAgIH1cclxuICAgIHZhciBvcHRpbWl6ZWRUcmVlT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIG9wdGltaXplZFRyZWVDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW1pemVkVHJlZU9ic2VydmVyKHJvb3QsIGNhbGxiYWNrcykge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcjtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJDYWxsYmFja3M7XHJcbiAgICAgICAgdmFyIGRvbVJlYWR5TGlzdGVuZXI7XHJcbiAgICAgICAgaWYgKG9wdGltaXplZFRyZWVPYnNlcnZlcnMuaGFzKHJvb3QpKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0gb3B0aW1pemVkVHJlZU9ic2VydmVycy5nZXQocm9vdCk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyQ2FsbGJhY2tzID0gb3B0aW1pemVkVHJlZUNhbGxiYWNrcy5nZXQob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoYWRIdWdlTXV0YXRpb25zQmVmb3JlXzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHN1YnNjcmliZWRGb3JSZWFkeVN0YXRlXzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIdWdlTXV0YXRpb24obXV0YXRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFkSHVnZU11dGF0aW9uc0JlZm9yZV8xIHx8IGlzRE9NUmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlckNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uSHVnZU11dGF0aW9ucyA9IF9hLm9uSHVnZU11dGF0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbkh1Z2VNdXRhdGlvbnMocm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN1YnNjcmliZWRGb3JSZWFkeVN0YXRlXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUmVhZHlMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlckNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkh1Z2VNdXRhdGlvbnMgPSBfYS5vbkh1Z2VNdXRhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uSHVnZU11dGF0aW9ucyhyb290KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRET01SZWFkeUxpc3RlbmVyKGRvbVJlYWR5TGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVkRm9yUmVhZHlTdGF0ZV8xID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaGFkSHVnZU11dGF0aW9uc0JlZm9yZV8xID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzT3BlcmF0aW9uc18xID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudHNUcmVlT3BlcmF0aW9ucyhtdXRhdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbk1pbm9yTXV0YXRpb25zID0gX2Eub25NaW5vck11dGF0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTWlub3JNdXRhdGlvbnMoZWxlbWVudHNPcGVyYXRpb25zXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XHJcbiAgICAgICAgICAgIG9wdGltaXplZFRyZWVPYnNlcnZlcnMuc2V0KHJvb3QsIG9ic2VydmVyKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJDYWxsYmFja3MgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIG9wdGltaXplZFRyZWVDYWxsYmFja3Muc2V0KG9ic2VydmVyLCBvYnNlcnZlckNhbGxiYWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmVyQ2FsbGJhY2tzLmFkZChjYWxsYmFja3MpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFja3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVJlYWR5TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVET01SZWFkeUxpc3RlbmVyKGRvbVJlYWR5TGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVkVHJlZUNhbGxiYWNrcy5kZWxldGUob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGltaXplZFRyZWVPYnNlcnZlcnMuZGVsZXRlKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYW5jaG9yO1xyXG4gICAgdmFyIHBhcnNlZFVSTENhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gZml4QmFzZVVSTCgkdXJsKSB7XHJcbiAgICAgICAgaWYgKCFhbmNob3IpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuY2hvci5ocmVmID0gJHVybDtcclxuICAgICAgICByZXR1cm4gYW5jaG9yLmhyZWY7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZVVSTCgkdXJsLCAkYmFzZSkge1xyXG4gICAgICAgIGlmICgkYmFzZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICRiYXNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KCR1cmwpLmNvbmNhdCgkYmFzZSA/IFwiO1wiLmNvbmNhdCgkYmFzZSkgOiBcIlwiKTtcclxuICAgICAgICBpZiAocGFyc2VkVVJMQ2FjaGUuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVSTENhY2hlLmdldChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJGJhc2UpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlZFVSTF8xID0gbmV3IFVSTCgkdXJsLCBmaXhCYXNlVVJMKCRiYXNlKSk7XHJcbiAgICAgICAgICAgIHBhcnNlZFVSTENhY2hlLnNldChrZXksIHBhcnNlZFVSTF8xKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVSTF8xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyc2VkVVJMID0gbmV3IFVSTChmaXhCYXNlVVJMKCR1cmwpKTtcclxuICAgICAgICBwYXJzZWRVUkxDYWNoZS5zZXQoJHVybCwgcGFyc2VkVVJMKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VkVVJMO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0QWJzb2x1dGVVUkwoJGJhc2UsICRyZWxhdGl2ZSkge1xyXG4gICAgICAgIGlmICgkcmVsYXRpdmUubWF0Y2goL15kYXRhXFxcXD9cXDovKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJHJlbGF0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL15cXC9cXC8vLnRlc3QoJHJlbGF0aXZlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobG9jYXRpb24ucHJvdG9jb2wpLmNvbmNhdCgkcmVsYXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IHBhcnNlVVJMKCRiYXNlKTtcclxuICAgICAgICB2YXIgYSA9IHBhcnNlVVJMKCRyZWxhdGl2ZSwgYi5ocmVmKTtcclxuICAgICAgICByZXR1cm4gYS5ocmVmO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNSZWxhdGl2ZUhyZWZPbkFic29sdXRlUGF0aChocmVmKSB7XHJcbiAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsID0gcGFyc2VVUkwoaHJlZik7XHJcbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gbG9jYXRpb24ucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmwucG9ydCAhPT0gbG9jYXRpb24ucG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmwucGF0aG5hbWUgPT09IGxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVDU1NSdWxlcyhydWxlcywgaXRlcmF0ZSwgb25NZWRpYVJ1bGVFcnJvcikge1xyXG4gICAgICAgIGZvckVhY2gocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0ZShydWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLmhyZWYpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUNTU1J1bGVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlU2hlZXQuY3NzUnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTWVkaWFSdWxlRXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nSW5mbyhcIkZvdW5kIGEgbm9uLWxvYWRlZCBsaW5rLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBvbk1lZGlhUnVsZUVycm9yICYmIG9uTWVkaWFSdWxlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLm1lZGlhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSBBcnJheS5mcm9tKHJ1bGUubWVkaWEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzU2NyZWVuT3JBbGxPclF1ZXJ5ID0gbWVkaWEuc29tZShmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc3RhcnRzV2l0aChcInNjcmVlblwiKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0YXJ0c1dpdGgoXCJhbGxcIikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zdGFydHNXaXRoKFwiKFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1ByaW50T3JTcGVlY2ggPSBtZWRpYS5zb21lKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uc3RhcnRzV2l0aChcInByaW50XCIpIHx8IG0uc3RhcnRzV2l0aChcInNwZWVjaFwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2NyZWVuT3JBbGxPclF1ZXJ5IHx8ICFpc1ByaW50T3JTcGVlY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlQ1NTUnVsZXMocnVsZS5jc3NSdWxlcywgaXRlcmF0ZSwgb25NZWRpYVJ1bGVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5jb25kaXRpb25UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ1NTLnN1cHBvcnRzKHJ1bGUuY29uZGl0aW9uVGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlQ1NTUnVsZXMocnVsZS5jc3NSdWxlcywgaXRlcmF0ZSwgb25NZWRpYVJ1bGVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2dXYXJuKFwiQ1NTUnVsZSB0eXBlIG5vdCBzdXBwb3J0ZWRcIiwgcnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBzaG9ydGhhbmRWYXJEZXBlbmRhbnRQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgIFwiYmFja2dyb3VuZFwiLFxyXG4gICAgICAgIFwiYm9yZGVyXCIsXHJcbiAgICAgICAgXCJib3JkZXItY29sb3JcIixcclxuICAgICAgICBcImJvcmRlci1ib3R0b21cIixcclxuICAgICAgICBcImJvcmRlci1sZWZ0XCIsXHJcbiAgICAgICAgXCJib3JkZXItcmlnaHRcIixcclxuICAgICAgICBcImJvcmRlci10b3BcIixcclxuICAgICAgICBcIm91dGxpbmVcIixcclxuICAgICAgICBcIm91dGxpbmUtY29sb3JcIlxyXG4gICAgXTtcclxuICAgIHZhciBzaG9ydGhhbmRWYXJEZXBQcm9wUmVnZXhwcyA9IGlzU2FmYXJpXHJcbiAgICAgICAgPyBzaG9ydGhhbmRWYXJEZXBlbmRhbnRQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHByb3AsIFwiOlxcXFxzKiguKj8pXFxcXHMqO1wiKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtwcm9wLCByZWdleHBdO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBmdW5jdGlvbiBpdGVyYXRlQ1NTRGVjbGFyYXRpb25zKHN0eWxlLCBpdGVyYXRlKSB7XHJcbiAgICAgICAgZm9yRWFjaChzdHlsZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZXJhdGUocHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQ7XHJcbiAgICAgICAgaWYgKGNzc1RleHQuaW5jbHVkZXMoXCJ2YXIoXCIpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kVmFyRGVwUHJvcFJlZ2V4cHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gX2JbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGNzc1RleHQubWF0Y2gocmVnZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1hdGNoWzFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZShwcm9wLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kVmFyRGVwZW5kYW50UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuaW5jbHVkZXMoXCJ2YXIoXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUocHJvcCwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBjc3NVUkxSZWdleCA9IC91cmxcXCgoKCcuKj8nKXwoXCIuKj9cIil8KFteXFwpXSo/KSlcXCkvZztcclxuICAgIHZhciBjc3NJbXBvcnRSZWdleCA9XHJcbiAgICAgICAgL0BpbXBvcnRcXHMqKHVybFxcKCk/KCgnLis/Jyl8KFwiLis/XCIpfChbXlxcKV0qPykpXFwpPyA/KHNjcmVlbik/Oz8vZ2k7XHJcbiAgICBmdW5jdGlvbiBnZXRDU1NVUkxWYWx1ZShjc3NVUkwpIHtcclxuICAgICAgICByZXR1cm4gY3NzVVJMXHJcbiAgICAgICAgICAgIC50cmltKClcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXG5cXHJcXFxcXSsvZywgXCJcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL151cmxcXCgoLiopXFwpJC8sIFwiJDFcIilcclxuICAgICAgICAgICAgLnRyaW0oKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKD86XFxcXCguKSkvZywgXCIkMVwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENTU0Jhc2VCYXRoKHVybCkge1xyXG4gICAgICAgIHZhciBjc3NVUkwgPSBwYXJzZVVSTCh1cmwpO1xyXG4gICAgICAgIHJldHVybiBcIlwiXHJcbiAgICAgICAgICAgIC5jb25jYXQoY3NzVVJMLm9yaWdpbilcclxuICAgICAgICAgICAgLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIGNzc1VSTC5wYXRobmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXFwvKShbXlxcL10rKSQvaSwgXCIkMVwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNTU1JlbGF0aXZlVVJMc1dpdGhBYnNvbHV0ZSgkY3NzLCBjc3NCYXNlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiAkY3NzLnJlcGxhY2UoY3NzVVJMUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gZ2V0Q1NTVVJMVmFsdWUobWF0Y2gpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidXJsKCdcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWJzb2x1dGVVUkwoY3NzQmFzZVBhdGgsIHBhdGhWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgXCInKVwiXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGNzc0NvbW1lbnRzUmVnZXggPSAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nO1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ1NTQ29tbWVudHMoJGNzcykge1xyXG4gICAgICAgIHJldHVybiAkY3NzLnJlcGxhY2UoY3NzQ29tbWVudHNSZWdleCwgXCJcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgZm9udEZhY2VSZWdleCA9IC9AZm9udC1mYWNlXFxzKntbXn1dKn0vZztcclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VDU1NGb250RmFjZSgkY3NzKSB7XHJcbiAgICAgICAgcmV0dXJuICRjc3MucmVwbGFjZShmb250RmFjZVJlZ2V4LCBcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBldmFsTWF0aChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIHJwblN0YWNrID0gW107XHJcbiAgICAgICAgdmFyIHdvcmtpbmdTdGFjayA9IFtdO1xyXG4gICAgICAgIHZhciBsYXN0VG9rZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cHJlc3Npb24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gZXhwcmVzc2lvbltpXTtcclxuICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbiA9PT0gXCIgXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaGFzKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wID0gb3BlcmF0b3JzLmdldCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAod29ya2luZ1N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50T3AgPSBvcGVyYXRvcnMuZ2V0KHdvcmtpbmdTdGFja1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50T3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5sZXNzT3JFcXVhbFRoYW4oY3VycmVudE9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBycG5TdGFjay5wdXNoKHdvcmtpbmdTdGFjay5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3b3JraW5nU3RhY2sudW5zaGlmdCh0b2tlbik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxhc3RUb2tlbiB8fCBvcGVyYXRvcnMuaGFzKGxhc3RUb2tlbikpIHtcclxuICAgICAgICAgICAgICAgIHJwblN0YWNrLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcnBuU3RhY2tbcnBuU3RhY2subGVuZ3RoIC0gMV0gKz0gdG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJwblN0YWNrLnB1c2guYXBwbHkoXHJcbiAgICAgICAgICAgIHJwblN0YWNrLFxyXG4gICAgICAgICAgICBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQod29ya2luZ1N0YWNrKSwgZmFsc2UpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcnBuU3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9wID0gb3BlcmF0b3JzLmdldChycG5TdGFja1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChvcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzdGFjay5zcGxpY2UoMCwgMik7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG9wLmV4ZWMoYXJnc1sxXSwgYXJnc1swXSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdChwYXJzZUZsb2F0KHJwblN0YWNrW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xyXG4gICAgfVxyXG4gICAgdmFyIE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBPcGVyYXRvcihwcmVjZWRlbmNlLCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVjZW5kY2UgPSBwcmVjZWRlbmNlO1xyXG4gICAgICAgICAgICB0aGlzLmV4ZWNNZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9wZXJhdG9yLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWNNZXRob2QobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT3BlcmF0b3IucHJvdG90eXBlLmxlc3NPckVxdWFsVGhhbiA9IGZ1bmN0aW9uIChvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVjZW5kY2UgPD0gb3AucHJlY2VuZGNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9wZXJhdG9yO1xyXG4gICAgfSkoKTtcclxuICAgIHZhciBvcGVyYXRvcnMgPSBuZXcgTWFwKFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIFwiK1wiLFxyXG4gICAgICAgICAgICBuZXcgT3BlcmF0b3IoMSwgZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBcIi1cIixcclxuICAgICAgICAgICAgbmV3IE9wZXJhdG9yKDEsIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICBdLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgXCIqXCIsXHJcbiAgICAgICAgICAgIG5ldyBPcGVyYXRvcigyLCBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIFwiL1wiLFxyXG4gICAgICAgICAgICBuZXcgT3BlcmF0b3IoMiwgZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF1cclxuICAgIF0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1hdGNoZXMocmVnZXgsIGlucHV0LCBncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGdyb3VwID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcclxuICAgICAgICB2YXIgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSByZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG1bZ3JvdXBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRDU1ModGV4dCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZW50KGRlcHRoKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiIFwiLnJlcGVhdCg0ICogZGVwdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPCA1MDAwMCkge1xyXG4gICAgICAgICAgICB2YXIgZW1wdHlSdWxlUmVnZXhwID0gL1tee31dK3tcXHMqfS87XHJcbiAgICAgICAgICAgIHdoaWxlIChlbXB0eVJ1bGVSZWdleHAudGVzdCh0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShlbXB0eVJ1bGVSZWdleHAsIFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjc3MgPSB0ZXh0XHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHN7Mix9L2csIFwiIFwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx7L2csIFwie1xcblwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx9L2csIFwiXFxufVxcblwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw7KD8hW15cXCh8XFxcIl0qKFxcKXxcXFwiKSkvZywgXCI7XFxuXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCwoPyFbXlxcKHxcXFwiXSooXFwpfFxcXCIpKS9nLCBcIixcXG5cIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxccypcXG4vZywgXCJcXG5cIilcclxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwLCBsZW4gPSBjc3MubGVuZ3RoOyB4IDwgbGVuOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSBcIlwiLmNvbmNhdChjc3NbeF0sIFwiXFxuXCIpO1xyXG4gICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcyhcIntcIikpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5wdXNoKGdldEluZGVudChkZXB0aCsrKSArIHRyaW1MZWZ0KGxpbmUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKFwifVwiKSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2goZ2V0SW5kZW50KC0tZGVwdGgpICsgdHJpbUxlZnQobGluZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkLnB1c2goZ2V0SW5kZW50KGRlcHRoKSArIHRyaW1MZWZ0KGxpbmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkLmpvaW4oXCJcIikudHJpbSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50aGVzZXNSYW5nZShpbnB1dCwgc2VhcmNoU3RhcnRJbmRleCkge1xyXG4gICAgICAgIGlmIChzZWFyY2hTdGFydEluZGV4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2VhcmNoU3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcclxuICAgICAgICB2YXIgZmlyc3RPcGVuSW5kZXggPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gc2VhcmNoU3RhcnRJbmRleDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZW5JbmRleCA9IGlucHV0LmluZGV4T2YoXCIoXCIsIGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5JbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpcnN0T3BlbkluZGV4ID0gb3BlbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICAgICAgICAgIGkgPSBvcGVuSW5kZXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2luZ0luZGV4ID0gaW5wdXQuaW5kZXhPZihcIilcIiwgaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ0luZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9wZW5JbmRleCA9IGlucHV0LmluZGV4T2YoXCIoXCIsIGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5JbmRleCA8IDAgfHwgY2xvc2luZ0luZGV4IDwgb3BlbkluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzdGFydDogZmlyc3RPcGVuSW5kZXgsIGVuZDogY2xvc2luZ0luZGV4ICsgMX07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjbG9zaW5nSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IG9wZW5JbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaHNsYVBhcnNlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgcmdiYVBhcnNlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yV2l0aENhY2hlKCRjb2xvcikge1xyXG4gICAgICAgICRjb2xvciA9ICRjb2xvci50cmltKCk7XHJcbiAgICAgICAgaWYgKHJnYmFQYXJzZUNhY2hlLmhhcygkY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhUGFyc2VDYWNoZS5nZXQoJGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCRjb2xvci5pbmNsdWRlcyhcImNhbGMoXCIpKSB7XHJcbiAgICAgICAgICAgICRjb2xvciA9IGxvd2VyQ2FsY0V4cHJlc3Npb24oJGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbG9yID0gcGFyc2UoJGNvbG9yKTtcclxuICAgICAgICBjb2xvciAmJiByZ2JhUGFyc2VDYWNoZS5zZXQoJGNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VUb0hTTFdpdGhDYWNoZShjb2xvcikge1xyXG4gICAgICAgIGlmIChoc2xhUGFyc2VDYWNoZS5oYXMoY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhUGFyc2VDYWNoZS5nZXQoY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmdiID0gcGFyc2VDb2xvcldpdGhDYWNoZShjb2xvcik7XHJcbiAgICAgICAgaWYgKCFyZ2IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hTTChyZ2IpO1xyXG4gICAgICAgIGhzbGFQYXJzZUNhY2hlLnNldChjb2xvciwgaHNsKTtcclxuICAgICAgICByZXR1cm4gaHNsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJDb2xvckNhY2hlKCkge1xyXG4gICAgICAgIGhzbGFQYXJzZUNhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgcmdiYVBhcnNlQ2FjaGUuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhzbFRvUkdCKF9hKSB7XHJcbiAgICAgICAgdmFyIGggPSBfYS5oLFxyXG4gICAgICAgICAgICBzID0gX2EucyxcclxuICAgICAgICAgICAgbCA9IF9hLmwsXHJcbiAgICAgICAgICAgIF9iID0gX2EuYSxcclxuICAgICAgICAgICAgYSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2I7XHJcbiAgICAgICAgaWYgKHMgPT09IDApIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKFxyXG4gICAgICAgICAgICAgICAgICAgIFtsLCBsLCBsXS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDI1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIHJfMSA9IF9jWzBdLFxyXG4gICAgICAgICAgICAgICAgYl8xID0gX2NbMV0sXHJcbiAgICAgICAgICAgICAgICBnXzEgPSBfY1syXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtyOiByXzEsIGc6IGdfMSwgYjogYl8xLCBhOiBhfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpICogcztcclxuICAgICAgICB2YXIgeCA9IGMgKiAoMSAtIE1hdGguYWJzKCgoaCAvIDYwKSAlIDIpIC0gMSkpO1xyXG4gICAgICAgIHZhciBtID0gbCAtIGMgLyAyO1xyXG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChcclxuICAgICAgICAgICAgICAgIChoIDwgNjBcclxuICAgICAgICAgICAgICAgICAgICA/IFtjLCB4LCAwXVxyXG4gICAgICAgICAgICAgICAgICAgIDogaCA8IDEyMFxyXG4gICAgICAgICAgICAgICAgICAgID8gW3gsIGMsIDBdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoIDwgMTgwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbMCwgYywgeF1cclxuICAgICAgICAgICAgICAgICAgICA6IGggPCAyNDBcclxuICAgICAgICAgICAgICAgICAgICA/IFswLCB4LCBjXVxyXG4gICAgICAgICAgICAgICAgICAgIDogaCA8IDMwMFxyXG4gICAgICAgICAgICAgICAgICAgID8gW3gsIDAsIGNdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbYywgMCwgeF1cclxuICAgICAgICAgICAgICAgICkubWFwKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKG4gKyBtKSAqIDI1NSk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgciA9IF9kWzBdLFxyXG4gICAgICAgICAgICBnID0gX2RbMV0sXHJcbiAgICAgICAgICAgIGIgPSBfZFsyXTtcclxuICAgICAgICByZXR1cm4ge3I6IHIsIGc6IGcsIGI6IGIsIGE6IGF9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmdiVG9IU0woX2EpIHtcclxuICAgICAgICB2YXIgcjI1NSA9IF9hLnIsXHJcbiAgICAgICAgICAgIGcyNTUgPSBfYS5nLFxyXG4gICAgICAgICAgICBiMjU1ID0gX2EuYixcclxuICAgICAgICAgICAgX2IgPSBfYS5hLFxyXG4gICAgICAgICAgICBhID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYjtcclxuICAgICAgICB2YXIgciA9IHIyNTUgLyAyNTU7XHJcbiAgICAgICAgdmFyIGcgPSBnMjU1IC8gMjU1O1xyXG4gICAgICAgIHZhciBiID0gYjI1NSAvIDI1NTtcclxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgIHZhciBjID0gbWF4IC0gbWluO1xyXG4gICAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgIGlmIChjID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7aDogMCwgczogMCwgbDogbCwgYTogYX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoID1cclxuICAgICAgICAgICAgKG1heCA9PT0gclxyXG4gICAgICAgICAgICAgICAgPyAoKGcgLSBiKSAvIGMpICUgNlxyXG4gICAgICAgICAgICAgICAgOiBtYXggPT09IGdcclxuICAgICAgICAgICAgICAgID8gKGIgLSByKSAvIGMgKyAyXHJcbiAgICAgICAgICAgICAgICA6IChyIC0gZykgLyBjICsgNCkgKiA2MDtcclxuICAgICAgICBpZiAoaCA8IDApIHtcclxuICAgICAgICAgICAgaCArPSAzNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzID0gYyAvICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSk7XHJcbiAgICAgICAgcmV0dXJuIHtoOiBoLCBzOiBzLCBsOiBsLCBhOiBhfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvRml4ZWQobiwgZGlnaXRzKSB7XHJcbiAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXhlZCA9IG4udG9GaXhlZChkaWdpdHMpO1xyXG4gICAgICAgIGlmIChkaWdpdHMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZG90ID0gZml4ZWQuaW5kZXhPZihcIi5cIik7XHJcbiAgICAgICAgaWYgKGRvdCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvc01hdGNoID0gZml4ZWQubWF0Y2goLzArJC8pO1xyXG4gICAgICAgICAgICBpZiAoemVyb3NNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zTWF0Y2guaW5kZXggPT09IGRvdCArIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWQuc3Vic3RyaW5nKDAsIGRvdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWQuc3Vic3RyaW5nKDAsIHplcm9zTWF0Y2guaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaXhlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJnYlRvU3RyaW5nKHJnYikge1xyXG4gICAgICAgIHZhciByID0gcmdiLnIsXHJcbiAgICAgICAgICAgIGcgPSByZ2IuZyxcclxuICAgICAgICAgICAgYiA9IHJnYi5iLFxyXG4gICAgICAgICAgICBhID0gcmdiLmE7XHJcbiAgICAgICAgaWYgKGEgIT0gbnVsbCAmJiBhIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRvRml4ZWQociksIFwiLCBcIilcclxuICAgICAgICAgICAgICAgIC5jb25jYXQodG9GaXhlZChnKSwgXCIsIFwiKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKGIpLCBcIiwgXCIpXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRvRml4ZWQoYSwgMiksIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwicmdiKFwiXHJcbiAgICAgICAgICAgIC5jb25jYXQodG9GaXhlZChyKSwgXCIsIFwiKVxyXG4gICAgICAgICAgICAuY29uY2F0KHRvRml4ZWQoZyksIFwiLCBcIilcclxuICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKGIpLCBcIilcIik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZ2JUb0hleFN0cmluZyhfYSkge1xyXG4gICAgICAgIHZhciByID0gX2EucixcclxuICAgICAgICAgICAgZyA9IF9hLmcsXHJcbiAgICAgICAgICAgIGIgPSBfYS5iLFxyXG4gICAgICAgICAgICBhID0gX2EuYTtcclxuICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAoYSAhPSBudWxsICYmIGEgPCAxID8gW3IsIGcsIGIsIE1hdGgucm91bmQoYSAqIDI1NSldIDogW3IsIGcsIGJdKVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4IDwgMTYgPyBcIjBcIiA6IFwiXCIpLmNvbmNhdCh4LnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIilcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaHNsVG9TdHJpbmcoaHNsKSB7XHJcbiAgICAgICAgdmFyIGggPSBoc2wuaCxcclxuICAgICAgICAgICAgcyA9IGhzbC5zLFxyXG4gICAgICAgICAgICBsID0gaHNsLmwsXHJcbiAgICAgICAgICAgIGEgPSBoc2wuYTtcclxuICAgICAgICBpZiAoYSAhPSBudWxsICYmIGEgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImhzbGEoXCJcclxuICAgICAgICAgICAgICAgIC5jb25jYXQodG9GaXhlZChoKSwgXCIsIFwiKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKHMgKiAxMDApLCBcIiUsIFwiKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKGwgKiAxMDApLCBcIiUsIFwiKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKGEsIDIpLCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcImhzbChcIlxyXG4gICAgICAgICAgICAuY29uY2F0KHRvRml4ZWQoaCksIFwiLCBcIilcclxuICAgICAgICAgICAgLmNvbmNhdCh0b0ZpeGVkKHMgKiAxMDApLCBcIiUsIFwiKVxyXG4gICAgICAgICAgICAuY29uY2F0KHRvRml4ZWQobCAqIDEwMCksIFwiJSlcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgcmdiTWF0Y2ggPSAvXnJnYmE/XFwoW15cXChcXCldK1xcKSQvO1xyXG4gICAgdmFyIGhzbE1hdGNoID0gL15oc2xhP1xcKFteXFwoXFwpXStcXCkkLztcclxuICAgIHZhciBoZXhNYXRjaCA9IC9eI1swLTlhLWZdKyQvaTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlKCRjb2xvcikge1xyXG4gICAgICAgIHZhciBjID0gJGNvbG9yLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChjLm1hdGNoKHJnYk1hdGNoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSR0IoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjLm1hdGNoKGhzbE1hdGNoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIU0woYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjLm1hdGNoKGhleE1hdGNoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIZXgoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrbm93bkNvbG9ycy5oYXMoYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbG9yQnlOYW1lKGMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3lzdGVtQ29sb3JzLmhhcyhjKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0U3lzdGVtQ29sb3IoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkY29sb3IgPT09IFwidHJhbnNwYXJlbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldE51bWJlcnMoJGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIG51bWJlcnMgPSBbXTtcclxuICAgICAgICB2YXIgcHJldlBvcyA9IDA7XHJcbiAgICAgICAgdmFyIGlzTWluaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAkY29sb3IuaW5kZXhPZihcIihcIik7XHJcbiAgICAgICAgJGNvbG9yID0gJGNvbG9yLnN1YnN0cmluZyhzdGFydEluZGV4ICsgMSwgJGNvbG9yLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJGNvbG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gJGNvbG9yW2ldO1xyXG4gICAgICAgICAgICBpZiAoKGMgPj0gXCIwXCIgJiYgYyA8PSBcIjlcIikgfHwgYyA9PT0gXCIuXCIgfHwgYyA9PT0gXCIrXCIgfHwgYyA9PT0gXCItXCIpIHtcclxuICAgICAgICAgICAgICAgIGlzTWluaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01pbmluZyAmJiAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCIsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2goJGNvbG9yLnN1YnN0cmluZyhwcmV2UG9zLCBpKSk7XHJcbiAgICAgICAgICAgICAgICBpc01pbmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcHJldlBvcyA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc01pbmluZykge1xyXG4gICAgICAgICAgICAgICAgcHJldlBvcyA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc01pbmluZykge1xyXG4gICAgICAgICAgICBudW1iZXJzLnB1c2goJGNvbG9yLnN1YnN0cmluZyhwcmV2UG9zLCAkY29sb3IubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1iZXJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0TnVtYmVyc0Zyb21TdHJpbmcoc3RyLCByYW5nZSwgdW5pdHMpIHtcclxuICAgICAgICB2YXIgcmF3ID0gZ2V0TnVtYmVycyhzdHIpO1xyXG4gICAgICAgIHZhciB1bml0c0xpc3QgPSBPYmplY3QuZW50cmllcyh1bml0cyk7XHJcbiAgICAgICAgdmFyIG51bWJlcnMgPSByYXdcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudHJpbSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gdW5pdHNMaXN0LmZpbmQoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IF9iWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByLmVuZHNXaXRoKHUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFyc2VGbG9hdChyLnN1YnN0cmluZygwLCByLmxlbmd0aCAtIHVuaXRbMF0ubGVuZ3RoKSkgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdFsxXSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVtpXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhcnNlRmxvYXQocik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbaV0gPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlcnM7XHJcbiAgICB9XHJcbiAgICB2YXIgcmdiUmFuZ2UgPSBbMjU1LCAyNTUsIDI1NSwgMV07XHJcbiAgICB2YXIgcmdiVW5pdHMgPSB7XCIlXCI6IDEwMH07XHJcbiAgICBmdW5jdGlvbiBwYXJzZVJHQigkcmdiKSB7XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGdldE51bWJlcnNGcm9tU3RyaW5nKCRyZ2IsIHJnYlJhbmdlLCByZ2JVbml0cyksIDQpLFxyXG4gICAgICAgICAgICByID0gX2FbMF0sXHJcbiAgICAgICAgICAgIGcgPSBfYVsxXSxcclxuICAgICAgICAgICAgYiA9IF9hWzJdLFxyXG4gICAgICAgICAgICBfYiA9IF9hWzNdLFxyXG4gICAgICAgICAgICBhID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYjtcclxuICAgICAgICByZXR1cm4ge3I6IHIsIGc6IGcsIGI6IGIsIGE6IGF9O1xyXG4gICAgfVxyXG4gICAgdmFyIGhzbFJhbmdlID0gWzM2MCwgMSwgMSwgMV07XHJcbiAgICB2YXIgaHNsVW5pdHMgPSB7XCIlXCI6IDEwMCwgXCJkZWdcIjogMzYwLCBcInJhZFwiOiAyICogTWF0aC5QSSwgXCJ0dXJuXCI6IDF9O1xyXG4gICAgZnVuY3Rpb24gcGFyc2VIU0woJGhzbCkge1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXROdW1iZXJzRnJvbVN0cmluZygkaHNsLCBoc2xSYW5nZSwgaHNsVW5pdHMpLCA0KSxcclxuICAgICAgICAgICAgaCA9IF9hWzBdLFxyXG4gICAgICAgICAgICBzID0gX2FbMV0sXHJcbiAgICAgICAgICAgIGwgPSBfYVsyXSxcclxuICAgICAgICAgICAgX2IgPSBfYVszXSxcclxuICAgICAgICAgICAgYSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2I7XHJcbiAgICAgICAgcmV0dXJuIGhzbFRvUkdCKHtoOiBoLCBzOiBzLCBsOiBsLCBhOiBhfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUhleCgkaGV4KSB7XHJcbiAgICAgICAgdmFyIGggPSAkaGV4LnN1YnN0cmluZygxKTtcclxuICAgICAgICBzd2l0Y2ggKGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgY2FzZSA0OiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChcIlwiLmNvbmNhdChoW2ldKS5jb25jYXQoaFtpXSksIDE2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBfYVswXSxcclxuICAgICAgICAgICAgICAgICAgICBnID0gX2FbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IF9hWzJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPVxyXG4gICAgICAgICAgICAgICAgICAgIGgubGVuZ3RoID09PSAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlSW50KFwiXCIuY29uY2F0KGhbM10pLmNvbmNhdChoWzNdKSwgMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyOiByLCBnOiBnLCBiOiBiLCBhOiBhfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgIGNhc2UgODoge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbMCwgMiwgNF0ubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICByID0gX2JbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IF9iWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBfYlsyXTtcclxuICAgICAgICAgICAgICAgIHZhciBhID1cclxuICAgICAgICAgICAgICAgICAgICBoLmxlbmd0aCA9PT0gNiA/IDEgOiBwYXJzZUludChoLnN1YnN0cmluZyg2LCA4KSwgMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyOiByLCBnOiBnLCBiOiBiLCBhOiBhfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbG9yQnlOYW1lKCRjb2xvcikge1xyXG4gICAgICAgIHZhciBuID0ga25vd25Db2xvcnMuZ2V0KCRjb2xvcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcjogKG4gPj4gMTYpICYgMjU1LFxyXG4gICAgICAgICAgICBnOiAobiA+PiA4KSAmIDI1NSxcclxuICAgICAgICAgICAgYjogKG4gPj4gMCkgJiAyNTUsXHJcbiAgICAgICAgICAgIGE6IDFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U3lzdGVtQ29sb3IoJGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIG4gPSBzeXN0ZW1Db2xvcnMuZ2V0KCRjb2xvcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcjogKG4gPj4gMTYpICYgMjU1LFxyXG4gICAgICAgICAgICBnOiAobiA+PiA4KSAmIDI1NSxcclxuICAgICAgICAgICAgYjogKG4gPj4gMCkgJiAyNTUsXHJcbiAgICAgICAgICAgIGE6IDFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbG93ZXJDYWxjRXhwcmVzc2lvbihjb2xvcikge1xyXG4gICAgICAgIHZhciBzZWFyY2hJbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHJlcGxhY2VCZXR3ZWVuSW5kaWNlcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCByZXBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICBjb2xvciA9XHJcbiAgICAgICAgICAgICAgICBjb2xvci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgcmVwbGFjZW1lbnQgKyBjb2xvci5zdWJzdHJpbmcoZW5kKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdoaWxlICgoc2VhcmNoSW5kZXggPSBjb2xvci5pbmRleE9mKFwiY2FsYyhcIikpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRQYXJlbnRoZXNlc1JhbmdlKGNvbG9yLCBzZWFyY2hJbmRleCk7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzbGljZSA9IGNvbG9yLnNsaWNlKHJhbmdlLnN0YXJ0ICsgMSwgcmFuZ2UuZW5kIC0gMSk7XHJcbiAgICAgICAgICAgIHZhciBpbmNsdWRlc1BlcmNlbnRhZ2UgPSBzbGljZS5pbmNsdWRlcyhcIiVcIik7XHJcbiAgICAgICAgICAgIHNsaWNlID0gc2xpY2Uuc3BsaXQoXCIlXCIpLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBNYXRoLnJvdW5kKGV2YWxNYXRoKHNsaWNlKSk7XHJcbiAgICAgICAgICAgIHJlcGxhY2VCZXR3ZWVuSW5kaWNlcyhcclxuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0IC0gNCxcclxuICAgICAgICAgICAgICAgIHJhbmdlLmVuZCxcclxuICAgICAgICAgICAgICAgIG91dHB1dCArIChpbmNsdWRlc1BlcmNlbnRhZ2UgPyBcIiVcIiA6IFwiXCIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuICAgIHZhciBrbm93bkNvbG9ycyA9IG5ldyBNYXAoXHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoe1xyXG4gICAgICAgICAgICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxyXG4gICAgICAgICAgICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxyXG4gICAgICAgICAgICBhcXVhOiAweDAwZmZmZixcclxuICAgICAgICAgICAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXHJcbiAgICAgICAgICAgIGF6dXJlOiAweGYwZmZmZixcclxuICAgICAgICAgICAgYmVpZ2U6IDB4ZjVmNWRjLFxyXG4gICAgICAgICAgICBiaXNxdWU6IDB4ZmZlNGM0LFxyXG4gICAgICAgICAgICBibGFjazogMHgwMDAwMDAsXHJcbiAgICAgICAgICAgIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcclxuICAgICAgICAgICAgYmx1ZTogMHgwMDAwZmYsXHJcbiAgICAgICAgICAgIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxyXG4gICAgICAgICAgICBicm93bjogMHhhNTJhMmEsXHJcbiAgICAgICAgICAgIGJ1cmx5d29vZDogMHhkZWI4ODcsXHJcbiAgICAgICAgICAgIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXHJcbiAgICAgICAgICAgIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxyXG4gICAgICAgICAgICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxyXG4gICAgICAgICAgICBjb3JhbDogMHhmZjdmNTAsXHJcbiAgICAgICAgICAgIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcclxuICAgICAgICAgICAgY29ybnNpbGs6IDB4ZmZmOGRjLFxyXG4gICAgICAgICAgICBjcmltc29uOiAweGRjMTQzYyxcclxuICAgICAgICAgICAgY3lhbjogMHgwMGZmZmYsXHJcbiAgICAgICAgICAgIGRhcmtibHVlOiAweDAwMDA4YixcclxuICAgICAgICAgICAgZGFya2N5YW46IDB4MDA4YjhiLFxyXG4gICAgICAgICAgICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcclxuICAgICAgICAgICAgZGFya2dyYXk6IDB4YTlhOWE5LFxyXG4gICAgICAgICAgICBkYXJrZ3JleTogMHhhOWE5YTksXHJcbiAgICAgICAgICAgIGRhcmtncmVlbjogMHgwMDY0MDAsXHJcbiAgICAgICAgICAgIGRhcmtraGFraTogMHhiZGI3NmIsXHJcbiAgICAgICAgICAgIGRhcmttYWdlbnRhOiAweDhiMDA4YixcclxuICAgICAgICAgICAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxyXG4gICAgICAgICAgICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcclxuICAgICAgICAgICAgZGFya29yY2hpZDogMHg5OTMyY2MsXHJcbiAgICAgICAgICAgIGRhcmtyZWQ6IDB4OGIwMDAwLFxyXG4gICAgICAgICAgICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcclxuICAgICAgICAgICAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcclxuICAgICAgICAgICAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXHJcbiAgICAgICAgICAgIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxyXG4gICAgICAgICAgICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcclxuICAgICAgICAgICAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXHJcbiAgICAgICAgICAgIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxyXG4gICAgICAgICAgICBkZWVwcGluazogMHhmZjE0OTMsXHJcbiAgICAgICAgICAgIGRlZXBza3libHVlOiAweDAwYmZmZixcclxuICAgICAgICAgICAgZGltZ3JheTogMHg2OTY5NjksXHJcbiAgICAgICAgICAgIGRpbWdyZXk6IDB4Njk2OTY5LFxyXG4gICAgICAgICAgICBkb2RnZXJibHVlOiAweDFlOTBmZixcclxuICAgICAgICAgICAgZmlyZWJyaWNrOiAweGIyMjIyMixcclxuICAgICAgICAgICAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxyXG4gICAgICAgICAgICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXHJcbiAgICAgICAgICAgIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxyXG4gICAgICAgICAgICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxyXG4gICAgICAgICAgICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcclxuICAgICAgICAgICAgZ29sZDogMHhmZmQ3MDAsXHJcbiAgICAgICAgICAgIGdvbGRlbnJvZDogMHhkYWE1MjAsXHJcbiAgICAgICAgICAgIGdyYXk6IDB4ODA4MDgwLFxyXG4gICAgICAgICAgICBncmV5OiAweDgwODA4MCxcclxuICAgICAgICAgICAgZ3JlZW46IDB4MDA4MDAwLFxyXG4gICAgICAgICAgICBncmVlbnllbGxvdzogMHhhZGZmMmYsXHJcbiAgICAgICAgICAgIGhvbmV5ZGV3OiAweGYwZmZmMCxcclxuICAgICAgICAgICAgaG90cGluazogMHhmZjY5YjQsXHJcbiAgICAgICAgICAgIGluZGlhbnJlZDogMHhjZDVjNWMsXHJcbiAgICAgICAgICAgIGluZGlnbzogMHg0YjAwODIsXHJcbiAgICAgICAgICAgIGl2b3J5OiAweGZmZmZmMCxcclxuICAgICAgICAgICAga2hha2k6IDB4ZjBlNjhjLFxyXG4gICAgICAgICAgICBsYXZlbmRlcjogMHhlNmU2ZmEsXHJcbiAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxyXG4gICAgICAgICAgICBsYXduZ3JlZW46IDB4N2NmYzAwLFxyXG4gICAgICAgICAgICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxyXG4gICAgICAgICAgICBsaWdodGJsdWU6IDB4YWRkOGU2LFxyXG4gICAgICAgICAgICBsaWdodGNvcmFsOiAweGYwODA4MCxcclxuICAgICAgICAgICAgbGlnaHRjeWFuOiAweGUwZmZmZixcclxuICAgICAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxyXG4gICAgICAgICAgICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxyXG4gICAgICAgICAgICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxyXG4gICAgICAgICAgICBsaWdodGdyZWVuOiAweDkwZWU5MCxcclxuICAgICAgICAgICAgbGlnaHRwaW5rOiAweGZmYjZjMSxcclxuICAgICAgICAgICAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxyXG4gICAgICAgICAgICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcclxuICAgICAgICAgICAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcclxuICAgICAgICAgICAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxyXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXHJcbiAgICAgICAgICAgIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcclxuICAgICAgICAgICAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxyXG4gICAgICAgICAgICBsaW1lOiAweDAwZmYwMCxcclxuICAgICAgICAgICAgbGltZWdyZWVuOiAweDMyY2QzMixcclxuICAgICAgICAgICAgbGluZW46IDB4ZmFmMGU2LFxyXG4gICAgICAgICAgICBtYWdlbnRhOiAweGZmMDBmZixcclxuICAgICAgICAgICAgbWFyb29uOiAweDgwMDAwMCxcclxuICAgICAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXHJcbiAgICAgICAgICAgIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxyXG4gICAgICAgICAgICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxyXG4gICAgICAgICAgICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxyXG4gICAgICAgICAgICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXHJcbiAgICAgICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXHJcbiAgICAgICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcclxuICAgICAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcclxuICAgICAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcclxuICAgICAgICAgICAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcclxuICAgICAgICAgICAgbWludGNyZWFtOiAweGY1ZmZmYSxcclxuICAgICAgICAgICAgbWlzdHlyb3NlOiAweGZmZTRlMSxcclxuICAgICAgICAgICAgbW9jY2FzaW46IDB4ZmZlNGI1LFxyXG4gICAgICAgICAgICBuYXZham93aGl0ZTogMHhmZmRlYWQsXHJcbiAgICAgICAgICAgIG5hdnk6IDB4MDAwMDgwLFxyXG4gICAgICAgICAgICBvbGRsYWNlOiAweGZkZjVlNixcclxuICAgICAgICAgICAgb2xpdmU6IDB4ODA4MDAwLFxyXG4gICAgICAgICAgICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxyXG4gICAgICAgICAgICBvcmFuZ2U6IDB4ZmZhNTAwLFxyXG4gICAgICAgICAgICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxyXG4gICAgICAgICAgICBvcmNoaWQ6IDB4ZGE3MGQ2LFxyXG4gICAgICAgICAgICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcclxuICAgICAgICAgICAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcclxuICAgICAgICAgICAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXHJcbiAgICAgICAgICAgIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxyXG4gICAgICAgICAgICBwYXBheWF3aGlwOiAweGZmZWZkNSxcclxuICAgICAgICAgICAgcGVhY2hwdWZmOiAweGZmZGFiOSxcclxuICAgICAgICAgICAgcGVydTogMHhjZDg1M2YsXHJcbiAgICAgICAgICAgIHBpbms6IDB4ZmZjMGNiLFxyXG4gICAgICAgICAgICBwbHVtOiAweGRkYTBkZCxcclxuICAgICAgICAgICAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXHJcbiAgICAgICAgICAgIHB1cnBsZTogMHg4MDAwODAsXHJcbiAgICAgICAgICAgIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxyXG4gICAgICAgICAgICByZWQ6IDB4ZmYwMDAwLFxyXG4gICAgICAgICAgICByb3N5YnJvd246IDB4YmM4ZjhmLFxyXG4gICAgICAgICAgICByb3lhbGJsdWU6IDB4NDE2OWUxLFxyXG4gICAgICAgICAgICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXHJcbiAgICAgICAgICAgIHNhbG1vbjogMHhmYTgwNzIsXHJcbiAgICAgICAgICAgIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxyXG4gICAgICAgICAgICBzZWFncmVlbjogMHgyZThiNTcsXHJcbiAgICAgICAgICAgIHNlYXNoZWxsOiAweGZmZjVlZSxcclxuICAgICAgICAgICAgc2llbm5hOiAweGEwNTIyZCxcclxuICAgICAgICAgICAgc2lsdmVyOiAweGMwYzBjMCxcclxuICAgICAgICAgICAgc2t5Ymx1ZTogMHg4N2NlZWIsXHJcbiAgICAgICAgICAgIHNsYXRlYmx1ZTogMHg2YTVhY2QsXHJcbiAgICAgICAgICAgIHNsYXRlZ3JheTogMHg3MDgwOTAsXHJcbiAgICAgICAgICAgIHNsYXRlZ3JleTogMHg3MDgwOTAsXHJcbiAgICAgICAgICAgIHNub3c6IDB4ZmZmYWZhLFxyXG4gICAgICAgICAgICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXHJcbiAgICAgICAgICAgIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXHJcbiAgICAgICAgICAgIHRhbjogMHhkMmI0OGMsXHJcbiAgICAgICAgICAgIHRlYWw6IDB4MDA4MDgwLFxyXG4gICAgICAgICAgICB0aGlzdGxlOiAweGQ4YmZkOCxcclxuICAgICAgICAgICAgdG9tYXRvOiAweGZmNjM0NyxcclxuICAgICAgICAgICAgdHVycXVvaXNlOiAweDQwZTBkMCxcclxuICAgICAgICAgICAgdmlvbGV0OiAweGVlODJlZSxcclxuICAgICAgICAgICAgd2hlYXQ6IDB4ZjVkZWIzLFxyXG4gICAgICAgICAgICB3aGl0ZTogMHhmZmZmZmYsXHJcbiAgICAgICAgICAgIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxyXG4gICAgICAgICAgICB5ZWxsb3c6IDB4ZmZmZjAwLFxyXG4gICAgICAgICAgICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICAgIHZhciBzeXN0ZW1Db2xvcnMgPSBuZXcgTWFwKFxyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHtcclxuICAgICAgICAgICAgXCJBY3RpdmVCb3JkZXJcIjogMHgzYjk5ZmMsXHJcbiAgICAgICAgICAgIFwiQWN0aXZlQ2FwdGlvblwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJBcHBXb3Jrc3BhY2VcIjogMHhhYWFhYWEsXHJcbiAgICAgICAgICAgIFwiQmFja2dyb3VuZFwiOiAweDYzNjNjZSxcclxuICAgICAgICAgICAgXCJCdXR0b25GYWNlXCI6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBcIkJ1dHRvbkhpZ2hsaWdodFwiOiAweGU5ZTllOSxcclxuICAgICAgICAgICAgXCJCdXR0b25TaGFkb3dcIjogMHg5ZmEwOWYsXHJcbiAgICAgICAgICAgIFwiQnV0dG9uVGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJDYXB0aW9uVGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJHcmF5VGV4dFwiOiAweDdmN2Y3ZixcclxuICAgICAgICAgICAgXCJIaWdobGlnaHRcIjogMHhiMmQ3ZmYsXHJcbiAgICAgICAgICAgIFwiSGlnaGxpZ2h0VGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJJbmFjdGl2ZUJvcmRlclwiOiAweGZmZmZmZixcclxuICAgICAgICAgICAgXCJJbmFjdGl2ZUNhcHRpb25cIjogMHhmZmZmZmYsXHJcbiAgICAgICAgICAgIFwiSW5hY3RpdmVDYXB0aW9uVGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJJbmZvQmFja2dyb3VuZFwiOiAweGZiZmNjNSxcclxuICAgICAgICAgICAgXCJJbmZvVGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJNZW51XCI6IDB4ZjZmNmY2LFxyXG4gICAgICAgICAgICBcIk1lbnVUZXh0XCI6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBcIlNjcm9sbGJhclwiOiAweGFhYWFhYSxcclxuICAgICAgICAgICAgXCJUaHJlZUREYXJrU2hhZG93XCI6IDB4MDAwMDAwLFxyXG4gICAgICAgICAgICBcIlRocmVlREZhY2VcIjogMHhjMGMwYzAsXHJcbiAgICAgICAgICAgIFwiVGhyZWVESGlnaGxpZ2h0XCI6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBcIlRocmVlRExpZ2h0U2hhZG93XCI6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBcIlRocmVlRFNoYWRvd1wiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCJXaW5kb3dcIjogMHhlY2VjZWMsXHJcbiAgICAgICAgICAgIFwiV2luZG93RnJhbWVcIjogMHhhYWFhYWEsXHJcbiAgICAgICAgICAgIFwiV2luZG93VGV4dFwiOiAweDAwMDAwMCxcclxuICAgICAgICAgICAgXCItd2Via2l0LWZvY3VzLXJpbmctY29sb3JcIjogMHhlNTk3MDBcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksXHJcbiAgICAgICAgICAgICAgICBrZXkgPSBfYlswXSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2JbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBba2V5LnRvTG93ZXJDYXNlKCksIHZhbHVlXTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICAgIGZ1bmN0aW9uIGdldFNSR0JMaWdodG5lc3MociwgZywgYikge1xyXG4gICAgICAgIHJldHVybiAoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiKSAvIDI1NTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcclxuICAgICAgICByZXR1cm4gKCh4IC0gaW5Mb3cpICogKG91dEhpZ2ggLSBvdXRMb3cpKSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgeCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhtMSwgbTIpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG0xLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IG0yWzBdLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuMyA9IG0xWzBdLmxlbmd0aDsgayA8IGxlbjM7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBtMVtpXVtrXSAqIG0yW2tdW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gc3VtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyTWF0cml4KGNvbmZpZykge1xyXG4gICAgICAgIHZhciBtID0gTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5zZXBpYSAhPT0gMCkge1xyXG4gICAgICAgICAgICBtID0gbXVsdGlwbHlNYXRyaWNlcyhtLCBNYXRyaXguc2VwaWEoY29uZmlnLnNlcGlhIC8gMTAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcuZ3JheXNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG0gPSBtdWx0aXBseU1hdHJpY2VzKG0sIE1hdHJpeC5ncmF5c2NhbGUoY29uZmlnLmdyYXlzY2FsZSAvIDEwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLmNvbnRyYXN0ICE9PSAxMDApIHtcclxuICAgICAgICAgICAgbSA9IG11bHRpcGx5TWF0cmljZXMobSwgTWF0cml4LmNvbnRyYXN0KGNvbmZpZy5jb250cmFzdCAvIDEwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLmJyaWdodG5lc3MgIT09IDEwMCkge1xyXG4gICAgICAgICAgICBtID0gbXVsdGlwbHlNYXRyaWNlcyhtLCBNYXRyaXguYnJpZ2h0bmVzcyhjb25maWcuYnJpZ2h0bmVzcyAvIDEwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLm1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgbSA9IG11bHRpcGx5TWF0cmljZXMobSwgTWF0cml4LmludmVydE5IdWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlDb2xvck1hdHJpeChfYSwgbWF0cml4KSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSxcclxuICAgICAgICAgICAgciA9IF9iWzBdLFxyXG4gICAgICAgICAgICBnID0gX2JbMV0sXHJcbiAgICAgICAgICAgIGIgPSBfYlsyXTtcclxuICAgICAgICB2YXIgcmdiID0gW1tyIC8gMjU1XSwgW2cgLyAyNTVdLCBbYiAvIDI1NV0sIFsxXSwgWzFdXTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIHJnYik7XHJcbiAgICAgICAgcmV0dXJuIFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGgucm91bmQocmVzdWx0W2ldWzBdICogMjU1KSwgMCwgMjU1KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBNYXRyaXggPSB7XHJcbiAgICAgICAgaWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFsxLCAwLCAwLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAxLCAwLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAxLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAxLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwLCAxXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW52ZXJ0Tkh1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgWzAuMzMzLCAtMC42NjcsIC0wLjY2NywgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICBbLTAuNjY3LCAwLjMzMywgLTAuNjY3LCAwLCAxXSxcclxuICAgICAgICAgICAgICAgIFstMC42NjcsIC0wLjY2NywgMC4zMzMsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDAsIDFdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBicmlnaHRuZXNzOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgW3YsIDAsIDAsIDAsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIHYsIDAsIDAsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDAsIHYsIDAsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDAsIDAsIDAsIDFdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250cmFzdDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSAoMSAtIHYpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFt2LCAwLCAwLCAwLCB0XSxcclxuICAgICAgICAgICAgICAgIFswLCB2LCAwLCAwLCB0XSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCB2LCAwLCB0XSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAxLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwLCAxXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwaWE6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgMC4zOTMgKyAwLjYwNyAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMC43NjkgLSAwLjc2OSAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMC4xODkgLSAwLjE4OSAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIDAuMzQ5IC0gMC4zNDkgKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAuNjg2ICsgMC4zMTQgKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAuMTY4IC0gMC4xNjggKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAwLjI3MiAtIDAuMjcyICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLjUzNCAtIDAuNTM0ICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLjEzMSArIDAuODY5ICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICBbMCwgMCwgMCwgMCwgMV1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyYXlzY2FsZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAwLjIxMjYgKyAwLjc4NzQgKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAuNzE1MiAtIDAuNzE1MiAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMC4wNzIyIC0gMC4wNzIyICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgMC4yMTI2IC0gMC4yMTI2ICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLjcxNTIgKyAwLjI4NDggKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAuMDcyMiAtIDAuMDcyMiAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gdiksXHJcbiAgICAgICAgICAgICAgICAgICAgMC43MTUyIC0gMC43MTUyICogKDEgLSB2KSxcclxuICAgICAgICAgICAgICAgICAgICAwLjA3MjIgKyAwLjkyNzggKiAoMSAtIHYpLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAxLCAwXSxcclxuICAgICAgICAgICAgICAgIFswLCAwLCAwLCAwLCAxXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QmdQb2xlKHRoZW1lKSB7XHJcbiAgICAgICAgdmFyIGlzRGFya1NjaGVtZSA9IHRoZW1lLm1vZGUgPT09IDE7XHJcbiAgICAgICAgdmFyIHByb3AgPSBpc0RhcmtTY2hlbWVcclxuICAgICAgICAgICAgPyBcImRhcmtTY2hlbWVCYWNrZ3JvdW5kQ29sb3JcIlxyXG4gICAgICAgICAgICA6IFwibGlnaHRTY2hlbWVCYWNrZ3JvdW5kQ29sb3JcIjtcclxuICAgICAgICByZXR1cm4gdGhlbWVbcHJvcF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRGZ1BvbGUodGhlbWUpIHtcclxuICAgICAgICB2YXIgaXNEYXJrU2NoZW1lID0gdGhlbWUubW9kZSA9PT0gMTtcclxuICAgICAgICB2YXIgcHJvcCA9IGlzRGFya1NjaGVtZVxyXG4gICAgICAgICAgICA/IFwiZGFya1NjaGVtZVRleHRDb2xvclwiXHJcbiAgICAgICAgICAgIDogXCJsaWdodFNjaGVtZVRleHRDb2xvclwiO1xyXG4gICAgICAgIHJldHVybiB0aGVtZVtwcm9wXTtcclxuICAgIH1cclxuICAgIHZhciBjb2xvck1vZGlmaWNhdGlvbkNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gY2xlYXJDb2xvck1vZGlmaWNhdGlvbkNhY2hlKCkge1xyXG4gICAgICAgIGNvbG9yTW9kaWZpY2F0aW9uQ2FjaGUuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHZhciByZ2JDYWNoZUtleXMgPSBbXCJyXCIsIFwiZ1wiLCBcImJcIiwgXCJhXCJdO1xyXG4gICAgdmFyIHRoZW1lQ2FjaGVLZXlzJDEgPSBbXHJcbiAgICAgICAgXCJtb2RlXCIsXHJcbiAgICAgICAgXCJicmlnaHRuZXNzXCIsXHJcbiAgICAgICAgXCJjb250cmFzdFwiLFxyXG4gICAgICAgIFwiZ3JheXNjYWxlXCIsXHJcbiAgICAgICAgXCJzZXBpYVwiLFxyXG4gICAgICAgIFwiZGFya1NjaGVtZUJhY2tncm91bmRDb2xvclwiLFxyXG4gICAgICAgIFwiZGFya1NjaGVtZVRleHRDb2xvclwiLFxyXG4gICAgICAgIFwibGlnaHRTY2hlbWVCYWNrZ3JvdW5kQ29sb3JcIixcclxuICAgICAgICBcImxpZ2h0U2NoZW1lVGV4dENvbG9yXCJcclxuICAgIF07XHJcbiAgICBmdW5jdGlvbiBnZXRDYWNoZUlkKHJnYiwgdGhlbWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0SWQgPSBcIlwiO1xyXG4gICAgICAgIHJnYkNhY2hlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmVzdWx0SWQgKz0gXCJcIi5jb25jYXQocmdiW2tleV0sIFwiO1wiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGVtZUNhY2hlS2V5cyQxLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXN1bHRJZCArPSBcIlwiLmNvbmNhdCh0aGVtZVtrZXldLCBcIjtcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdElkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kaWZ5Q29sb3JXaXRoQ2FjaGUoXHJcbiAgICAgICAgcmdiLFxyXG4gICAgICAgIHRoZW1lLFxyXG4gICAgICAgIG1vZGlmeUhTTCxcclxuICAgICAgICBwb2xlQ29sb3IsXHJcbiAgICAgICAgYW5vdGhlclBvbGVDb2xvclxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIGZuQ2FjaGU7XHJcbiAgICAgICAgaWYgKGNvbG9yTW9kaWZpY2F0aW9uQ2FjaGUuaGFzKG1vZGlmeUhTTCkpIHtcclxuICAgICAgICAgICAgZm5DYWNoZSA9IGNvbG9yTW9kaWZpY2F0aW9uQ2FjaGUuZ2V0KG1vZGlmeUhTTCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm5DYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY29sb3JNb2RpZmljYXRpb25DYWNoZS5zZXQobW9kaWZ5SFNMLCBmbkNhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlkID0gZ2V0Q2FjaGVJZChyZ2IsIHRoZW1lKTtcclxuICAgICAgICBpZiAoZm5DYWNoZS5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbkNhY2hlLmdldChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hTTChyZ2IpO1xyXG4gICAgICAgIHZhciBwb2xlID0gcG9sZUNvbG9yID09IG51bGwgPyBudWxsIDogcGFyc2VUb0hTTFdpdGhDYWNoZShwb2xlQ29sb3IpO1xyXG4gICAgICAgIHZhciBhbm90aGVyUG9sZSA9XHJcbiAgICAgICAgICAgIGFub3RoZXJQb2xlQ29sb3IgPT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgICAgICA6IHBhcnNlVG9IU0xXaXRoQ2FjaGUoYW5vdGhlclBvbGVDb2xvcik7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVkID0gbW9kaWZ5SFNMKGhzbCwgcG9sZSwgYW5vdGhlclBvbGUpO1xyXG4gICAgICAgIHZhciBfYSA9IGhzbFRvUkdCKG1vZGlmaWVkKSxcclxuICAgICAgICAgICAgciA9IF9hLnIsXHJcbiAgICAgICAgICAgIGcgPSBfYS5nLFxyXG4gICAgICAgICAgICBiID0gX2EuYixcclxuICAgICAgICAgICAgYSA9IF9hLmE7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IGNyZWF0ZUZpbHRlck1hdHJpeCh0aGVtZSk7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKGFwcGx5Q29sb3JNYXRyaXgoW3IsIGcsIGJdLCBtYXRyaXgpLCAzKSxcclxuICAgICAgICAgICAgcmYgPSBfYlswXSxcclxuICAgICAgICAgICAgZ2YgPSBfYlsxXSxcclxuICAgICAgICAgICAgYmYgPSBfYlsyXTtcclxuICAgICAgICB2YXIgY29sb3IgPVxyXG4gICAgICAgICAgICBhID09PSAxXHJcbiAgICAgICAgICAgICAgICA/IHJnYlRvSGV4U3RyaW5nKHtyOiByZiwgZzogZ2YsIGI6IGJmfSlcclxuICAgICAgICAgICAgICAgIDogcmdiVG9TdHJpbmcoe3I6IHJmLCBnOiBnZiwgYjogYmYsIGE6IGF9KTtcclxuICAgICAgICBmbkNhY2hlLnNldChpZCwgY29sb3IpO1xyXG4gICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG5vb3BIU0woaHNsKSB7XHJcbiAgICAgICAgcmV0dXJuIGhzbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZGlmeUNvbG9yKHJnYiwgdGhlbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9kaWZ5Q29sb3JXaXRoQ2FjaGUocmdiLCB0aGVtZSwgbm9vcEhTTCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtb2RpZnlMaWdodFNjaGVtZUNvbG9yKHJnYiwgdGhlbWUpIHtcclxuICAgICAgICB2YXIgcG9sZUJnID0gZ2V0QmdQb2xlKHRoZW1lKTtcclxuICAgICAgICB2YXIgcG9sZUZnID0gZ2V0RmdQb2xlKHRoZW1lKTtcclxuICAgICAgICByZXR1cm4gbW9kaWZ5Q29sb3JXaXRoQ2FjaGUoXHJcbiAgICAgICAgICAgIHJnYixcclxuICAgICAgICAgICAgdGhlbWUsXHJcbiAgICAgICAgICAgIG1vZGlmeUxpZ2h0TW9kZUhTTCxcclxuICAgICAgICAgICAgcG9sZUZnLFxyXG4gICAgICAgICAgICBwb2xlQmdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kaWZ5TGlnaHRNb2RlSFNMKF9hLCBwb2xlRmcsIHBvbGVCZykge1xyXG4gICAgICAgIHZhciBoID0gX2EuaCxcclxuICAgICAgICAgICAgcyA9IF9hLnMsXHJcbiAgICAgICAgICAgIGwgPSBfYS5sLFxyXG4gICAgICAgICAgICBhID0gX2EuYTtcclxuICAgICAgICB2YXIgaXNEYXJrID0gbCA8IDAuNTtcclxuICAgICAgICB2YXIgaXNOZXV0cmFsO1xyXG4gICAgICAgIGlmIChpc0RhcmspIHtcclxuICAgICAgICAgICAgaXNOZXV0cmFsID0gbCA8IDAuMiB8fCBzIDwgMC4xMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXNCbHVlID0gaCA+IDIwMCAmJiBoIDwgMjgwO1xyXG4gICAgICAgICAgICBpc05ldXRyYWwgPSBzIDwgMC4yNCB8fCAobCA+IDAuOCAmJiBpc0JsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaHggPSBoO1xyXG4gICAgICAgIHZhciBzeCA9IGw7XHJcbiAgICAgICAgaWYgKGlzTmV1dHJhbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNEYXJrKSB7XHJcbiAgICAgICAgICAgICAgICBoeCA9IHBvbGVGZy5oO1xyXG4gICAgICAgICAgICAgICAgc3ggPSBwb2xlRmcucztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh4ID0gcG9sZUJnLmg7XHJcbiAgICAgICAgICAgICAgICBzeCA9IHBvbGVCZy5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBseCA9IHNjYWxlKGwsIDAsIDEsIHBvbGVGZy5sLCBwb2xlQmcubCk7XHJcbiAgICAgICAgcmV0dXJuIHtoOiBoeCwgczogc3gsIGw6IGx4LCBhOiBhfTtcclxuICAgIH1cclxuICAgIHZhciBNQVhfQkdfTElHSFRORVNTID0gMC40O1xyXG4gICAgZnVuY3Rpb24gbW9kaWZ5QmdIU0woX2EsIHBvbGUpIHtcclxuICAgICAgICB2YXIgaCA9IF9hLmgsXHJcbiAgICAgICAgICAgIHMgPSBfYS5zLFxyXG4gICAgICAgICAgICBsID0gX2EubCxcclxuICAgICAgICAgICAgYSA9IF9hLmE7XHJcbiAgICAgICAgdmFyIGlzRGFyayA9IGwgPCAwLjU7XHJcbiAgICAgICAgdmFyIGlzQmx1ZSA9IGggPiAyMDAgJiYgaCA8IDI4MDtcclxuICAgICAgICB2YXIgaXNOZXV0cmFsID0gcyA8IDAuMTIgfHwgKGwgPiAwLjggJiYgaXNCbHVlKTtcclxuICAgICAgICBpZiAoaXNEYXJrKSB7XHJcbiAgICAgICAgICAgIHZhciBseF8xID0gc2NhbGUobCwgMCwgMC41LCAwLCBNQVhfQkdfTElHSFRORVNTKTtcclxuICAgICAgICAgICAgaWYgKGlzTmV1dHJhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGh4XzEgPSBwb2xlLmg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSBwb2xlLnM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge2g6IGh4XzEsIHM6IHN4LCBsOiBseF8xLCBhOiBhfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge2g6IGgsIHM6IHMsIGw6IGx4XzEsIGE6IGF9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbHggPSBzY2FsZShsLCAwLjUsIDEsIE1BWF9CR19MSUdIVE5FU1MsIHBvbGUubCk7XHJcbiAgICAgICAgaWYgKGlzTmV1dHJhbCkge1xyXG4gICAgICAgICAgICB2YXIgaHhfMiA9IHBvbGUuaDtcclxuICAgICAgICAgICAgdmFyIHN4ID0gcG9sZS5zO1xyXG4gICAgICAgICAgICByZXR1cm4ge2g6IGh4XzIsIHM6IHN4LCBsOiBseCwgYTogYX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoeCA9IGg7XHJcbiAgICAgICAgdmFyIGlzWWVsbG93ID0gaCA+IDYwICYmIGggPCAxODA7XHJcbiAgICAgICAgaWYgKGlzWWVsbG93KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0Nsb3NlclRvR3JlZW4gPSBoID4gMTIwO1xyXG4gICAgICAgICAgICBpZiAoaXNDbG9zZXJUb0dyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBoeCA9IHNjYWxlKGgsIDEyMCwgMTgwLCAxMzUsIDE4MCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoeCA9IHNjYWxlKGgsIDYwLCAxMjAsIDYwLCAxMDUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoeCA+IDQwICYmIGh4IDwgODApIHtcclxuICAgICAgICAgICAgbHggKj0gMC43NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtoOiBoeCwgczogcywgbDogbHgsIGE6IGF9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kaWZ5QmFja2dyb3VuZENvbG9yKHJnYiwgdGhlbWUpIHtcclxuICAgICAgICBpZiAodGhlbWUubW9kZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kaWZ5TGlnaHRTY2hlbWVDb2xvcihyZ2IsIHRoZW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvbGUgPSBnZXRCZ1BvbGUodGhlbWUpO1xyXG4gICAgICAgIHJldHVybiBtb2RpZnlDb2xvcldpdGhDYWNoZShcclxuICAgICAgICAgICAgcmdiLFxyXG4gICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhlbWUpLCB7bW9kZTogMH0pLFxyXG4gICAgICAgICAgICBtb2RpZnlCZ0hTTCxcclxuICAgICAgICAgICAgcG9sZVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICB2YXIgTUlOX0ZHX0xJR0hUTkVTUyA9IDAuNTU7XHJcbiAgICBmdW5jdGlvbiBtb2RpZnlCbHVlRmdIdWUoaHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlKGh1ZSwgMjA1LCAyNDUsIDIwNSwgMjIwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZGlmeUZnSFNMKF9hLCBwb2xlKSB7XHJcbiAgICAgICAgdmFyIGggPSBfYS5oLFxyXG4gICAgICAgICAgICBzID0gX2EucyxcclxuICAgICAgICAgICAgbCA9IF9hLmwsXHJcbiAgICAgICAgICAgIGEgPSBfYS5hO1xyXG4gICAgICAgIHZhciBpc0xpZ2h0ID0gbCA+IDAuNTtcclxuICAgICAgICB2YXIgaXNOZXV0cmFsID0gbCA8IDAuMiB8fCBzIDwgMC4yNDtcclxuICAgICAgICB2YXIgaXNCbHVlID0gIWlzTmV1dHJhbCAmJiBoID4gMjA1ICYmIGggPCAyNDU7XHJcbiAgICAgICAgaWYgKGlzTGlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIGx4XzIgPSBzY2FsZShsLCAwLjUsIDEsIE1JTl9GR19MSUdIVE5FU1MsIHBvbGUubCk7XHJcbiAgICAgICAgICAgIGlmIChpc05ldXRyYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoeF8zID0gcG9sZS5oO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN4ID0gcG9sZS5zO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtoOiBoeF8zLCBzOiBzeCwgbDogbHhfMiwgYTogYX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGh4XzQgPSBoO1xyXG4gICAgICAgICAgICBpZiAoaXNCbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBoeF80ID0gbW9kaWZ5Qmx1ZUZnSHVlKGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7aDogaHhfNCwgczogcywgbDogbHhfMiwgYTogYX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05ldXRyYWwpIHtcclxuICAgICAgICAgICAgdmFyIGh4XzUgPSBwb2xlLmg7XHJcbiAgICAgICAgICAgIHZhciBzeCA9IHBvbGUucztcclxuICAgICAgICAgICAgdmFyIGx4XzMgPSBzY2FsZShsLCAwLCAwLjUsIHBvbGUubCwgTUlOX0ZHX0xJR0hUTkVTUyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7aDogaHhfNSwgczogc3gsIGw6IGx4XzMsIGE6IGF9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaHggPSBoO1xyXG4gICAgICAgIHZhciBseDtcclxuICAgICAgICBpZiAoaXNCbHVlKSB7XHJcbiAgICAgICAgICAgIGh4ID0gbW9kaWZ5Qmx1ZUZnSHVlKGgpO1xyXG4gICAgICAgICAgICBseCA9IHNjYWxlKGwsIDAsIDAuNSwgcG9sZS5sLCBNYXRoLm1pbigxLCBNSU5fRkdfTElHSFRORVNTICsgMC4wNSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGx4ID0gc2NhbGUobCwgMCwgMC41LCBwb2xlLmwsIE1JTl9GR19MSUdIVE5FU1MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge2g6IGh4LCBzOiBzLCBsOiBseCwgYTogYX07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtb2RpZnlGb3JlZ3JvdW5kQ29sb3IocmdiLCB0aGVtZSkge1xyXG4gICAgICAgIGlmICh0aGVtZS5tb2RlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RpZnlMaWdodFNjaGVtZUNvbG9yKHJnYiwgdGhlbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9sZSA9IGdldEZnUG9sZSh0aGVtZSk7XHJcbiAgICAgICAgcmV0dXJuIG1vZGlmeUNvbG9yV2l0aENhY2hlKFxyXG4gICAgICAgICAgICByZ2IsXHJcbiAgICAgICAgICAgIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGVtZSksIHttb2RlOiAwfSksXHJcbiAgICAgICAgICAgIG1vZGlmeUZnSFNMLFxyXG4gICAgICAgICAgICBwb2xlXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZGlmeUJvcmRlckhTTChfYSwgcG9sZUZnLCBwb2xlQmcpIHtcclxuICAgICAgICB2YXIgaCA9IF9hLmgsXHJcbiAgICAgICAgICAgIHMgPSBfYS5zLFxyXG4gICAgICAgICAgICBsID0gX2EubCxcclxuICAgICAgICAgICAgYSA9IF9hLmE7XHJcbiAgICAgICAgdmFyIGlzRGFyayA9IGwgPCAwLjU7XHJcbiAgICAgICAgdmFyIGlzTmV1dHJhbCA9IGwgPCAwLjIgfHwgcyA8IDAuMjQ7XHJcbiAgICAgICAgdmFyIGh4ID0gaDtcclxuICAgICAgICB2YXIgc3ggPSBzO1xyXG4gICAgICAgIGlmIChpc05ldXRyYWwpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGFyaykge1xyXG4gICAgICAgICAgICAgICAgaHggPSBwb2xlRmcuaDtcclxuICAgICAgICAgICAgICAgIHN4ID0gcG9sZUZnLnM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoeCA9IHBvbGVCZy5oO1xyXG4gICAgICAgICAgICAgICAgc3ggPSBwb2xlQmcucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbHggPSBzY2FsZShsLCAwLCAxLCAwLjUsIDAuMik7XHJcbiAgICAgICAgcmV0dXJuIHtoOiBoeCwgczogc3gsIGw6IGx4LCBhOiBhfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZGlmeUJvcmRlckNvbG9yKHJnYiwgdGhlbWUpIHtcclxuICAgICAgICBpZiAodGhlbWUubW9kZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kaWZ5TGlnaHRTY2hlbWVDb2xvcihyZ2IsIHRoZW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvbGVGZyA9IGdldEZnUG9sZSh0aGVtZSk7XHJcbiAgICAgICAgdmFyIHBvbGVCZyA9IGdldEJnUG9sZSh0aGVtZSk7XHJcbiAgICAgICAgcmV0dXJuIG1vZGlmeUNvbG9yV2l0aENhY2hlKFxyXG4gICAgICAgICAgICByZ2IsXHJcbiAgICAgICAgICAgIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGVtZSksIHttb2RlOiAwfSksXHJcbiAgICAgICAgICAgIG1vZGlmeUJvcmRlckhTTCxcclxuICAgICAgICAgICAgcG9sZUZnLFxyXG4gICAgICAgICAgICBwb2xlQmdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW9kaWZ5U2hhZG93Q29sb3IocmdiLCBmaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbW9kaWZ5QmFja2dyb3VuZENvbG9yKHJnYiwgZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZGlmeUdyYWRpZW50Q29sb3IocmdiLCBmaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbW9kaWZ5QmFja2dyb3VuZENvbG9yKHJnYiwgZmlsdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVUZXh0U3R5bGUoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgJyo6bm90KHByZSwgcHJlICosIGNvZGUsIC5mYXIsIC5mYSwgLmdseXBoaWNvbiwgW2NsYXNzKj1cInZqcy1cIl0sIC5mYWIsIC5mYS1naXRodWIsIC5mYXMsIC5tYXRlcmlhbC1pY29ucywgLmljb2ZvbnQsIC50eXBjbiwgbXUsIFtjbGFzcyo9XCJtdS1cIl0sIC5nbHlwaGljb24sIC5pY29uKSB7J1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy51c2VGb250ICYmIGNvbmZpZy5mb250RmFtaWx5KSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBcIiAgZm9udC1mYW1pbHk6IFwiLmNvbmNhdChjb25maWcuZm9udEZhbWlseSwgXCIgIWltcG9ydGFudDtcIilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbmZpZy50ZXh0U3Ryb2tlID4gMCkge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgXCIgIC13ZWJraXQtdGV4dC1zdHJva2U6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcudGV4dFN0cm9rZSxcclxuICAgICAgICAgICAgICAgICAgICBcInB4ICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgICAgIFwiICB0ZXh0LXN0cm9rZTogXCIuY29uY2F0KGNvbmZpZy50ZXh0U3Ryb2tlLCBcInB4ICFpbXBvcnRhbnQ7XCIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBGaWx0ZXJNb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChGaWx0ZXJNb2RlKSB7XHJcbiAgICAgICAgRmlsdGVyTW9kZVsoRmlsdGVyTW9kZVtcImxpZ2h0XCJdID0gMCldID0gXCJsaWdodFwiO1xyXG4gICAgICAgIEZpbHRlck1vZGVbKEZpbHRlck1vZGVbXCJkYXJrXCJdID0gMSldID0gXCJkYXJrXCI7XHJcbiAgICB9KShGaWx0ZXJNb2RlIHx8IChGaWx0ZXJNb2RlID0ge30pKTtcclxuICAgIGZ1bmN0aW9uIGdldENTU0ZpbHRlclZhbHVlKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gW107XHJcbiAgICAgICAgaWYgKGNvbmZpZy5tb2RlID09PSBGaWx0ZXJNb2RlLmRhcmspIHtcclxuICAgICAgICAgICAgZmlsdGVycy5wdXNoKFwiaW52ZXJ0KDEwMCUpIGh1ZS1yb3RhdGUoMTgwZGVnKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbmZpZy5icmlnaHRuZXNzICE9PSAxMDApIHtcclxuICAgICAgICAgICAgZmlsdGVycy5wdXNoKFwiYnJpZ2h0bmVzcyhcIi5jb25jYXQoY29uZmlnLmJyaWdodG5lc3MsIFwiJSlcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLmNvbnRyYXN0ICE9PSAxMDApIHtcclxuICAgICAgICAgICAgZmlsdGVycy5wdXNoKFwiY29udHJhc3QoXCIuY29uY2F0KGNvbmZpZy5jb250cmFzdCwgXCIlKVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcuZ3JheXNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGZpbHRlcnMucHVzaChcImdyYXlzY2FsZShcIi5jb25jYXQoY29uZmlnLmdyYXlzY2FsZSwgXCIlKVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcuc2VwaWEgIT09IDApIHtcclxuICAgICAgICAgICAgZmlsdGVycy5wdXNoKFwic2VwaWEoXCIuY29uY2F0KGNvbmZpZy5zZXBpYSwgXCIlKVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMuam9pbihcIiBcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9TVkdNYXRyaXgobWF0cml4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeFxyXG4gICAgICAgICAgICAuc2xpY2UoMCwgNClcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1cclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnRvRml4ZWQoMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFNWR0ZpbHRlck1hdHJpeFZhbHVlKGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiB0b1NWR01hdHJpeChjcmVhdGVGaWx0ZXJNYXRyaXgoY29uZmlnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvdW50ZXIgPSAwO1xyXG4gICAgdmFyIHJlc29sdmVycyQxID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHJlamVjdG9ycyA9IG5ldyBNYXAoKTtcclxuICAgIGZ1bmN0aW9uIGJnRmV0Y2gocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gKytjb3VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcnMkMS5zZXQoaWQsIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RvcnMuc2V0KGlkLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5DU19GRVRDSCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSxcclxuICAgICAgICAgICAgZGF0YSA9IF9hLmRhdGEsXHJcbiAgICAgICAgICAgIGVycm9yID0gX2EuZXJyb3IsXHJcbiAgICAgICAgICAgIGlkID0gX2EuaWQ7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IE1lc3NhZ2VUeXBlLkJHX0ZFVENIX1JFU1BPTlNFKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gcmVzb2x2ZXJzJDEuZ2V0KGlkKTtcclxuICAgICAgICAgICAgdmFyIHJlamVjdCA9IHJlamVjdG9ycy5nZXQoaWQpO1xyXG4gICAgICAgICAgICByZXNvbHZlcnMkMS5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICByZWplY3RvcnMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QgJiYgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUgJiYgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBBc3luY1F1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBc3luY1F1ZXVlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXN5bmNRdWV1ZS5wcm90b3R5cGUuYWRkVG9RdWV1ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UXVldWUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFzeW5jUXVldWUucHJvdG90eXBlLnN0b3BRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lcklkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXN5bmNRdWV1ZS5wcm90b3R5cGUuc3RhcnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lcklkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNiID0gX3RoaXMucXVldWUuc2hpZnQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPj0gX3RoaXMuZnJhbWVEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQXN5bmNRdWV1ZTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgdmFyIGltYWdlTWFuYWdlciA9IG5ldyBBc3luY1F1ZXVlKCk7XHJcbiAgICBmdW5jdGlvbiBnZXRJbWFnZURldGFpbHModXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFVUkwsIGVycm9yXzEsIGltYWdlXzEsIGVycm9yXzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVUkwgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBnZXRJbWFnZURhdGFVUkwodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVUkwgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFs0LCA2LCAsIDddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdXJsVG9JbWFnZShkYXRhVVJMKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU1hbmFnZXIuYWRkVG9RdWV1ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVSTDogZGF0YVVSTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2VfMS5uYXR1cmFsV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZV8xLm5hdHVyYWxIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmFseXplSW1hZ2UoaW1hZ2VfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRJbWFnZURhdGFVUkwodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VkVVJMO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcnNlZFVSTC5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGxvYWRBc0RhdGFVUkwodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnRmV0Y2goe3VybDogdXJsLCByZXNwb25zZVR5cGU6IFwiZGF0YS11cmxcIn0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXJsVG9JbWFnZSh1cmwpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgMixcclxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFwiVW5hYmxlIHRvIGxvYWQgaW1hZ2UgXCIuY29uY2F0KHVybCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIE1BWF9BTkFMSVpFX1BJWEVMU19DT1VOVCA9IDMyICogMzI7XHJcbiAgICB2YXIgY2FudmFzO1xyXG4gICAgdmFyIGNvbnRleHQ7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDYW52YXMoKSB7XHJcbiAgICAgICAgdmFyIG1heFdpZHRoID0gTUFYX0FOQUxJWkVfUElYRUxTX0NPVU5UO1xyXG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBNQVhfQU5BTElaRV9QSVhFTFNfQ09VTlQ7XHJcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVDYW52YXMoKSB7XHJcbiAgICAgICAgY2FudmFzID0gbnVsbDtcclxuICAgICAgICBjb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBNQVhfSU1BR0VfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcclxuICAgIGZ1bmN0aW9uIGFuYWx5emVJbWFnZShpbWFnZSkge1xyXG4gICAgICAgIGlmICghY2FudmFzKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZUNhbnZhcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoLFxyXG4gICAgICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICBpZiAobmF0dXJhbEhlaWdodCA9PT0gMCB8fCBuYXR1cmFsV2lkdGggPT09IDApIHtcclxuICAgICAgICAgICAgbG9nV2FybihcImxvZ1dhcm4oSW1hZ2UgaXMgZW1wdHkgXCIuY29uY2F0KGltYWdlLmN1cnJlbnRTcmMsIFwiKVwiKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IG5hdHVyYWxXaWR0aCAqIG5hdHVyYWxIZWlnaHQgKiA0O1xyXG4gICAgICAgIGlmIChzaXplID4gTUFYX0lNQUdFX1NJWkUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzRGFyazogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0xpZ2h0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzVHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNMYXJnZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc1Rvb0xhcmdlOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuYXR1cmFsUGl4ZWxzQ291bnQgPSBuYXR1cmFsV2lkdGggKiBuYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIE1hdGguc3FydChNQVhfQU5BTElaRV9QSVhFTFNfQ09VTlQgLyBuYXR1cmFsUGl4ZWxzQ291bnQpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwobmF0dXJhbFdpZHRoICogayk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguY2VpbChuYXR1cmFsSGVpZ2h0ICogayk7XHJcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIGltYWdlLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBuYXR1cmFsV2lkdGgsXHJcbiAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQsXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB2YXIgZCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIHZhciBUUkFOU1BBUkVOVF9BTFBIQV9USFJFU0hPTEQgPSAwLjA1O1xyXG4gICAgICAgIHZhciBEQVJLX0xJR0hUTkVTU19USFJFU0hPTEQgPSAwLjQ7XHJcbiAgICAgICAgdmFyIExJR0hUX0xJR0hUTkVTU19USFJFU0hPTEQgPSAwLjc7XHJcbiAgICAgICAgdmFyIHRyYW5zcGFyZW50UGl4ZWxzQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBkYXJrUGl4ZWxzQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBsaWdodFBpeGVsc0NvdW50ID0gMDtcclxuICAgICAgICB2YXIgaSwgeCwgeTtcclxuICAgICAgICB2YXIgciwgZywgYiwgYTtcclxuICAgICAgICB2YXIgbDtcclxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGkgPSA0ICogKHkgKiB3aWR0aCArIHgpO1xyXG4gICAgICAgICAgICAgICAgciA9IGRbaSArIDBdO1xyXG4gICAgICAgICAgICAgICAgZyA9IGRbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgYiA9IGRbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgYSA9IGRbaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgLyAyNTUgPCBUUkFOU1BBUkVOVF9BTFBIQV9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudFBpeGVsc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBnZXRTUkdCTGlnaHRuZXNzKHIsIGcsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsIDwgREFSS19MSUdIVE5FU1NfVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhcmtQaXhlbHNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobCA+IExJR0hUX0xJR0hUTkVTU19USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlnaHRQaXhlbHNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG90YWxQaXhlbHNDb3VudCA9IHdpZHRoICogaGVpZ2h0O1xyXG4gICAgICAgIHZhciBvcGFxdWVQaXhlbHNDb3VudCA9IHRvdGFsUGl4ZWxzQ291bnQgLSB0cmFuc3BhcmVudFBpeGVsc0NvdW50O1xyXG4gICAgICAgIHZhciBEQVJLX0lNQUdFX1RIUkVTSE9MRCA9IDAuNztcclxuICAgICAgICB2YXIgTElHSFRfSU1BR0VfVEhSRVNIT0xEID0gMC43O1xyXG4gICAgICAgIHZhciBUUkFOU1BBUkVOVF9JTUFHRV9USFJFU0hPTEQgPSAwLjE7XHJcbiAgICAgICAgdmFyIExBUkdFX0lNQUdFX1BJWEVMU19DT1VOVCA9IDgwMCAqIDYwMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0Rhcms6IGRhcmtQaXhlbHNDb3VudCAvIG9wYXF1ZVBpeGVsc0NvdW50ID49IERBUktfSU1BR0VfVEhSRVNIT0xELFxyXG4gICAgICAgICAgICBpc0xpZ2h0OlxyXG4gICAgICAgICAgICAgICAgbGlnaHRQaXhlbHNDb3VudCAvIG9wYXF1ZVBpeGVsc0NvdW50ID49IExJR0hUX0lNQUdFX1RIUkVTSE9MRCxcclxuICAgICAgICAgICAgaXNUcmFuc3BhcmVudDpcclxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50UGl4ZWxzQ291bnQgLyB0b3RhbFBpeGVsc0NvdW50ID49XHJcbiAgICAgICAgICAgICAgICBUUkFOU1BBUkVOVF9JTUFHRV9USFJFU0hPTEQsXHJcbiAgICAgICAgICAgIGlzTGFyZ2U6IG5hdHVyYWxQaXhlbHNDb3VudCA+PSBMQVJHRV9JTUFHRV9QSVhFTFNfQ09VTlQsXHJcbiAgICAgICAgICAgIGlzVG9vTGFyZ2U6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcmVkSW1hZ2VEYXRhVVJMKF9hLCB0aGVtZSkge1xyXG4gICAgICAgIHZhciBkYXRhVVJMID0gX2EuZGF0YVVSTCxcclxuICAgICAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBnZXRTVkdGaWx0ZXJNYXRyaXhWYWx1ZSh0aGVtZSk7XHJcbiAgICAgICAgdmFyIHN2ZyA9IFtcclxuICAgICAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHdpZHRoPVwiJ1xyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh3aWR0aCwgJ1wiIGhlaWdodD1cIicpXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KGhlaWdodCwgJ1wiPicpLFxyXG4gICAgICAgICAgICBcIjxkZWZzPlwiLFxyXG4gICAgICAgICAgICAnPGZpbHRlciBpZD1cImRhcmtyZWFkZXItaW1hZ2UtZmlsdGVyXCI+JyxcclxuICAgICAgICAgICAgJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCInLmNvbmNhdChtYXRyaXgsICdcIiAvPicpLFxyXG4gICAgICAgICAgICBcIjwvZmlsdGVyPlwiLFxyXG4gICAgICAgICAgICBcIjwvZGVmcz5cIixcclxuICAgICAgICAgICAgJzxpbWFnZSB3aWR0aD1cIidcclxuICAgICAgICAgICAgICAgIC5jb25jYXQod2lkdGgsICdcIiBoZWlnaHQ9XCInKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGZpbHRlcj1cInVybCgjZGFya3JlYWRlci1pbWFnZS1maWx0ZXIpXCIgeGxpbms6aHJlZj1cIidcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoZGF0YVVSTCwgJ1wiIC8+JyksXHJcbiAgICAgICAgICAgIFwiPC9zdmc+XCJcclxuICAgICAgICBdLmpvaW4oXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIi5jb25jYXQoYnRvYShzdmcpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFuSW1hZ2VQcm9jZXNzaW5nQ2FjaGUoKSB7XHJcbiAgICAgICAgaW1hZ2VNYW5hZ2VyICYmIGltYWdlTWFuYWdlci5zdG9wUXVldWUoKTtcclxuICAgICAgICByZW1vdmVDYW52YXMoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ3JhZGllbnRMZW5ndGggPSBcImdyYWRpZW50XCIubGVuZ3RoO1xyXG4gICAgdmFyIGNvbmljR3JhZGllbnQgPSBcImNvbmljLVwiO1xyXG4gICAgdmFyIGNvbmljR3JhZGllbnRMZW5ndGggPSBjb25pY0dyYWRpZW50Lmxlbmd0aDtcclxuICAgIHZhciByYWRpYWxHcmFkaWVudCA9IFwicmFkaWFsLVwiO1xyXG4gICAgdmFyIGxpbmVhckdyYWRpZW50ID0gXCJsaW5lYXItXCI7XHJcbiAgICBmdW5jdGlvbiBwYXJzZUdyYWRpZW50KHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBjb25pY0dyYWRpZW50Lmxlbmd0aDtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVHcmFkaWVudDtcclxuICAgICAgICAgICAgW2xpbmVhckdyYWRpZW50LCByYWRpYWxHcmFkaWVudCwgY29uaWNHcmFkaWVudF0uZmluZChmdW5jdGlvbiAoXHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVR5cGVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggLSBwb3NzaWJsZVR5cGUubGVuZ3RoID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVHcmFkaWVudCA9IHZhbHVlLnN1YnN0cmluZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLSBwb3NzaWJsZVR5cGUubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlR3JhZGllbnQgPT09IHBvc3NpYmxlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAtIHBvc3NpYmxlVHlwZS5sZW5ndGggLSAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAtIHBvc3NpYmxlVHlwZS5sZW5ndGggLSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApID09PSBcInJlcGVhdGluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUdyYWRpZW50ID0gXCJyZXBlYXRpbmctXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdyYWRpZW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAtIHBvc3NpYmxlVHlwZS5sZW5ndGggLSA4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IC0gcG9zc2libGVUeXBlLmxlbmd0aCAtIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgPT09IFwiLXdlYmtpdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUdyYWRpZW50ID0gXCItd2Via2l0LVwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJncmFkaWVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUdyYWRpZW50ID0gXCJcIi5jb25jYXQocG9zc2libGVUeXBlLCBcImdyYWRpZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIXR5cGVHcmFkaWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRQYXJlbnRoZXNlc1JhbmdlKHZhbHVlLCBpbmRleCArIGdyYWRpZW50TGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gX2Euc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQgPSBfYS5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzdGFydCArIDEsIGVuZCAtIDEpO1xyXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kICsgMSArIGNvbmljR3JhZGllbnRMZW5ndGg7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGVHcmFkaWVudDogdHlwZUdyYWRpZW50LFxyXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0eXBlR3JhZGllbnQubGVuZ3RoICsgMixcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCAtIHR5cGVHcmFkaWVudC5sZW5ndGggKyBncmFkaWVudExlbmd0aCxcclxuICAgICAgICAgICAgICAgIGhhc0NvbW1hOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgd2hpbGUgKChpbmRleCA9IHZhbHVlLmluZGV4T2YoXCJncmFkaWVudFwiLCBzdGFydEluZGV4KSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5oYXNDb21tYSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXR5KHJ1bGVTdHlsZSwgcHJvcGVydHkpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihydWxlU3R5bGUgJiYgcnVsZVN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldE1vZGlmaWFibGVDU1NEZWNsYXJhdGlvbihcclxuICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBydWxlLFxyXG4gICAgICAgIHZhcmlhYmxlc1N0b3JlLFxyXG4gICAgICAgIGlnbm9yZUltYWdlU2VsZWN0b3JzLFxyXG4gICAgICAgIGlzQ2FuY2VsbGVkXHJcbiAgICApIHtcclxuICAgICAgICBpZiAocHJvcGVydHkuc3RhcnRzV2l0aChcIi0tXCIpKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGdldFZhcmlhYmxlTW9kaWZpZXIoXHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXNTdG9yZSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlSW1hZ2VTZWxlY3RvcnMsXHJcbiAgICAgICAgICAgICAgICBpc0NhbmNlbGxlZFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQ6IGdldFByaW9yaXR5KHJ1bGUuc3R5bGUsIHByb3BlcnR5KSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmluY2x1ZGVzKFwidmFyKFwiKSkge1xyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBnZXRWYXJpYWJsZURlcGVuZGFudE1vZGlmaWVyKFxyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzU3RvcmUsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1vZGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogZ2V0UHJpb3JpdHkocnVsZS5zdHlsZSwgcHJvcGVydHkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09IFwiY29sb3Itc2NoZW1lXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgKHByb3BlcnR5LmluY2x1ZGVzKFwiY29sb3JcIikgJiZcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ICE9PSBcIi13ZWJraXQtcHJpbnQtY29sb3ItYWRqdXN0XCIpIHx8XHJcbiAgICAgICAgICAgIHByb3BlcnR5ID09PSBcImZpbGxcIiB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJzdHJva2VcIiB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJzdG9wLWNvbG9yXCJcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIG1vZGlmaWVyID0gZ2V0Q29sb3JNb2RpZmllcihwcm9wZXJ0eSwgdmFsdWUsIHJ1bGUpO1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQ6IGdldFByaW9yaXR5KHJ1bGUuc3R5bGUsIHByb3BlcnR5KSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJiYWNrZ3JvdW5kLWltYWdlXCIgfHxcclxuICAgICAgICAgICAgcHJvcGVydHkgPT09IFwibGlzdC1zdHlsZS1pbWFnZVwiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGdldEJnSW1hZ2VNb2RpZmllcihcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcnVsZSxcclxuICAgICAgICAgICAgICAgIGlnbm9yZUltYWdlU2VsZWN0b3JzLFxyXG4gICAgICAgICAgICAgICAgaXNDYW5jZWxsZWRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbW9kaWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50OiBnZXRQcmlvcml0eShydWxlLnN0eWxlLCBwcm9wZXJ0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS5pbmNsdWRlcyhcInNoYWRvd1wiKSkge1xyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBnZXRTaGFkb3dNb2RpZmllcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1vZGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogZ2V0UHJpb3JpdHkocnVsZS5zdHlsZSwgcHJvcGVydHkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGpvaW5TZWxlY3RvcnMoKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3JzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLCBcIik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRNb2RpZmllZFVzZXJBZ2VudFN0eWxlKHRoZW1lLCBpc0lGcmFtZSwgc3R5bGVTeXN0ZW1Db250cm9scykge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGlmICghaXNJRnJhbWUpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChcImh0bWwge1wiKTtcclxuICAgICAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgICAgIFwiICAgIGJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZnlCYWNrZ3JvdW5kQ29sb3Ioe3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9LCB0aGVtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgIWltcG9ydGFudDtcIlxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ1NTQ29sb3JTY2hlbWVQcm9wU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJodG1sIHtcIik7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBcIiAgICBjb2xvci1zY2hlbWU6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICB0aGVtZS5tb2RlID09PSAxID8gXCJkYXJrXCIgOiBcImRhcmsgbGlnaHRcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiAhaW1wb3J0YW50O1wiXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmdTZWxlY3RvcnMgPSBqb2luU2VsZWN0b3JzKFxyXG4gICAgICAgICAgICBpc0lGcmFtZSA/IFwiXCIgOiBcImh0bWwsIGJvZHlcIixcclxuICAgICAgICAgICAgc3R5bGVTeXN0ZW1Db250cm9scyA/IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGJ1dHRvbiwgZGlhbG9nXCIgOiBcIlwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoYmdTZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChcIlwiLmNvbmNhdChiZ1NlbGVjdG9ycywgXCIge1wiKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBcIiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZ5QmFja2dyb3VuZENvbG9yKHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fSwgdGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiO1wiXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICBcIlwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIGpvaW5TZWxlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJodG1sLCBib2R5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTeXN0ZW1Db250cm9scyA/IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGJ1dHRvblwiIDogXCJcIlxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIFwiIHtcIlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICBcIiAgICBib3JkZXItY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUJvcmRlckNvbG9yKHtyOiA3NiwgZzogNzYsIGI6IDc2fSwgdGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgXCI7XCJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgXCIgICAgY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUZvcmVncm91bmRDb2xvcih7cjogMCwgZzogMCwgYjogMH0sIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIFwiO1wiXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJhIHtcIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgXCIgICAgY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUZvcmVncm91bmRDb2xvcih7cjogMCwgZzogNjQsIGI6IDI1NX0sIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIFwiO1wiXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJ0YWJsZSB7XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgIFwiICAgIGJvcmRlci1jb2xvcjogXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgbW9kaWZ5Qm9yZGVyQ29sb3Ioe3I6IDEyOCwgZzogMTI4LCBiOiAxMjh9LCB0aGVtZSksXHJcbiAgICAgICAgICAgICAgICBcIjtcIlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiOjpwbGFjZWhvbGRlciB7XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgIFwiICAgIGNvbG9yOiBcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBtb2RpZnlGb3JlZ3JvdW5kQ29sb3Ioe3I6IDE2OSwgZzogMTY5LCBiOiAxNjl9LCB0aGVtZSksXHJcbiAgICAgICAgICAgICAgICBcIjtcIlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiaW5wdXQ6LXdlYmtpdC1hdXRvZmlsbCxcIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcInRleHRhcmVhOi13ZWJraXQtYXV0b2ZpbGwsXCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJzZWxlY3Q6LXdlYmtpdC1hdXRvZmlsbCB7XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgIFwiICAgIGJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUJhY2tncm91bmRDb2xvcih7cjogMjUwLCBnOiAyNTUsIGI6IDE4OX0sIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIFwiICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgXCIgICAgY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUZvcmVncm91bmRDb2xvcih7cjogMCwgZzogMCwgYjogMH0sIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIFwiICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGluZXMucHVzaChcIn1cIik7XHJcbiAgICAgICAgaWYgKHRoZW1lLnNjcm9sbGJhckNvbG9yKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goZ2V0TW9kaWZpZWRTY3JvbGxiYXJTdHlsZSh0aGVtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhlbWUuc2VsZWN0aW9uQ29sb3IpIHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChnZXRNb2RpZmllZFNlbGVjdGlvblN0eWxlKHRoZW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ29sb3IodGhlbWUpIHtcclxuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yU2VsZWN0aW9uO1xyXG4gICAgICAgIHZhciBmb3JlZ3JvdW5kQ29sb3JTZWxlY3Rpb247XHJcbiAgICAgICAgaWYgKHRoZW1lLnNlbGVjdGlvbkNvbG9yID09PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3JTZWxlY3Rpb24gPSBtb2RpZnlCYWNrZ3JvdW5kQ29sb3IoXHJcbiAgICAgICAgICAgICAgICB7cjogMCwgZzogOTYsIGI6IDIxMn0sXHJcbiAgICAgICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhlbWUpLCB7Z3JheXNjYWxlOiAwfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yU2VsZWN0aW9uID0gbW9kaWZ5Rm9yZWdyb3VuZENvbG9yKFxyXG4gICAgICAgICAgICAgICAge3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9LFxyXG4gICAgICAgICAgICAgICAgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoZW1lKSwge2dyYXlzY2FsZTogMH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJnYiA9IHBhcnNlQ29sb3JXaXRoQ2FjaGUodGhlbWUuc2VsZWN0aW9uQ29sb3IpO1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gcmdiVG9IU0wocmdiKTtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yU2VsZWN0aW9uID0gdGhlbWUuc2VsZWN0aW9uQ29sb3I7XHJcbiAgICAgICAgICAgIGlmIChoc2wubCA8IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yU2VsZWN0aW9uID0gXCIjRkZGXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JlZ3JvdW5kQ29sb3JTZWxlY3Rpb24gPSBcIiMwMDBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3JTZWxlY3Rpb246IGJhY2tncm91bmRDb2xvclNlbGVjdGlvbixcclxuICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yU2VsZWN0aW9uOiBmb3JlZ3JvdW5kQ29sb3JTZWxlY3Rpb25cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0TW9kaWZpZWRTZWxlY3Rpb25TdHlsZSh0aGVtZSkge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIHZhciBtb2RpZmllZFNlbGVjdGlvbkNvbG9yID0gZ2V0U2VsZWN0aW9uQ29sb3IodGhlbWUpO1xyXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3JTZWxlY3Rpb24gPVxyXG4gICAgICAgICAgICBtb2RpZmllZFNlbGVjdGlvbkNvbG9yLmJhY2tncm91bmRDb2xvclNlbGVjdGlvbjtcclxuICAgICAgICB2YXIgZm9yZWdyb3VuZENvbG9yU2VsZWN0aW9uID1cclxuICAgICAgICAgICAgbW9kaWZpZWRTZWxlY3Rpb25Db2xvci5mb3JlZ3JvdW5kQ29sb3JTZWxlY3Rpb247XHJcbiAgICAgICAgW1wiOjpzZWxlY3Rpb25cIiwgXCI6Oi1tb3otc2VsZWN0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIuY29uY2F0KHNlbGVjdGlvbiwgXCIge1wiKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBcIiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yU2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgICAgIFwiICAgIGNvbG9yOiBcIi5jb25jYXQoZm9yZWdyb3VuZENvbG9yU2VsZWN0aW9uLCBcIiAhaW1wb3J0YW50O1wiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldE1vZGlmaWVkU2Nyb2xsYmFyU3R5bGUodGhlbWUpIHtcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICB2YXIgY29sb3JUcmFjaztcclxuICAgICAgICB2YXIgY29sb3JJY29ucztcclxuICAgICAgICB2YXIgY29sb3JUaHVtYjtcclxuICAgICAgICB2YXIgY29sb3JUaHVtYkhvdmVyO1xyXG4gICAgICAgIHZhciBjb2xvclRodW1iQWN0aXZlO1xyXG4gICAgICAgIHZhciBjb2xvckNvcm5lcjtcclxuICAgICAgICBpZiAodGhlbWUuc2Nyb2xsYmFyQ29sb3IgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgIGNvbG9yVHJhY2sgPSBtb2RpZnlCYWNrZ3JvdW5kQ29sb3Ioe3I6IDI0MSwgZzogMjQxLCBiOiAyNDF9LCB0aGVtZSk7XHJcbiAgICAgICAgICAgIGNvbG9ySWNvbnMgPSBtb2RpZnlGb3JlZ3JvdW5kQ29sb3Ioe3I6IDk2LCBnOiA5NiwgYjogOTZ9LCB0aGVtZSk7XHJcbiAgICAgICAgICAgIGNvbG9yVGh1bWIgPSBtb2RpZnlCYWNrZ3JvdW5kQ29sb3Ioe3I6IDE3NiwgZzogMTc2LCBiOiAxNzZ9LCB0aGVtZSk7XHJcbiAgICAgICAgICAgIGNvbG9yVGh1bWJIb3ZlciA9IG1vZGlmeUJhY2tncm91bmRDb2xvcihcclxuICAgICAgICAgICAgICAgIHtyOiAxNDQsIGc6IDE0NCwgYjogMTQ0fSxcclxuICAgICAgICAgICAgICAgIHRoZW1lXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbG9yVGh1bWJBY3RpdmUgPSBtb2RpZnlCYWNrZ3JvdW5kQ29sb3IoXHJcbiAgICAgICAgICAgICAgICB7cjogOTYsIGc6IDk2LCBiOiA5Nn0sXHJcbiAgICAgICAgICAgICAgICB0aGVtZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb2xvckNvcm5lciA9IG1vZGlmeUJhY2tncm91bmRDb2xvcihcclxuICAgICAgICAgICAgICAgIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fSxcclxuICAgICAgICAgICAgICAgIHRoZW1lXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJnYiA9IHBhcnNlQ29sb3JXaXRoQ2FjaGUodGhlbWUuc2Nyb2xsYmFyQ29sb3IpO1xyXG4gICAgICAgICAgICB2YXIgaHNsXzEgPSByZ2JUb0hTTChyZ2IpO1xyXG4gICAgICAgICAgICB2YXIgaXNMaWdodCA9IGhzbF8xLmwgPiAwLjU7XHJcbiAgICAgICAgICAgIHZhciBsaWdodGVuID0gZnVuY3Rpb24gKGxpZ2h0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHNsXzEpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbDogY2xhbXAoaHNsXzEubCArIGxpZ2h0ZXIsIDAsIDEpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIChkYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHNsXzEpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbDogY2xhbXAoaHNsXzEubCAtIGRhcmtlciwgMCwgMSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb2xvclRyYWNrID0gaHNsVG9TdHJpbmcoZGFya2VuKDAuNCkpO1xyXG4gICAgICAgICAgICBjb2xvckljb25zID0gaHNsVG9TdHJpbmcoaXNMaWdodCA/IGRhcmtlbigwLjQpIDogbGlnaHRlbigwLjQpKTtcclxuICAgICAgICAgICAgY29sb3JUaHVtYiA9IGhzbFRvU3RyaW5nKGhzbF8xKTtcclxuICAgICAgICAgICAgY29sb3JUaHVtYkhvdmVyID0gaHNsVG9TdHJpbmcobGlnaHRlbigwLjEpKTtcclxuICAgICAgICAgICAgY29sb3JUaHVtYkFjdGl2ZSA9IGhzbFRvU3RyaW5nKGxpZ2h0ZW4oMC4yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmVzLnB1c2goXCI6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcIiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoY29sb3JUcmFjaywgXCI7XCIpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiICAgIGNvbG9yOiBcIi5jb25jYXQoY29sb3JJY29ucywgXCI7XCIpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XCIpO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCIgICAgYmFja2dyb3VuZC1jb2xvcjogXCIuY29uY2F0KGNvbG9yVGh1bWIsIFwiO1wiKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChcIn1cIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcIjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWI6aG92ZXIge1wiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiICAgIGJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChjb2xvclRodW1iSG92ZXIsIFwiO1wiKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChcIn1cIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcIjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWI6YWN0aXZlIHtcIik7XHJcbiAgICAgICAgbGluZXMucHVzaChcIiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoY29sb3JUaHVtYkFjdGl2ZSwgXCI7XCIpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXIge1wiKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwiICAgIGJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChjb2xvckNvcm5lciwgXCI7XCIpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICBpZiAoaXNGaXJlZm94KSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCIqIHtcIik7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBcIiAgICBzY3JvbGxiYXItY29sb3I6IFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjb2xvclRodW1iLCBcIiBcIilcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNvbG9yVHJhY2ssIFwiO1wiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRNb2RpZmllZEZhbGxiYWNrU3R5bGUoZmlsdGVyLCBfYSkge1xyXG4gICAgICAgIHZhciBzdHJpY3QgPSBfYS5zdHJpY3Q7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgdmFyIGlzTWljcm9zb2Z0ID0gW1wibWljcm9zb2Z0LmNvbVwiLCBcImRvY3MubWljcm9zb2Z0LmNvbVwiXS5pbmNsdWRlcyhcclxuICAgICAgICAgICAgbG9jYXRpb24uaG9zdG5hbWVcclxuICAgICAgICApO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXHJcbiAgICAgICAgICAgIFwiaHRtbCwgYm9keSwgXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgc3RyaWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBcImJvZHkgOm5vdChpZnJhbWUpXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWljcm9zb2Z0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzpub3QoZGl2W3N0eWxlXj1cInBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LVwiXSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcImJvZHkgPiA6bm90KGlmcmFtZSlcIixcclxuICAgICAgICAgICAgICAgIFwiIHtcIlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICBcIiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBtb2RpZnlCYWNrZ3JvdW5kQ29sb3Ioe3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9LCBmaWx0ZXIpLFxyXG4gICAgICAgICAgICAgICAgXCIgIWltcG9ydGFudDtcIlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICBcIiAgICBib3JkZXItY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUJvcmRlckNvbG9yKHtyOiA2NCwgZzogNjQsIGI6IDY0fSwgZmlsdGVyKSxcclxuICAgICAgICAgICAgICAgIFwiICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGluZXMucHVzaChcclxuICAgICAgICAgICAgXCIgICAgY29sb3I6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG1vZGlmeUZvcmVncm91bmRDb2xvcih7cjogMCwgZzogMCwgYjogMH0sIGZpbHRlciksXHJcbiAgICAgICAgICAgICAgICBcIiAhaW1wb3J0YW50O1wiXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xyXG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHVucGFyc2FibGVDb2xvcnMgPSBuZXcgU2V0KFtcclxuICAgICAgICBcImluaGVyaXRcIixcclxuICAgICAgICBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgXCJpbml0aWFsXCIsXHJcbiAgICAgICAgXCJjdXJyZW50Y29sb3JcIixcclxuICAgICAgICBcIm5vbmVcIixcclxuICAgICAgICBcInVuc2V0XCJcclxuICAgIF0pO1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JNb2RpZmllcihwcm9wLCB2YWx1ZSwgcnVsZSkge1xyXG4gICAgICAgIGlmICh1bnBhcnNhYmxlQ29sb3JzLmhhcyh2YWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZ2IgPSBwYXJzZUNvbG9yV2l0aENhY2hlKHZhbHVlKTtcclxuICAgICAgICBpZiAoIXJnYikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3AuaW5jbHVkZXMoXCJiYWNrZ3JvdW5kXCIpKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChydWxlLnN0eWxlLndlYmtpdE1hc2tJbWFnZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUud2Via2l0TWFza0ltYWdlICE9PSBcIm5vbmVcIikgfHxcclxuICAgICAgICAgICAgICAgIChydWxlLnN0eWxlLndlYmtpdE1hc2sgJiZcclxuICAgICAgICAgICAgICAgICAgICAhcnVsZS5zdHlsZS53ZWJraXRNYXNrLnN0YXJ0c1dpdGgoXCJub25lXCIpKSB8fFxyXG4gICAgICAgICAgICAgICAgKHJ1bGUuc3R5bGUubWFzayAmJiBydWxlLnN0eWxlLm1hc2sgIT09IFwibm9uZVwiKSB8fFxyXG4gICAgICAgICAgICAgICAgKHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm1hc2staW1hZ2VcIikgJiZcclxuICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJtYXNrLWltYWdlXCIpICE9PSBcIm5vbmVcIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RpZnlGb3JlZ3JvdW5kQ29sb3IocmdiLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmeUJhY2tncm91bmRDb2xvcihyZ2IsIGZpbHRlcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wLmluY2x1ZGVzKFwiYm9yZGVyXCIpIHx8IHByb3AuaW5jbHVkZXMoXCJvdXRsaW5lXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kaWZ5Qm9yZGVyQ29sb3IocmdiLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kaWZ5Rm9yZWdyb3VuZENvbG9yKHJnYiwgZmlsdGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGltYWdlRGV0YWlsc0NhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIGF3YWl0aW5nRm9ySW1hZ2VMb2FkaW5nID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gc2hvdWxkSWdub3JlSW1hZ2Uoc2VsZWN0b3JUZXh0LCBzZWxlY3RvcnMpIHtcclxuICAgICAgICBpZiAoIXNlbGVjdG9yVGV4dCB8fCBzZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBzZWxlY3RvcnMuc29tZShmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgPT09IFwiKlwiO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJ1bGVTZWxlY3RvcnMgPSBzZWxlY3RvclRleHQuc3BsaXQoLyxcXHMqL2cpO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIGlnbm9yZWRTZWxlY3RvciA9IHNlbGVjdG9yc1tpXTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgcnVsZVNlbGVjdG9ycy5zb21lKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMgPT09IGlnbm9yZWRTZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogdHJ1ZX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShpKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKSByZXR1cm4gc3RhdGVfMS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0QmdJbWFnZU1vZGlmaWVyKFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIHJ1bGUsXHJcbiAgICAgICAgaWdub3JlSW1hZ2VTZWxlY3RvcnMsXHJcbiAgICAgICAgaXNDYW5jZWxsZWRcclxuICAgICkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGdyYWRpZW50cyA9IHBhcnNlR3JhZGllbnQodmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgdXJscyA9IGdldE1hdGNoZXMoY3NzVVJMUmVnZXgsIHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHVybHMubGVuZ3RoID09PSAwICYmIGdyYWRpZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZ2V0SW5kaWNlcyA9IGZ1bmN0aW9uIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUluZGV4ID0gdmFsdWUuaW5kZXhPZihtYXRjaCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdmFsdWVJbmRleCArIG1hdGNoLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge21hdGNoOiBtYXRjaCwgaW5kZXg6IHZhbHVlSW5kZXh9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVzXzEgPSBncmFkaWVudHNcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe3R5cGU6IFwiZ3JhZGllbnRcIn0sIGkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kaWNlcyh1cmxzKS5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt0eXBlOiBcInVybFwiLCBvZmZzZXQ6IDB9LCBpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCA+IGIuaW5kZXggPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGdldEdyYWRpZW50TW9kaWZpZXJfMSA9IGZ1bmN0aW9uIChncmFkaWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVHcmFkaWVudCA9IGdyYWRpZW50LnR5cGVHcmFkaWVudCxcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGdyYWRpZW50Lm1hdGNoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbW1hID0gZ3JhZGllbnQuaGFzQ29tbWE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydHNSZWdleCA9XHJcbiAgICAgICAgICAgICAgICAgICAgLyhbXlxcKFxcKSxdKyhcXChbXlxcKFxcKV0qKFxcKFteXFwoXFwpXSpcXCkqW15cXChcXCldKik/XFwpKT8oW15cXChcXCksIF18KCAoPyFjYWxjKSkpKiksPy9nO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yU3RvcFJlZ2V4ID1cclxuICAgICAgICAgICAgICAgICAgICAvXihmcm9tfGNvbG9yLXN0b3B8dG8pXFwoKFteXFwoXFwpXSo/LFxccyopPyguKj8pXFwpJC87XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBnZXRNYXRjaGVzKHBhcnRzUmVnZXgsIG1hdGNoLCAxKS5tYXAoZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiID0gcGFyc2VDb2xvcldpdGhDYWNoZShwYXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmdiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kaWZ5R3JhZGllbnRDb2xvcihyZ2IsIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHBhcnQubGFzdEluZGV4T2YoXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJnYiA9IHBhcnNlQ29sb3JXaXRoQ2FjaGUocGFydC5zdWJzdHJpbmcoMCwgc3BhY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmdiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobW9kaWZ5R3JhZGllbnRDb2xvcihyZ2IsIGZpbHRlciksIFwiIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocGFydC5zdWJzdHJpbmcoc3BhY2UgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvclN0b3BNYXRjaCA9IHBhcnQubWF0Y2goY29sb3JTdG9wUmVnZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvclN0b3BNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZ2IgPSBwYXJzZUNvbG9yV2l0aENhY2hlKGNvbG9yU3RvcE1hdGNoWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNvbG9yU3RvcE1hdGNoWzFdLCBcIihcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcE1hdGNoWzJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChjb2xvclN0b3BNYXRjaFsyXSwgXCIsIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlHcmFkaWVudENvbG9yKHJnYiwgZmlsdGVyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0eXBlR3JhZGllbnQsIFwiKFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtb2RpZnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmeShmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChoYXNDb21tYSA/IFwiLCBcIiA6IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldFVSTE1vZGlmaWVyXzEgPSBmdW5jdGlvbiAodXJsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRJZ25vcmVJbWFnZShydWxlLnNlbGVjdG9yVGV4dCwgaWdub3JlSW1hZ2VTZWxlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBnZXRDU1NVUkxWYWx1ZSh1cmxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNVUkxFbXB0eSA9IHVybC5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3R5bGVTaGVldCA9IHJ1bGUucGFyZW50U3R5bGVTaGVldDtcclxuICAgICAgICAgICAgICAgIHZhciBiYXNlVVJMID1cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdHlsZVNoZWV0ICYmIHBhcmVudFN0eWxlU2hlZXQuaHJlZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldENTU0Jhc2VCYXRoKHBhcmVudFN0eWxlU2hlZXQuaHJlZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoKF9hID0gcGFyZW50U3R5bGVTaGVldC5vd25lck5vZGUpID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPT09IHZvaWQgMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF9hLmJhc2VVUkkpIHx8IGxvY2F0aW9uLm9yaWdpbjtcclxuICAgICAgICAgICAgICAgIHVybCA9IGdldEFic29sdXRlVVJMKGJhc2VVUkwsIHVybCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVWYWx1ZSA9ICd1cmwoXCInLmNvbmNhdCh1cmwsICdcIiknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGV0YWlscywgYXdhaXRlcnNfMSwgZXJyXzEsIGJnSW1hZ2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVVJMRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgXCJ1cmwoJycpXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VEZXRhaWxzQ2FjaGUuaGFzKHVybCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURldGFpbHMgPSBpbWFnZURldGFpbHNDYWNoZS5nZXQodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA3XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgNiwgLCA3XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXdhaXRpbmdGb3JJbWFnZUxvYWRpbmcuaGFzKHVybCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdGVyc18xID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0aW5nRm9ySW1hZ2VMb2FkaW5nLmdldCh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ZXJzXzEucHVzaChyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURldGFpbHMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VEZXRhaWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdGluZ0ZvckltYWdlTG9hZGluZy5zZXQodXJsLCBbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZ2V0SW1hZ2VEZXRhaWxzKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEZXRhaWxzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURldGFpbHNDYWNoZS5zZXQodXJsLCBpbWFnZURldGFpbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdGluZ0ZvckltYWdlTG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldCh1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGltYWdlRGV0YWlscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRpbmdGb3JJbWFnZUxvYWRpbmcuZGVsZXRlKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nV2FybihlcnJfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhd2FpdGluZ0ZvckltYWdlTG9hZGluZy5oYXModXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRpbmdGb3JJbWFnZUxvYWRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHVybClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0aW5nRm9ySW1hZ2VMb2FkaW5nLmRlbGV0ZSh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgYWJzb2x1dGVWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0ltYWdlVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmdJbWFnZVZhbHVlXzEoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEZXRhaWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCBhYnNvbHV0ZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGJnSW1hZ2VWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldEJnSW1hZ2VWYWx1ZV8xID0gZnVuY3Rpb24gKGltYWdlRGV0YWlscywgZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEYXJrID0gaW1hZ2VEZXRhaWxzLmlzRGFyayxcclxuICAgICAgICAgICAgICAgICAgICBpc0xpZ2h0ID0gaW1hZ2VEZXRhaWxzLmlzTGlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFuc3BhcmVudCA9IGltYWdlRGV0YWlscy5pc1RyYW5zcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzTGFyZ2UgPSBpbWFnZURldGFpbHMuaXNMYXJnZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1Rvb0xhcmdlID0gaW1hZ2VEZXRhaWxzLmlzVG9vTGFyZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZURldGFpbHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVG9vTGFyZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAndXJsKFwiJy5jb25jYXQoaW1hZ2VEZXRhaWxzLnNyYywgJ1wiKScpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBpc0RhcmsgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1RyYW5zcGFyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm1vZGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNMYXJnZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID4gMlxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nSW5mbyhcIkludmVydGluZyBkYXJrIGltYWdlIFwiLmNvbmNhdChpbWFnZURldGFpbHMuc3JjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludmVydGVkID0gZ2V0RmlsdGVyZWRJbWFnZURhdGFVUkwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGV0YWlscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlciksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGlhOiBjbGFtcChmaWx0ZXIuc2VwaWEgKyAxMCwgMCwgMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3VybChcIicuY29uY2F0KGludmVydGVkLCAnXCIpJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGlnaHQgJiYgIWlzVHJhbnNwYXJlbnQgJiYgZmlsdGVyLm1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYXJnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dJbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEaW1taW5nIGxpZ2h0IGltYWdlIFwiLmNvbmNhdChpbWFnZURldGFpbHMuc3JjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltbWVkID0gZ2V0RmlsdGVyZWRJbWFnZURhdGFVUkwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURldGFpbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3VybChcIicuY29uY2F0KGRpbW1lZCwgJ1wiKScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyLm1vZGUgPT09IDAgJiYgaXNMaWdodCAmJiAhaXNMYXJnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0luZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQXBwbHlpbmcgZmlsdGVyIHRvIGltYWdlIFwiLmNvbmNhdChpbWFnZURldGFpbHMuc3JjKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZ2V0RmlsdGVyZWRJbWFnZURhdGFVUkwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGV0YWlscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlciksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyaWdodG5lc3M6IGNsYW1wKGZpbHRlci5icmlnaHRuZXNzIC0gMTAsIDUsIDIwMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBpYTogY2xhbXAoZmlsdGVyLnNlcGlhICsgMTAsIDAsIDEwMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd1cmwoXCInLmNvbmNhdChmaWx0ZXJlZCwgJ1wiKScpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG1vZGlmaWVyc18xID0gW107XHJcbiAgICAgICAgICAgIHZhciBtYXRjaEluZGV4XzEgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcHJldkhhc0NvbW1hXzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgbWF0Y2hlc18xLmZvckVhY2goZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBfYS5tYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF9hLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVHcmFkaWVudCA9IF9hLnR5cGVHcmFkaWVudCxcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb21tYSA9IF9hLmhhc0NvbW1hLFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9hLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaFN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4U3RhcnQgPSBtYXRjaEluZGV4XzE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2gubGVuZ3RoICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hJbmRleF8xID0gbWF0Y2hFbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4U3RhcnQgIT09IG1hdGNoU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkhhc0NvbW1hXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzXzEucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmV0d2VlblZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeFN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoU3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmV0d2VlblZhbHVlWzBdID09PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldHdlZW5WYWx1ZSA9IGJldHdlZW5WYWx1ZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmV0d2VlblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnNfMS5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcocHJlZml4U3RhcnQsIG1hdGNoU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2SGFzQ29tbWFfMSA9IGhhc0NvbW1hIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwidXJsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnNfMS5wdXNoKGdldFVSTE1vZGlmaWVyXzEobWF0Y2gpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJncmFkaWVudFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzXzEucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0R3JhZGllbnRNb2RpZmllcl8xKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVHcmFkaWVudDogdHlwZUdyYWRpZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29tbWE6IGhhc0NvbW1hLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IG1hdGNoZXNfMS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzXzEucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcobWF0Y2hFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gbW9kaWZpZXJzXzFcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobW9kaWZ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RpZnkoZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNvbWUoZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgaW5zdGFuY2VvZiBQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihmdW5jdGlvbiAoYXN5bmNSZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3luY1Jlc3VsdHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRSZXN1bHQgPSByZXN1bHRzLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tYmluZWRSZXN1bHQuZW5kc1dpdGgoXCIsIGluaXRpYWxcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluZWRSZXN1bHQuc2xpY2UoMCwgLTkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkUmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTaGFkb3dNb2RpZmllcldpdGhJbmZvKHZhbHVlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGluZGV4XzEgPSAwO1xyXG4gICAgICAgICAgICB2YXIgY29sb3JNYXRjaGVzXzEgPSBnZXRNYXRjaGVzKFxyXG4gICAgICAgICAgICAgICAgLyhefFxccykoPyFjYWxjKShbYS16XStcXCguKz9cXCl8I1swLTlhLWZdK3xbYS16XSspKC4qPyhpbnNldHxvdXRzZXQpPygkfCwpKS9naSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgMlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YXIgbm90UGFyc2VkXzEgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZXJzXzIgPSBjb2xvck1hdGNoZXNfMS5tYXAoZnVuY3Rpb24gKG1hdGNoLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4SW5kZXggPSBpbmRleF8xO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoSW5kZXggPSB2YWx1ZS5pbmRleE9mKG1hdGNoLCBpbmRleF8xKTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaEVuZCA9IG1hdGNoSW5kZXggKyBtYXRjaC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpbmRleF8xID0gbWF0Y2hFbmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmdiID0gcGFyc2VDb2xvcldpdGhDYWNoZShtYXRjaCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJnYikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vdFBhcnNlZF8xKys7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhwcmVmaXhJbmRleCwgbWF0Y2hFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodmFsdWUuc3Vic3RyaW5nKHByZWZpeEluZGV4LCBtYXRjaEluZGV4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtb2RpZnlTaGFkb3dDb2xvcihyZ2IsIGZpbHRlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09PSBjb2xvck1hdGNoZXNfMS5sZW5ndGggLSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS5zdWJzdHJpbmcobWF0Y2hFbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZCA9IG1vZGlmaWVyc18yXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobW9kaWZ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RpZnkoZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzTGVuZ3RoOiBjb2xvck1hdGNoZXNfMS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5wYXJzZWFibGVNYXRjaGVzTGVuZ3RoOiBub3RQYXJzZWRfMSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG1vZGlmaWVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTaGFkb3dNb2RpZmllcih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzaGFkb3dNb2RpZmllciA9IGdldFNoYWRvd01vZGlmaWVyV2l0aEluZm8odmFsdWUpO1xyXG4gICAgICAgIGlmICghc2hhZG93TW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhlbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWRvd01vZGlmaWVyKHRoZW1lKS5yZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFZhcmlhYmxlTW9kaWZpZXIoXHJcbiAgICAgICAgdmFyaWFibGVzU3RvcmUsXHJcbiAgICAgICAgcHJvcCxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBydWxlLFxyXG4gICAgICAgIGlnbm9yZWRJbWdTZWxlY3RvcnMsXHJcbiAgICAgICAgaXNDYW5jZWxsZWRcclxuICAgICkge1xyXG4gICAgICAgIHJldHVybiB2YXJpYWJsZXNTdG9yZS5nZXRNb2RpZmllckZvclZhcmlhYmxlKHtcclxuICAgICAgICAgICAgdmFyTmFtZTogcHJvcCxcclxuICAgICAgICAgICAgc291cmNlVmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBydWxlOiBydWxlLFxyXG4gICAgICAgICAgICBpZ25vcmVkSW1nU2VsZWN0b3JzOiBpZ25vcmVkSW1nU2VsZWN0b3JzLFxyXG4gICAgICAgICAgICBpc0NhbmNlbGxlZDogaXNDYW5jZWxsZWRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFZhcmlhYmxlRGVwZW5kYW50TW9kaWZpZXIodmFyaWFibGVzU3RvcmUsIHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlc1N0b3JlLmdldE1vZGlmaWVyRm9yVmFyRGVwZW5kYW50KHByb3AsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFuTW9kaWZpY2F0aW9uQ2FjaGUoKSB7XHJcbiAgICAgICAgY2xlYXJDb2xvck1vZGlmaWNhdGlvbkNhY2hlKCk7XHJcbiAgICAgICAgaW1hZ2VEZXRhaWxzQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICBjbGVhbkltYWdlUHJvY2Vzc2luZ0NhY2hlKCk7XHJcbiAgICAgICAgYXdhaXRpbmdGb3JJbWFnZUxvYWRpbmcuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgVkFSX1RZUEVfQkdDT0xPUiA9IDEgPDwgMDtcclxuICAgIHZhciBWQVJfVFlQRV9URVhUQ09MT1IgPSAxIDw8IDE7XHJcbiAgICB2YXIgVkFSX1RZUEVfQk9SREVSQ09MT1IgPSAxIDw8IDI7XHJcbiAgICB2YXIgVkFSX1RZUEVfQkdJTUcgPSAxIDw8IDM7XHJcbiAgICB2YXIgVmFyaWFibGVzU3RvcmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFZhcmlhYmxlc1N0b3JlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhclR5cGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbmVkVmFycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy52YXJSZWZzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnVua25vd25Db2xvclZhcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5rbm93bkJnVmFycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy51bmRlZmluZWRWYXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYXJUeXBlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkVHlwZVZhcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZUNoYW5nZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zdGFibGVWYXJWYWx1ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy52YXJUeXBlcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzUXVldWUuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmluZWRWYXJzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFyUmVmcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnVua25vd25Db2xvclZhcnMuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy51bmtub3duQmdWYXJzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5kZWZpbmVkVmFycy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYXJUeXBlcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRUeXBlVmFycy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVDaGFuZ2VTdWJzY3JpcHRpb25zLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zdGFibGVWYXJWYWx1ZXMuY2xlYXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5pc1ZhclR5cGUgPSBmdW5jdGlvbiAodmFyTmFtZSwgdHlwZU51bSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgdGhpcy52YXJUeXBlcy5oYXModmFyTmFtZSkgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLnZhclR5cGVzLmdldCh2YXJOYW1lKSAmIHR5cGVOdW0pID4gMFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLmFkZFJ1bGVzRm9yTWF0Y2hpbmcgPSBmdW5jdGlvbiAocnVsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5ydWxlc1F1ZXVlLnB1c2gocnVsZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLm1hdGNoVmFyaWFibGVzQW5kRGVwZW5kYW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkVHlwZVZhcnMuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFyVHlwZXMgPSBuZXcgTWFwKHRoaXMudmFyVHlwZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RSb290VmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdFZhcmlhYmxlc0FuZFZhckRlcCh0aGlzLnJ1bGVzUXVldWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzUXVldWUuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RSb290VmFyRGVwZW5kYW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLnZhclJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmcywgdikge1xyXG4gICAgICAgICAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhclR5cGVzLmhhcyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlVmFyaWFibGVUeXBlKHIsIF90aGlzLnZhclR5cGVzLmdldCh2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnVua25vd25Db2xvclZhcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVua25vd25CZ1ZhcnMuaGFzKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5rbm93bkNvbG9yVmFycy5kZWxldGUodik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5rbm93bkJnVmFycy5kZWxldGUodik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzb2x2ZVZhcmlhYmxlVHlwZSh2LCBWQVJfVFlQRV9CR0NPTE9SKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNWYXJUeXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWQVJfVFlQRV9CR0NPTE9SIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZBUl9UWVBFX1RFWFRDT0xPUiB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJfVFlQRV9CT1JERVJDT0xPUlxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVua25vd25Db2xvclZhcnMuZGVsZXRlKHYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmRlZmluZWRWYXJzLmFkZCh2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudW5rbm93bkJnVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ29sb3IgPVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmRWYXJSZWYodiwgZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5rbm93bkNvbG9yVmFycy5oYXMocmVmKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNWYXJUeXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJfVFlQRV9URVhUQ09MT1IgfCBWQVJfVFlQRV9CT1JERVJDT0xPUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pICE9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGFyYXRlVmFyUmVmcyh2LCBmdW5jdGlvbiAocmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmVWYXJpYWJsZVR5cGUocmVmLCBWQVJfVFlQRV9CR0NPTE9SKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNWYXJUeXBlKHYsIFZBUl9UWVBFX0JHQ09MT1IgfCBWQVJfVFlQRV9CR0lNRylcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVua25vd25CZ1ZhcnMuZGVsZXRlKHYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmRlZmluZWRWYXJzLmFkZCh2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZFR5cGVWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50eXBlQ2hhbmdlU3Vic2NyaXB0aW9ucy5oYXModmFyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50eXBlQ2hhbmdlU3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHZhck5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRUeXBlVmFycy5jbGVhcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLmdldE1vZGlmaWVyRm9yVmFyaWFibGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoZW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyTmFtZSA9IG9wdGlvbnMudmFyTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMuc291cmNlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IG9wdGlvbnMucnVsZSxcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkSW1nU2VsZWN0b3JzID0gb3B0aW9ucy5pZ25vcmVkSW1nU2VsZWN0b3JzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FuY2VsbGVkID0gb3B0aW9ucy5pc0NhbmNlbGxlZDtcclxuICAgICAgICAgICAgICAgIHZhciBnZXREZWNsYXJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRNb2RpZmllZFZhbHVlID0gZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTnVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lV3JhcHBlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNb2RpZmllclxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzVmFyVHlwZSh2YXJOYW1lLCB0eXBlTnVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHZhck5hbWVXcmFwcGVyKHZhck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyRGVwZW5kYW50KHNvdXJjZVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0ZWRDb2xvclZhcihzb3VyY2VWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnNlcnRWYXJWYWx1ZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bnN0YWJsZVZhclZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTnVtID09PSBWQVJfVFlQRV9CR0NPTE9SXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiNmZmZmZmZcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkVmFsdWUgPSBjb2xvck1vZGlmaWVyKHZhbHVlLCB0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkVmFsdWUgPSByZXBsYWNlQ1NTVmFyaWFibGVzTmFtZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhck5hbWVXcmFwcGVyKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvck1vZGlmaWVyKGZhbGxiYWNrLCB0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IGNvbG9yTW9kaWZpZXIoc291cmNlVmFsdWUsIHRoZW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbW9kaWZpZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZE1vZGlmaWVkVmFsdWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZBUl9UWVBFX0JHQ09MT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBCZ0NvbG9yVmFyaWFibGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlNb2RpZnlCZ0NvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb2RpZmllZFZhbHVlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWQVJfVFlQRV9URVhUQ09MT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBUZXh0Q29sb3JWYXJpYWJsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeU1vZGlmeVRleHRDb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkTW9kaWZpZWRWYWx1ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgVkFSX1RZUEVfQk9SREVSQ09MT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBCb3JkZXJDb2xvclZhcmlhYmxlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5TW9kaWZ5Qm9yZGVyQ29sb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1ZhclR5cGUodmFyTmFtZSwgVkFSX1RZUEVfQkdJTUcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHdyYXBCZ0ltZ1ZhcmlhYmxlTmFtZSh2YXJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBzb3VyY2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyRGVwZW5kYW50KHNvdXJjZVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IHJlcGxhY2VDU1NWYXJpYWJsZXNOYW1lcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcEJnQ29sb3JWYXJpYWJsZU5hbWUodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU1vZGlmeUJnQ29sb3IoZmFsbGJhY2ssIHRoZW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZ01vZGlmaWVyID0gZ2V0QmdJbWFnZU1vZGlmaWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkSW1nU2VsZWN0b3JzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDYW5jZWxsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRWYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYmdNb2RpZmllciA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBiZ01vZGlmaWVyKHRoZW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYmdNb2RpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1vZGlmaWVkVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChvblR5cGVDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNzID0gZ2V0RGVjbGFyYXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVHlwZUNoYW5nZShkZWNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZUZvclZhclR5cGVDaGFuZ2UodmFyTmFtZSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuc3Vic2NyaWJlRnJvbVZhcmlhYmxlVHlwZUNoYW5nZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZ2V0RGVjbGFyYXRpb25zKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb25UeXBlQ2hhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyOiBhZGRMaXN0ZW5lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzOiByZW1vdmVMaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLmdldE1vZGlmaWVyRm9yVmFyRGVwZW5kYW50ID0gZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgc291cmNlVmFsdWVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlLm1hdGNoKC9eXFxzKihyZ2J8aHNsKWE/XFwoLykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0JnXzEgPSBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiYmFja2dyb3VuZFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1RleHRfMSA9IGlzVGV4dENvbG9yUHJvcGVydHkocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluc2VydFZhclZhbHVlcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuc3RhYmxlVmFyVmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNCZ18xID8gXCIjZmZmZmZmXCIgOiBcIiMwMDAwMDBcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyID0gaXNCZ18xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ5TW9kaWZ5QmdDb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzVGV4dF8xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ5TW9kaWZ5VGV4dENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5TW9kaWZ5Qm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVyKHZhbHVlLCB0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJiYWNrZ3JvdW5kLWNvbG9yXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhlbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZUNTU1ZhcmlhYmxlc05hbWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwQmdDb2xvclZhcmlhYmxlTmFtZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TW9kaWZ5QmdDb2xvcihmYWxsYmFjaywgdGhlbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVGV4dENvbG9yUHJvcGVydHkocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoZW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDU1NWYXJpYWJsZXNOYW1lcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcFRleHRDb2xvclZhcmlhYmxlTmFtZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TW9kaWZ5VGV4dENvbG9yKGZhbGxiYWNrLCB0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJiYWNrZ3JvdW5kXCIgfHxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID09PSBcImJhY2tncm91bmQtaW1hZ2VcIiB8fFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPT09IFwiYm94LXNoYWRvd1wiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmtub3duVmFycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVSZXBsYWNlZCA9IHJlcGxhY2VDU1NWYXJpYWJsZXNOYW1lcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNWYXJUeXBlKHYsIFZBUl9UWVBFX0JHQ09MT1IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwQmdDb2xvclZhcmlhYmxlTmFtZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVmFyVHlwZSh2LCBWQVJfVFlQRV9CR0lNRykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBCZ0ltZ1ZhcmlhYmxlTmFtZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93blZhcnMuYWRkKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlNb2RpZnlCZ0NvbG9yKGZhbGxiYWNrLCB0aGVtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJib3gtc2hhZG93XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dNb2RpZmllciA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2hhZG93TW9kaWZpZXJXaXRoSW5mbyh2YXJpYWJsZVJlcGxhY2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZFNoYWRvdyA9IHNoYWRvd01vZGlmaWVyKHRoZW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFNoYWRvdy51bnBhcnNlYWJsZU1hdGNoZXNMZW5ndGggIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTaGFkb3cubWF0Y2hlc0xlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVkU2hhZG93LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVSZXBsYWNlZDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZCA9IG1vZGlmeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmtub3duVmFycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFVua25vd25WYXIgPSB1bmtub3duVmFyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZXMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmVGcm9tVmFyaWFibGVUeXBlQ2hhbmdlcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RVbmtub3duVmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gbW9kaWZ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlRm9yVmFyVHlwZUNoYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFVua25vd25WYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kaWZpZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5LnN0YXJ0c1dpdGgoXCJib3JkZXJcIikgfHxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5LnN0YXJ0c1dpdGgoXCJvdXRsaW5lXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlQ1NTVmFyaWFibGVzTmFtZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBCb3JkZXJDb2xvclZhcmlhYmxlTmFtZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TW9kaWZ5Qm9yZGVyQ29sb3IoZmFsbGJhY2ssIHRoZW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZUZvclZhclR5cGVDaGFuZ2UgPSBmdW5jdGlvbiAoXHJcbiAgICAgICAgICAgIHZhck5hbWUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlQ2hhbmdlU3Vic2NyaXB0aW9ucy5oYXModmFyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZUNoYW5nZVN1YnNjcmlwdGlvbnMuc2V0KHZhck5hbWUsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJvb3RTdG9yZSA9IHRoaXMudHlwZUNoYW5nZVN1YnNjcmlwdGlvbnMuZ2V0KHZhck5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIXJvb3RTdG9yZS5oYXMoY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICByb290U3RvcmUuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLnVuc3Vic2NyaWJlRnJvbVZhcmlhYmxlVHlwZUNoYW5nZXMgPSBmdW5jdGlvbiAoXHJcbiAgICAgICAgICAgIHZhck5hbWUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGVDaGFuZ2VTdWJzY3JpcHRpb25zLmhhcyh2YXJOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlQ2hhbmdlU3Vic2NyaXB0aW9ucy5nZXQodmFyTmFtZSkuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLmNvbGxlY3RWYXJpYWJsZXNBbmRWYXJEZXAgPSBmdW5jdGlvbiAoXHJcbiAgICAgICAgICAgIHJ1bGVMaXN0XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJ1bGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRlQ1NTUnVsZXMocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5zdHlsZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlQ1NTRGVjbGFyYXRpb25zKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5zdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zcGVjdFZhcmlhYmxlKHByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhckRlcGVuZGFudCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zcGVjdFZhckRlcGVuZGFudChwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5jb2xsZWN0Um9vdFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaXRlcmF0ZUNTU0RlY2xhcmF0aW9ucyhcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zcGVjdFZhcmlhYmxlKHByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLmluc3BlY3RWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJOYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuc3RhYmxlVmFyVmFsdWVzLnNldCh2YXJOYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhckRlcGVuZGFudCh2YWx1ZSkgJiYgaXNDb25zdHJ1Y3RlZENvbG9yVmFyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmtub3duQ29sb3JWYXJzLmFkZCh2YXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lZFZhcnMuYWRkKHZhck5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmluZWRWYXJzLmhhcyh2YXJOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lZFZhcnMuYWRkKHZhck5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBwYXJzZUNvbG9yV2l0aENhY2hlKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVua25vd25Db2xvclZhcnMuYWRkKHZhck5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgdmFsdWUuaW5jbHVkZXMoXCJ1cmwoXCIpIHx8XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5pbmNsdWRlcyhcImxpbmVhci1ncmFkaWVudChcIikgfHxcclxuICAgICAgICAgICAgICAgIHZhbHVlLmluY2x1ZGVzKFwicmFkaWFsLWdyYWRpZW50KFwiKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVZhcmlhYmxlVHlwZSh2YXJOYW1lLCBWQVJfVFlQRV9CR0lNRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5yZXNvbHZlVmFyaWFibGVUeXBlID0gZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICB2YXJOYW1lLFxyXG4gICAgICAgICAgICB0eXBlTnVtXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsVHlwZSA9IHRoaXMuaW5pdGlhbFZhclR5cGVzLmdldCh2YXJOYW1lKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFR5cGUgPSB0aGlzLnZhclR5cGVzLmdldCh2YXJOYW1lKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgbmV3VHlwZSA9IGN1cnJlbnRUeXBlIHwgdHlwZU51bTtcclxuICAgICAgICAgICAgdGhpcy52YXJUeXBlcy5zZXQodmFyTmFtZSwgbmV3VHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdUeXBlICE9PSBpbml0aWFsVHlwZSB8fCB0aGlzLnVuZGVmaW5lZFZhcnMuaGFzKHZhck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRUeXBlVmFycy5hZGQodmFyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuZGVmaW5lZFZhcnMuZGVsZXRlKHZhck5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5rbm93bkNvbG9yVmFycy5kZWxldGUodmFyTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMudW5rbm93bkJnVmFycy5kZWxldGUodmFyTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWYXJpYWJsZXNTdG9yZS5wcm90b3R5cGUuY29sbGVjdFJvb3RWYXJEZXBlbmRhbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpdGVyYXRlQ1NTRGVjbGFyYXRpb25zKFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhckRlcGVuZGFudCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zcGVjdFZhckRlcGVuZGFudChwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5pbnNwZWN0VmFyRGVwZW5kYW50ID0gZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVWYXJEZXBzKHZhbHVlLCBmdW5jdGlvbiAocmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy52YXJSZWZzLmhhcyhwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFyUmVmcy5zZXQocHJvcGVydHksIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhclJlZnMuZ2V0KHByb3BlcnR5KS5hZGQocmVmKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPT09IFwiYmFja2dyb3VuZC1jb2xvclwiIHx8XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJib3gtc2hhZG93XCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVWYXJEZXBzKHZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlVmFyaWFibGVUeXBlKHYsIFZBUl9UWVBFX0JHQ09MT1IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUZXh0Q29sb3JQcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlcmF0ZVZhckRlcHModmFsdWUsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVWYXJpYWJsZVR5cGUodiwgVkFSX1RZUEVfVEVYVENPTE9SKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc3RhcnRzV2l0aChcImJvcmRlclwiKSB8fFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc3RhcnRzV2l0aChcIm91dGxpbmVcIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVWYXJEZXBzKHZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlVmFyaWFibGVUeXBlKHYsIFZBUl9UWVBFX0JPUkRFUkNPTE9SKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPT09IFwiYmFja2dyb3VuZFwiIHx8XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCJiYWNrZ3JvdW5kLWltYWdlXCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVWYXJEZXBzKHZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1ZhclR5cGUodiwgVkFSX1RZUEVfQkdDT0xPUiB8IFZBUl9UWVBFX0JHSU1HKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0JnQ29sb3IgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5kVmFyUmVmKHYsIGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5rbm93bkNvbG9yVmFycy5oYXMocmVmKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzVmFyVHlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJfVFlQRV9URVhUQ09MT1IgfCBWQVJfVFlQRV9CT1JERVJDT0xPUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICE9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXRhcmF0ZVZhclJlZnModiwgZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCZ0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlVmFyaWFibGVUeXBlKHJlZiwgVkFSX1RZUEVfQkdDT0xPUik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmtub3duQmdWYXJzLmFkZChyZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLml0ZXJhdGVWYXJEZXBzID0gZnVuY3Rpb24gKHZhbHVlLCBpdGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgdmFyRGVwcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgaXRlcmF0ZVZhckRlcGVuZGVuY2llcyh2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJEZXBzLmFkZCh2KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhckRlcHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKHYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZhcmlhYmxlc1N0b3JlLnByb3RvdHlwZS5maW5kVmFyUmVmID0gZnVuY3Rpb24gKFxyXG4gICAgICAgICAgICB2YXJOYW1lLFxyXG4gICAgICAgICAgICBpdGVyYXRvcixcclxuICAgICAgICAgICAgc3RhY2tcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgICAgIGlmIChzdGFjayA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjayA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhY2suaGFzKHZhck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGFjay5hZGQodmFyTmFtZSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvcih2YXJOYW1lKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhck5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlZnMgPSB0aGlzLnZhclJlZnMuZ2V0KHZhck5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIXJlZnMgfHwgcmVmcy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmc18xID0gX192YWx1ZXMocmVmcyksIHJlZnNfMV8xID0gcmVmc18xLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAhcmVmc18xXzEuZG9uZTtcclxuICAgICAgICAgICAgICAgICAgICByZWZzXzFfMSA9IHJlZnNfMS5uZXh0KClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSByZWZzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmRWYXJSZWYocmVmLCBpdGVyYXRvciwgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xyXG4gICAgICAgICAgICAgICAgZV8xID0ge2Vycm9yOiBlXzFfMX07XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZzXzFfMSAmJiAhcmVmc18xXzEuZG9uZSAmJiAoX2EgPSByZWZzXzEucmV0dXJuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EuY2FsbChyZWZzXzEpO1xyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWYXJpYWJsZXNTdG9yZS5wcm90b3R5cGUuaXRhcmF0ZVZhclJlZnMgPSBmdW5jdGlvbiAodmFyTmFtZSwgaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5kVmFyUmVmKHZhck5hbWUsIGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHJlZik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmFyaWFibGVzU3RvcmUucHJvdG90eXBlLnNldE9uUm9vdFZhcmlhYmxlQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Sb290VmFyaWFibGVEZWZpbmVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWYXJpYWJsZXNTdG9yZS5wcm90b3R5cGUucHV0Um9vdFZhcnMgPSBmdW5jdGlvbiAoc3R5bGVFbGVtZW50LCB0aGVtZSkge1xyXG4gICAgICAgICAgICB2YXIgZV8yLCBfYTtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHNoZWV0ID0gc3R5bGVFbGVtZW50LnNoZWV0O1xyXG4gICAgICAgICAgICBpZiAoc2hlZXQuY3NzUnVsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc2hlZXQuZGVsZXRlUnVsZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBpdGVyYXRlQ1NTRGVjbGFyYXRpb25zKFxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNWYXJUeXBlKHByb3BlcnR5LCBWQVJfVFlQRV9CR0NPTE9SKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnNldChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwQmdDb2xvclZhcmlhYmxlTmFtZShwcm9wZXJ0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5TW9kaWZ5QmdDb2xvcih2YWx1ZSwgdGhlbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1ZhclR5cGUocHJvcGVydHksIFZBUl9UWVBFX1RFWFRDT0xPUikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5zZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFRleHRDb2xvclZhcmlhYmxlTmFtZShwcm9wZXJ0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5TW9kaWZ5VGV4dENvbG9yKHZhbHVlLCB0aGVtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVmFyVHlwZShwcm9wZXJ0eSwgVkFSX1RZUEVfQk9SREVSQ09MT1IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnMuc2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBCb3JkZXJDb2xvclZhcmlhYmxlTmFtZShwcm9wZXJ0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5TW9kaWZ5Qm9yZGVyQ29sb3IodmFsdWUsIHRoZW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmVGb3JWYXJUeXBlQ2hhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblJvb3RWYXJpYWJsZURlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBjc3NMaW5lcyA9IFtdO1xyXG4gICAgICAgICAgICBjc3NMaW5lcy5wdXNoKFwiOnJvb3Qge1wiKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uc18xID0gX192YWx1ZXMoZGVjbGFyYXRpb25zKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zXzFfMSA9IGRlY2xhcmF0aW9uc18xLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAhZGVjbGFyYXRpb25zXzFfMS5kb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uc18xXzEgPSBkZWNsYXJhdGlvbnNfMS5uZXh0KClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChkZWNsYXJhdGlvbnNfMV8xLnZhbHVlLCAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBfYlswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiAgICBcIi5jb25jYXQocHJvcGVydHksIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcIjtcIilcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlXzJfMSkge1xyXG4gICAgICAgICAgICAgICAgZV8yID0ge2Vycm9yOiBlXzJfMX07XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zXzFfMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhZGVjbGFyYXRpb25zXzFfMS5kb25lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGRlY2xhcmF0aW9uc18xLnJldHVybilcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmNhbGwoZGVjbGFyYXRpb25zXzEpO1xyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3NzTGluZXMucHVzaChcIn1cIik7XHJcbiAgICAgICAgICAgIHZhciBjc3NUZXh0ID0gY3NzTGluZXMuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShjc3NUZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBWYXJpYWJsZXNTdG9yZTtcclxuICAgIH0pKCk7XHJcbiAgICB2YXIgdmFyaWFibGVzU3RvcmUgPSBuZXcgVmFyaWFibGVzU3RvcmUoKTtcclxuICAgIGZ1bmN0aW9uIGdldFZhcmlhYmxlUmFuZ2UoaW5wdXQsIHNlYXJjaFN0YXJ0KSB7XHJcbiAgICAgICAgaWYgKHNlYXJjaFN0YXJ0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2VhcmNoU3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBpbnB1dC5pbmRleE9mKFwidmFyKFwiLCBzZWFyY2hTdGFydCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZ2V0UGFyZW50aGVzZXNSYW5nZShpbnB1dCwgc3RhcnQgKyAzKTtcclxuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiByYW5nZS5lbmR9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFZhcmlhYmxlc01hdGNoZXMoaW5wdXQpIHtcclxuICAgICAgICB2YXIgcmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciByYW5nZTtcclxuICAgICAgICB3aGlsZSAoKHJhbmdlID0gZ2V0VmFyaWFibGVSYW5nZShpbnB1dCwgaSkpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGkgPSByYW5nZS5lbmQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZVZhcmlhYmxlc01hdGNoZXMoaW5wdXQsIHJlcGxhY2VyKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBnZXRWYXJpYWJsZXNNYXRjaGVzKGlucHV0KTtcclxuICAgICAgICB2YXIgbWF0Y2hlc0NvdW50ID0gbWF0Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG1hdGNoZXNDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICB2YXIgcmVwbGFjZW1lbnRzID0gbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKG0udmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIHBhcnRzLnB1c2goaW5wdXQuc3Vic3RyaW5nKDAsIG1hdGNoZXNbMF0uc3RhcnQpKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocmVwbGFjZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWF0Y2hlc1tpXS5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbWF0Y2hlc0NvdW50IC0gMSA/IG1hdGNoZXNbaSArIDFdLnN0YXJ0IDogaW5wdXRMZW5ndGg7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRWYXJpYWJsZU5hbWVBbmRGYWxsYmFjayhtYXRjaCkge1xyXG4gICAgICAgIHZhciBjb21tYUluZGV4ID0gbWF0Y2guaW5kZXhPZihcIixcIik7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgdmFyIGZhbGxiYWNrO1xyXG4gICAgICAgIGlmIChjb21tYUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoLnN1YnN0cmluZyg0LCBjb21tYUluZGV4KS50cmltKCk7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrID0gbWF0Y2guc3Vic3RyaW5nKGNvbW1hSW5kZXggKyAxLCBtYXRjaC5sZW5ndGggLSAxKS50cmltKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoLnN1YnN0cmluZyg0LCBtYXRjaC5sZW5ndGggLSAxKS50cmltKCk7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtuYW1lOiBuYW1lLCBmYWxsYmFjazogZmFsbGJhY2t9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNTU1ZhcmlhYmxlc05hbWVzKHZhbHVlLCBuYW1lUmVwbGFjZXIsIGZhbGxiYWNrUmVwbGFjZXIpIHtcclxuICAgICAgICB2YXIgbWF0Y2hSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRWYXJpYWJsZU5hbWVBbmRGYWxsYmFjayhtYXRjaCksXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gX2EubmFtZSxcclxuICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gX2EuZmFsbGJhY2s7XHJcbiAgICAgICAgICAgIHZhciBuZXdOYW1lID0gbmFtZVJlcGxhY2VyKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXIoXCIuY29uY2F0KG5ld05hbWUsIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3RmFsbGJhY2s7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhckRlcGVuZGFudChmYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIG5ld0ZhbGxiYWNrID0gcmVwbGFjZUNTU1ZhcmlhYmxlc05hbWVzKFxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVSZXBsYWNlcixcclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxhY2VyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrUmVwbGFjZXIpIHtcclxuICAgICAgICAgICAgICAgIG5ld0ZhbGxiYWNrID0gZmFsbGJhY2tSZXBsYWNlcihmYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdGYWxsYmFjayA9IGZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcInZhcihcIi5jb25jYXQobmV3TmFtZSwgXCIsIFwiKS5jb25jYXQobmV3RmFsbGJhY2ssIFwiKVwiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXBsYWNlVmFyaWFibGVzTWF0Y2hlcyh2YWx1ZSwgbWF0Y2hSZXBsYWNlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpdGVyYXRlVmFyRGVwZW5kZW5jaWVzKHZhbHVlLCBpdGVyYXRvcikge1xyXG4gICAgICAgIHJlcGxhY2VDU1NWYXJpYWJsZXNOYW1lcyh2YWx1ZSwgZnVuY3Rpb24gKHZhck5hbWUpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IodmFyTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YXJOYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd3JhcEJnQ29sb3JWYXJpYWJsZU5hbWUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBcIi0tZGFya3JlYWRlci1iZ1wiLmNvbmNhdChuYW1lKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdyYXBUZXh0Q29sb3JWYXJpYWJsZU5hbWUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBcIi0tZGFya3JlYWRlci10ZXh0XCIuY29uY2F0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd3JhcEJvcmRlckNvbG9yVmFyaWFibGVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gXCItLWRhcmtyZWFkZXItYm9yZGVyXCIuY29uY2F0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd3JhcEJnSW1nVmFyaWFibGVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gXCItLWRhcmtyZWFkZXItYmdpbWdcIi5jb25jYXQobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1ZhcmlhYmxlKHByb3BlcnR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LnN0YXJ0c1dpdGgoXCItLVwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzVmFyRGVwZW5kYW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmluY2x1ZGVzKFwidmFyKFwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQ29uc3RydWN0ZWRDb2xvclZhcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXRjaCgvXlxccyoocmdifGhzbClhP1xcKC8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNUZXh0Q29sb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHByb3BlcnR5ID09PSBcImNvbG9yXCIgfHxcclxuICAgICAgICAgICAgcHJvcGVydHkgPT09IFwiY2FyZXQtY29sb3JcIiB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9PT0gXCItd2Via2l0LXRleHQtZmlsbC1jb2xvclwiXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHZhciByYXdWYWx1ZVJlZ2V4ID0gL15cXGR7MSwzfSwgP1xcZHsxLDN9LCA/XFxkezEsM30kLztcclxuICAgIGZ1bmN0aW9uIHBhcnNlUmF3VmFsdWUoY29sb3IpIHtcclxuICAgICAgICBpZiAocmF3VmFsdWVSZWdleC50ZXN0KGNvbG9yKSkge1xyXG4gICAgICAgICAgICB2YXIgc3BsaXR0ZWQgPSBjb2xvci5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRJblJHQl8xID0gXCJyZ2IoXCI7XHJcbiAgICAgICAgICAgIHNwbGl0dGVkLmZvckVhY2goZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0SW5SR0JfMSArPSBcIlwiLmNvbmNhdChudW1iZXIudHJpbSgpLCBcIiwgXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVzdWx0SW5SR0JfMSA9IHJlc3VsdEluUkdCXzEuc3Vic3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdEluUkdCXzEubGVuZ3RoIC0gMlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXN1bHRJblJHQl8xICs9IFwiKVwiO1xyXG4gICAgICAgICAgICByZXR1cm4ge2lzUmF3OiB0cnVlLCBjb2xvcjogcmVzdWx0SW5SR0JfMX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7aXNSYXc6IGZhbHNlLCBjb2xvcjogY29sb3J9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmF3VmFsdWUoY29sb3IsIHRoZW1lLCBtb2RpZnlGdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBfYSA9IHBhcnNlUmF3VmFsdWUoY29sb3IpLFxyXG4gICAgICAgICAgICBpc1JhdyA9IF9hLmlzUmF3LFxyXG4gICAgICAgICAgICBuZXdDb2xvciA9IF9hLmNvbG9yO1xyXG4gICAgICAgIHZhciByZ2IgPSBwYXJzZUNvbG9yV2l0aENhY2hlKG5ld0NvbG9yKTtcclxuICAgICAgICBpZiAocmdiKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRDb2xvciA9IG1vZGlmeUZ1bmN0aW9uKHJnYiwgdGhlbWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNSYXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRJblJHQiA9IHBhcnNlQ29sb3JXaXRoQ2FjaGUob3V0cHV0Q29sb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dEluUkdCXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChvdXRwdXRJblJHQi5yLCBcIiwgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChvdXRwdXRJblJHQi5nLCBcIiwgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChvdXRwdXRJblJHQi5iKVxyXG4gICAgICAgICAgICAgICAgICAgIDogb3V0cHV0Q29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3Q29sb3I7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cnlNb2RpZnlCZ0NvbG9yKGNvbG9yLCB0aGVtZSkge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVSYXdWYWx1ZShjb2xvciwgdGhlbWUsIG1vZGlmeUJhY2tncm91bmRDb2xvcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cnlNb2RpZnlUZXh0Q29sb3IoY29sb3IsIHRoZW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJhd1ZhbHVlKGNvbG9yLCB0aGVtZSwgbW9kaWZ5Rm9yZWdyb3VuZENvbG9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyeU1vZGlmeUJvcmRlckNvbG9yKGNvbG9yLCB0aGVtZSkge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVSYXdWYWx1ZShjb2xvciwgdGhlbWUsIG1vZGlmeUJvcmRlckNvbG9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluc2VydFZhclZhbHVlcyhzb3VyY2UsIHZhclZhbHVlcywgc3RhY2spIHtcclxuICAgICAgICBpZiAoc3RhY2sgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBzdGFjayA9IG5ldyBTZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRhaW5zVW5yZXNvbHZlZFZhciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBtYXRjaFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFZhcmlhYmxlTmFtZUFuZEZhbGxiYWNrKG1hdGNoKSxcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBfYS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBfYS5mYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKHN0YWNrLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbnNVbnJlc29sdmVkVmFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YWNrLmFkZChuYW1lKTtcclxuICAgICAgICAgICAgdmFyIHZhclZhbHVlID0gdmFyVmFsdWVzLmdldChuYW1lKSB8fCBmYWxsYmFjaztcclxuICAgICAgICAgICAgdmFyIGluc2VydGVkID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHZhclZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYXJEZXBlbmRhbnQodmFyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBpbnNlcnRWYXJWYWx1ZXModmFyVmFsdWUsIHZhclZhbHVlcywgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHZhclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaW5zZXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5zVW5yZXNvbHZlZFZhciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXBsYWNlVmFyaWFibGVzTWF0Y2hlcyhzb3VyY2UsIG1hdGNoUmVwbGFjZXIpO1xyXG4gICAgICAgIGlmIChjb250YWluc1VucmVzb2x2ZWRWYXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXBsYWNlZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3ZlcnJpZGVzID0ge1xyXG4gICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XHJcbiAgICAgICAgICAgIGN1c3RvbVByb3A6IFwiLS1kYXJrcmVhZGVyLWlubGluZS1iZ2NvbG9yXCIsXHJcbiAgICAgICAgICAgIGNzc1Byb3A6IFwiYmFja2dyb3VuZC1jb2xvclwiLFxyXG4gICAgICAgICAgICBkYXRhQXR0cjogXCJkYXRhLWRhcmtyZWFkZXItaW5saW5lLWJnY29sb3JcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLWJnaW1hZ2VcIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJiYWNrZ3JvdW5kLWltYWdlXCIsXHJcbiAgICAgICAgICAgIGRhdGFBdHRyOiBcImRhdGEtZGFya3JlYWRlci1pbmxpbmUtYmdpbWFnZVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJvcmRlci1jb2xvclwiOiB7XHJcbiAgICAgICAgICAgIGN1c3RvbVByb3A6IFwiLS1kYXJrcmVhZGVyLWlubGluZS1ib3JkZXJcIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJib3JkZXItY29sb3JcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1ib3JkZXJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJib3JkZXItYm90dG9tLWNvbG9yXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLWJvcmRlci1ib3R0b21cIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXHJcbiAgICAgICAgICAgIGRhdGFBdHRyOiBcImRhdGEtZGFya3JlYWRlci1pbmxpbmUtYm9yZGVyLWJvdHRvbVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJvcmRlci1sZWZ0LWNvbG9yXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLWJvcmRlci1sZWZ0XCIsXHJcbiAgICAgICAgICAgIGNzc1Byb3A6IFwiYm9yZGVyLWxlZnQtY29sb3JcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1ib3JkZXItbGVmdFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJvcmRlci1yaWdodC1jb2xvclwiOiB7XHJcbiAgICAgICAgICAgIGN1c3RvbVByb3A6IFwiLS1kYXJrcmVhZGVyLWlubGluZS1ib3JkZXItcmlnaHRcIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJib3JkZXItcmlnaHQtY29sb3JcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1ib3JkZXItcmlnaHRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJib3JkZXItdG9wLWNvbG9yXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLWJvcmRlci10b3BcIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJib3JkZXItdG9wLWNvbG9yXCIsXHJcbiAgICAgICAgICAgIGRhdGFBdHRyOiBcImRhdGEtZGFya3JlYWRlci1pbmxpbmUtYm9yZGVyLXRvcFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJveC1zaGFkb3dcIjoge1xyXG4gICAgICAgICAgICBjdXN0b21Qcm9wOiBcIi0tZGFya3JlYWRlci1pbmxpbmUtYm94c2hhZG93XCIsXHJcbiAgICAgICAgICAgIGNzc1Byb3A6IFwiYm94LXNoYWRvd1wiLFxyXG4gICAgICAgICAgICBkYXRhQXR0cjogXCJkYXRhLWRhcmtyZWFkZXItaW5saW5lLWJveHNoYWRvd1wiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbG9yXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLWNvbG9yXCIsXHJcbiAgICAgICAgICAgIGNzc1Byb3A6IFwiY29sb3JcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1jb2xvclwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZpbGxcIjoge1xyXG4gICAgICAgICAgICBjdXN0b21Qcm9wOiBcIi0tZGFya3JlYWRlci1pbmxpbmUtZmlsbFwiLFxyXG4gICAgICAgICAgICBjc3NQcm9wOiBcImZpbGxcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1maWxsXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3Ryb2tlXCI6IHtcclxuICAgICAgICAgICAgY3VzdG9tUHJvcDogXCItLWRhcmtyZWFkZXItaW5saW5lLXN0cm9rZVwiLFxyXG4gICAgICAgICAgICBjc3NQcm9wOiBcInN0cm9rZVwiLFxyXG4gICAgICAgICAgICBkYXRhQXR0cjogXCJkYXRhLWRhcmtyZWFkZXItaW5saW5lLXN0cm9rZVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm91dGxpbmUtY29sb3JcIjoge1xyXG4gICAgICAgICAgICBjdXN0b21Qcm9wOiBcIi0tZGFya3JlYWRlci1pbmxpbmUtb3V0bGluZVwiLFxyXG4gICAgICAgICAgICBjc3NQcm9wOiBcIm91dGxpbmUtY29sb3JcIixcclxuICAgICAgICAgICAgZGF0YUF0dHI6IFwiZGF0YS1kYXJrcmVhZGVyLWlubGluZS1vdXRsaW5lXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiB7XHJcbiAgICAgICAgICAgIGN1c3RvbVByb3A6IFwiLS1kYXJrcmVhZGVyLWlubGluZS1zdG9wY29sb3JcIixcclxuICAgICAgICAgICAgY3NzUHJvcDogXCJzdG9wLWNvbG9yXCIsXHJcbiAgICAgICAgICAgIGRhdGFBdHRyOiBcImRhdGEtZGFya3JlYWRlci1pbmxpbmUtc3RvcGNvbG9yXCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIG92ZXJyaWRlc0xpc3QgPSBPYmplY3QudmFsdWVzKG92ZXJyaWRlcyk7XHJcbiAgICB2YXIgbm9ybWFsaXplZFByb3BMaXN0ID0ge307XHJcbiAgICBvdmVycmlkZXNMaXN0LmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGNzc1Byb3AgPSBfYS5jc3NQcm9wLFxyXG4gICAgICAgICAgICBjdXN0b21Qcm9wID0gX2EuY3VzdG9tUHJvcDtcclxuICAgICAgICByZXR1cm4gKG5vcm1hbGl6ZWRQcm9wTGlzdFtjdXN0b21Qcm9wXSA9IGNzc1Byb3ApO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgSU5MSU5FX1NUWUxFX0FUVFJTID0gW1xyXG4gICAgICAgIFwic3R5bGVcIixcclxuICAgICAgICBcImZpbGxcIixcclxuICAgICAgICBcInN0b3AtY29sb3JcIixcclxuICAgICAgICBcInN0cm9rZVwiLFxyXG4gICAgICAgIFwiYmdjb2xvclwiLFxyXG4gICAgICAgIFwiY29sb3JcIlxyXG4gICAgXTtcclxuICAgIHZhciBJTkxJTkVfU1RZTEVfU0VMRUNUT1IgPSBJTkxJTkVfU1RZTEVfQVRUUlMubWFwKGZ1bmN0aW9uIChhdHRyKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChhdHRyLCBcIl1cIik7XHJcbiAgICB9KS5qb2luKFwiLCBcIik7XHJcbiAgICBmdW5jdGlvbiBnZXRJbmxpbmVPdmVycmlkZVN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiBvdmVycmlkZXNMaXN0XHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUF0dHIgPSBfYS5kYXRhQXR0cixcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21Qcm9wID0gX2EuY3VzdG9tUHJvcCxcclxuICAgICAgICAgICAgICAgICAgICBjc3NQcm9wID0gX2EuY3NzUHJvcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGRhdGFBdHRyLCBcIl0ge1wiKSxcclxuICAgICAgICAgICAgICAgICAgICBcIiAgXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjc3NQcm9wLCBcIjogdmFyKFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGN1c3RvbVByb3AsIFwiKSAhaW1wb3J0YW50O1wiKSxcclxuICAgICAgICAgICAgICAgICAgICBcIn1cIlxyXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldElubGluZVN0eWxlRWxlbWVudHMocm9vdCkge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBFbGVtZW50ICYmIHJvb3QubWF0Y2hlcyhJTkxJTkVfU1RZTEVfU0VMRUNUT1IpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICByb290IGluc3RhbmNlb2YgRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAoaXNTaGFkb3dEb21TdXBwb3J0ZWQgJiYgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHx8XHJcbiAgICAgICAgICAgIHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBwdXNoKHJlc3VsdHMsIHJvb3QucXVlcnlTZWxlY3RvckFsbChJTkxJTkVfU1RZTEVfU0VMRUNUT1IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICB2YXIgdHJlZU9ic2VydmVycyA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBhdHRyT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gd2F0Y2hGb3JJbmxpbmVTdHlsZXMoZWxlbWVudFN0eWxlRGlkQ2hhbmdlLCBzaGFkb3dSb290RGlzY292ZXJlZCkge1xyXG4gICAgICAgIGRlZXBXYXRjaEZvcklubGluZVN0eWxlcyhcclxuICAgICAgICAgICAgZG9jdW1lbnQsXHJcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZURpZENoYW5nZSxcclxuICAgICAgICAgICAgc2hhZG93Um9vdERpc2NvdmVyZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChob3N0KSB7XHJcbiAgICAgICAgICAgIGRlZXBXYXRjaEZvcklubGluZVN0eWxlcyhcclxuICAgICAgICAgICAgICAgIGhvc3Quc2hhZG93Um9vdCxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZURpZENoYW5nZSxcclxuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3REaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWVwV2F0Y2hGb3JJbmxpbmVTdHlsZXMoXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICBlbGVtZW50U3R5bGVEaWRDaGFuZ2UsXHJcbiAgICAgICAgc2hhZG93Um9vdERpc2NvdmVyZWRcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0cmVlT2JzZXJ2ZXJzLmhhcyhyb290KSkge1xyXG4gICAgICAgICAgICB0cmVlT2JzZXJ2ZXJzLmdldChyb290KS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGF0dHJPYnNlcnZlcnMuZ2V0KHJvb3QpLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc2NvdmVyZWROb2RlcyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICAgICAgZnVuY3Rpb24gZGlzY292ZXJOb2Rlcyhub2RlKSB7XHJcbiAgICAgICAgICAgIGdldElubGluZVN0eWxlRWxlbWVudHMobm9kZSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNjb3ZlcmVkTm9kZXMuaGFzKGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpc2NvdmVyZWROb2Rlcy5hZGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlRGlkQ2hhbmdlKGVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhub2RlLCBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2NvdmVyZWROb2Rlcy5oYXMobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdERpc2NvdmVyZWQobi5zaGFkb3dSb290KTtcclxuICAgICAgICAgICAgICAgIGRlZXBXYXRjaEZvcklubGluZVN0eWxlcyhcclxuICAgICAgICAgICAgICAgICAgICBuLnNoYWRvd1Jvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlRGlkQ2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3REaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRyZWVPYnNlcnZlciA9IGNyZWF0ZU9wdGltaXplZFRyZWVPYnNlcnZlcihyb290LCB7XHJcbiAgICAgICAgICAgIG9uTWlub3JNdXRhdGlvbnM6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IF9hLmFkZGl0aW9ucztcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNjb3Zlck5vZGVzKGFkZGVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkh1Z2VNdXRhdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRpc2NvdmVyTm9kZXMocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmVlT2JzZXJ2ZXJzLnNldChyb290LCB0cmVlT2JzZXJ2ZXIpO1xyXG4gICAgICAgIHZhciBhdHRlbXB0Q291bnQgPSAwO1xyXG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XHJcbiAgICAgICAgdmFyIEFUVEVNUFRTX0lOVEVSVkFMID0gZ2V0RHVyYXRpb24oe3NlY29uZHM6IDEwfSk7XHJcbiAgICAgICAgdmFyIFJFVFJZX1RJTUVPVVQgPSBnZXREdXJhdGlvbih7c2Vjb25kczogMn0pO1xyXG4gICAgICAgIHZhciBNQVhfQVRURU1QVFNfQ09VTlQgPSA1MDtcclxuICAgICAgICB2YXIgY2FjaGUgPSBbXTtcclxuICAgICAgICB2YXIgdGltZW91dElkID0gbnVsbDtcclxuICAgICAgICB2YXIgaGFuZGxlQXR0cmlidXRlTXV0YXRpb25zID0gdGhyb3R0bGUoZnVuY3Rpb24gKG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKElOTElORV9TVFlMRV9BVFRSUy5pbmNsdWRlcyhtLmF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlRGlkQ2hhbmdlKG0udGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGF0dHJPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUucHVzaC5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobXV0YXRpb25zKSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0dGVtcHRDb3VudCsrO1xyXG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbm93O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dGVtcHRDb3VudCA+PSBNQVhfQVRURU1QVFNfQ09VTlQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub3cgLSBzdGFydCA8IEFUVEVNUFRTX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUNhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZU11dGF0aW9ucyhhdHRyaWJ1dGVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgUkVUUllfVElNRU9VVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUucHVzaC5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChtdXRhdGlvbnMpLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbm93O1xyXG4gICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoYW5kbGVBdHRyaWJ1dGVNdXRhdGlvbnMobXV0YXRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhdHRyT2JzZXJ2ZXIub2JzZXJ2ZShyb290LCB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogSU5MSU5FX1NUWUxFX0FUVFJTLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlc0xpc3QubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQXR0ciA9IF9hLmRhdGFBdHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQXR0cjtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBhdHRyT2JzZXJ2ZXJzLnNldChyb290LCBhdHRyT2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9ySW5saW5lU3R5bGVzKCkge1xyXG4gICAgICAgIHRyZWVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICByZXR1cm4gby5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXR0ck9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmVlT2JzZXJ2ZXJzLmNsZWFyKCk7XHJcbiAgICAgICAgYXR0ck9ic2VydmVycy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgdmFyIGlubGluZVN0eWxlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgdmFyIGZpbHRlclByb3BzID0gW1wiYnJpZ2h0bmVzc1wiLCBcImNvbnRyYXN0XCIsIFwiZ3JheXNjYWxlXCIsIFwic2VwaWFcIiwgXCJtb2RlXCJdO1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGVDYWNoZUtleShlbCwgdGhlbWUpIHtcclxuICAgICAgICByZXR1cm4gSU5MSU5FX1NUWUxFX0FUVFJTLm1hcChmdW5jdGlvbiAoYXR0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYXR0ciwgJz1cIicpLmNvbmNhdChlbC5nZXRBdHRyaWJ1dGUoYXR0ciksICdcIicpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJvcCwgJz1cIicpLmNvbmNhdCh0aGVtZVtwcm9wXSwgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNob3VsZElnbm9yZUlubGluZVN0eWxlKGVsZW1lbnQsIHNlbGVjdG9ycykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxlY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGluZ25vcmVkU2VsZWN0b3IgPSBzZWxlY3RvcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMoaW5nbm9yZWRTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG92ZXJyaWRlSW5saW5lU3R5bGUoXHJcbiAgICAgICAgZWxlbWVudCxcclxuICAgICAgICB0aGVtZSxcclxuICAgICAgICBpZ25vcmVJbmxpbmVTZWxlY3RvcnMsXHJcbiAgICAgICAgaWdub3JlSW1hZ2VTZWxlY3RvcnNcclxuICAgICkge1xyXG4gICAgICAgIHZhciBjYWNoZUtleSA9IGdldElubGluZVN0eWxlQ2FjaGVLZXkoZWxlbWVudCwgdGhlbWUpO1xyXG4gICAgICAgIGlmIChjYWNoZUtleSA9PT0gaW5saW5lU3R5bGVDYWNoZS5nZXQoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdW5zZXRQcm9wcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMob3ZlcnJpZGVzKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0Q3VzdG9tUHJvcCh0YXJnZXRDU1NQcm9wLCBtb2RpZmllckNTU1Byb3AsIGNzc1ZhbCkge1xyXG4gICAgICAgICAgICB2YXIgaXNQcm9wZXJ0eVZhcmlhYmxlID0gdGFyZ2V0Q1NTUHJvcC5zdGFydHNXaXRoKFwiLS1cIik7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGlzUHJvcGVydHlWYXJpYWJsZSA/IHt9IDogb3ZlcnJpZGVzW3RhcmdldENTU1Byb3BdLFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tUHJvcCA9IF9hLmN1c3RvbVByb3AsXHJcbiAgICAgICAgICAgICAgICBkYXRhQXR0ciA9IF9hLmRhdGFBdHRyO1xyXG4gICAgICAgICAgICB2YXIgbW9kID0gZ2V0TW9kaWZpYWJsZUNTU0RlY2xhcmF0aW9uKFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJDU1NQcm9wLFxyXG4gICAgICAgICAgICAgICAgY3NzVmFsLFxyXG4gICAgICAgICAgICAgICAge3N0eWxlOiBlbGVtZW50LnN0eWxlfSxcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlc1N0b3JlLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlSW1hZ2VTZWxlY3RvcnMsXHJcbiAgICAgICAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodGhlbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VmFyaWFibGUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHlwZWRWYWx1ZS5kZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBfYS5wcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGN1c3RvbVByb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoZGF0YUF0dHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUF0dHIsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5zZXRQcm9wcy5kZWxldGUodGFyZ2V0Q1NTUHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlnbm9yZUlubGluZVNlbGVjdG9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVJbmxpbmVTdHlsZShlbGVtZW50LCBpZ25vcmVJbmxpbmVTZWxlY3RvcnMpKSB7XHJcbiAgICAgICAgICAgICAgICB1bnNldFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGNzc1Byb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShvdmVycmlkZXNbY3NzUHJvcF0uZGF0YUF0dHIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiYmdjb2xvclwiKSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImJnY29sb3JcIik7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHZhbHVlLm1hdGNoKC9eWzAtOWEtZl17M30kL2kpIHx8XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5tYXRjaCgvXlswLTlhLWZdezZ9JC9pKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIjXCIuY29uY2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRDdXN0b21Qcm9wKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImJhY2tncm91bmQtY29sb3JcIiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjb2xvclwiKSAmJiBlbGVtZW50LnJlbCAhPT0gXCJtYXNrLWljb25cIikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbG9yXCIpO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5tYXRjaCgvXlswLTlhLWZdezN9JC9pKSB8fFxyXG4gICAgICAgICAgICAgICAgdmFsdWUubWF0Y2goL15bMC05YS1mXXs2fSQvaSlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiI1wiLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0Q3VzdG9tUHJvcChcImNvbG9yXCIsIFwiY29sb3JcIiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZmlsbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFNNQUxMX1NWR19MSU1JVF8xID0gMzI7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdUZXh0RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZVNWR0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQmcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID4gU01BTExfU1ZHX0xJTUlUXzEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPiBTTUFMTF9TVkdfTElNSVRfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVByb3AoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNCZyA/IFwiYmFja2dyb3VuZC1jb2xvclwiIDogXCJjb2xvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlYWR5U3RhdGVDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTVkdFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWFkeVN0YXRlQ29tcGxldGVMaXN0ZW5lcihoYW5kbGVTVkdFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVByb3AoXCJmaWxsXCIsIFwiY29sb3JcIiwgdmFsdWVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInN0b3AtY29sb3JcIikpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1c3RvbVByb3AoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdG9wLWNvbG9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdG9wLWNvbG9yXCIpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInN0cm9rZVwiKSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0cm9rZVwiKTtcclxuICAgICAgICAgICAgc2V0Q3VzdG9tUHJvcChcclxuICAgICAgICAgICAgICAgIFwic3Ryb2tlXCIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgU1ZHTGluZUVsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgU1ZHVGV4dEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IFwiYm9yZGVyLWNvbG9yXCJcclxuICAgICAgICAgICAgICAgICAgICA6IFwiY29sb3JcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUgJiZcclxuICAgICAgICAgICAgaXRlcmF0ZUNTU0RlY2xhcmF0aW9ucyhlbGVtZW50LnN0eWxlLCBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IFwiYmFja2dyb3VuZC1pbWFnZVwiICYmIHZhbHVlLmluY2x1ZGVzKFwidXJsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAocHJvcGVydHkuc3RhcnRzV2l0aChcIi0tXCIpICYmICFub3JtYWxpemVkUHJvcExpc3RbcHJvcGVydHldKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tUHJvcChwcm9wZXJ0eSwgcHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlblByb3AgPSBub3JtYWxpemVkUHJvcExpc3RbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVuUHJvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG92ZXJyaWRlblByb3ApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFlbGVtZW50Lmhhc0F0dHJpYnV0ZShvdmVycmlkZW5Qcm9wKVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZW5Qcm9wID09PSBcImJhY2tncm91bmQtY29sb3JcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJiZ2NvbG9yXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlICYmXHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdUZXh0RWxlbWVudCAmJlxyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZpbGxcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc2V0Q3VzdG9tUHJvcChcclxuICAgICAgICAgICAgICAgIFwiZmlsbFwiLFxyXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZmlsbFwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JFYWNoKHVuc2V0UHJvcHMsIGZ1bmN0aW9uIChjc3NQcm9wKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG92ZXJyaWRlc1tjc3NQcm9wXS5kYXRhQXR0cik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW5saW5lU3R5bGVDYWNoZS5zZXQoZWxlbWVudCwgZ2V0SW5saW5lU3R5bGVDYWNoZUtleShlbGVtZW50LCB0aGVtZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtZXRhVGhlbWVDb2xvck5hbWUgPSBcInRoZW1lLWNvbG9yXCI7XHJcbiAgICB2YXIgbWV0YVRoZW1lQ29sb3JTZWxlY3RvciA9ICdtZXRhW25hbWU9XCInLmNvbmNhdChtZXRhVGhlbWVDb2xvck5hbWUsICdcIl0nKTtcclxuICAgIHZhciBzcmNNZXRhVGhlbWVDb2xvciA9IG51bGw7XHJcbiAgICB2YXIgb2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgZnVuY3Rpb24gY2hhbmdlTWV0YVRoZW1lQ29sb3IobWV0YSwgdGhlbWUpIHtcclxuICAgICAgICBzcmNNZXRhVGhlbWVDb2xvciA9IHNyY01ldGFUaGVtZUNvbG9yIHx8IG1ldGEuY29udGVudDtcclxuICAgICAgICB2YXIgY29sb3IgPSBwYXJzZUNvbG9yV2l0aENhY2hlKHNyY01ldGFUaGVtZUNvbG9yKTtcclxuICAgICAgICBpZiAoIWNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWV0YS5jb250ZW50ID0gbW9kaWZ5QmFja2dyb3VuZENvbG9yKGNvbG9yLCB0aGVtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGFuZ2VNZXRhVGhlbWVDb2xvcldoZW5BdmFpbGFibGUodGhlbWUpIHtcclxuICAgICAgICB2YXIgbWV0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobWV0YVRoZW1lQ29sb3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKG1ldGEpIHtcclxuICAgICAgICAgICAgY2hhbmdlTWV0YVRoZW1lQ29sb3IobWV0YSwgdGhlbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkZWROb2RlcyA9IG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWRkZWROb2Rlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZGVkTm9kZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBIVE1MTWV0YUVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9PT0gbWV0YVRoZW1lQ29sb3JOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlTWV0YVRoZW1lQ29sb3Iobm9kZSwgdGhlbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuaGVhZCwge2NoaWxkTGlzdDogdHJ1ZX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc3RvcmVNZXRhVGhlbWVDb2xvcigpIHtcclxuICAgICAgICBpZiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihtZXRhVGhlbWVDb2xvclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAobWV0YSAmJiBzcmNNZXRhVGhlbWVDb2xvcikge1xyXG4gICAgICAgICAgICBtZXRhLmNvbnRlbnQgPSBzcmNNZXRhVGhlbWVDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRoZW1lQ2FjaGVLZXlzID0gW1xyXG4gICAgICAgIFwibW9kZVwiLFxyXG4gICAgICAgIFwiYnJpZ2h0bmVzc1wiLFxyXG4gICAgICAgIFwiY29udHJhc3RcIixcclxuICAgICAgICBcImdyYXlzY2FsZVwiLFxyXG4gICAgICAgIFwic2VwaWFcIixcclxuICAgICAgICBcImRhcmtTY2hlbWVCYWNrZ3JvdW5kQ29sb3JcIixcclxuICAgICAgICBcImRhcmtTY2hlbWVUZXh0Q29sb3JcIixcclxuICAgICAgICBcImxpZ2h0U2NoZW1lQmFja2dyb3VuZENvbG9yXCIsXHJcbiAgICAgICAgXCJsaWdodFNjaGVtZVRleHRDb2xvclwiXHJcbiAgICBdO1xyXG4gICAgZnVuY3Rpb24gZ2V0VGhlbWVLZXkodGhlbWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0S2V5ID0gXCJcIjtcclxuICAgICAgICB0aGVtZUNhY2hlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmVzdWx0S2V5ICs9IFwiXCIuY29uY2F0KGtleSwgXCI6XCIpLmNvbmNhdCh0aGVtZVtrZXldLCBcIjtcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdEtleTtcclxuICAgIH1cclxuICAgIHZhciBhc3luY1F1ZXVlID0gY3JlYXRlQXN5bmNUYXNrc1F1ZXVlKCk7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0TW9kaWZpZXIoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcklkID0gMDtcclxuICAgICAgICB2YXIgcnVsZXNUZXh0Q2FjaGUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIHJ1bGVzTW9kQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIHZhclR5cGVDaGFuZ2VDbGVhbmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB2YXIgcHJldkZpbHRlcktleSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGhhc05vbkxvYWRlZExpbmsgPSBmYWxzZTtcclxuICAgICAgICB2YXIgd2FzUmVidWlsdCA9IGZhbHNlO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNob3VsZFJlYnVpbGRTdHlsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc05vbkxvYWRlZExpbmsgJiYgIXdhc1JlYnVpbHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG1vZGlmeVNoZWV0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gb3B0aW9ucy5zb3VyY2VDU1NSdWxlcztcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gb3B0aW9ucy50aGVtZSxcclxuICAgICAgICAgICAgICAgIGlnbm9yZUltYWdlQW5hbHlzaXMgPSBvcHRpb25zLmlnbm9yZUltYWdlQW5hbHlzaXMsXHJcbiAgICAgICAgICAgICAgICBmb3JjZSA9IG9wdGlvbnMuZm9yY2UsXHJcbiAgICAgICAgICAgICAgICBwcmVwYXJlU2hlZXQgPSBvcHRpb25zLnByZXBhcmVTaGVldCxcclxuICAgICAgICAgICAgICAgIGlzQXN5bmNDYW5jZWxsZWQgPSBvcHRpb25zLmlzQXN5bmNDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgIHZhciBydWxlc0NoYW5nZWQgPSBydWxlc01vZENhY2hlLnNpemUgPT09IDA7XHJcbiAgICAgICAgICAgIHZhciBub3RGb3VuZENhY2hlS2V5cyA9IG5ldyBTZXQocnVsZXNNb2RDYWNoZS5rZXlzKCkpO1xyXG4gICAgICAgICAgICB2YXIgdGhlbWVLZXkgPSBnZXRUaGVtZUtleSh0aGVtZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNoYW5nZWQgPSB0aGVtZUtleSAhPT0gcHJldkZpbHRlcktleTtcclxuICAgICAgICAgICAgaWYgKGhhc05vbkxvYWRlZExpbmspIHtcclxuICAgICAgICAgICAgICAgIHdhc1JlYnVpbHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtb2RSdWxlcyA9IFtdO1xyXG4gICAgICAgICAgICBpdGVyYXRlQ1NTUnVsZXMoXHJcbiAgICAgICAgICAgICAgICBydWxlcyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1RleHQgPSBydWxlLmNzc1RleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHREaWZmZXJzRnJvbVByZXYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBub3RGb3VuZENhY2hlS2V5cy5kZWxldGUoY3NzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ICs9IFwiO1wiLmNvbmNhdChydWxlLnBhcmVudFJ1bGUubWVkaWEubWVkaWFUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlc1RleHRDYWNoZS5oYXMoY3NzVGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNUZXh0Q2FjaGUuYWRkKGNzc1RleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGlmZmVyc0Zyb21QcmV2ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHREaWZmZXJzRnJvbVByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RSdWxlcy5wdXNoKHJ1bGVzTW9kQ2FjaGUuZ2V0KGNzc1RleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kRGVjcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUNTU0RlY2xhcmF0aW9ucyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IGdldE1vZGlmaWFibGVDU1NEZWNsYXJhdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNTdG9yZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlSW1hZ2VBbmFseXNpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY0NhbmNlbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2REZWNzLnB1c2gobW9kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZFJ1bGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2REZWNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFJ1bGUgPSBydWxlLnBhcmVudFJ1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZFJ1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogcnVsZS5zZWxlY3RvclRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IG1vZERlY3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdWxlOiBwYXJlbnRSdWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZFJ1bGVzLnB1c2gobW9kUnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzTW9kQ2FjaGUuc2V0KGNzc1RleHQsIG1vZFJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNOb25Mb2FkZWRMaW5rID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbm90Rm91bmRDYWNoZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBydWxlc1RleHRDYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJ1bGVzTW9kQ2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwcmV2RmlsdGVyS2V5ID0gdGhlbWVLZXk7XHJcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXJ1bGVzQ2hhbmdlZCAmJiAhdGhlbWVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVySWQrKztcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0UnVsZSh0YXJnZXQsIGluZGV4LCBydWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHJ1bGUuZGVjbGFyYXRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdldERlY2xhcmF0aW9uVGV4dCA9IGZ1bmN0aW9uIChkZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBkZWMucHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSBkZWMuaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSA9IGRlYy5zb3VyY2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb3BlcnR5LCBcIjogXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodmFsdWUgPT0gbnVsbCA/IHNvdXJjZVZhbHVlIDogdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoaW1wb3J0YW50ID8gXCIgIWltcG9ydGFudFwiIDogXCJcIiwgXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBjc3NSdWxlc1RleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNzc1J1bGVzVGV4dCArPSBcIlwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RGVjbGFyYXRpb25UZXh0KGRlY2xhcmF0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVUZXh0ID0gXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoc2VsZWN0b3IsIFwiIHsgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjc3NSdWxlc1RleHQsIFwiIH1cIik7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0UnVsZShydWxlVGV4dCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhc3luY0RlY2xhcmF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdmFyIHZhckRlY2xhcmF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdmFyIGFzeW5jRGVjbGFyYXRpb25Db3VudGVyID0gMDtcclxuICAgICAgICAgICAgdmFyIHZhckRlY2xhcmF0aW9uQ291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIHZhciByb290UmVhZHlHcm91cCA9IHtydWxlOiBudWxsLCBydWxlczogW10sIGlzR3JvdXA6IHRydWV9O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBSZWZzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXAocnVsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290UmVhZHlHcm91cDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChncm91cFJlZnMuaGFzKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwUmVmcy5nZXQocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB7cnVsZTogcnVsZSwgcnVsZXM6IFtdLCBpc0dyb3VwOiB0cnVlfTtcclxuICAgICAgICAgICAgICAgIGdyb3VwUmVmcy5zZXQocnVsZSwgZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEdyb3VwID0gZ2V0R3JvdXAocnVsZS5wYXJlbnRSdWxlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudEdyb3VwLnJ1bGVzLnB1c2goZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhclR5cGVDaGFuZ2VDbGVhbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbGVhcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXJUeXBlQ2hhbmdlQ2xlYW5lcnMuY2xlYXIoKTtcclxuICAgICAgICAgICAgbW9kUnVsZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBfYS5zZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gX2EuZGVjbGFyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdWxlID0gX2EucGFyZW50UnVsZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBnZXRHcm91cChwYXJlbnRSdWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZHlTdHlsZVJ1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNHcm91cDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkeURlY2xhcmF0aW9ucyA9IHJlYWR5U3R5bGVSdWxlLmRlY2xhcmF0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5ydWxlcy5wdXNoKHJlYWR5U3R5bGVSdWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVBc3luY0RlY2xhcmF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzeW5jS2V5ID0gKythc3luY0RlY2xhcmF0aW9uQ291bnRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzeW5jRGVjbGFyYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNLZXk6IGFzeW5jS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHNvdXJjZVZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5RGVjbGFyYXRpb25zLnB1c2goYXN5bmNEZWNsYXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UmVuZGVySWQgPSByZW5kZXJJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQudGhlbihmdW5jdGlvbiAoYXN5bmNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhc3luY1ZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY0NhbmNlbGxlZCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlbmRlcklkICE9PSByZW5kZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNEZWNsYXJhdGlvbi52YWx1ZSA9IGFzeW5jVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY1F1ZXVlLmFkZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FzeW5jQ2FuY2VsbGVkKCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlbmRlcklkICE9PSByZW5kZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYnVpbGRBc3luY1J1bGUoYXN5bmNLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVWYXJEZWNsYXJhdGlvbnMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBtb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhckRlY3MgPSBfYS5kZWNsYXJhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblR5cGVDaGFuZ2UgPSBfYS5vblR5cGVDaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJLZXkgPSArK3ZhckRlY2xhcmF0aW9uQ291bnRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZW5kZXJJZCA9IHJlbmRlcklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEluZGV4ID0gcmVhZHlEZWNsYXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkRGVjcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyRGVjcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wRGVjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50OiBpbXBvcnRhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcktleTogdmFyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlEZWNsYXJhdGlvbnMucHVzaCh0ZW1wRGVjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZERlY3MgPSBbdGVtcERlY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyRGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2QudmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXN5bmNEZWNsYXJhdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLnByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZHlEZWMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtb2QucHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2QudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZTogc291cmNlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcktleTogdmFyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeURlY2xhcmF0aW9ucy5wdXNoKHJlYWR5RGVjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREZWNzLnB1c2gocmVhZHlEZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25UeXBlQ2hhbmdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChuZXdEZWNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY0NhbmNlbGxlZCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlbmRlcklkICE9PSByZW5kZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWR5VmFyRGVjcyA9IG5ld0RlY3MubWFwKGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbW9kLnByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbW9kLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQ6IGltcG9ydGFudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHNvdXJjZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJLZXk6IHZhcktleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlYWR5RGVjbGFyYXRpb25zLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGVjc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeURlY2xhcmF0aW9ucy5zcGxpY2UuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlEZWNsYXJhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zcHJlYWRBcnJheShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2luZGV4LCBvbGREZWNzLmxlbmd0aF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fcmVhZChyZWFkeVZhckRlY3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREZWNzID0gcmVhZHlWYXJEZWNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVidWlsZFZhclJ1bGUodmFyS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhclR5cGVDaGFuZ2VDbGVhbmVycy5hZGQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uVHlwZUNoYW5nZS5yZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBfYS5wcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2EudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSBfYS5pbXBvcnRhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSA9IF9hLnNvdXJjZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZCA9IHZhbHVlKHRoZW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBc3luY0RlY2xhcmF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS5zdGFydHNXaXRoKFwiLS1cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVWYXJEZWNsYXJhdGlvbnMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5RGVjbGFyYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50OiBpbXBvcnRhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlOiBzb3VyY2VWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlEZWNsYXJhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQ6IGltcG9ydGFudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZTogc291cmNlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHNoZWV0ID0gcHJlcGFyZVNoZWV0KCk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkU3R5bGVTaGVldCgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRhcmdldChncm91cCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBncm91cC5ydWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYSA9IHJ1bGUubWVkaWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcmVudC5jc3NSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRSdWxlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJAbWVkaWEgXCIuY29uY2F0KG1lZGlhLm1lZGlhVGV4dCwgXCIge31cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmNzc1J1bGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVSZWFkeVJ1bGVzKGdyb3VwLCB0YXJnZXQsIHN0eWxlSXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gY3JlYXRlVGFyZ2V0KHIsIHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlUmVhZHlSdWxlcyhyLCB0LCBzdHlsZUl0ZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSXRlcmF0b3IociwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXRlcmF0ZVJlYWR5UnVsZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdFJlYWR5R3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJ1bGUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0YXJnZXQuY3NzUnVsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzeW5jS2V5ID0gX2EuYXN5bmNLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyS2V5ID0gX2EudmFyS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jS2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luY0RlY2xhcmF0aW9ucy5zZXQoYXN5bmNLZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcktleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyRGVjbGFyYXRpb25zLnNldCh2YXJLZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UnVsZSh0YXJnZXQsIGluZGV4LCBydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlYnVpbGRBc3luY1J1bGUoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBhc3luY0RlY2xhcmF0aW9ucy5nZXQoa2V5KSxcclxuICAgICAgICAgICAgICAgICAgICBydWxlID0gX2EucnVsZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfYS5pbmRleDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGVSdWxlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHNldFJ1bGUodGFyZ2V0LCBpbmRleCwgcnVsZSk7XHJcbiAgICAgICAgICAgICAgICBhc3luY0RlY2xhcmF0aW9ucy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWJ1aWxkVmFyUnVsZShrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHZhckRlY2xhcmF0aW9ucy5nZXQoa2V5KSxcclxuICAgICAgICAgICAgICAgICAgICBydWxlID0gX2EucnVsZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfYS5pbmRleDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGVSdWxlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHNldFJ1bGUodGFyZ2V0LCBpbmRleCwgcnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVpbGRTdHlsZVNoZWV0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1vZGlmeVNoZWV0OiBtb2RpZnlTaGVldCxcclxuICAgICAgICAgICAgc2hvdWxkUmVidWlsZFN0eWxlOiBzaG91bGRSZWJ1aWxkU3R5bGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTVFlMRV9TRUxFQ1RPUiA9ICdzdHlsZSwgbGlua1tyZWwqPVwic3R5bGVzaGVldFwiIGldOm5vdChbZGlzYWJsZWRdKSc7XHJcbiAgICBmdW5jdGlvbiBpc0ZvbnRzR29vZ2xlQXBpU3R5bGUoZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghZWxlbWVudC5ocmVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRVUkwgPSBuZXcgVVJMKGVsZW1lbnQuaHJlZik7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VVJMLmhvc3RuYW1lID09PSBcImZvbnRzLmdvb2dsZWFwaXMuY29tXCI7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGxvZ0luZm8oXCJDb3VsZG4ndCBjb25zdHJ1Y3QgXCIuY29uY2F0KGVsZW1lbnQuaHJlZiwgXCIgYXMgVVJMXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNob3VsZE1hbmFnZVN0eWxlKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdTdHlsZUVsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic3R5bGVzaGVldFwiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaHJlZiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFlbGVtZW50LmRpc2FibGVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzRmlyZWZveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICFlbGVtZW50LmhyZWYuc3RhcnRzV2l0aChcIm1vei1leHRlbnNpb246Ly9cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc0ZvbnRzR29vZ2xlQXBpU3R5bGUoZWxlbWVudCkpKSAmJlxyXG4gICAgICAgICAgICAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrcmVhZGVyXCIpICYmXHJcbiAgICAgICAgICAgIGVsZW1lbnQubWVkaWEudG9Mb3dlckNhc2UoKSAhPT0gXCJwcmludFwiICYmXHJcbiAgICAgICAgICAgICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInN0eWx1c1wiKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRNYW5hZ2VhYmxlU3R5bGVzKG5vZGUsIHJlc3VsdHMsIGRlZXApIHtcclxuICAgICAgICBpZiAocmVzdWx0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZXAgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBkZWVwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZE1hbmFnZVN0eWxlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAoaXNTaGFkb3dEb21TdXBwb3J0ZWQgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHx8XHJcbiAgICAgICAgICAgIG5vZGUgPT09IGRvY3VtZW50XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGZvckVhY2gobm9kZS5xdWVyeVNlbGVjdG9yQWxsKFNUWUxFX1NFTEVDVE9SKSwgZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFuYWdlYWJsZVN0eWxlcyhzdHlsZSwgcmVzdWx0cywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhub2RlLCBmdW5jdGlvbiAoaG9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYW5hZ2VhYmxlU3R5bGVzKGhvc3Quc2hhZG93Um9vdCwgcmVzdWx0cywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICB2YXIgc3luY1N0eWxlU2V0ID0gbmV3IFdlYWtTZXQoKTtcclxuICAgIHZhciBjb3JzU3R5bGVTZXQgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgdmFyIGNhbk9wdGltaXplVXNpbmdQcm94eSQxID0gZmFsc2U7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIFwiX19kYXJrcmVhZGVyX19pbmxpbmVTY3JpcHRzQWxsb3dlZFwiLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FuT3B0aW1pemVVc2luZ1Byb3h5JDEgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcbiAgICB2YXIgbG9hZGluZ0xpbmtDb3VudGVyID0gMDtcclxuICAgIHZhciByZWplY3RvcnNGb3JMb2FkaW5nTGlua3MgPSBuZXcgTWFwKCk7XHJcbiAgICBmdW5jdGlvbiBjbGVhbkxvYWRpbmdMaW5rcygpIHtcclxuICAgICAgICByZWplY3RvcnNGb3JMb2FkaW5nTGlua3MuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hbmFnZVN0eWxlKGVsZW1lbnQsIF9hKSB7XHJcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZSxcclxuICAgICAgICAgICAgbG9hZGluZ1N0YXJ0ID0gX2EubG9hZGluZ1N0YXJ0LFxyXG4gICAgICAgICAgICBsb2FkaW5nRW5kID0gX2EubG9hZGluZ0VuZDtcclxuICAgICAgICB2YXIgcHJldlN0eWxlcyA9IFtdO1xyXG4gICAgICAgIHZhciBuZXh0ID0gZWxlbWVudDtcclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgIChuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmcpICYmXHJcbiAgICAgICAgICAgIG5leHQubWF0Y2hlcyhcIi5kYXJrcmVhZGVyXCIpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHByZXZTdHlsZXMucHVzaChuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvcnNDb3B5ID1cclxuICAgICAgICAgICAgcHJldlN0eWxlcy5maW5kKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoXCIuZGFya3JlYWRlci0tY29yc1wiKSAmJiAhY29yc1N0eWxlU2V0LmhhcyhlbCk7XHJcbiAgICAgICAgICAgIH0pIHx8IG51bGw7XHJcbiAgICAgICAgdmFyIHN5bmNTdHlsZSA9XHJcbiAgICAgICAgICAgIHByZXZTdHlsZXMuZmluZChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5tYXRjaGVzKFwiLmRhcmtyZWFkZXItLXN5bmNcIikgJiYgIXN5bmNTdHlsZVNldC5oYXMoZWwpO1xyXG4gICAgICAgICAgICB9KSB8fCBudWxsO1xyXG4gICAgICAgIHZhciBjb3JzQ29weVBvc2l0aW9uV2F0Y2hlciA9IG51bGw7XHJcbiAgICAgICAgdmFyIHN5bmNTdHlsZVBvc2l0aW9uV2F0Y2hlciA9IG51bGw7XHJcbiAgICAgICAgdmFyIGNhbmNlbEFzeW5jT3BlcmF0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc092ZXJyaWRlRW1wdHkgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaGVldE1vZGlmaWVyID0gY3JlYXRlU3R5bGVTaGVldE1vZGlmaWVyKCk7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zQ1NTSW1wb3J0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpLm1hdGNoKGNzc0ltcG9ydFJlZ2V4KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBoYXNJbXBvcnRzKGNzc1J1bGVzLCBjaGVja0Nyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGNzc1J1bGVzTG9vcDogZm9yIChcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGNzc1J1bGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpIDwgbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrK1xyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IGNzc1J1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmhyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ3Jvc3NPcmlnaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcnVsZS5ocmVmLnN0YXJ0c1dpdGgobG9jYXRpb24ub3JpZ2luKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBjc3NSdWxlc0xvb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgY3NzUnVsZXNMb29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFJ1bGVzU3luYygpIHtcclxuICAgICAgICAgICAgaWYgKGNvcnNDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yc0NvcHkuc2hlZXQuY3NzUnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zQ1NTSW1wb3J0KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjc3NSdWxlcyA9IHNhZmVHZXRTaGVldFJ1bGVzKCk7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICFpc1JlbGF0aXZlSHJlZk9uQWJzb2x1dGVQYXRoKGVsZW1lbnQuaHJlZikgJiZcclxuICAgICAgICAgICAgICAgIGhhc0ltcG9ydHMoY3NzUnVsZXMsIGZhbHNlKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNJbXBvcnRzKGNzc1J1bGVzLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRTdHlsZSgpIHtcclxuICAgICAgICAgICAgaWYgKGNvcnNDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uZXh0U2libGluZyAhPT0gY29yc0NvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JzQ29weSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5uZXh0U2libGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29yc0NvcHkubmV4dFNpYmxpbmcgIT09IHN5bmNTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yc0NvcHkubmV4dFNpYmxpbmdcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubmV4dFNpYmxpbmcgIT09IHN5bmNTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzeW5jU3R5bGUsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVN5bmNTdHlsZSgpIHtcclxuICAgICAgICAgICAgc3luY1N0eWxlID1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdTdHlsZUVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICAgICAgICAgIHN5bmNTdHlsZS5jbGFzc0xpc3QuYWRkKFwiZGFya3JlYWRlclwiKTtcclxuICAgICAgICAgICAgc3luY1N0eWxlLmNsYXNzTGlzdC5hZGQoXCJkYXJrcmVhZGVyLS1zeW5jXCIpO1xyXG4gICAgICAgICAgICBzeW5jU3R5bGUubWVkaWEgPSBcInNjcmVlblwiO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1N0eWxlLnRpdGxlID0gZWxlbWVudC50aXRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzeW5jU3R5bGVTZXQuYWRkKHN5bmNTdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0xvYWRpbmdSdWxlcyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB3YXNMb2FkaW5nRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbG9hZGluZ0xpbmtJZCA9ICsrbG9hZGluZ0xpbmtDb3VudGVyO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldFJ1bGVzQXN5bmMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0Jhc2VQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIF9hLFxyXG4gICAgICAgICAgICAgICAgICAgIGNzc1J1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0Vycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxDU1NUZXh0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA3XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF9fcmVhZChnZXRSdWxlc09yRXJyb3IoKSwgMikpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjc3NSdWxlcyA9IF9hWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWNjZXNzRXJyb3IgPSBfYVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjc3NSdWxlcyAmJiAhYWNjZXNzRXJyb3IgJiYgIWlzU2FmYXJpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNTYWZhcmkgJiYgIWVsZW1lbnQuc2hlZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RpbGxMb2FkaW5nRXJyb3IoYWNjZXNzRXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGxpbmtMb2FkaW5nKGVsZW1lbnQsIGxvYWRpbmdMaW5rSWQpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzTG9hZGluZ0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWxBc3luY09wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gX19yZWFkKGdldFJ1bGVzT3JFcnJvcigpLCAyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNzc1J1bGVzID0gX2JbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhY2Nlc3NFcnJvciA9IF9iWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNJbXBvcnRzKGNzc1J1bGVzLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBjc3NSdWxlc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBsb2FkVGV4dChlbGVtZW50LmhyZWYpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc0Jhc2VQYXRoID0gZ2V0Q1NTQmFzZUJhdGgoZWxlbWVudC5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWxBc3luY09wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zQ1NTSW1wb3J0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ID0gZWxlbWVudC50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzQmFzZVBhdGggPSBnZXRDU1NCYXNlQmF0aChsb2NhdGlvbi5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjc3NUZXh0KSByZXR1cm4gWzMsIDEzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gOTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs5LCAxMSwgLCAxMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZXBsYWNlQ1NTSW1wb3J0cyhjc3NUZXh0LCBjc3NCYXNlUGF0aCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbENTU1RleHQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JzQ29weSA9IGNyZWF0ZUNPUlNDb3B5KGVsZW1lbnQsIGZ1bGxDU1NUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMTJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yc0NvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JzQ29weVBvc2l0aW9uV2F0Y2hlciA9IHdhdGNoRm9yTm9kZVBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JzQ29weSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2LXNpYmxpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBjb3JzQ29weS5zaGVldC5jc3NSdWxlc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDEzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGRldGFpbHMob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBnZXRSdWxlc1N5bmMoKTtcclxuICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kUm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0xvYWRpbmdSdWxlcyB8fCB3YXNMb2FkaW5nRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlzTG9hZGluZ1J1bGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgZ2V0UnVsZXNBc3luYygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2FkaW5nUnVsZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ0VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9hZGluZ1J1bGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmdFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7cnVsZXM6IHJ1bGVzfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvcmNlUmVuZGVyU3R5bGUgPSBmYWxzZTtcclxuICAgICAgICBmdW5jdGlvbiByZW5kZXIodGhlbWUsIGlnbm9yZUltYWdlQW5hbHlzaXMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gZ2V0UnVsZXNTeW5jKCk7XHJcbiAgICAgICAgICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYW5jZWxBc3luY09wZXJhdGlvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ1NTUnVsZXNGcm9tU2hlZXQoc2hlZXQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzaGVldC5jc3NSdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZU92ZXJyaWRlc1NoZWV0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzeW5jU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTeW5jU3R5bGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN5bmNTdHlsZVBvc2l0aW9uV2F0Y2hlciAmJiBzeW5jU3R5bGVQb3NpdGlvbldhdGNoZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0U3R5bGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzeW5jU3R5bGUuc2hlZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNTdHlsZS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBzeW5jU3R5bGUuc2hlZXQ7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDU1NSdWxlc0Zyb21TaGVldChzaGVldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3luY1N0eWxlUG9zaXRpb25XYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1N0eWxlUG9zaXRpb25XYXRjaGVyLnJ1bigpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jU3R5bGVQb3NpdGlvbldhdGNoZXIgPSB3YXRjaEZvck5vZGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1N0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXYtc2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlclN0eWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkT3ZlcnJpZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNTdHlsZS5zaGVldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZE92ZXJyaWRlcygpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IGZvcmNlUmVuZGVyU3R5bGU7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlclN0eWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzaGVldE1vZGlmaWVyLm1vZGlmeVNoZWV0KHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlU2hlZXQ6IHByZXBhcmVPdmVycmlkZXNTaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDU1NSdWxlczogcnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZUltYWdlQW5hbHlzaXM6IGlnbm9yZUltYWdlQW5hbHlzaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IGZvcmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmNDYW5jZWxsZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbEFzeW5jT3BlcmF0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlzT3ZlcnJpZGVFbXB0eSA9IHN5bmNTdHlsZS5zaGVldC5jc3NSdWxlcy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hlZXRNb2RpZmllci5zaG91bGRSZWJ1aWxkU3R5bGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFJlYWR5U3RhdGVDb21wbGV0ZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1aWxkT3ZlcnJpZGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFJ1bGVzT3JFcnJvcigpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnNoZWV0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50LnNoZWV0LmNzc1J1bGVzLCBudWxsXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW251bGwsIGVycl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gaXNTdGlsbExvYWRpbmdFcnJvcihlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwibG9hZGluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2FmZUdldFNoZWV0UnVsZXMoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXRSdWxlc09yRXJyb3IoKSwgMiksXHJcbiAgICAgICAgICAgICAgICBjc3NSdWxlcyA9IF9hWzBdLFxyXG4gICAgICAgICAgICAgICAgZXJyID0gX2FbMV07XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NSdWxlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gd2F0Y2hGb3JTaGVldENoYW5nZXMoKSB7XHJcbiAgICAgICAgICAgIHdhdGNoRm9yU2hlZXRDaGFuZ2VzVXNpbmdQcm94eSgpO1xyXG4gICAgICAgICAgICBpZiAoIShjYW5PcHRpbWl6ZVVzaW5nUHJveHkkMSAmJiBlbGVtZW50LnNoZWV0KSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hGb3JTaGVldENoYW5nZXNVc2luZ1JBRigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydWxlc0NoYW5nZUtleSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHJ1bGVzQ2hlY2tGcmFtZUlkID0gbnVsbDtcclxuICAgICAgICBmdW5jdGlvbiBnZXRSdWxlc0NoYW5nZUtleSgpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gc2FmZUdldFNoZWV0UnVsZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzID8gcnVsZXMubGVuZ3RoIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZGlkUnVsZXNLZXlDaGFuZ2UoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRSdWxlc0NoYW5nZUtleSgpICE9PSBydWxlc0NoYW5nZUtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gd2F0Y2hGb3JTaGVldENoYW5nZXNVc2luZ1JBRigpIHtcclxuICAgICAgICAgICAgcnVsZXNDaGFuZ2VLZXkgPSBnZXRSdWxlc0NoYW5nZUtleSgpO1xyXG4gICAgICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTaGVldENoYW5nZXNVc2luZ1JBRigpO1xyXG4gICAgICAgICAgICB2YXIgY2hlY2tGb3JVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlkUnVsZXNLZXlDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzQ2hhbmdlS2V5ID0gZ2V0UnVsZXNDaGFuZ2VLZXkoKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjYW5PcHRpbWl6ZVVzaW5nUHJveHkkMSAmJiBlbGVtZW50LnNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcFdhdGNoaW5nRm9yU2hlZXRDaGFuZ2VzVXNpbmdSQUYoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBydWxlc0NoZWNrRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja0ZvclVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNoZWNrRm9yVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclNoZWV0Q2hhbmdlc1VzaW5nUkFGKCkge1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShydWxlc0NoZWNrRnJhbWVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhcmVTaGVldENoYW5nZXNQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgZnVuY3Rpb24gb25TaGVldENoYW5nZSgpIHtcclxuICAgICAgICAgICAgY2FuT3B0aW1pemVVc2luZ1Byb3h5JDEgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTaGVldENoYW5nZXNVc2luZ1JBRigpO1xyXG4gICAgICAgICAgICBpZiAoYXJlU2hlZXRDaGFuZ2VzUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNoZWV0Q2hhbmdlcygpIHtcclxuICAgICAgICAgICAgICAgIGFyZVNoZWV0Q2hhbmdlc1BlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxBc3luY09wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmVTaGVldENoYW5nZXNQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhoYW5kbGVTaGVldENoYW5nZXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGhhbmRsZVNoZWV0Q2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gd2F0Y2hGb3JTaGVldENoYW5nZXNVc2luZ1Byb3h5KCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICBcIl9fZGFya3JlYWRlcl9fdXBkYXRlU2hlZXRcIixcclxuICAgICAgICAgICAgICAgIG9uU2hlZXRDaGFuZ2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yU2hlZXRDaGFuZ2VzVXNpbmdQcm94eSgpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgXCJfX2RhcmtyZWFkZXJfX3VwZGF0ZVNoZWV0XCIsXHJcbiAgICAgICAgICAgICAgICBvblNoZWV0Q2hhbmdlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclNoZWV0Q2hhbmdlcygpIHtcclxuICAgICAgICAgICAgc3RvcFdhdGNoaW5nRm9yU2hlZXRDaGFuZ2VzVXNpbmdQcm94eSgpO1xyXG4gICAgICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTaGVldENoYW5nZXNVc2luZ1JBRigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwYXVzZSgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBjYW5jZWxBc3luY09wZXJhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb3JzQ29weVBvc2l0aW9uV2F0Y2hlciAmJiBjb3JzQ29weVBvc2l0aW9uV2F0Y2hlci5zdG9wKCk7XHJcbiAgICAgICAgICAgIHN5bmNTdHlsZVBvc2l0aW9uV2F0Y2hlciAmJiBzeW5jU3R5bGVQb3NpdGlvbldhdGNoZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTaGVldENoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgcGF1c2UoKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjb3JzQ29weSk7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoc3luY1N0eWxlKTtcclxuICAgICAgICAgICAgbG9hZGluZ0VuZCgpO1xyXG4gICAgICAgICAgICBpZiAocmVqZWN0b3JzRm9yTG9hZGluZ0xpbmtzLmhhcyhsb2FkaW5nTGlua0lkKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdCA9IHJlamVjdG9yc0ZvckxvYWRpbmdMaW5rcy5nZXQobG9hZGluZ0xpbmtJZCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3RvcnNGb3JMb2FkaW5nTGlua3MuZGVsZXRlKGxvYWRpbmdMaW5rSWQpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0ICYmIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHdhdGNoKCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFN0eWxlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hGb3JTaGVldENoYW5nZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4TW92ZUNvdW50ID0gMTA7XHJcbiAgICAgICAgdmFyIG1vdmVDb3VudCA9IDA7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFzeW5jU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtb3ZlQ291bnQrKztcclxuICAgICAgICAgICAgaWYgKG1vdmVDb3VudCA+IG1heE1vdmVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc2VydFN0eWxlKCk7XHJcbiAgICAgICAgICAgIGNvcnNDb3B5UG9zaXRpb25XYXRjaGVyICYmIGNvcnNDb3B5UG9zaXRpb25XYXRjaGVyLnNraXAoKTtcclxuICAgICAgICAgICAgc3luY1N0eWxlUG9zaXRpb25XYXRjaGVyICYmIHN5bmNTdHlsZVBvc2l0aW9uV2F0Y2hlci5za2lwKCk7XHJcbiAgICAgICAgICAgIGlmICghaXNPdmVycmlkZUVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlclN0eWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXHJcbiAgICAgICAgICAgIHJlbmRlcjogcmVuZGVyLFxyXG4gICAgICAgICAgICBwYXVzZTogcGF1c2UsXHJcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXHJcbiAgICAgICAgICAgIHdhdGNoOiB3YXRjaCxcclxuICAgICAgICAgICAgcmVzdG9yZTogcmVzdG9yZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsaW5rTG9hZGluZyhsaW5rLCBsb2FkaW5nSWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgMixcclxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGVhblVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RvcnNGb3JMb2FkaW5nTGlua3MuZGVsZXRlKGxvYWRpbmdJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5VcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGlua2VsZW1lbnQgXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChsb2FkaW5nSWQsIFwiIGNvdWxkbid0IGJlIGxvYWRlZC4gXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobGluay5ocmVmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0b3JzRm9yTG9hZGluZ0xpbmtzLnNldChsb2FkaW5nSWQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rLmhyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENTU0ltcG9ydFVSTChpbXBvcnREZWNsYXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBnZXRDU1NVUkxWYWx1ZShcclxuICAgICAgICAgICAgaW1wb3J0RGVjbGFyYXRpb25cclxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoNylcclxuICAgICAgICAgICAgICAgIC50cmltKClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC87JC8sIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvc2NyZWVuJC8sIFwiXCIpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxvYWRUZXh0KHVybCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSByZXR1cm4gWzMsIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGZldGNoKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfYS5zZW50KCkudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdGZXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcInRleHRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L2Nzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXBsYWNlQ1NTSW1wb3J0cyhjc3NUZXh0LCBiYXNlUGF0aCwgY2FjaGUpIHtcclxuICAgICAgICBpZiAoY2FjaGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW1wb3J0TWF0Y2hlcyxcclxuICAgICAgICAgICAgICAgIGltcG9ydE1hdGNoZXNfMSxcclxuICAgICAgICAgICAgICAgIGltcG9ydE1hdGNoZXNfMV8xLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgICAgICAgICBpbXBvcnRVUkwsXHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVVSTCxcclxuICAgICAgICAgICAgICAgIGltcG9ydGVkQ1NTLFxyXG4gICAgICAgICAgICAgICAgZV8xXzE7XHJcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ID0gcmVtb3ZlQ1NTQ29tbWVudHMoY3NzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQgPSByZXBsYWNlQ1NTRm9udEZhY2UoY3NzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQgPSByZXBsYWNlQ1NTUmVsYXRpdmVVUkxzV2l0aEFic29sdXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydE1hdGNoZXMgPSBnZXRNYXRjaGVzKGNzc0ltcG9ydFJlZ2V4LCBjc3NUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAxMCwgMTEsIDEyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbXBvcnRNYXRjaGVzXzEgPSBfX3ZhbHVlcyhpbXBvcnRNYXRjaGVzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW1wb3J0TWF0Y2hlc18xXzEgPSBpbXBvcnRNYXRjaGVzXzEubmV4dCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhaW1wb3J0TWF0Y2hlc18xXzEuZG9uZSkgcmV0dXJuIFszLCA5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBpbXBvcnRNYXRjaGVzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0VVJMID0gZ2V0Q1NTSW1wb3J0VVJMKG1hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVUkwgPSBnZXRBYnNvbHV0ZVVSTChiYXNlUGF0aCwgaW1wb3J0VVJMKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRDU1MgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGUuaGFzKGFic29sdXRlVVJMKSkgcmV0dXJuIFszLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRDU1MgPSBjYWNoZS5nZXQoYWJzb2x1dGVVUkwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDddO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFszLCA2LCAsIDddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBsb2FkVGV4dChhYnNvbHV0ZVVSTCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRDU1MgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChhYnNvbHV0ZVVSTCwgaW1wb3J0ZWRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDU1NJbXBvcnRzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkQ1NTLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENTU0Jhc2VCYXRoKGFic29sdXRlVVJMKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRDU1MgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkQ1NTID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA3XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnNwbGl0KG1hdGNoKS5qb2luKGltcG9ydGVkQ1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0TWF0Y2hlc18xXzEgPSBpbXBvcnRNYXRjaGVzXzEubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxMl07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHtlcnJvcjogZV8xXzF9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDEyXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydE1hdGNoZXNfMV8xICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWltcG9ydE1hdGNoZXNfMV8xLmRvbmUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbXBvcnRNYXRjaGVzXzEucmV0dXJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmNhbGwoaW1wb3J0TWF0Y2hlc18xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzddO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBjc3NUZXh0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDT1JTQ29weShzcmNFbGVtZW50LCBjc3NUZXh0KSB7XHJcbiAgICAgICAgaWYgKCFjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29ycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgICBjb3JzLmNsYXNzTGlzdC5hZGQoXCJkYXJrcmVhZGVyXCIpO1xyXG4gICAgICAgIGNvcnMuY2xhc3NMaXN0LmFkZChcImRhcmtyZWFkZXItLWNvcnNcIik7XHJcbiAgICAgICAgY29ycy5tZWRpYSA9IFwic2NyZWVuXCI7XHJcbiAgICAgICAgY29ycy50ZXh0Q29udGVudCA9IGNzc1RleHQ7XHJcbiAgICAgICAgc3JjRWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb3JzLCBzcmNFbGVtZW50Lm5leHRTaWJsaW5nKTtcclxuICAgICAgICBjb3JzLnNoZWV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICBjb3JzU3R5bGVTZXQuYWRkKGNvcnMpO1xyXG4gICAgICAgIHJldHVybiBjb3JzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvYnNlcnZlcnMgPSBbXTtcclxuICAgIHZhciBvYnNlcnZlZFJvb3RzO1xyXG4gICAgdmFyIHVuZGVmaW5lZEdyb3VwcyA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBlbGVtZW50c0RlZmluaXRpb25DYWxsYmFjaztcclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RVbmRlZmluZWRFbGVtZW50cyhyb290KSB7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWRTZWxlY3RvclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2gocm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiOm5vdCg6ZGVmaW5lZClcIiksIGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHRlbmRlZFRhZyA9IGVsLmdldEF0dHJpYnV0ZShcImlzXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkVGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnID0gZXh0ZW5kZWRUYWc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXVuZGVmaW5lZEdyb3Vwcy5oYXModGFnKSkge1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkR3JvdXBzLnNldCh0YWcsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50c1doZW5EZWZpbmVkKHRhZykudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzRGVmaW5pdGlvbkNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHVuZGVmaW5lZEdyb3Vwcy5nZXQodGFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkR3JvdXBzLmRlbGV0ZSh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0RlZmluaXRpb25DYWxsYmFjayhBcnJheS5mcm9tKGVsZW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5kZWZpbmVkR3JvdXBzLmdldCh0YWcpLmFkZChlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2FuT3B0aW1pemVVc2luZ1Byb3h5ID0gZmFsc2U7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIFwiX19kYXJrcmVhZGVyX19pbmxpbmVTY3JpcHRzQWxsb3dlZFwiLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FuT3B0aW1pemVVc2luZ1Byb3h5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG4gICAgdmFyIHJlc29sdmVycyA9IG5ldyBNYXAoKTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZUlzRGVmaW5lZChlKSB7XHJcbiAgICAgICAgY2FuT3B0aW1pemVVc2luZ1Byb3h5ID0gdHJ1ZTtcclxuICAgICAgICBpZiAocmVzb2x2ZXJzLmhhcyhlLmRldGFpbC50YWcpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gcmVzb2x2ZXJzLmdldChlLmRldGFpbC50YWcpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3VzdG9tRWxlbWVudHNXaGVuRGVmaW5lZCh0YWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgMixcclxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQodGFnKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FuT3B0aW1pemVVc2luZ1Byb3h5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcnMuc2V0KHRhZywgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJfX2RhcmtyZWFkZXJfX2FkZFVuZGVmaW5lZFJlc29sdmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtkZXRhaWw6IHt0YWc6IHRhZ319XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja0lmRGVmaW5lZF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHVuZGVmaW5lZEdyb3Vwcy5nZXQodGFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWVzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmV4dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlLm1hdGNoZXMoXCI6ZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja0lmRGVmaW5lZF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hlY2tJZkRlZmluZWRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3YXRjaFdoZW5DdXN0b21FbGVtZW50c0RlZmluZWQoY2FsbGJhY2spIHtcclxuICAgICAgICBlbGVtZW50c0RlZmluaXRpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmVGcm9tRGVmaW5lQ3VzdG9tRWxlbWVudHMoKSB7XHJcbiAgICAgICAgZWxlbWVudHNEZWZpbml0aW9uQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHVuZGVmaW5lZEdyb3Vwcy5jbGVhcigpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFwiX19kYXJrcmVhZGVyX19pc0RlZmluZWRcIixcclxuICAgICAgICAgICAgaGFuZGxlSXNEZWZpbmVkXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdhdGNoRm9yU3R5bGVDaGFuZ2VzKGN1cnJlbnRTdHlsZXMsIHVwZGF0ZSwgc2hhZG93Um9vdERpc2NvdmVyZWQpIHtcclxuICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTdHlsZUNoYW5nZXMoKTtcclxuICAgICAgICB2YXIgcHJldlN0eWxlcyA9IG5ldyBTZXQoY3VycmVudFN0eWxlcyk7XHJcbiAgICAgICAgdmFyIHByZXZTdHlsZVNpYmxpbmdzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB2YXIgbmV4dFN0eWxlU2libGluZ3MgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNhdmVTdHlsZVBvc2l0aW9uKHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHByZXZTdHlsZVNpYmxpbmdzLnNldChzdHlsZSwgc3R5bGUucHJldmlvdXNFbGVtZW50U2libGluZyk7XHJcbiAgICAgICAgICAgIG5leHRTdHlsZVNpYmxpbmdzLnNldChzdHlsZSwgc3R5bGUubmV4dEVsZW1lbnRTaWJsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZm9yZ2V0U3R5bGVQb3NpdGlvbihzdHlsZSkge1xyXG4gICAgICAgICAgICBwcmV2U3R5bGVTaWJsaW5ncy5kZWxldGUoc3R5bGUpO1xyXG4gICAgICAgICAgICBuZXh0U3R5bGVTaWJsaW5ncy5kZWxldGUoc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBkaWRTdHlsZVBvc2l0aW9uQ2hhbmdlKHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICBzdHlsZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICE9PSBwcmV2U3R5bGVTaWJsaW5ncy5nZXQoc3R5bGUpIHx8XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IG5leHRTdHlsZVNpYmxpbmdzLmdldChzdHlsZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFN0eWxlcy5mb3JFYWNoKHNhdmVTdHlsZVBvc2l0aW9uKTtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTdHlsZU9wZXJhdGlvbnMob3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlZFN0eWxlcyA9IG9wZXJhdGlvbnMuY3JlYXRlZFN0eWxlcyxcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRTdHlsZXMgPSBvcGVyYXRpb25zLnJlbW92ZWRTdHlsZXMsXHJcbiAgICAgICAgICAgICAgICBtb3ZlZFN0eWxlcyA9IG9wZXJhdGlvbnMubW92ZWRTdHlsZXM7XHJcbiAgICAgICAgICAgIGNyZWF0ZWRTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhdmVTdHlsZVBvc2l0aW9uKHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW92ZWRTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhdmVTdHlsZVBvc2l0aW9uKHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVtb3ZlZFN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9yZ2V0U3R5bGVQb3NpdGlvbihzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNyZWF0ZWRTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZTdHlsZXMuYWRkKHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVtb3ZlZFN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldlN0eWxlcy5kZWxldGUocyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkU3R5bGVzLnNpemUgKyByZW1vdmVkU3R5bGVzLnNpemUgKyBtb3ZlZFN0eWxlcy5zaXplID5cclxuICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IEFycmF5LmZyb20oY3JlYXRlZFN0eWxlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogQXJyYXkuZnJvbShyZW1vdmVkU3R5bGVzKSxcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlZDogQXJyYXkuZnJvbShtb3ZlZFN0eWxlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogW11cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pbm9yVHJlZU11dGF0aW9ucyhfYSkge1xyXG4gICAgICAgICAgICB2YXIgYWRkaXRpb25zID0gX2EuYWRkaXRpb25zLFxyXG4gICAgICAgICAgICAgICAgbW92ZXMgPSBfYS5tb3ZlcyxcclxuICAgICAgICAgICAgICAgIGRlbGV0aW9ucyA9IF9hLmRlbGV0aW9ucztcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZWRTdHlsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkU3R5bGVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB2YXIgbW92ZWRTdHlsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGFkZGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFuYWdlYWJsZVN0eWxlcyhub2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVkU3R5bGVzLmFkZChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFuYWdlYWJsZVN0eWxlcyhub2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkU3R5bGVzLmFkZChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vdmVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYW5hZ2VhYmxlU3R5bGVzKG5vZGUpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVkU3R5bGVzLmFkZChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlT3BlcmF0aW9ucyh7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkU3R5bGVzOiBjcmVhdGVkU3R5bGVzLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFN0eWxlczogcmVtb3ZlZFN0eWxlcyxcclxuICAgICAgICAgICAgICAgIG1vdmVkU3R5bGVzOiBtb3ZlZFN0eWxlc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYWRkaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhuLCBzdWJzY3JpYmVGb3JTaGFkb3dSb290Q2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0VW5kZWZpbmVkRWxlbWVudHMobik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVIdWdlVHJlZU11dGF0aW9ucyhyb290KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBuZXcgU2V0KGdldE1hbmFnZWFibGVTdHlsZXMocm9vdCkpO1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlZFN0eWxlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWRTdHlsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHZhciBtb3ZlZFN0eWxlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJldlN0eWxlcy5oYXMocykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkU3R5bGVzLmFkZChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHByZXZTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFN0eWxlcy5hZGQocyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICFjcmVhdGVkU3R5bGVzLmhhcyhzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFyZW1vdmVkU3R5bGVzLmhhcyhzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRpZFN0eWxlUG9zaXRpb25DaGFuZ2UocylcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVkU3R5bGVzLmFkZChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlT3BlcmF0aW9ucyh7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkU3R5bGVzOiBjcmVhdGVkU3R5bGVzLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFN0eWxlczogcmVtb3ZlZFN0eWxlcyxcclxuICAgICAgICAgICAgICAgIG1vdmVkU3R5bGVzOiBtb3ZlZFN0eWxlc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXRlcmF0ZVNoYWRvd0hvc3RzKHJvb3QsIHN1YnNjcmliZUZvclNoYWRvd1Jvb3RDaGFuZ2VzKTtcclxuICAgICAgICAgICAgY29sbGVjdFVuZGVmaW5lZEVsZW1lbnRzKHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVkU3R5bGVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZFN0eWxlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTWFuYWdlU3R5bGUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkU3R5bGVzLmFkZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFN0eWxlcy5hZGQodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlZFN0eWxlcy5zaXplICsgcmVtb3ZlZFN0eWxlcy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiBBcnJheS5mcm9tKHVwZGF0ZWRTdHlsZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IEFycmF5LmZyb20ocmVtb3ZlZFN0eWxlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQ6IFtdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlKHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIHRyZWVPYnNlcnZlciA9IGNyZWF0ZU9wdGltaXplZFRyZWVPYnNlcnZlcihyb290LCB7XHJcbiAgICAgICAgICAgICAgICBvbk1pbm9yTXV0YXRpb25zOiBoYW5kbGVNaW5vclRyZWVNdXRhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBvbkh1Z2VNdXRhdGlvbnM6IGhhbmRsZUh1Z2VUcmVlTXV0YXRpb25zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgYXR0ck9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlQXR0cmlidXRlTXV0YXRpb25zKTtcclxuICAgICAgICAgICAgYXR0ck9ic2VydmVyLm9ic2VydmUocm9vdCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wicmVsXCIsIFwiZGlzYWJsZWRcIiwgXCJtZWRpYVwiLCBcImhyZWZcIl0sXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMucHVzaCh0cmVlT2JzZXJ2ZXIsIGF0dHJPYnNlcnZlcik7XHJcbiAgICAgICAgICAgIG9ic2VydmVkUm9vdHMuYWRkKHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmVGb3JTaGFkb3dSb290Q2hhbmdlcyhub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFkb3dSb290ID0gbm9kZS5zaGFkb3dSb290O1xyXG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdCA9PSBudWxsIHx8IG9ic2VydmVkUm9vdHMuaGFzKHNoYWRvd1Jvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JzZXJ2ZShzaGFkb3dSb290KTtcclxuICAgICAgICAgICAgc2hhZG93Um9vdERpc2NvdmVyZWQoc2hhZG93Um9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmUoZG9jdW1lbnQpO1xyXG4gICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICBzdWJzY3JpYmVGb3JTaGFkb3dSb290Q2hhbmdlc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgd2F0Y2hXaGVuQ3VzdG9tRWxlbWVudHNEZWZpbmVkKGZ1bmN0aW9uIChob3N0cykge1xyXG4gICAgICAgICAgICB2YXIgbmV3U3R5bGVzID0gW107XHJcbiAgICAgICAgICAgIGhvc3RzLmZvckVhY2goZnVuY3Rpb24gKGhvc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwdXNoKG5ld1N0eWxlcywgZ2V0TWFuYWdlYWJsZVN0eWxlcyhob3N0LnNoYWRvd1Jvb3QpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZSh7Y3JlYXRlZDogbmV3U3R5bGVzLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW10sIG1vdmVkOiBbXX0pO1xyXG4gICAgICAgICAgICBob3N0cy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93Um9vdCA9IGhvc3Quc2hhZG93Um9vdDtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVGb3JTaGFkb3dSb290Q2hhbmdlcyhob3N0KTtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFkb3dIb3N0cyhzaGFkb3dSb290LCBzdWJzY3JpYmVGb3JTaGFkb3dSb290Q2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0VW5kZWZpbmVkRWxlbWVudHMoc2hhZG93Um9vdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJfX2RhcmtyZWFkZXJfX2lzRGVmaW5lZFwiLCBoYW5kbGVJc0RlZmluZWQpO1xyXG4gICAgICAgIGNvbGxlY3RVbmRlZmluZWRFbGVtZW50cyhkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNldE9ic2VydmVycygpIHtcclxuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICByZXR1cm4gby5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZSgwLCBvYnNlcnZlcnMubGVuZ3RoKTtcclxuICAgICAgICBvYnNlcnZlZFJvb3RzID0gbmV3IFdlYWtTZXQoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclN0eWxlQ2hhbmdlcygpIHtcclxuICAgICAgICByZXNldE9ic2VydmVycygpO1xyXG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbURlZmluZUN1c3RvbUVsZW1lbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGV4aWZ5KG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiAobnVtYmVyIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVUlEKCkge1xyXG4gICAgICAgIGlmIChcInJhbmRvbVVVSURcIiBpbiBjcnlwdG8pIHtcclxuICAgICAgICAgICAgdmFyIHV1aWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgdXVpZC5zdWJzdHJpbmcoMCwgOCkgK1xyXG4gICAgICAgICAgICAgICAgdXVpZC5zdWJzdHJpbmcoOSwgMTMpICtcclxuICAgICAgICAgICAgICAgIHV1aWQuc3Vic3RyaW5nKDE0LCAxOCkgK1xyXG4gICAgICAgICAgICAgICAgdXVpZC5zdWJzdHJpbmcoMTksIDIzKSArXHJcbiAgICAgICAgICAgICAgICB1dWlkLnN1YnN0cmluZygyNClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4aWZ5KHgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbihcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWRvcHRlZFN0eWxlT3ZlcnJpZGVzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIHZhciBvdmVycmlkZUxpc3QgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRvcHRlZFN0eWxlU2hlZXRPdmVycmlkZShub2RlKSB7XHJcbiAgICAgICAgdmFyIGNhbmNlbEFzeW5jT3BlcmF0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgIGZ1bmN0aW9uIGluamVjdFNoZWV0KHNoZWV0LCBvdmVycmlkZSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3U2hlZXRzID0gX19zcHJlYWRBcnJheShcclxuICAgICAgICAgICAgICAgIFtdLFxyXG4gICAgICAgICAgICAgICAgX19yZWFkKG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzKSxcclxuICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBzaGVldEluZGV4ID0gbmV3U2hlZXRzLmluZGV4T2Yoc2hlZXQpO1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IG5ld1NoZWV0cy5pbmRleE9mKG92ZXJyaWRlKTtcclxuICAgICAgICAgICAgaWYgKHNoZWV0SW5kZXggPT09IGV4aXN0aW5nSW5kZXggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2hlZXRzLnNwbGljZShleGlzdGluZ0luZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdTaGVldHMuc3BsaWNlKHNoZWV0SW5kZXggKyAxLCAwLCBvdmVycmlkZSk7XHJcbiAgICAgICAgICAgIG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzID0gbmV3U2hlZXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICBjYW5jZWxBc3luY09wZXJhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgbmV3U2hlZXRzID0gX19zcHJlYWRBcnJheShcclxuICAgICAgICAgICAgICAgIFtdLFxyXG4gICAgICAgICAgICAgICAgX19yZWFkKG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzKSxcclxuICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKGFkb3B0ZWRTdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVMaXN0LmhhcyhhZG9wdGVkU3R5bGVTaGVldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IG5ld1NoZWV0cy5pbmRleE9mKGFkb3B0ZWRTdHlsZVNoZWV0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NoZWV0cy5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkb3B0ZWRTdHlsZU92ZXJyaWRlcy5kZWxldGUoYWRvcHRlZFN0eWxlU2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlTGlzdC5kZWxldGUoYWRvcHRlZFN0eWxlU2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBuZXdTaGVldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcih0aGVtZSwgaWdub3JlSW1hZ2VBbmFseXNpcykge1xyXG4gICAgICAgICAgICBub2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChzaGVldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlTGlzdC5oYXMoc2hlZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gc2hlZXQucnVsZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZU92ZXJyaWRlc1NoZWV0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvdmVycmlkZS5jc3NSdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZS5kZWxldGVSdWxlKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RTaGVldChzaGVldCwgb3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkb3B0ZWRTdHlsZU92ZXJyaWRlcy5zZXQoc2hlZXQsIG92ZXJyaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUxpc3QuYWRkKG92ZXJyaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hlZXRNb2RpZmllciA9IGNyZWF0ZVN0eWxlU2hlZXRNb2RpZmllcigpO1xyXG4gICAgICAgICAgICAgICAgc2hlZXRNb2RpZmllci5tb2RpZnlTaGVldCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVNoZWV0OiBwcmVwYXJlT3ZlcnJpZGVzU2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ1NTUnVsZXM6IHJ1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVJbWFnZUFuYWx5c2lzOiBpZ25vcmVJbWFnZUFuYWx5c2lzLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FzeW5jQ2FuY2VsbGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxBc3luY09wZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZW5kZXI6IHJlbmRlcixcclxuICAgICAgICAgICAgZGVzdHJveTogZGVzdHJveVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5qZWN0UHJveHkoZW5hYmxlU3R5bGVTaGVldHNQcm94eSkge1xyXG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcIl9fZGFya3JlYWRlcl9faW5saW5lU2NyaXB0c0FsbG93ZWRcIilcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBhZGRSdWxlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXHJcbiAgICAgICAgICAgIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLFxyXG4gICAgICAgICAgICBcImFkZFJ1bGVcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIGluc2VydFJ1bGVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcclxuICAgICAgICAgICAgQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgIFwiaW5zZXJ0UnVsZVwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgZGVsZXRlUnVsZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxyXG4gICAgICAgICAgICBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgXCJkZWxldGVSdWxlXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciByZW1vdmVSdWxlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXHJcbiAgICAgICAgICAgIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLFxyXG4gICAgICAgICAgICBcInJlbW92ZVJ1bGVcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIGRvY3VtZW50U3R5bGVTaGVldHNEZXNjcmlwdG9yID0gZW5hYmxlU3R5bGVTaGVldHNQcm94eVxyXG4gICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRG9jdW1lbnQucHJvdG90eXBlLCBcInN0eWxlU2hlZXRzXCIpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICB2YXIgc2hvdWxkV3JhcEhUTUxFbGVtZW50ID0gW1xyXG4gICAgICAgICAgICBcImJhaWR1LmNvbVwiLFxyXG4gICAgICAgICAgICBcImJhaWtlLmJhaWR1LmNvbVwiLFxyXG4gICAgICAgICAgICBcImRpdHUuYmFpZHUuY29tXCIsXHJcbiAgICAgICAgICAgIFwibWFwLmJhaWR1LmNvbVwiLFxyXG4gICAgICAgICAgICBcIm1hcHMuYmFpZHUuY29tXCIsXHJcbiAgICAgICAgICAgIFwiaGFva2FuLmJhaWR1LmNvbVwiLFxyXG4gICAgICAgICAgICBcInBhbi5iYWlkdS5jb21cIixcclxuICAgICAgICAgICAgXCJwYXNzcG9ydC5iYWlkdS5jb21cIixcclxuICAgICAgICAgICAgXCJ0aWViYS5iYWlkdS5jb21cIixcclxuICAgICAgICAgICAgXCJ3d3cuYmFpZHUuY29tXCJcclxuICAgICAgICBdLmluY2x1ZGVzKGxvY2F0aW9uLmhvc3RuYW1lKTtcclxuICAgICAgICB2YXIgZ2V0RWxlbWVudHNCeVRhZ05hbWVEZXNjcmlwdG9yID0gc2hvdWxkV3JhcEhUTUxFbGVtZW50XHJcbiAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcclxuICAgICAgICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAgICAgIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIlxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHZhciBjbGVhblVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgICAgICAgICAgICBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgICAgIFwiYWRkUnVsZVwiLFxyXG4gICAgICAgICAgICAgICAgYWRkUnVsZURlc2NyaXB0b3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICAgICAgQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAgICBcImluc2VydFJ1bGVcIixcclxuICAgICAgICAgICAgICAgIGluc2VydFJ1bGVEZXNjcmlwdG9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLFxyXG4gICAgICAgICAgICAgICAgXCJkZWxldGVSdWxlXCIsXHJcbiAgICAgICAgICAgICAgICBkZWxldGVSdWxlRGVzY3JpcHRvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgICAgICAgICAgICBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgICAgIFwicmVtb3ZlUnVsZVwiLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUnVsZURlc2NyaXB0b3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIl9fZGFya3JlYWRlcl9fY2xlYW5VcFwiLCBjbGVhblVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIFwiX19kYXJrcmVhZGVyX19hZGRVbmRlZmluZWRSZXNvbHZlclwiLFxyXG4gICAgICAgICAgICAgICAgYWRkVW5kZWZpbmVkUmVzb2x2ZXJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZVN0eWxlU2hlZXRzUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgICAgICBEb2N1bWVudC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHlsZVNoZWV0c1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50U3R5bGVTaGVldHNEZXNjcmlwdG9yXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRXcmFwSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWVEZXNjcmlwdG9yXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYWRkVW5kZWZpbmVkUmVzb2x2ZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChlLmRldGFpbC50YWcpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJfX2RhcmtyZWFkZXJfX2lzRGVmaW5lZFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDoge3RhZzogZS5kZXRhaWwudGFnfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJfX2RhcmtyZWFkZXJfX2NsZWFuVXBcIiwgY2xlYW5VcCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgXCJfX2RhcmtyZWFkZXJfX2FkZFVuZGVmaW5lZFJlc29sdmVyXCIsXHJcbiAgICAgICAgICAgIGFkZFVuZGVmaW5lZFJlc29sdmVyXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgdXBkYXRlU2hlZXRFdmVudCA9IG5ldyBFdmVudChcIl9fZGFya3JlYWRlcl9fdXBkYXRlU2hlZXRcIik7XHJcbiAgICAgICAgZnVuY3Rpb24gcHJveHlBZGRSdWxlKHNlbGVjdG9yLCBzdHlsZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgYWRkUnVsZURlc2NyaXB0b3IudmFsdWUuY2FsbCh0aGlzLCBzZWxlY3Rvciwgc3R5bGUsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lck5vZGUgJiZcclxuICAgICAgICAgICAgICAgICF0aGlzLm93bmVyTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrcmVhZGVyXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lck5vZGUuZGlzcGF0Y2hFdmVudCh1cGRhdGVTaGVldEV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHByb3h5SW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBpbnNlcnRSdWxlRGVzY3JpcHRvci52YWx1ZS5jYWxsKFxyXG4gICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgIHJ1bGUsXHJcbiAgICAgICAgICAgICAgICBpbmRleFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMub3duZXJOb2RlLmNsYXNzTGlzdC5jb250YWlucyhcImRhcmtyZWFkZXJcIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyTm9kZS5kaXNwYXRjaEV2ZW50KHVwZGF0ZVNoZWV0RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJveHlEZWxldGVSdWxlKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVEZXNjcmlwdG9yLnZhbHVlLmNhbGwodGhpcywgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMub3duZXJOb2RlLmNsYXNzTGlzdC5jb250YWlucyhcImRhcmtyZWFkZXJcIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyTm9kZS5kaXNwYXRjaEV2ZW50KHVwZGF0ZVNoZWV0RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHByb3h5UmVtb3ZlUnVsZShpbmRleCkge1xyXG4gICAgICAgICAgICByZW1vdmVSdWxlRGVzY3JpcHRvci52YWx1ZS5jYWxsKHRoaXMsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lck5vZGUgJiZcclxuICAgICAgICAgICAgICAgICF0aGlzLm93bmVyTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrcmVhZGVyXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lck5vZGUuZGlzcGF0Y2hFdmVudCh1cGRhdGVTaGVldEV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwcm94eURvY3VtZW50U3R5bGVTaGVldHMoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBnZXRDdXJyZW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9jU2hlZXRzID0gZG9jdW1lbnRTdHlsZVNoZWV0c0Rlc2NyaXB0b3IuZ2V0LmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkU2hlZXRzID0gX19zcHJlYWRBcnJheShcclxuICAgICAgICAgICAgICAgICAgICBbXSxcclxuICAgICAgICAgICAgICAgICAgICBfX3JlYWQoZG9jU2hlZXRzKSxcclxuICAgICAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICAgICAgKS5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXN0eWxlU2hlZXQub3duZXJOb2RlLmNsYXNzTGlzdC5jb250YWlucyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXJrcmVhZGVyXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFNoZWV0cy5pdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTaGVldHNbaXRlbV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFNoZWV0cyxcclxuICAgICAgICAgICAgICAgICAgICBTdHlsZVNoZWV0TGlzdC5wcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGdldEN1cnJlbnRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVTaGVldExpc3RCZWhhdmlvciA9IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF8sIHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRWYWx1ZSgpW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZWxlbWVudHMgPSBuZXcgUHJveHkoZWxlbWVudHMsIHN0eWxlU2hlZXRMaXN0QmVoYXZpb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHByb3h5R2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSAhPT0gXCJzdHlsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVRhZ05hbWVEZXNjcmlwdG9yLnZhbHVlLmNhbGwodGhpcywgdGFnTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdldEN1cnJlbnRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBnZXRFbGVtZW50c0J5VGFnTmFtZURlc2NyaXB0b3IudmFsdWUuY2FsbChcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihcclxuICAgICAgICAgICAgICAgICAgICBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZWxlbWVudHMpLCBmYWxzZSkuZmlsdGVyKGZ1bmN0aW9uIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGFya3JlYWRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBOb2RlTGlzdC5wcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGdldEN1cnJlbnRFbGVtZW50VmFsdWUoKTtcclxuICAgICAgICAgICAgdmFyIG5vZGVMaXN0QmVoYXZpb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDdXJyZW50RWxlbWVudFZhbHVlKClbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcihwcm9wZXJ0eSkgfHwgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlbGVtZW50cyA9IG5ldyBQcm94eShlbGVtZW50cywgbm9kZUxpc3RCZWhhdmlvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgXCJhZGRSdWxlXCIsXHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGFkZFJ1bGVEZXNjcmlwdG9yLCB7dmFsdWU6IHByb3h5QWRkUnVsZX0pXHJcbiAgICAgICAgKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgICAgICAgIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLFxyXG4gICAgICAgICAgICBcImluc2VydFJ1bGVcIixcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgaW5zZXJ0UnVsZURlc2NyaXB0b3IsIHt2YWx1ZTogcHJveHlJbnNlcnRSdWxlfSlcclxuICAgICAgICApO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgIFwiZGVsZXRlUnVsZVwiLFxyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBkZWxldGVSdWxlRGVzY3JpcHRvciwge3ZhbHVlOiBwcm94eURlbGV0ZVJ1bGV9KVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgXCJyZW1vdmVSdWxlXCIsXHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHJlbW92ZVJ1bGVEZXNjcmlwdG9yLCB7dmFsdWU6IHByb3h5UmVtb3ZlUnVsZX0pXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoZW5hYmxlU3R5bGVTaGVldHNQcm94eSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXHJcbiAgICAgICAgICAgICAgICBEb2N1bWVudC5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAgICBcInN0eWxlU2hlZXRzXCIsXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBkb2N1bWVudFN0eWxlU2hlZXRzRGVzY3JpcHRvciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldDogcHJveHlEb2N1bWVudFN0eWxlU2hlZXRzXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkV3JhcEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLFxyXG4gICAgICAgICAgICAgICAgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZ2V0RWxlbWVudHNCeVRhZ05hbWVEZXNjcmlwdG9yLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3h5R2V0RWxlbWVudHNCeVRhZ05hbWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBJTlNUQU5DRV9JRCA9IGdlbmVyYXRlVUlEKCk7XHJcbiAgICB2YXIgc3R5bGVNYW5hZ2VycyA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBhZG9wdGVkU3R5bGVNYW5hZ2VycyA9IFtdO1xyXG4gICAgdmFyIGZpbHRlciA9IG51bGw7XHJcbiAgICB2YXIgZml4ZXMgPSBudWxsO1xyXG4gICAgdmFyIGlzSUZyYW1lJDEgPSBudWxsO1xyXG4gICAgdmFyIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzID0gbnVsbDtcclxuICAgIHZhciBpZ25vcmVkSW5saW5lU2VsZWN0b3JzID0gbnVsbDtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlU3R5bGUoY2xhc3NOYW1lLCByb290KSB7XHJcbiAgICAgICAgaWYgKHJvb3QgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByb290ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KGNsYXNzTmFtZSkpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkYXJrcmVhZGVyXCIpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgZWxlbWVudC5tZWRpYSA9IFwic2NyZWVuXCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlU2NyaXB0KGNsYXNzTmFtZSwgcm9vdCkge1xyXG4gICAgICAgIGlmIChyb290ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcm9vdCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChjbGFzc05hbWUpKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRhcmtyZWFkZXJcIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIHZhciBub2RlUG9zaXRpb25XYXRjaGVycyA9IG5ldyBNYXAoKTtcclxuICAgIGZ1bmN0aW9uIHNldHVwTm9kZVBvc2l0aW9uV2F0Y2hlcihub2RlLCBhbGlhcykge1xyXG4gICAgICAgIG5vZGVQb3NpdGlvbldhdGNoZXJzLmhhcyhhbGlhcykgJiZcclxuICAgICAgICAgICAgbm9kZVBvc2l0aW9uV2F0Y2hlcnMuZ2V0KGFsaWFzKS5zdG9wKCk7XHJcbiAgICAgICAgbm9kZVBvc2l0aW9uV2F0Y2hlcnMuc2V0KGFsaWFzLCB3YXRjaEZvck5vZGVQb3NpdGlvbihub2RlLCBcInBhcmVudFwiKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdG9wU3R5bGVQb3NpdGlvbldhdGNoZXJzKCkge1xyXG4gICAgICAgIGZvckVhY2gobm9kZVBvc2l0aW9uV2F0Y2hlcnMudmFsdWVzKCksIGZ1bmN0aW9uICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3YXRjaGVyLnN0b3AoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBub2RlUG9zaXRpb25XYXRjaGVycy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU3RhdGljU3R5bGVPdmVycmlkZXMoKSB7XHJcbiAgICAgICAgdmFyIGZhbGxiYWNrU3R5bGUgPSBjcmVhdGVPclVwZGF0ZVN0eWxlKFxyXG4gICAgICAgICAgICBcImRhcmtyZWFkZXItLWZhbGxiYWNrXCIsXHJcbiAgICAgICAgICAgIGRvY3VtZW50XHJcbiAgICAgICAgKTtcclxuICAgICAgICBmYWxsYmFja1N0eWxlLnRleHRDb250ZW50ID0gZ2V0TW9kaWZpZWRGYWxsYmFja1N0eWxlKGZpbHRlciwge1xyXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShmYWxsYmFja1N0eWxlLCBkb2N1bWVudC5oZWFkLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIHNldHVwTm9kZVBvc2l0aW9uV2F0Y2hlcihmYWxsYmFja1N0eWxlLCBcImZhbGxiYWNrXCIpO1xyXG4gICAgICAgIHZhciB1c2VyQWdlbnRTdHlsZSA9IGNyZWF0ZU9yVXBkYXRlU3R5bGUoXCJkYXJrcmVhZGVyLS11c2VyLWFnZW50XCIpO1xyXG4gICAgICAgIHVzZXJBZ2VudFN0eWxlLnRleHRDb250ZW50ID0gZ2V0TW9kaWZpZWRVc2VyQWdlbnRTdHlsZShcclxuICAgICAgICAgICAgZmlsdGVyLFxyXG4gICAgICAgICAgICBpc0lGcmFtZSQxLFxyXG4gICAgICAgICAgICBmaWx0ZXIuc3R5bGVTeXN0ZW1Db250cm9sc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUodXNlckFnZW50U3R5bGUsIGZhbGxiYWNrU3R5bGUubmV4dFNpYmxpbmcpO1xyXG4gICAgICAgIHNldHVwTm9kZVBvc2l0aW9uV2F0Y2hlcih1c2VyQWdlbnRTdHlsZSwgXCJ1c2VyLWFnZW50XCIpO1xyXG4gICAgICAgIHZhciB0ZXh0U3R5bGUgPSBjcmVhdGVPclVwZGF0ZVN0eWxlKFwiZGFya3JlYWRlci0tdGV4dFwiKTtcclxuICAgICAgICBpZiAoZmlsdGVyLnVzZUZvbnQgfHwgZmlsdGVyLnRleHRTdHJva2UgPiAwKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS50ZXh0Q29udGVudCA9IGNyZWF0ZVRleHRTdHlsZShmaWx0ZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKHRleHRTdHlsZSwgZmFsbGJhY2tTdHlsZS5uZXh0U2libGluZyk7XHJcbiAgICAgICAgc2V0dXBOb2RlUG9zaXRpb25XYXRjaGVyKHRleHRTdHlsZSwgXCJ0ZXh0XCIpO1xyXG4gICAgICAgIHZhciBpbnZlcnRTdHlsZSA9IGNyZWF0ZU9yVXBkYXRlU3R5bGUoXCJkYXJrcmVhZGVyLS1pbnZlcnRcIik7XHJcbiAgICAgICAgaWYgKGZpeGVzICYmIEFycmF5LmlzQXJyYXkoZml4ZXMuaW52ZXJ0KSAmJiBmaXhlcy5pbnZlcnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpbnZlcnRTdHlsZS50ZXh0Q29udGVudCA9IFtcclxuICAgICAgICAgICAgICAgIFwiXCIuY29uY2F0KGZpeGVzLmludmVydC5qb2luKFwiLCBcIiksIFwiIHtcIiksXHJcbiAgICAgICAgICAgICAgICBcIiAgICBmaWx0ZXI6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgICAgICBnZXRDU1NGaWx0ZXJWYWx1ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlciksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYXN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5tb2RlID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmlsdGVyLmNvbnRyYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2xhbXAoZmlsdGVyLmNvbnRyYXN0IC0gMTAsIDAsIDEwMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiICFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBcIn1cIlxyXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW52ZXJ0U3R5bGUudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShpbnZlcnRTdHlsZSwgdGV4dFN0eWxlLm5leHRTaWJsaW5nKTtcclxuICAgICAgICBzZXR1cE5vZGVQb3NpdGlvbldhdGNoZXIoaW52ZXJ0U3R5bGUsIFwiaW52ZXJ0XCIpO1xyXG4gICAgICAgIHZhciBpbmxpbmVTdHlsZSA9IGNyZWF0ZU9yVXBkYXRlU3R5bGUoXCJkYXJrcmVhZGVyLS1pbmxpbmVcIik7XHJcbiAgICAgICAgaW5saW5lU3R5bGUudGV4dENvbnRlbnQgPSBnZXRJbmxpbmVPdmVycmlkZVN0eWxlKCk7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoaW5saW5lU3R5bGUsIGludmVydFN0eWxlLm5leHRTaWJsaW5nKTtcclxuICAgICAgICBzZXR1cE5vZGVQb3NpdGlvbldhdGNoZXIoaW5saW5lU3R5bGUsIFwiaW5saW5lXCIpO1xyXG4gICAgICAgIHZhciBvdmVycmlkZVN0eWxlID0gY3JlYXRlT3JVcGRhdGVTdHlsZShcImRhcmtyZWFkZXItLW92ZXJyaWRlXCIpO1xyXG4gICAgICAgIG92ZXJyaWRlU3R5bGUudGV4dENvbnRlbnQgPVxyXG4gICAgICAgICAgICBmaXhlcyAmJiBmaXhlcy5jc3MgPyByZXBsYWNlQ1NTVGVtcGxhdGVzKGZpeGVzLmNzcykgOiBcIlwiO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQob3ZlcnJpZGVTdHlsZSk7XHJcbiAgICAgICAgc2V0dXBOb2RlUG9zaXRpb25XYXRjaGVyKG92ZXJyaWRlU3R5bGUsIFwib3ZlcnJpZGVcIik7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlU3R5bGUgPSBjcmVhdGVPclVwZGF0ZVN0eWxlKFwiZGFya3JlYWRlci0tdmFyaWFibGVzXCIpO1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb25Db2xvcnMgPSBnZXRTZWxlY3Rpb25Db2xvcihmaWx0ZXIpO1xyXG4gICAgICAgIHZhciBkYXJrU2NoZW1lQmFja2dyb3VuZENvbG9yID0gZmlsdGVyLmRhcmtTY2hlbWVCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGRhcmtTY2hlbWVUZXh0Q29sb3IgPSBmaWx0ZXIuZGFya1NjaGVtZVRleHRDb2xvcixcclxuICAgICAgICAgICAgbGlnaHRTY2hlbWVCYWNrZ3JvdW5kQ29sb3IgPSBmaWx0ZXIubGlnaHRTY2hlbWVCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGxpZ2h0U2NoZW1lVGV4dENvbG9yID0gZmlsdGVyLmxpZ2h0U2NoZW1lVGV4dENvbG9yLFxyXG4gICAgICAgICAgICBtb2RlID0gZmlsdGVyLm1vZGU7XHJcbiAgICAgICAgdmFyIHNjaGVtZUJhY2tncm91bmRDb2xvciA9XHJcbiAgICAgICAgICAgIG1vZGUgPT09IDAgPyBsaWdodFNjaGVtZUJhY2tncm91bmRDb2xvciA6IGRhcmtTY2hlbWVCYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdmFyIHNjaGVtZVRleHRDb2xvciA9XHJcbiAgICAgICAgICAgIG1vZGUgPT09IDAgPyBsaWdodFNjaGVtZVRleHRDb2xvciA6IGRhcmtTY2hlbWVUZXh0Q29sb3I7XHJcbiAgICAgICAgc2NoZW1lQmFja2dyb3VuZENvbG9yID0gbW9kaWZ5QmFja2dyb3VuZENvbG9yKFxyXG4gICAgICAgICAgICBwYXJzZUNvbG9yV2l0aENhY2hlKHNjaGVtZUJhY2tncm91bmRDb2xvciksXHJcbiAgICAgICAgICAgIGZpbHRlclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2NoZW1lVGV4dENvbG9yID0gbW9kaWZ5Rm9yZWdyb3VuZENvbG9yKFxyXG4gICAgICAgICAgICBwYXJzZUNvbG9yV2l0aENhY2hlKHNjaGVtZVRleHRDb2xvciksXHJcbiAgICAgICAgICAgIGZpbHRlclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyaWFibGVTdHlsZS50ZXh0Q29udGVudCA9IFtcclxuICAgICAgICAgICAgXCI6cm9vdCB7XCIsXHJcbiAgICAgICAgICAgIFwiICAgLS1kYXJrcmVhZGVyLW5ldXRyYWwtYmFja2dyb3VuZDogXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgc2NoZW1lQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgXCI7XCJcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgXCIgICAtLWRhcmtyZWFkZXItbmV1dHJhbC10ZXh0OiBcIi5jb25jYXQoc2NoZW1lVGV4dENvbG9yLCBcIjtcIiksXHJcbiAgICAgICAgICAgIFwiICAgLS1kYXJrcmVhZGVyLXNlbGVjdGlvbi1iYWNrZ3JvdW5kOiBcIi5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Db2xvcnMuYmFja2dyb3VuZENvbG9yU2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgXCI7XCJcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgXCIgICAtLWRhcmtyZWFkZXItc2VsZWN0aW9uLXRleHQ6IFwiLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkNvbG9ycy5mb3JlZ3JvdW5kQ29sb3JTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBcIjtcIlxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBcIn1cIlxyXG4gICAgICAgIF0uam9pbihcIlxcblwiKTtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSh2YXJpYWJsZVN0eWxlLCBpbmxpbmVTdHlsZS5uZXh0U2libGluZyk7XHJcbiAgICAgICAgc2V0dXBOb2RlUG9zaXRpb25XYXRjaGVyKHZhcmlhYmxlU3R5bGUsIFwidmFyaWFibGVzXCIpO1xyXG4gICAgICAgIHZhciByb290VmFyc1N0eWxlID0gY3JlYXRlT3JVcGRhdGVTdHlsZShcImRhcmtyZWFkZXItLXJvb3QtdmFyc1wiKTtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShyb290VmFyc1N0eWxlLCB2YXJpYWJsZVN0eWxlLm5leHRTaWJsaW5nKTtcclxuICAgICAgICB2YXIgaW5qZWN0UHJveHlBcmcgPSAhKGZpeGVzICYmIGZpeGVzLmRpc2FibGVTdHlsZVNoZWV0c1Byb3h5KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwcm94eVNjcmlwdCA9IGNyZWF0ZU9yVXBkYXRlU2NyaXB0KFwiZGFya3JlYWRlci0tcHJveHlcIik7XHJcbiAgICAgICAgICAgIHByb3h5U2NyaXB0LmFwcGVuZChcclxuICAgICAgICAgICAgICAgIFwiKFwiLmNvbmNhdChpbmplY3RQcm94eSwgXCIpKFwiKS5jb25jYXQoaW5qZWN0UHJveHlBcmcsIFwiKVwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShwcm94eVNjcmlwdCwgcm9vdFZhcnNTdHlsZS5uZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIHByb3h5U2NyaXB0LnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBzaGFkb3dSb290c1dpdGhPdmVycmlkZXMgPSBuZXcgU2V0KCk7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaGFkb3dTdGF0aWNTdHlsZU92ZXJyaWRlcyhyb290KSB7XHJcbiAgICAgICAgdmFyIGlubGluZVN0eWxlID0gY3JlYXRlT3JVcGRhdGVTdHlsZShcImRhcmtyZWFkZXItLWlubGluZVwiLCByb290KTtcclxuICAgICAgICBpbmxpbmVTdHlsZS50ZXh0Q29udGVudCA9IGdldElubGluZU92ZXJyaWRlU3R5bGUoKTtcclxuICAgICAgICByb290Lmluc2VydEJlZm9yZShpbmxpbmVTdHlsZSwgcm9vdC5maXJzdENoaWxkKTtcclxuICAgICAgICB2YXIgb3ZlcnJpZGVTdHlsZSA9IGNyZWF0ZU9yVXBkYXRlU3R5bGUoXCJkYXJrcmVhZGVyLS1vdmVycmlkZVwiLCByb290KTtcclxuICAgICAgICBvdmVycmlkZVN0eWxlLnRleHRDb250ZW50ID1cclxuICAgICAgICAgICAgZml4ZXMgJiYgZml4ZXMuY3NzID8gcmVwbGFjZUNTU1RlbXBsYXRlcyhmaXhlcy5jc3MpIDogXCJcIjtcclxuICAgICAgICByb290Lmluc2VydEJlZm9yZShvdmVycmlkZVN0eWxlLCBpbmxpbmVTdHlsZS5uZXh0U2libGluZyk7XHJcbiAgICAgICAgdmFyIGludmVydFN0eWxlID0gY3JlYXRlT3JVcGRhdGVTdHlsZShcImRhcmtyZWFkZXItLWludmVydFwiLCByb290KTtcclxuICAgICAgICBpZiAoZml4ZXMgJiYgQXJyYXkuaXNBcnJheShmaXhlcy5pbnZlcnQpICYmIGZpeGVzLmludmVydC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGludmVydFN0eWxlLnRleHRDb250ZW50ID0gW1xyXG4gICAgICAgICAgICAgICAgXCJcIi5jb25jYXQoZml4ZXMuaW52ZXJ0LmpvaW4oXCIsIFwiKSwgXCIge1wiKSxcclxuICAgICAgICAgICAgICAgIFwiICAgIGZpbHRlcjogXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgIGdldENTU0ZpbHRlclZhbHVlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmlsdGVyKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm1vZGUgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWx0ZXIuY29udHJhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjbGFtcChmaWx0ZXIuY29udHJhc3QgLSAxMCwgMCwgMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgIWltcG9ydGFudDtcIlxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIFwifVwiXHJcbiAgICAgICAgICAgIF0uam9pbihcIlxcblwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnZlcnRTdHlsZS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKGludmVydFN0eWxlLCBvdmVycmlkZVN0eWxlLm5leHRTaWJsaW5nKTtcclxuICAgICAgICBzaGFkb3dSb290c1dpdGhPdmVycmlkZXMuYWRkKHJvb3QpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNTU1RlbXBsYXRlcygkY3NzVGV4dCkge1xyXG4gICAgICAgIHJldHVybiAkY3NzVGV4dC5yZXBsYWNlKC9cXCR7KC4rPyl9L2csIGZ1bmN0aW9uIChfLCAkY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gcGFyc2VDb2xvcldpdGhDYWNoZSgkY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb2RpZnlDb2xvcihjb2xvciwgZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJGNvbG9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYW5GYWxsYmFja1N0eWxlKCkge1xyXG4gICAgICAgIHZhciBmYWxsYmFjayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZGFya3JlYWRlci0tZmFsbGJhY2tcIik7XHJcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrLnRleHRDb250ZW50ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEeW5hbWljU3R5bGVPdmVycmlkZXMoKSB7XHJcbiAgICAgICAgY2FuY2VsUmVuZGVyaW5nKCk7XHJcbiAgICAgICAgdmFyIGFsbFN0eWxlcyA9IGdldE1hbmFnZWFibGVTdHlsZXMoZG9jdW1lbnQpO1xyXG4gICAgICAgIHZhciBuZXdNYW5hZ2VycyA9IGFsbFN0eWxlc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFzdHlsZU1hbmFnZXJzLmhhcyhzdHlsZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTWFuYWdlcihzdHlsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIG5ld01hbmFnZXJzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLmRldGFpbHMoe3NlY29uZFJvdW5kOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkZXRhaWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXRhaWwgJiYgZGV0YWlsLnJ1bGVzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWwpIHtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlc1N0b3JlLmFkZFJ1bGVzRm9yTWF0Y2hpbmcoZGV0YWlsLnJ1bGVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyaWFibGVzU3RvcmUubWF0Y2hWYXJpYWJsZXNBbmREZXBlbmRhbnRzKCk7XHJcbiAgICAgICAgdmFyaWFibGVzU3RvcmUuc2V0T25Sb290VmFyaWFibGVDaGFuZ2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXJpYWJsZXNTdG9yZS5wdXRSb290VmFycyhcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcihcIi5kYXJrcmVhZGVyLS1yb290LXZhcnNcIiksXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXJpYWJsZXNTdG9yZS5wdXRSb290VmFycyhcclxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLXJvb3QtdmFyc1wiKSxcclxuICAgICAgICAgICAgZmlsdGVyXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzdHlsZU1hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIucmVuZGVyKGZpbHRlciwgaWdub3JlZEltYWdlQW5hbHlzaXNTZWxlY3RvcnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChsb2FkaW5nU3R5bGVzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgY2xlYW5GYWxsYmFja1N0eWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld01hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIud2F0Y2goKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaW5saW5lU3R5bGVFbGVtZW50cyA9IHRvQXJyYXkoXHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoSU5MSU5FX1NUWUxFX1NFTEVDVE9SKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaXRlcmF0ZVNoYWRvd0hvc3RzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKGhvc3QpIHtcclxuICAgICAgICAgICAgY3JlYXRlU2hhZG93U3RhdGljU3R5bGVPdmVycmlkZXMoaG9zdC5zaGFkb3dSb290KTtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gaG9zdC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoXHJcbiAgICAgICAgICAgICAgICBJTkxJTkVfU1RZTEVfU0VMRUNUT1JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHB1c2goaW5saW5lU3R5bGVFbGVtZW50cywgZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW5saW5lU3R5bGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVJbmxpbmVTdHlsZShcclxuICAgICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlZElubGluZVNlbGVjdG9ycyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaGFuZGxlQWRvcHRlZFN0eWxlU2hlZXRzKGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIHZhciBsb2FkaW5nU3R5bGVzQ291bnRlciA9IDA7XHJcbiAgICB2YXIgbG9hZGluZ1N0eWxlcyA9IG5ldyBTZXQoKTtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hbmFnZXIoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBsb2FkaW5nU3R5bGVJZCA9ICsrbG9hZGluZ1N0eWxlc0NvdW50ZXI7XHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZGluZ1N0YXJ0KCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzRE9NUmVhZHkoKSB8fCAhZGlkRG9jdW1lbnRTaG93VXApIHtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdHlsZXMuYWRkKGxvYWRpbmdTdHlsZUlkKTtcclxuICAgICAgICAgICAgICAgIGxvZ0luZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJDdXJyZW50IGFtb3VudCBvZiBzdHlsZXMgbG9hZGluZzogXCIuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nU3R5bGVzLnNpemVcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrU3R5bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiLmRhcmtyZWFkZXItLWZhbGxiYWNrXCJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZhbGxiYWNrU3R5bGUudGV4dENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1N0eWxlLnRleHRDb250ZW50ID0gZ2V0TW9kaWZpZWRGYWxsYmFja1N0eWxlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpY3Q6IGZhbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZGluZ0VuZCgpIHtcclxuICAgICAgICAgICAgbG9hZGluZ1N0eWxlcy5kZWxldGUobG9hZGluZ1N0eWxlSWQpO1xyXG4gICAgICAgICAgICBsb2dJbmZvKFxyXG4gICAgICAgICAgICAgICAgXCJSZW1vdmVkIGxvYWRpbmdTdHlsZSBcIlxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQobG9hZGluZ1N0eWxlSWQsIFwiLCBub3cgYXdhaXRpbmc6IFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQobG9hZGluZ1N0eWxlcy5zaXplKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAobG9hZGluZ1N0eWxlcy5zaXplID09PSAwICYmIGlzRE9NUmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2xlYW5GYWxsYmFja1N0eWxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgICAgICAgICB2YXIgZGV0YWlscyA9IG1hbmFnZXIuZGV0YWlscyh7c2Vjb25kUm91bmQ6IHRydWV9KTtcclxuICAgICAgICAgICAgaWYgKCFkZXRhaWxzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyaWFibGVzU3RvcmUuYWRkUnVsZXNGb3JNYXRjaGluZyhkZXRhaWxzLnJ1bGVzKTtcclxuICAgICAgICAgICAgdmFyaWFibGVzU3RvcmUubWF0Y2hWYXJpYWJsZXNBbmREZXBlbmRhbnRzKCk7XHJcbiAgICAgICAgICAgIG1hbmFnZXIucmVuZGVyKGZpbHRlciwgaWdub3JlZEltYWdlQW5hbHlzaXNTZWxlY3RvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFuYWdlciA9IG1hbmFnZVN0eWxlKGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGUsXHJcbiAgICAgICAgICAgIGxvYWRpbmdTdGFydDogbG9hZGluZ1N0YXJ0LFxyXG4gICAgICAgICAgICBsb2FkaW5nRW5kOiBsb2FkaW5nRW5kXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3R5bGVNYW5hZ2Vycy5zZXQoZWxlbWVudCwgbWFuYWdlcik7XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVNYW5hZ2VyKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgbWFuYWdlciA9IHN0eWxlTWFuYWdlcnMuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBzdHlsZU1hbmFnZXJzLmRlbGV0ZShlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgdGhyb3R0bGVkUmVuZGVyQWxsU3R5bGVzID0gdGhyb3R0bGUoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgc3R5bGVNYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLnJlbmRlcihmaWx0ZXIsIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhZG9wdGVkU3R5bGVNYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLnJlbmRlcihmaWx0ZXIsIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgY2FuY2VsUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm90dGxlZFJlbmRlckFsbFN0eWxlcy5jYW5jZWwoKTtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBvbkRPTVJlYWR5KCkge1xyXG4gICAgICAgIGlmIChsb2FkaW5nU3R5bGVzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgY2xlYW5GYWxsYmFja1N0eWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgZG9jdW1lbnRWaXNpYmlsaXR5TGlzdGVuZXIgPSBudWxsO1xyXG4gICAgdmFyIGRpZERvY3VtZW50U2hvd1VwID0gIWRvY3VtZW50LmhpZGRlbjtcclxuICAgIGZ1bmN0aW9uIHdhdGNoRm9yRG9jdW1lbnRWaXNpYmlsaXR5KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGFscmVhZHlXYXRjaGluZyA9IEJvb2xlYW4oZG9jdW1lbnRWaXNpYmlsaXR5TGlzdGVuZXIpO1xyXG4gICAgICAgIGRvY3VtZW50VmlzaWJpbGl0eUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgc3RvcFdhdGNoaW5nRm9yRG9jdW1lbnRWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgZGlkRG9jdW1lbnRTaG93VXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFscmVhZHlXYXRjaGluZykge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudFZpc2liaWxpdHlMaXN0ZW5lclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckRvY3VtZW50VmlzaWJpbGl0eSgpIHtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICBcInZpc2liaWxpdHljaGFuZ2VcIixcclxuICAgICAgICAgICAgZG9jdW1lbnRWaXNpYmlsaXR5TGlzdGVuZXJcclxuICAgICAgICApO1xyXG4gICAgICAgIGRvY3VtZW50VmlzaWJpbGl0eUxpc3RlbmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRoZW1lQW5kV2F0Y2hGb3JVcGRhdGVzKCkge1xyXG4gICAgICAgIGNyZWF0ZVN0YXRpY1N0eWxlT3ZlcnJpZGVzKCk7XHJcbiAgICAgICAgZnVuY3Rpb24gcnVuRHluYW1pY1N0eWxlKCkge1xyXG4gICAgICAgICAgICBjcmVhdGVEeW5hbWljU3R5bGVPdmVycmlkZXMoKTtcclxuICAgICAgICAgICAgd2F0Y2hGb3JVcGRhdGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gJiYgIWZpbHRlci5pbW1lZGlhdGVNb2RpZnkpIHtcclxuICAgICAgICAgICAgd2F0Y2hGb3JEb2N1bWVudFZpc2liaWxpdHkocnVuRHluYW1pY1N0eWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBydW5EeW5hbWljU3R5bGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhbmdlTWV0YVRoZW1lQ29sb3JXaGVuQXZhaWxhYmxlKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVBZG9wdGVkU3R5bGVTaGVldHMobm9kZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TWFuZ2VyID0gY3JlYXRlQWRvcHRlZFN0eWxlU2hlZXRPdmVycmlkZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZG9wdGVkU3R5bGVNYW5hZ2Vycy5wdXNoKG5ld01hbmdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TWFuZ2VyLnJlbmRlcihmaWx0ZXIsIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdhdGNoRm9yVXBkYXRlcygpIHtcclxuICAgICAgICB2YXIgbWFuYWdlZFN0eWxlcyA9IEFycmF5LmZyb20oc3R5bGVNYW5hZ2Vycy5rZXlzKCkpO1xyXG4gICAgICAgIHdhdGNoRm9yU3R5bGVDaGFuZ2VzKFxyXG4gICAgICAgICAgICBtYW5hZ2VkU3R5bGVzLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVkID0gX2EuY3JlYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gX2EudXBkYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IF9hLm1vdmVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlc1RvUmVtb3ZlID0gcmVtb3ZlZDtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXNUb01hbmFnZSA9IGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHVwZGF0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtb3ZlZClcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXN0eWxlTWFuYWdlcnMuaGFzKHN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXNUb1Jlc3RvcmUgPSBtb3ZlZC5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlTWFuYWdlcnMuaGFzKHN0eWxlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTWFuYWdlcihzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdNYW5hZ2VycyA9IHN0eWxlc1RvTWFuYWdlLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTWFuYWdlcihzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG5ld01hbmFnZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5kZXRhaWxzKHtzZWNvbmRSb3VuZDogZmFsc2V9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRldGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWlsICYmIGRldGFpbC5ydWxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNTdG9yZS5hZGRSdWxlc0Zvck1hdGNoaW5nKGRldGFpbC5ydWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXNTdG9yZS5tYXRjaFZhcmlhYmxlc0FuZERlcGVuZGFudHMoKTtcclxuICAgICAgICAgICAgICAgIG5ld01hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5yZW5kZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZEltYWdlQW5hbHlzaXNTZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBuZXdNYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIud2F0Y2goKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzVG9SZXN0b3JlLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlTWFuYWdlcnMuZ2V0KHN0eWxlKS5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVNoYWRvd1N0YXRpY1N0eWxlT3ZlcnJpZGVzKHNoYWRvd1Jvb3QpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlQWRvcHRlZFN0eWxlU2hlZXRzKHNoYWRvd1Jvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICB3YXRjaEZvcklubGluZVN0eWxlcyhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlSW5saW5lU3R5bGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZElubGluZVNlbGVjdG9ycyxcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkSW1hZ2VBbmFseXNpc1NlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZUF0dHIuaW5jbHVkZXMoXCItLVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNTdG9yZS5tYXRjaFZhcmlhYmxlc0FuZERlcGVuZGFudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzU3RvcmUucHV0Um9vdFZhcnMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuZGFya3JlYWRlci0tcm9vdC12YXJzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVTaGFkb3dTdGF0aWNTdHlsZU92ZXJyaWRlcyhyb290KTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmxpbmVTdHlsZUVsZW1lbnRzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgICAgICAgICAgICAgICAgIElOTElORV9TVFlMRV9TRUxFQ1RPUlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmxpbmVTdHlsZUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGlubGluZVN0eWxlRWxlbWVudHMsIGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVJbmxpbmVTdHlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZElubGluZVNlbGVjdG9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGFkZERPTVJlYWR5TGlzdGVuZXIob25ET01SZWFkeSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JVcGRhdGVzKCkge1xyXG4gICAgICAgIHN0eWxlTWFuYWdlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlci5wYXVzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0b3BTdHlsZVBvc2l0aW9uV2F0Y2hlcnMoKTtcclxuICAgICAgICBzdG9wV2F0Y2hpbmdGb3JTdHlsZUNoYW5nZXMoKTtcclxuICAgICAgICBzdG9wV2F0Y2hpbmdGb3JJbmxpbmVTdHlsZXMoKTtcclxuICAgICAgICByZW1vdmVET01SZWFkeUxpc3RlbmVyKG9uRE9NUmVhZHkpO1xyXG4gICAgICAgIGNsZWFuUmVhZHlTdGF0ZUNvbXBsZXRlTGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgbWV0YU9ic2VydmVyO1xyXG4gICAgZnVuY3Rpb24gYWRkTWV0YUxpc3RlbmVyKCkge1xyXG4gICAgICAgIG1ldGFPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImRhcmtyZWFkZXItbG9ja1wiXScpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRHluYW1pY1RoZW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBtZXRhT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXJrUmVhZGVySW5zdGFuY2VNYXJrZXIoKSB7XHJcbiAgICAgICAgdmFyIG1ldGFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIik7XHJcbiAgICAgICAgbWV0YUVsZW1lbnQubmFtZSA9IFwiZGFya3JlYWRlclwiO1xyXG4gICAgICAgIG1ldGFFbGVtZW50LmNvbnRlbnQgPSBJTlNUQU5DRV9JRDtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG1ldGFFbGVtZW50KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQW5vdGhlckRhcmtSZWFkZXJJbnN0YW5jZUFjdGl2ZSgpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiZGFya3JlYWRlci1sb2NrXCJdJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiZGFya3JlYWRlclwiXScpO1xyXG4gICAgICAgIGlmIChtZXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmNvbnRlbnQgIT09IElOU1RBTkNFX0lEKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNyZWF0ZURhcmtSZWFkZXJJbnN0YW5jZU1hcmtlcigpO1xyXG4gICAgICAgIGFkZE1ldGFMaXN0ZW5lcigpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRHluYW1pY1RoZW1lKFxyXG4gICAgICAgIGZpbHRlckNvbmZpZyxcclxuICAgICAgICBkeW5hbWljVGhlbWVGaXhlcyxcclxuICAgICAgICBpZnJhbWVcclxuICAgICkge1xyXG4gICAgICAgIGZpbHRlciA9IGZpbHRlckNvbmZpZztcclxuICAgICAgICBmaXhlcyA9IGR5bmFtaWNUaGVtZUZpeGVzO1xyXG4gICAgICAgIGlmIChmaXhlcykge1xyXG4gICAgICAgICAgICBpZ25vcmVkSW1hZ2VBbmFseXNpc1NlbGVjdG9ycyA9IEFycmF5LmlzQXJyYXkoXHJcbiAgICAgICAgICAgICAgICBmaXhlcy5pZ25vcmVJbWFnZUFuYWx5c2lzXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgID8gZml4ZXMuaWdub3JlSW1hZ2VBbmFseXNpc1xyXG4gICAgICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICAgICAgaWdub3JlZElubGluZVNlbGVjdG9ycyA9IEFycmF5LmlzQXJyYXkoZml4ZXMuaWdub3JlSW5saW5lU3R5bGUpXHJcbiAgICAgICAgICAgICAgICA/IGZpeGVzLmlnbm9yZUlubGluZVN0eWxlXHJcbiAgICAgICAgICAgICAgICA6IFtdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlnbm9yZWRJbWFnZUFuYWx5c2lzU2VsZWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIGlnbm9yZWRJbmxpbmVTZWxlY3RvcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlci5pbW1lZGlhdGVNb2RpZnkpIHtcclxuICAgICAgICAgICAgc2V0SXNET01SZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzSUZyYW1lJDEgPSBpZnJhbWU7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmhlYWQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQW5vdGhlckRhcmtSZWFkZXJJbnN0YW5jZUFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgICAgIFwiZGF0YS1kYXJrcmVhZGVyLW1vZGVcIixcclxuICAgICAgICAgICAgICAgIFwiZHluYW1pY1wiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgICAgICBcImRhdGEtZGFya3JlYWRlci1zY2hlbWVcIixcclxuICAgICAgICAgICAgICAgIGZpbHRlci5tb2RlID8gXCJkYXJrXCIgOiBcImRpbW1lZFwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNyZWF0ZVRoZW1lQW5kV2F0Y2hGb3JVcGRhdGVzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ZpcmVmb3gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmYWxsYmFja1N0eWxlID0gY3JlYXRlT3JVcGRhdGVTdHlsZShcImRhcmtyZWFkZXItLWZhbGxiYWNrXCIpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGZhbGxiYWNrU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tTdHlsZS50ZXh0Q29udGVudCA9IGdldE1vZGlmaWVkRmFsbGJhY2tTdHlsZShmaWx0ZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoZWFkT2JzZXJ2ZXJfMSA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZE9ic2VydmVyXzEuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fub3RoZXJEYXJrUmVhZGVySW5zdGFuY2VBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVEeW5hbWljVGhlbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUaGVtZUFuZFdhdGNoRm9yVXBkYXRlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGVhZE9ic2VydmVyXzEub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZVByb3h5KCkge1xyXG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiX19kYXJrcmVhZGVyX19jbGVhblVwXCIpKTtcclxuICAgICAgICByZW1vdmVOb2RlKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcihcIi5kYXJrcmVhZGVyLS1wcm94eVwiKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVEeW5hbWljVGhlbWUoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtZGFya3JlYWRlci1tb2RlXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWRhcmtyZWFkZXItc2NoZW1lXCIpO1xyXG4gICAgICAgIGNsZWFuRHluYW1pY1RoZW1lQ2FjaGUoKTtcclxuICAgICAgICByZW1vdmVOb2RlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZGFya3JlYWRlci0tZmFsbGJhY2tcIikpO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5oZWFkKSB7XHJcbiAgICAgICAgICAgIHJlc3RvcmVNZXRhVGhlbWVDb2xvcigpO1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcihcIi5kYXJrcmVhZGVyLS11c2VyLWFnZW50XCIpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIuZGFya3JlYWRlci0tdGV4dFwiKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLWludmVydFwiKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLWlubGluZVwiKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLW92ZXJyaWRlXCIpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIuZGFya3JlYWRlci0tdmFyaWFibGVzXCIpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIuZGFya3JlYWRlci0tcm9vdC12YXJzXCIpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImRhcmtyZWFkZXJcIl0nKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZVByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYWRvd1Jvb3RzV2l0aE92ZXJyaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLWlubGluZVwiKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRhcmtyZWFkZXItLW92ZXJyaWRlXCIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzaGFkb3dSb290c1dpdGhPdmVycmlkZXMuY2xlYXIoKTtcclxuICAgICAgICBmb3JFYWNoKHN0eWxlTWFuYWdlcnMua2V5cygpLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZU1hbmFnZXIoZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxvYWRpbmdTdHlsZXMuY2xlYXIoKTtcclxuICAgICAgICBjbGVhbkxvYWRpbmdMaW5rcygpO1xyXG4gICAgICAgIGZvckVhY2goZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5kYXJrcmVhZGVyXCIpLCByZW1vdmVOb2RlKTtcclxuICAgICAgICBhZG9wdGVkU3R5bGVNYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkb3B0ZWRTdHlsZU1hbmFnZXJzLnNwbGljZSgwKTtcclxuICAgICAgICBtZXRhT2JzZXJ2ZXIgJiYgbWV0YU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFuRHluYW1pY1RoZW1lQ2FjaGUoKSB7XHJcbiAgICAgICAgdmFyaWFibGVzU3RvcmUuY2xlYXIoKTtcclxuICAgICAgICBwYXJzZWRVUkxDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIHN0b3BXYXRjaGluZ0ZvckRvY3VtZW50VmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIGNhbmNlbFJlbmRlcmluZygpO1xyXG4gICAgICAgIHN0b3BXYXRjaGluZ0ZvclVwZGF0ZXMoKTtcclxuICAgICAgICBjbGVhbk1vZGlmaWNhdGlvbkNhY2hlKCk7XHJcbiAgICAgICAgY2xlYXJDb2xvckNhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJsb2JSZWdleCA9IC91cmxcXChcXFwiKGJsb2JcXDouKj8pXFxcIlxcKS9nO1xyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUJsb2JzKHRleHQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlcywgZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TWF0Y2hlcyhibG9iUmVnZXgsIHRleHQsIDEpLmZvckVhY2goZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBsb2FkQXNEYXRhVVJMKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChwcm9taXNlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnJlcGxhY2UoYmxvYlJlZ2V4LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd1cmwoXCInLmNvbmNhdChkYXRhLnNoaWZ0KCksICdcIiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGJhbm5lciA9XHJcbiAgICAgICAgJy8qXFxuICAgICAgICAgICAgICAgICAgICAgICAgX19fX19fX1xcbiAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICBcXFxcXFxuICAgICAgICAgICAgICAgICAgICAgIC49PS4gICAgLj09LlxcbiAgICAgICAgICAgICAgICAgICAgICgoICApKT09KCggICkpXFxuICAgICAgICAgICAgICAgICAgICAvIFwiPT1cIiAgICBcIj09XCJcXFxcXFxuICAgICAgICAgICAgICAgICAgIC9fX19ffHwgfHwgfHxfX19cXFxcXFxuICAgICAgIF9fX19fX19fICAgICBfX19fICAgIF9fX19fX19fICBfX18gICAgX19fXFxuICAgICAgIHwgIF9fXyAgXFxcXCAgIC8gICAgXFxcXCAgIHwgIF9fXyAgXFxcXCB8ICB8ICAvICAvXFxuICAgICAgIHwgIHwgIFxcXFwgIFxcXFwgLyAgL1xcXFwgIFxcXFwgIHwgIHwgIFxcXFwgIFxcXFx8ICB8Xy8gIC9cXG4gICAgICAgfCAgfCAgICkgIC8gIC9fX1xcXFwgIFxcXFwgfCAgfF9fLyAgL3wgIF9fXyAgXFxcXFxcbiAgICAgICB8ICB8X18vICAvICBfX19fX18gIFxcXFx8ICBfX19fICBcXFxcfCAgfCAgXFxcXCAgXFxcXFxcbl9fX19fX198X19fX19fXy9fXy8gX19fXyBcXFxcX19cXFxcX198X19fXFxcXF9fXFxcXF9ffF9fX1xcXFxfX1xcXFxfX19fXFxufCAgX19fICBcXFxcIHwgIF9fX18vIC8gICAgXFxcXCAgIHwgIF9fXyAgXFxcXCB8ICBfX19ffCAgX19fICBcXFxcXFxufCAgfCAgXFxcXCAgXFxcXHwgIHxfX18gLyAgL1xcXFwgIFxcXFwgIHwgIHwgIFxcXFwgIFxcXFx8ICB8X19ffCAgfCAgXFxcXCAgXFxcXFxcbnwgIHxfXy8gIC98ICBfX19fLyAgL19fXFxcXCAgXFxcXCB8ICB8ICAgKSAgfCAgX19fX3wgIHxfXy8gIC9cXG58ICBfX19fICBcXFxcfCAgfF9fLyAgX19fX19fICBcXFxcfCAgfF9fLyAgL3wgIHxfX198ICBfX19fICBcXFxcXFxufF9ffCAgIFxcXFxfX1xcXFxfX19fL19fLyAgICAgIFxcXFxfX1xcXFxfX19fX19fLyB8X19fX19ffF9ffCAgIFxcXFxfX1xcXFxcXG4gICAgICAgICAgICAgICAgaHR0cHM6Ly9kYXJrcmVhZGVyLm9yZ1xcbiovXFxuXFxuLyohIERhcmsgcmVhZGVyIGdlbmVyYXRlZCBDU1MgfCBMaWNlbnNlZCB1bmRlciBNSVQgaHR0cHM6Ly9naXRodWIuY29tL2RhcmtyZWFkZXIvZGFya3JlYWRlci9ibG9iL21haW4vTElDRU5TRSAqL1xcbic7XHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q1NTKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3RhdGljQ1NTKHNlbGVjdG9yLCBjb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGljU3R5bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTdHlsZSAmJiBzdGF0aWNTdHlsZS50ZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNzcy5wdXNoKFwiLyogXCIuY29uY2F0KGNvbW1lbnQsIFwiICovXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICBjc3MucHVzaChzdGF0aWNTdHlsZS50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzLnB1c2goXCJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNzcywgbW9kaWZpZWRDU1MsIGZvcm1hdHRlZENTUywgX2EsIF9iO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3MgPSBbYmFubmVyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGljQ1NTKFwiLmRhcmtyZWFkZXItLWZhbGxiYWNrXCIsIFwiRmFsbGJhY2sgU3R5bGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN0YXRpY0NTUyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLmRhcmtyZWFkZXItLXVzZXItYWdlbnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVXNlci1BZ2VudCBTdHlsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN0YXRpY0NTUyhcIi5kYXJrcmVhZGVyLS10ZXh0XCIsIFwiVGV4dCBTdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGljQ1NTKFwiLmRhcmtyZWFkZXItLWludmVydFwiLCBcIkludmVydCBTdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGljQ1NTKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuZGFya3JlYWRlci0tdmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlZhcmlhYmxlcyBTdHlsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQ1NTID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbChcIi5kYXJrcmVhZGVyLS1zeW5jXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2hlZXQuY3NzUnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5jc3NUZXh0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRDU1MucHVzaChydWxlLmNzc1RleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZGlmaWVkQ1NTLmxlbmd0aCkgcmV0dXJuIFszLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQ1NTID0gZm9ybWF0Q1NTKG1vZGlmaWVkQ1NTLmpvaW4oXCJcXG5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3MucHVzaChcIi8qIE1vZGlmaWVkIENTUyAqL1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBjc3MpLnB1c2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVwbGFjZUJsb2JzKGZvcm1hdHRlZENTUyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnB1c2goXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN0YXRpY0NTUyhcIi5kYXJrcmVhZGVyLS1vdmVycmlkZVwiLCBcIk92ZXJyaWRlIFN0eWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGNzcy5qb2luKFwiXFxuXCIpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzRGFya1JlYWRlckVuYWJsZWQgPSBmYWxzZTtcclxuICAgIHZhciBpc0lGcmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKTtcclxuICAgIGZ1bmN0aW9uIGVuYWJsZSh0aGVtZU9wdGlvbnMsIGZpeGVzKSB7XHJcbiAgICAgICAgaWYgKHRoZW1lT3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHRoZW1lT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZml4ZXMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBmaXhlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX1RIRU1FKSwgdGhlbWVPcHRpb25zKTtcclxuICAgICAgICBpZiAodGhlbWUuZW5naW5lICE9PSBUaGVtZUVuZ2luZS5keW5hbWljVGhlbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlbWUgZW5naW5lIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmVhdGVPclVwZGF0ZUR5bmFtaWNUaGVtZSh0aGVtZSwgZml4ZXMsIGlzSUZyYW1lKTtcclxuICAgICAgICBpc0RhcmtSZWFkZXJFbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gaXNEYXJrUmVhZGVyRW5hYmxlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcbiAgICAgICAgcmVtb3ZlRHluYW1pY1RoZW1lKCk7XHJcbiAgICAgICAgaXNEYXJrUmVhZGVyRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIGRhcmtTY2hlbWUgPSBtYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKTtcclxuICAgIHZhciBzdG9yZSA9IHtcclxuICAgICAgICB0aGVtZU9wdGlvbnM6IG51bGwsXHJcbiAgICAgICAgZml4ZXM6IG51bGxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDb2xvclNjaGVtZSgpIHtcclxuICAgICAgICBpZiAoZGFya1NjaGVtZS5tYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIGVuYWJsZShzdG9yZS50aGVtZU9wdGlvbnMsIHN0b3JlLmZpeGVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXNhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXV0byh0aGVtZU9wdGlvbnMsIGZpeGVzKSB7XHJcbiAgICAgICAgaWYgKHRoZW1lT3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHRoZW1lT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZml4ZXMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBmaXhlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVtZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc3RvcmUgPSB7dGhlbWVPcHRpb25zOiB0aGVtZU9wdGlvbnMsIGZpeGVzOiBmaXhlc307XHJcbiAgICAgICAgICAgIGhhbmRsZUNvbG9yU2NoZW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChpc01hdGNoTWVkaWFDaGFuZ2VFdmVudExpc3RlbmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBkYXJrU2NoZW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ29sb3JTY2hlbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGFya1NjaGVtZS5hZGRMaXN0ZW5lcihoYW5kbGVDb2xvclNjaGVtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNNYXRjaE1lZGlhQ2hhbmdlRXZlbnRMaXN0ZW5lclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgZGFya1NjaGVtZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZUNvbG9yU2NoZW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhcmtTY2hlbWUucmVtb3ZlTGlzdGVuZXIoaGFuZGxlQ29sb3JTY2hlbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc2FibGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHBvcnRHZW5lcmF0ZWRDU1MoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNvbGxlY3RDU1MoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHNldEZldGNoTWV0aG9kID0gc2V0RmV0Y2hNZXRob2QkMTtcclxuXHJcbiAgICBleHBvcnRzLmF1dG8gPSBhdXRvO1xyXG4gICAgZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcclxuICAgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4gICAgZXhwb3J0cy5leHBvcnRHZW5lcmF0ZWRDU1MgPSBleHBvcnRHZW5lcmF0ZWRDU1M7XHJcbiAgICBleHBvcnRzLmlzRW5hYmxlZCA9IGlzRW5hYmxlZDtcclxuICAgIGV4cG9ydHMuc2V0RmV0Y2hNZXRob2QgPSBzZXRGZXRjaE1ldGhvZDtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCkge1xuXHRcdGlmIChwcmVkaWNhdGUgPT09IHRydWUpIHtcblx0XHRcdGlmIChvYmplY3RbbmFtZV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpXG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKVxuXG5mdW5jdGlvbiBDdXJ2ZSAocCwgYSwgYiwgR3gsIEd5LCBuLCBoKSB7XG4gIHRoaXMucCA9IHBcbiAgdGhpcy5hID0gYVxuICB0aGlzLmIgPSBiXG4gIHRoaXMuRyA9IFBvaW50LmZyb21BZmZpbmUodGhpcywgR3gsIEd5KVxuICB0aGlzLm4gPSBuXG4gIHRoaXMuaCA9IGhcblxuICB0aGlzLmluZmluaXR5ID0gbmV3IFBvaW50KHRoaXMsIG51bGwsIG51bGwsIEJpZ0ludGVnZXIuWkVSTylcblxuICAvLyByZXN1bHQgY2FjaGluZ1xuICB0aGlzLnBPdmVyRm91ciA9IHAuYWRkKEJpZ0ludGVnZXIuT05FKS5zaGlmdFJpZ2h0KDIpXG5cbiAgLy8gZGV0ZXJtaW5lIHNpemUgb2YgcCBpbiBieXRlc1xuICB0aGlzLnBMZW5ndGggPSBNYXRoLmZsb29yKCh0aGlzLnAuYml0TGVuZ3RoKCkgKyA3KSAvIDgpXG59XG5cbkN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gKGlzT2RkLCB4KSB7XG4gIHZhciBhbHBoYSA9IHgucG93KDMpLmFkZCh0aGlzLmEubXVsdGlwbHkoeCkpLmFkZCh0aGlzLmIpLm1vZCh0aGlzLnApXG4gIHZhciBiZXRhID0gYWxwaGEubW9kUG93KHRoaXMucE92ZXJGb3VyLCB0aGlzLnApIC8vIFhYWDogbm90IGNvbXBhdGlibGUgd2l0aCBhbGwgY3VydmVzXG5cbiAgdmFyIHkgPSBiZXRhXG4gIGlmIChiZXRhLmlzRXZlbigpIF4gIWlzT2RkKSB7XG4gICAgeSA9IHRoaXMucC5zdWJ0cmFjdCh5KSAvLyAteSAlIHBcbiAgfVxuXG4gIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHRoaXMsIHgsIHkpXG59XG5cbkN1cnZlLnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gKFEpIHtcbiAgaWYgKFEgPT09IHRoaXMuaW5maW5pdHkpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIFEuei5zaWdudW0oKSA9PT0gMCAmJiBRLnkuc2lnbnVtKCkgIT09IDBcbn1cblxuQ3VydmUucHJvdG90eXBlLmlzT25DdXJ2ZSA9IGZ1bmN0aW9uIChRKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoUSkpIHJldHVybiB0cnVlXG5cbiAgdmFyIHggPSBRLmFmZmluZVhcbiAgdmFyIHkgPSBRLmFmZmluZVlcbiAgdmFyIGEgPSB0aGlzLmFcbiAgdmFyIGIgPSB0aGlzLmJcbiAgdmFyIHAgPSB0aGlzLnBcblxuICAvLyBDaGVjayB0aGF0IHhRIGFuZCB5USBhcmUgaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFswLCBwIC0gMV1cbiAgaWYgKHguc2lnbnVtKCkgPCAwIHx8IHguY29tcGFyZVRvKHApID49IDApIHJldHVybiBmYWxzZVxuICBpZiAoeS5zaWdudW0oKSA8IDAgfHwgeS5jb21wYXJlVG8ocCkgPj0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgLy8gYW5kIGNoZWNrIHRoYXQgeV4yID0geF4zICsgYXggKyBiIChtb2QgcClcbiAgdmFyIGxocyA9IHkuc3F1YXJlKCkubW9kKHApXG4gIHZhciByaHMgPSB4LnBvdygzKS5hZGQoYS5tdWx0aXBseSh4KSkuYWRkKGIpLm1vZChwKVxuICByZXR1cm4gbGhzLmVxdWFscyhyaHMpXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKlxuICogU2VlIFNFQyAxLCBzZWN0aW9uIDMuMi4yLjE6IEVsbGlwdGljIEN1cnZlIFB1YmxpYyBLZXkgVmFsaWRhdGlvbiBQcmltaXRpdmVcbiAqL1xuQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKFEpIHtcbiAgLy8gQ2hlY2sgUSAhPSBPXG4gIGFzc2VydCghdGhpcy5pc0luZmluaXR5KFEpLCAnUG9pbnQgaXMgYXQgaW5maW5pdHknKVxuICBhc3NlcnQodGhpcy5pc09uQ3VydmUoUSksICdQb2ludCBpcyBub3Qgb24gdGhlIGN1cnZlJylcblxuICAvLyBDaGVjayBuUSA9IE8gKHdoZXJlIFEgaXMgYSBzY2FsYXIgbXVsdGlwbGUgb2YgRylcbiAgdmFyIG5RID0gUS5tdWx0aXBseSh0aGlzLm4pXG4gIGFzc2VydCh0aGlzLmlzSW5maW5pdHkoblEpLCAnUG9pbnQgaXMgbm90IGEgc2NhbGFyIG11bHRpcGxlIG9mIEcnKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmVcbiIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKVxudmFyIEN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpXG5cbnZhciBnZXRDdXJ2ZUJ5TmFtZSA9IHJlcXVpcmUoJy4vbmFtZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ3VydmU6IEN1cnZlLFxuICBQb2ludDogUG9pbnQsXG4gIGdldEN1cnZlQnlOYW1lOiBnZXRDdXJ2ZUJ5TmFtZVxufVxuIiwidmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcblxudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzLmpzb24nKVxudmFyIEN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpXG5cbmZ1bmN0aW9uIGdldEN1cnZlQnlOYW1lIChuYW1lKSB7XG4gIHZhciBjdXJ2ZSA9IGN1cnZlc1tuYW1lXVxuICBpZiAoIWN1cnZlKSByZXR1cm4gbnVsbFxuXG4gIHZhciBwID0gbmV3IEJpZ0ludGVnZXIoY3VydmUucCwgMTYpXG4gIHZhciBhID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuYSwgMTYpXG4gIHZhciBiID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuYiwgMTYpXG4gIHZhciBuID0gbmV3IEJpZ0ludGVnZXIoY3VydmUubiwgMTYpXG4gIHZhciBoID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuaCwgMTYpXG4gIHZhciBHeCA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLkd4LCAxNilcbiAgdmFyIEd5ID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuR3ksIDE2KVxuXG4gIHJldHVybiBuZXcgQ3VydmUocCwgYSwgYiwgR3gsIEd5LCBuLCBoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnZlQnlOYW1lXG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcblxudmFyIFRIUkVFID0gQmlnSW50ZWdlci52YWx1ZU9mKDMpXG5cbmZ1bmN0aW9uIFBvaW50IChjdXJ2ZSwgeCwgeSwgeikge1xuICBhc3NlcnQubm90U3RyaWN0RXF1YWwoeiwgdW5kZWZpbmVkLCAnTWlzc2luZyBaIGNvb3JkaW5hdGUnKVxuXG4gIHRoaXMuY3VydmUgPSBjdXJ2ZVxuICB0aGlzLnggPSB4XG4gIHRoaXMueSA9IHlcbiAgdGhpcy56ID0gelxuICB0aGlzLl96SW52ID0gbnVsbFxuXG4gIHRoaXMuY29tcHJlc3NlZCA9IHRydWVcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ3pJbnYnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl96SW52ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl96SW52ID0gdGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5wKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl96SW52XG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsICdhZmZpbmVYJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy54Lm11bHRpcGx5KHRoaXMuekludikubW9kKHRoaXMuY3VydmUucClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ2FmZmluZVknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnkubXVsdGlwbHkodGhpcy56SW52KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB9XG59KVxuXG5Qb2ludC5mcm9tQWZmaW5lID0gZnVuY3Rpb24gKGN1cnZlLCB4LCB5KSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIHgsIHksIEJpZ0ludGVnZXIuT05FKVxufVxuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykgcmV0dXJuIHRydWVcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIHRoaXMuY3VydmUuaXNJbmZpbml0eShvdGhlcilcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eShvdGhlcikpIHJldHVybiB0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcylcblxuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdmFyIHUgPSBvdGhlci55Lm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55Lm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIGlmICh1LnNpZ251bSgpICE9PSAwKSByZXR1cm4gZmFsc2VcblxuICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgdmFyIHYgPSBvdGhlci54Lm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54Lm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIHJldHVybiB2LnNpZ251bSgpID09PSAwXG59XG5cblBvaW50LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gdGhpcy5jdXJ2ZS5wLnN1YnRyYWN0KHRoaXMueSlcblxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMuY3VydmUsIHRoaXMueCwgeSwgdGhpcy56KVxufVxuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIGJcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eShiKSkgcmV0dXJuIHRoaXNcblxuICB2YXIgeDEgPSB0aGlzLnhcbiAgdmFyIHkxID0gdGhpcy55XG4gIHZhciB4MiA9IGIueFxuICB2YXIgeTIgPSBiLnlcblxuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdmFyIHUgPSB5Mi5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHkxLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2YXIgdiA9IHgyLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QoeDEubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucClcblxuICBpZiAodi5zaWdudW0oKSA9PT0gMCkge1xuICAgIGlmICh1LnNpZ251bSgpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50d2ljZSgpIC8vIHRoaXMgPT0gYiwgc28gZG91YmxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHkgLy8gdGhpcyA9IC1iLCBzbyBpbmZpbml0eVxuICB9XG5cbiAgdmFyIHYyID0gdi5zcXVhcmUoKVxuICB2YXIgdjMgPSB2Mi5tdWx0aXBseSh2KVxuICB2YXIgeDF2MiA9IHgxLm11bHRpcGx5KHYyKVxuICB2YXIgenUyID0gdS5zcXVhcmUoKS5tdWx0aXBseSh0aGlzLnopXG5cbiAgLy8geDMgPSB2ICogKHoyICogKHoxICogdV4yIC0gMiAqIHgxICogdl4yKSAtIHZeMylcbiAgdmFyIHgzID0genUyLnN1YnRyYWN0KHgxdjIuc2hpZnRMZWZ0KDEpKS5tdWx0aXBseShiLnopLnN1YnRyYWN0KHYzKS5tdWx0aXBseSh2KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB5MyA9IHoyICogKDMgKiB4MSAqIHUgKiB2XjIgLSB5MSAqIHZeMyAtIHoxICogdV4zKSArIHUgKiB2XjNcbiAgdmFyIHkzID0geDF2Mi5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkodSkuc3VidHJhY3QoeTEubXVsdGlwbHkodjMpKS5zdWJ0cmFjdCh6dTIubXVsdGlwbHkodSkpLm11bHRpcGx5KGIueikuYWRkKHUubXVsdGlwbHkodjMpKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB6MyA9IHZeMyAqIHoxICogejJcbiAgdmFyIHozID0gdjMubXVsdGlwbHkodGhpcy56KS5tdWx0aXBseShiLnopLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmN1cnZlLCB4MywgeTMsIHozKVxufVxuXG5Qb2ludC5wcm90b3R5cGUudHdpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiB0aGlzXG4gIGlmICh0aGlzLnkuc2lnbnVtKCkgPT09IDApIHJldHVybiB0aGlzLmN1cnZlLmluZmluaXR5XG5cbiAgdmFyIHgxID0gdGhpcy54XG4gIHZhciB5MSA9IHRoaXMueVxuXG4gIHZhciB5MXoxID0geTEubXVsdGlwbHkodGhpcy56KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB2YXIgeTFzcXoxID0geTF6MS5tdWx0aXBseSh5MSkubW9kKHRoaXMuY3VydmUucClcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmFcblxuICAvLyB3ID0gMyAqIHgxXjIgKyBhICogejFeMlxuICB2YXIgdyA9IHgxLnNxdWFyZSgpLm11bHRpcGx5KFRIUkVFKVxuXG4gIGlmIChhLnNpZ251bSgpICE9PSAwKSB7XG4gICAgdyA9IHcuYWRkKHRoaXMuei5zcXVhcmUoKS5tdWx0aXBseShhKSlcbiAgfVxuXG4gIHcgPSB3Lm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHgzID0gMiAqIHkxICogejEgKiAod14yIC0gOCAqIHgxICogeTFeMiAqIHoxKVxuICB2YXIgeDMgPSB3LnNxdWFyZSgpLnN1YnRyYWN0KHgxLnNoaWZ0TGVmdCgzKS5tdWx0aXBseSh5MXNxejEpKS5zaGlmdExlZnQoMSkubXVsdGlwbHkoeTF6MSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8geTMgPSA0ICogeTFeMiAqIHoxICogKDMgKiB3ICogeDEgLSAyICogeTFeMiAqIHoxKSAtIHdeM1xuICB2YXIgeTMgPSB3Lm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh4MSkuc3VidHJhY3QoeTFzcXoxLnNoaWZ0TGVmdCgxKSkuc2hpZnRMZWZ0KDIpLm11bHRpcGx5KHkxc3F6MSkuc3VidHJhY3Qody5wb3coMykpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHozID0gOCAqICh5MSAqIHoxKV4zXG4gIHZhciB6MyA9IHkxejEucG93KDMpLnNoaWZ0TGVmdCgzKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5jdXJ2ZSwgeDMsIHkzLCB6Mylcbn1cblxuLy8gU2ltcGxlIE5BRiAoTm9uLUFkamFjZW50IEZvcm0pIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuLy8gVE9ETzogbW9kdWxhcml6ZSB0aGUgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG5Qb2ludC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoaykge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gdGhpc1xuICBpZiAoay5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHlcblxuICB2YXIgZSA9IGtcbiAgdmFyIGggPSBlLm11bHRpcGx5KFRIUkVFKVxuXG4gIHZhciBuZWcgPSB0aGlzLm5lZ2F0ZSgpXG4gIHZhciBSID0gdGhpc1xuXG4gIGZvciAodmFyIGkgPSBoLmJpdExlbmd0aCgpIC0gMjsgaSA+IDA7IC0taSkge1xuICAgIHZhciBoQml0ID0gaC50ZXN0Qml0KGkpXG4gICAgdmFyIGVCaXQgPSBlLnRlc3RCaXQoaSlcblxuICAgIFIgPSBSLnR3aWNlKClcblxuICAgIGlmIChoQml0ICE9PSBlQml0KSB7XG4gICAgICBSID0gUi5hZGQoaEJpdCA/IHRoaXMgOiBuZWcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJcbn1cblxuLy8gQ29tcHV0ZSB0aGlzKmogKyB4KmsgKHNpbXVsdGFuZW91cyBtdWx0aXBsaWNhdGlvbilcblBvaW50LnByb3RvdHlwZS5tdWx0aXBseVR3byA9IGZ1bmN0aW9uIChqLCB4LCBrKSB7XG4gIHZhciBpID0gTWF0aC5tYXgoai5iaXRMZW5ndGgoKSwgay5iaXRMZW5ndGgoKSkgLSAxXG4gIHZhciBSID0gdGhpcy5jdXJ2ZS5pbmZpbml0eVxuICB2YXIgYm90aCA9IHRoaXMuYWRkKHgpXG5cbiAgd2hpbGUgKGkgPj0gMCkge1xuICAgIHZhciBqQml0ID0gai50ZXN0Qml0KGkpXG4gICAgdmFyIGtCaXQgPSBrLnRlc3RCaXQoaSlcblxuICAgIFIgPSBSLnR3aWNlKClcblxuICAgIGlmIChqQml0KSB7XG4gICAgICBpZiAoa0JpdCkge1xuICAgICAgICBSID0gUi5hZGQoYm90aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFIgPSBSLmFkZCh0aGlzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa0JpdCkge1xuICAgICAgUiA9IFIuYWRkKHgpXG4gICAgfVxuICAgIC0taVxuICB9XG5cbiAgcmV0dXJuIFJcbn1cblxuUG9pbnQucHJvdG90eXBlLmdldEVuY29kZWQgPSBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICBpZiAoY29tcHJlc3NlZCA9PSBudWxsKSBjb21wcmVzc2VkID0gdGhpcy5jb21wcmVzc2VkXG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiBCdWZmZXIuYWxsb2MoMSwgMCkgLy8gSW5maW5pdHkgcG9pbnQgZW5jb2RlZCBpcyBzaW1wbHkgJzAwJ1xuXG4gIHZhciB4ID0gdGhpcy5hZmZpbmVYXG4gIHZhciB5ID0gdGhpcy5hZmZpbmVZXG4gIHZhciBieXRlTGVuZ3RoID0gdGhpcy5jdXJ2ZS5wTGVuZ3RoXG4gIHZhciBidWZmZXJcblxuICAvLyAweDAyLzB4MDMgfCBYXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEgKyBieXRlTGVuZ3RoKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHkuaXNFdmVuKCkgPyAweDAyIDogMHgwMywgMClcblxuICAvLyAweDA0IHwgWCB8IFlcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSArIGJ5dGVMZW5ndGggKyBieXRlTGVuZ3RoKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4MDQsIDApXG5cbiAgICB5LnRvQnVmZmVyKGJ5dGVMZW5ndGgpLmNvcHkoYnVmZmVyLCAxICsgYnl0ZUxlbmd0aClcbiAgfVxuXG4gIHgudG9CdWZmZXIoYnl0ZUxlbmd0aCkuY29weShidWZmZXIsIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5Qb2ludC5kZWNvZGVGcm9tID0gZnVuY3Rpb24gKGN1cnZlLCBidWZmZXIpIHtcbiAgdmFyIHR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KDApXG4gIHZhciBjb21wcmVzc2VkID0gKHR5cGUgIT09IDQpXG5cbiAgdmFyIGJ5dGVMZW5ndGggPSBNYXRoLmZsb29yKChjdXJ2ZS5wLmJpdExlbmd0aCgpICsgNykgLyA4KVxuICB2YXIgeCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSwgMSArIGJ5dGVMZW5ndGgpKVxuXG4gIHZhciBRXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsIGJ5dGVMZW5ndGggKyAxLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKVxuICAgIGFzc2VydCh0eXBlID09PSAweDAyIHx8IHR5cGUgPT09IDB4MDMsICdJbnZhbGlkIHNlcXVlbmNlIHRhZycpXG5cbiAgICB2YXIgaXNPZGQgPSAodHlwZSA9PT0gMHgwMylcbiAgICBRID0gY3VydmUucG9pbnRGcm9tWChpc09kZCwgeClcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCwgMSArIGJ5dGVMZW5ndGggKyBieXRlTGVuZ3RoLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKVxuXG4gICAgdmFyIHkgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEgKyBieXRlTGVuZ3RoKSlcbiAgICBRID0gUG9pbnQuZnJvbUFmZmluZShjdXJ2ZSwgeCwgeSlcbiAgfVxuXG4gIFEuY29tcHJlc3NlZCA9IGNvbXByZXNzZWRcbiAgcmV0dXJuIFFcbn1cblxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gJyhJTkZJTklUWSknXG5cbiAgcmV0dXJuICcoJyArIHRoaXMuYWZmaW5lWC50b1N0cmluZygpICsgJywnICsgdGhpcy5hZmZpbmVZLnRvU3RyaW5nKCkgKyAnKSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFxuIiwiLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZvckVhY2hBcnJheSA9IGZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hTdHJpbmcgPSBmdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hPYmplY3QgPSBmdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgdGhpc0FyZykge1xuICAgIGlmICghaXNDYWxsYWJsZShpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VpdmVyO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVjZWl2ZXIgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIGlmICh0b1N0ci5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1Byb3RvID0gcmVxdWlyZSgnaGFzLXByb3RvJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG5pZiAoZ2V0UHJvdG8pIHtcblx0dHJ5IHtcblx0XHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2hhZG93cmVhbG0vcHVsbC8zODQjaXNzdWVjb21tZW50LTEzNjQyNjQyMjlcblx0XHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0XHRJTlRSSU5TSUNTWyclRXJyb3IucHJvdG90eXBlJSddID0gZXJyb3JQcm90bztcblx0fVxufVxuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuICYmIGdldFByb3RvKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuXG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSB7XG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR0cnkge1xuXHRcdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoIWhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVzdCA9IHtcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb28gJiYgISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBkZGFDbGFzcyA9ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSc7IC8vIElFIDExXG52YXIgZGRhQ2xhc3MyID0gJ1tvYmplY3QgSFRNTCBkb2N1bWVudC5hbGwgY2xhc3NdJztcbnZhciBkZGFDbGFzczMgPSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOyAvLyBJRSA5LTEwXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuXG52YXIgaXNJRTY4ID0gISgwIGluIFssXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc3BhcnNlLWFycmF5cywgY29tbWEtc3BhY2luZ1xuXG52YXIgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKCkgeyByZXR1cm4gZmFsc2U7IH07XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuXHQvLyBGaXJlZm94IDMgY2Fub25pY2FsaXplcyBEREEgdG8gdW5kZWZpbmVkIHdoZW4gaXQncyBub3QgYWNjZXNzZWQgZGlyZWN0bHlcblx0dmFyIGFsbCA9IGRvY3VtZW50LmFsbDtcblx0aWYgKHRvU3RyLmNhbGwoYWxsKSA9PT0gdG9TdHIuY2FsbChkb2N1bWVudC5hbGwpKSB7XG5cdFx0aXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xuXHRcdFx0Ly8gaW4gSUUgNi04LCB0eXBlb2YgZG9jdW1lbnQuYWxsIGlzIFwib2JqZWN0XCIgYW5kIGl0J3MgdHJ1dGh5XG5cdFx0XHRpZiAoKGlzSUU2OCB8fCAhdmFsdWUpICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRzdHIgPT09IGRkYUNsYXNzXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczMgLy8gb3BlcmEgMTIuMTZcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gb2JqZWN0Q2xhc3MgLy8gSUUgNi04XG5cdFx0XHRcdFx0KSAmJiB2YWx1ZSgnJykgPT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdGlmIChzdHJDbGFzcyAhPT0gZm5DbGFzcyAmJiBzdHJDbGFzcyAhPT0gZ2VuQ2xhc3MgJiYgISgvXlxcW29iamVjdCBIVE1MLykudGVzdChzdHJDbGFzcykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcbiIsIi8qKlxuICogW2pzLXNoYTI1Nl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTZ9XG4gKlxuICogQHZlcnNpb24gMC45LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRVJST1IgPSAnaW5wdXQgaXMgaW52YWxpZCB0eXBlJztcbiAgdmFyIFdJTkRPVyA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnO1xuICB2YXIgcm9vdCA9IFdJTkRPVyA/IHdpbmRvdyA6IHt9O1xuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19DT01NT05fSlMgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBBTUQgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAhcm9vdC5KU19TSEEyNTZfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xuICB2YXIgU0hJRlQgPSBbMjQsIDE2LCA4LCAwXTtcbiAgdmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG4gIF07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdhcnJheScsICdkaWdlc3QnLCAnYXJyYXlCdWZmZXInXTtcblxuICB2YXIgYmxvY2tzID0gW107XG5cbiAgaWYgKHJvb3QuSlNfU0hBMjU2X05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGlzMjI0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYTI1NihpczIyNCwgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGlzMjI0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIGlmIChOT0RFX0pTKSB7XG4gICAgICBtZXRob2QgPSBub2RlV3JhcChtZXRob2QsIGlzMjI0KTtcbiAgICB9XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0KTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVPdXRwdXRNZXRob2QodHlwZSwgaXMyMjQpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBub2RlV3JhcCA9IGZ1bmN0aW9uIChtZXRob2QsIGlzMjI0KSB7XG4gICAgdmFyIGNyeXB0byA9IGV2YWwoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICB2YXIgYWxnb3JpdGhtID0gaXMyMjQgPyAnc2hhMjI0JyA6ICdzaGEyNTYnO1xuICAgIHZhciBub2RlTWV0aG9kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG1lc3NhZ2UsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSB8fFxuICAgICAgICBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG5ldyBCdWZmZXIobWVzc2FnZSkpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5vZGVNZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHRydWUpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlSG1hY091dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEhtYWNTaGEyNTYoa2V5LCBpczIyNCk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5KS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kKHR5cGUsIGlzMjI0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGEyNTYoaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIGlmIChpczIyNCkge1xuICAgICAgdGhpcy5oMCA9IDB4YzEwNTllZDg7XG4gICAgICB0aGlzLmgxID0gMHgzNjdjZDUwNztcbiAgICAgIHRoaXMuaDIgPSAweDMwNzBkZDE3O1xuICAgICAgdGhpcy5oMyA9IDB4ZjcwZTU5Mzk7XG4gICAgICB0aGlzLmg0ID0gMHhmZmMwMGIzMTtcbiAgICAgIHRoaXMuaDUgPSAweDY4NTgxNTExO1xuICAgICAgdGhpcy5oNiA9IDB4NjRmOThmYTc7XG4gICAgICB0aGlzLmg3ID0gMHhiZWZhNGZhNDtcbiAgICB9IGVsc2UgeyAvLyAyNTZcbiAgICAgIHRoaXMuaDAgPSAweDZhMDllNjY3O1xuICAgICAgdGhpcy5oMSA9IDB4YmI2N2FlODU7XG4gICAgICB0aGlzLmgyID0gMHgzYzZlZjM3MjtcbiAgICAgIHRoaXMuaDMgPSAweGE1NGZmNTNhO1xuICAgICAgdGhpcy5oNCA9IDB4NTEwZTUyN2Y7XG4gICAgICB0aGlzLmg1ID0gMHg5YjA1Njg4YztcbiAgICAgIHRoaXMuaDYgPSAweDFmODNkOWFiO1xuICAgICAgdGhpcy5oNyA9IDB4NWJlMGNkMTk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzMjI0ID0gaXMyMjQ7XG4gIH1cblxuICBTaGEyNTYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHRoaXMuaEJ5dGVzICs9IHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2IDw8IDA7XG4gICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgfVxuICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gdGhpcy5oQnl0ZXMgPDwgMyB8IHRoaXMuYnl0ZXMgPj4+IDI5O1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQsIGYgPSB0aGlzLmg1LCBnID0gdGhpcy5oNixcbiAgICAgIGggPSB0aGlzLmg3LCBibG9ja3MgPSB0aGlzLmJsb2NrcywgaiwgczAsIHMxLCBtYWosIHQxLCB0MiwgY2gsIGFiLCBkYSwgY2QsIGJjO1xuXG4gICAgZm9yIChqID0gMTY7IGogPCA2NDsgKytqKSB7XG4gICAgICAvLyByaWdodHJvdGF0ZVxuICAgICAgdDEgPSBibG9ja3NbaiAtIDE1XTtcbiAgICAgIHMwID0gKCh0MSA+Pj4gNykgfCAodDEgPDwgMjUpKSBeICgodDEgPj4+IDE4KSB8ICh0MSA8PCAxNCkpIF4gKHQxID4+PiAzKTtcbiAgICAgIHQxID0gYmxvY2tzW2ogLSAyXTtcbiAgICAgIHMxID0gKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXiAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeICh0MSA+Pj4gMTApO1xuICAgICAgYmxvY2tzW2pdID0gYmxvY2tzW2ogLSAxNl0gKyBzMCArIGJsb2Nrc1tqIC0gN10gKyBzMSA8PCAwO1xuICAgIH1cblxuICAgIGJjID0gYiAmIGM7XG4gICAgZm9yIChqID0gMDsgaiA8IDY0OyBqICs9IDQpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzMjI0KSB7XG4gICAgICAgICAgYWIgPSAzMDAwMzI7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAxNDEzMjU3ODE5O1xuICAgICAgICAgIGggPSB0MSAtIDE1MDA1NDU5OSA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDI0MTc3MDc3IDw8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWIgPSA3MDQ3NTExMDk7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAyMTAyNDQyNDg7XG4gICAgICAgICAgaCA9IHQxIC0gMTUyMTQ4NjUzNCA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDE0MzY5NDU2NSA8PCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXiAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXiAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAgIHMxID0gKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXiAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXiAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgICAgYWIgPSBhICYgYjtcbiAgICAgICAgbWFqID0gYWIgXiAoYSAmIGMpIF4gYmM7XG4gICAgICAgIGNoID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgS1tqXSArIGJsb2Nrc1tqXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgaCA9IGQgKyB0MSA8PCAwO1xuICAgICAgICBkID0gdDEgKyB0MiA8PCAwO1xuICAgICAgfVxuICAgICAgczAgPSAoKGQgPj4+IDIpIHwgKGQgPDwgMzApKSBeICgoZCA+Pj4gMTMpIHwgKGQgPDwgMTkpKSBeICgoZCA+Pj4gMjIpIHwgKGQgPDwgMTApKTtcbiAgICAgIHMxID0gKChoID4+PiA2KSB8IChoIDw8IDI2KSkgXiAoKGggPj4+IDExKSB8IChoIDw8IDIxKSkgXiAoKGggPj4+IDI1KSB8IChoIDw8IDcpKTtcbiAgICAgIGRhID0gZCAmIGE7XG4gICAgICBtYWogPSBkYSBeIChkICYgYikgXiBhYjtcbiAgICAgIGNoID0gKGggJiBlKSBeICh+aCAmIGYpO1xuICAgICAgdDEgPSBnICsgczEgKyBjaCArIEtbaiArIDFdICsgYmxvY2tzW2ogKyAxXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBnID0gYyArIHQxIDw8IDA7XG4gICAgICBjID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGMgPj4+IDIpIHwgKGMgPDwgMzApKSBeICgoYyA+Pj4gMTMpIHwgKGMgPDwgMTkpKSBeICgoYyA+Pj4gMjIpIHwgKGMgPDwgMTApKTtcbiAgICAgIHMxID0gKChnID4+PiA2KSB8IChnIDw8IDI2KSkgXiAoKGcgPj4+IDExKSB8IChnIDw8IDIxKSkgXiAoKGcgPj4+IDI1KSB8IChnIDw8IDcpKTtcbiAgICAgIGNkID0gYyAmIGQ7XG4gICAgICBtYWogPSBjZCBeIChjICYgYSkgXiBkYTtcbiAgICAgIGNoID0gKGcgJiBoKSBeICh+ZyAmIGUpO1xuICAgICAgdDEgPSBmICsgczEgKyBjaCArIEtbaiArIDJdICsgYmxvY2tzW2ogKyAyXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBmID0gYiArIHQxIDw8IDA7XG4gICAgICBiID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGIgPj4+IDIpIHwgKGIgPDwgMzApKSBeICgoYiA+Pj4gMTMpIHwgKGIgPDwgMTkpKSBeICgoYiA+Pj4gMjIpIHwgKGIgPDwgMTApKTtcbiAgICAgIHMxID0gKChmID4+PiA2KSB8IChmIDw8IDI2KSkgXiAoKGYgPj4+IDExKSB8IChmIDw8IDIxKSkgXiAoKGYgPj4+IDI1KSB8IChmIDw8IDcpKTtcbiAgICAgIGJjID0gYiAmIGM7XG4gICAgICBtYWogPSBiYyBeIChiICYgZCkgXiBjZDtcbiAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgdDEgPSBlICsgczEgKyBjaCArIEtbaiArIDNdICsgYmxvY2tzW2ogKyAzXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBlID0gYSArIHQxIDw8IDA7XG4gICAgICBhID0gdDEgKyB0MiA8PCAwO1xuICAgIH1cblxuICAgIHRoaXMuaDAgPSB0aGlzLmgwICsgYSA8PCAwO1xuICAgIHRoaXMuaDEgPSB0aGlzLmgxICsgYiA8PCAwO1xuICAgIHRoaXMuaDIgPSB0aGlzLmgyICsgYyA8PCAwO1xuICAgIHRoaXMuaDMgPSB0aGlzLmgzICsgZCA8PCAwO1xuICAgIHRoaXMuaDQgPSB0aGlzLmg0ICsgZSA8PCAwO1xuICAgIHRoaXMuaDUgPSB0aGlzLmg1ICsgZiA8PCAwO1xuICAgIHRoaXMuaDYgPSB0aGlzLmg2ICsgZyA8PCAwO1xuICAgIHRoaXMuaDcgPSB0aGlzLmg3ICsgaCA8PCAwO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LFxuICAgICAgaDYgPSB0aGlzLmg2LCBoNyA9IHRoaXMuaDc7XG5cbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDAgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gyICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDMgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g1ICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDYgJiAweDBGXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGg3ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNyAmIDB4MEZdO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGEyNTYucHJvdG90eXBlLmhleDtcblxuICBTaGEyNTYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSxcbiAgICAgIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuXG4gICAgdmFyIGFyciA9IFtcbiAgICAgIChoMCA+PiAyNCkgJiAweEZGLCAoaDAgPj4gMTYpICYgMHhGRiwgKGgwID4+IDgpICYgMHhGRiwgaDAgJiAweEZGLFxuICAgICAgKGgxID4+IDI0KSAmIDB4RkYsIChoMSA+PiAxNikgJiAweEZGLCAoaDEgPj4gOCkgJiAweEZGLCBoMSAmIDB4RkYsXG4gICAgICAoaDIgPj4gMjQpICYgMHhGRiwgKGgyID4+IDE2KSAmIDB4RkYsIChoMiA+PiA4KSAmIDB4RkYsIGgyICYgMHhGRixcbiAgICAgIChoMyA+PiAyNCkgJiAweEZGLCAoaDMgPj4gMTYpICYgMHhGRiwgKGgzID4+IDgpICYgMHhGRiwgaDMgJiAweEZGLFxuICAgICAgKGg0ID4+IDI0KSAmIDB4RkYsIChoNCA+PiAxNikgJiAweEZGLCAoaDQgPj4gOCkgJiAweEZGLCBoNCAmIDB4RkYsXG4gICAgICAoaDUgPj4gMjQpICYgMHhGRiwgKGg1ID4+IDE2KSAmIDB4RkYsIChoNSA+PiA4KSAmIDB4RkYsIGg1ICYgMHhGRixcbiAgICAgIChoNiA+PiAyNCkgJiAweEZGLCAoaDYgPj4gMTYpICYgMHhGRiwgKGg2ID4+IDgpICYgMHhGRiwgaDYgJiAweEZGXG4gICAgXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGFyci5wdXNoKChoNyA+PiAyNCkgJiAweEZGLCAoaDcgPj4gMTYpICYgMHhGRiwgKGg3ID4+IDgpICYgMHhGRiwgaDcgJiAweEZGKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmFycmF5ID0gU2hhMjU2LnByb3RvdHlwZS5kaWdlc3Q7XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmg1KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjQsIHRoaXMuaDYpO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKDI4LCB0aGlzLmg3KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBmdW5jdGlvbiBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIHZhciBpLCB0eXBlID0gdHlwZW9mIGtleTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBieXRlcyA9IFtdLCBsZW5ndGggPSBrZXkubGVuZ3RoLCBpbmRleCA9IDAsIGNvZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhjMCB8IChjb2RlID4+IDYpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZTAgfCAoY29kZSA+PiAxMikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhmMCB8IChjb2RlID4+IDE4KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleSA9IGJ5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIGtleS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBrZXkgPSBuZXcgVWludDhBcnJheShrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkubGVuZ3RoID4gNjQpIHtcbiAgICAgIGtleSA9IChuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKSkudXBkYXRlKGtleSkuYXJyYXkoKTtcbiAgICB9XG5cbiAgICB2YXIgb0tleVBhZCA9IFtdLCBpS2V5UGFkID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIHZhciBiID0ga2V5W2ldIHx8IDA7XG4gICAgICBvS2V5UGFkW2ldID0gMHg1YyBeIGI7XG4gICAgICBpS2V5UGFkW2ldID0gMHgzNiBeIGI7XG4gICAgfVxuXG4gICAgU2hhMjU2LmNhbGwodGhpcywgaXMyMjQsIHNoYXJlZE1lbW9yeSk7XG5cbiAgICB0aGlzLnVwZGF0ZShpS2V5UGFkKTtcbiAgICB0aGlzLm9LZXlQYWQgPSBvS2V5UGFkO1xuICAgIHRoaXMuaW5uZXIgPSB0cnVlO1xuICAgIHRoaXMuc2hhcmVkTWVtb3J5ID0gc2hhcmVkTWVtb3J5O1xuICB9XG4gIEhtYWNTaGEyNTYucHJvdG90eXBlID0gbmV3IFNoYTI1NigpO1xuXG4gIEhtYWNTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgdGhpcy5pbm5lciA9IGZhbHNlO1xuICAgICAgdmFyIGlubmVySGFzaCA9IHRoaXMuYXJyYXkoKTtcbiAgICAgIFNoYTI1Ni5jYWxsKHRoaXMsIHRoaXMuaXMyMjQsIHRoaXMuc2hhcmVkTWVtb3J5KTtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMub0tleVBhZCk7XG4gICAgICB0aGlzLnVwZGF0ZShpbm5lckhhc2gpO1xuICAgICAgU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IGNyZWF0ZU1ldGhvZCgpO1xuICBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHM7XG4gIGV4cG9ydHMuc2hhMjI0ID0gY3JlYXRlTWV0aG9kKHRydWUpO1xuICBleHBvcnRzLnNoYTI1Ni5obWFjID0gY3JlYXRlSG1hY01ldGhvZCgpO1xuICBleHBvcnRzLnNoYTIyNC5obWFjID0gY3JlYXRlSG1hY01ldGhvZCh0cnVlKTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2hhMjU2ID0gZXhwb3J0cy5zaGEyNTY7XG4gICAgcm9vdC5zaGEyMjQgPSBleHBvcnRzLnNoYTIyNDtcbiAgICBpZiAoQU1EKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJjb25zdCBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5jb25zdCBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcbmNvbnN0IGN1cnZlID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbmNvbnN0IHsgbWF0aCwgY29udmVydCB9ID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKTtcbmNvbnN0IGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpXG5cbmNvbnN0IGNvbmNhdCA9IEJ1ZmZlci5jb25jYXQ7XG5jb25zdCBHID0gY3VydmUuRztcbmNvbnN0IHAgPSBjdXJ2ZS5wO1xuY29uc3QgbiA9IGN1cnZlLm47XG5jb25zdCB6ZXJvID0gQmlnSW50ZWdlci5aRVJPO1xuXG5mdW5jdGlvbiBjcmVhdGVBZGFwdG9yUG9pbnQocHViS2V5cywgbWVzc2FnZXMsIHJWYWx1ZXMpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rpc2NyZWV0bG9nY29udHJhY3RzL2RsY3NwZWNzL2Jsb2IvYzRmYjEyZDk1YTQyNTVlYWJiODczNjExNDM3ZDA1Yjc0MGJiZWNjYy9DRVRDb21wcmVzc2lvbi5tZCNhZGFwdG9yLXBvaW50cy13aXRoLW11bHRpcGxlLXNpZ25hdHVyZXNcbiAgLy8gcyAqIEcgPSAoczEgKyBzMiArIC4uLiArIHNuKSAqIEcgPSAoUjEgKyBSMiArIC4uLiArIFJuKSArIEgoUjEsIG0xKSAqIFAgKyAuLi4gKyBIKFJuLCBtbikgKiBQXG4gIGNoZWNrLmNoZWNrQ3JlYXRlQWRhcHRvclBvaW50UGFyYW1zKHB1YktleXMsIG1lc3NhZ2VzLCByVmFsdWVzKVxuXG4gIGxldCBzRyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHViS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFAgPSBtYXRoLmxpZnRYKHB1YktleXNbaV0pO1xuICAgIGNvbnN0IFB4ID0gY29udmVydC5pbnRUb0J1ZmZlcihQLmFmZmluZVgpO1xuICAgIGNvbnN0IHIgPSBjb252ZXJ0LmJ1ZmZlclRvSW50KHJWYWx1ZXNbaV0pO1xuICAgIGNvbnN0IGUgPSBtYXRoLmdldEUoY29udmVydC5pbnRUb0J1ZmZlcihyKSwgUHgsIG1lc3NhZ2VzW2ldKTtcbiAgICBjb25zdCBSID0gbWF0aC5saWZ0WChyVmFsdWVzW2ldKTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBzRyA9IFI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNHID0gc0cuYWRkKFIpO1xuICAgIH1cbiAgICBzRyA9IHNHLmFkZChQLm11bHRpcGx5KGUpKTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0LmludFRvQnVmZmVyKHNHLmFmZmluZVgpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFkYXB0b3JTZWNyZXQocHJpdktleXMsIG1lc3NhZ2VzLCBrVmFsdWVzKSB7XG4gIGNoZWNrLmNoZWNrQ3JlYXRlQWRhcHRvclNlY3JldFBhcmFtcyhwcml2S2V5cywgbWVzc2FnZXMsIGtWYWx1ZXMpXG5cbiAgbGV0IHMgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga1ZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcml2S2V5c1tpXVxuICAgIGNvbnN0IFAgPSBHLm11bHRpcGx5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IFB4ID0gY29udmVydC5pbnRUb0J1ZmZlcihQLmFmZmluZVgpO1xuXG4gICAgY29uc3QgZCA9IG1hdGguZ2V0RXZlbktleShQLCBwcml2YXRlS2V5KTtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXVxuICAgIGNvbnN0IGtQcmltZSA9IGtWYWx1ZXNbaV1cblxuICAgIGNvbnN0IFIgPSBHLm11bHRpcGx5KGtQcmltZSk7XG4gICAgY29uc3QgayA9IG1hdGguZ2V0RXZlbktleShSLCBrUHJpbWUpO1xuICAgIGNvbnN0IFJ4ID0gY29udmVydC5pbnRUb0J1ZmZlcihSLmFmZmluZVgpO1xuICAgIGNvbnN0IGUgPSBtYXRoLmdldEUoUngsIFB4LCBtZXNzYWdlKTtcblxuICAgIGlmIChzID09PSBudWxsKSB7XG4gICAgICBzID0ga1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcy5hZGQoaylcbiAgICB9XG4gICAgcyA9IHMuYWRkKGUubXVsdGlwbHkoZCkpXG4gIH1cblxuICByZXR1cm4gY29udmVydC5pbnRUb0J1ZmZlcihzLm1vZChuKSlcbn1cblxuZnVuY3Rpb24gY29tYmluZVNlY3JldHMoc2VjcmV0cykge1xuICBjaGVjay5jaGVja1NlY3JldEFycihzZWNyZXRzKVxuXG4gIGxldCBzID0gY29udmVydC5idWZmZXJUb0ludChzZWNyZXRzWzBdKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHNlY3JldHMubGVuZ3RoOyBpKyspIHtcbiAgICBzID0gcy5hZGQoY29udmVydC5idWZmZXJUb0ludChzZWNyZXRzW2ldKSkubW9kKG4pXG4gIH1cbiAgcmV0dXJuIGNvbnZlcnQuaW50VG9CdWZmZXIocylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUFkYXB0b3JQb2ludCxcbiAgY3JlYXRlQWRhcHRvclNlY3JldCxcbiAgY29tYmluZVNlY3JldHMsXG59O1xuIiwiY29uc3QgeyBjaGVjayB9ID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKVxuXG5cbmNvbnN0IEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbmNvbnN0IGVjdXJ2ZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuY29uc3QgY3VydmUgPSBlY3VydmUuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG5jb25zdCBvbmUgPSBCaWdJbnRlZ2VyLk9ORTtcbmNvbnN0IG4gPSBjdXJ2ZS5uO1xuY29uc3QgcCA9IGN1cnZlLnA7XG5cbmZ1bmN0aW9uIGNoZWNrQnVmZmVyKG5hbWUsIGJ1ZiwgbGVuLCBpZHgpIHtcbiAgY29uc3QgaWR4U3RyID0gKGlkeCAhPT0gdW5kZWZpbmVkID8gJ1snICsgaWR4ICsgJ10nIDogJycpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBpZHhTdHIgKyAnIG11c3QgYmUgYSBCdWZmZXInKTtcbiAgfVxuICBpZiAoYnVmLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBpZHhTdHIgKyAnIG11c3QgYmUgJyArIGxlbiArICcgYnl0ZXMgbG9uZycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2VjcmV0QXJyKHNlY3JldHMpIHtcbiAgY2hlY2suY2hlY2tBcnJheSgnc2VjcmV0cycsIHNlY3JldHMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3JldHMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja0J1ZmZlcignc2VjcmV0cycsIHNlY3JldHNbaV0sIDMyLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja01lc3NhZ2VBcnIobWVzc2FnZXMpIHtcbiAgY2hlY2suY2hlY2tBcnJheSgnbWVzc2FnZXMnLCBtZXNzYWdlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja0J1ZmZlcignbWVzc2FnZScsIG1lc3NhZ2VzW2ldLCAzMiwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcml2YXRlS2V5KHByaXZhdGVLZXksIGlkeCkge1xuICBjb25zdCBpZHhTdHIgPSAoaWR4ICE9PSB1bmRlZmluZWQgPyAnWycgKyBpZHggKyAnXScgOiAnJyk7XG4gIGlmICghQmlnSW50ZWdlci5pc0JpZ0ludGVnZXIocHJpdmF0ZUtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGVLZXknICsgaWR4U3RyICsgJyBtdXN0IGJlIGEgQmlnSW50ZWdlcicpO1xuICB9XG4gIGNoZWNrLmNoZWNrUmFuZ2UoJ3ByaXZhdGVLZXknLCBwcml2YXRlS2V5KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tQcml2YXRlS2V5QXJyKHByaXZhdGVLZXlzKSB7XG4gIGNoZWNrLmNoZWNrQXJyYXkoJ3ByaXZhdGVLZXlzJywgcHJpdmF0ZUtleXMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJpdmF0ZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja1ByaXZhdGVLZXkocHJpdmF0ZUtleXNbaV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tCaWdJbnRlZ2VyKHZhbHVlLCBpZHgpIHtcbiAgY29uc3QgaWR4U3RyID0gKGlkeCAhPT0gdW5kZWZpbmVkID8gJ1snICsgaWR4ICsgJ10nIDogJycpO1xuICBpZiAoIUJpZ0ludGVnZXIuaXNCaWdJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihpZHhTdHIgKyAnIG11c3QgYmUgYSBCaWdJbnRlZ2VyJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tCaWdJbnRlZ2VyQXJyKHZhbHVlcywgaWR4KSB7XG4gIGNvbnN0IGlkeFN0ciA9IChpZHggIT09IHVuZGVmaW5lZCA/ICdbJyArIGlkeCArICddJyA6ICcnKTtcbiAgY2hlY2suY2hlY2tBcnJheShpZHgsIHZhbHVlcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja0JpZ0ludGVnZXIodmFsdWVzW2ldKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS1ZhbHVlKHByaXZhdGVLZXksIGlkeCkge1xuICBjb25zdCBpZHhTdHIgPSAoaWR4ICE9PSB1bmRlZmluZWQgPyAnWycgKyBpZHggKyAnXScgOiAnJyk7XG4gIGlmICghQmlnSW50ZWdlci5pc0JpZ0ludGVnZXIocHJpdmF0ZUtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tWYWx1ZScgKyBpZHhTdHIgKyAnIG11c3QgYmUgYSBCaWdJbnRlZ2VyJyk7XG4gIH1cbiAgY2hlY2suY2hlY2tSYW5nZSgna1ZhbHVlJywgcHJpdmF0ZUtleSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrS1ZhbHVlQXJyKGtWYWx1ZXMpIHtcbiAgY2hlY2suY2hlY2tBcnJheSgnS1ZhbHVlcycsIGtWYWx1ZXMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga1ZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoZWNrS1ZhbHVlKGtWYWx1ZXNbaV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tDcmVhdGVBZGFwdG9yUG9pbnRQYXJhbXMocHViS2V5cywgbWVzc2FnZXMsIHJWYWx1ZXMpIHtcbiAgY2hlY2suY2hlY2tQdWJLZXlBcnIocHViS2V5cylcbiAgY2hlY2tNZXNzYWdlQXJyKG1lc3NhZ2VzKVxuICBjaGVjay5jaGVja05vbmNlQXJyKHJWYWx1ZXMpXG5cbiAgaWYgKHB1YktleXMubGVuZ3RoICE9PSBtZXNzYWdlcy5sZW5ndGggfHwgbWVzc2FnZXMubGVuZ3RoICE9PSByVmFsdWVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tDcmVhdGVBZGFwdG9yU2VjcmV0UGFyYW1zKHByaXZLZXlzLCBtZXNzYWdlcywga1ZhbHVlcykge1xuICBjaGVja1ByaXZhdGVLZXlBcnIocHJpdktleXMpO1xuICBjaGVja01lc3NhZ2VBcnIobWVzc2FnZXMpO1xuICBjaGVja0tWYWx1ZUFycihrVmFsdWVzKTtcblxuICBpZiAocHJpdktleXMubGVuZ3RoICE9PSBtZXNzYWdlcy5sZW5ndGggfHwgbWVzc2FnZXMubGVuZ3RoICE9PSBrVmFsdWVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrQ3JlYXRlQWRhcHRvclBvaW50UGFyYW1zLFxuICBjaGVja0NyZWF0ZUFkYXB0b3JTZWNyZXRQYXJhbXMsXG4gIGNoZWNrU2VjcmV0QXJyXG59O1xuIiwiaW1wb3J0IHsgZGFya2lmeSB9IGZyb20gXCIuL3V0aWwvZHJcIjtcbmltcG9ydCB7IHByb2Nlc3NUZW1wbGF0ZSB9IGZyb20gXCIuL3V0aWwvdGVtcGxhdGVzXCI7XG5pbXBvcnQgeyBTY2hub3JyQXBpLCBzY2hub3JyQXBpIH0gZnJvbSBcIi4vdXRpbC9zY2hub3JyXCJcbmltcG9ydCB7IFR4QXBpLCB0eEFwaSB9IGZyb20gXCIuL3V0aWwvdHhcIlxuXG5cbmludGVyZmFjZSBNYXJsb3dlQ29udHJhY3Qge1xuICAgIHRlbXBsYXRlOiBzdHJpbmdcbiAgICB0ZXJtczoge1trZXk6IHN0cmluZ106IG51bWJlcn1cbn1cblxuaW50ZXJmYWNlIFNhbXBsZWRSb3cge1xuICAgIG9yYWNsZVZhbHVlOiBudW1iZXIsXG4gICAgYWxpY2VQYXlvdXQ6IG51bWJlcixcbiAgICBib2JQYXlvdXQ6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgQ29udHJhY3RBcGkge1xuICAgIHN0YXRlOiBOb3RlYm9va1N0YXRlXG4gICAgaW5qZWN0TWFybG93ZUNvbnRyYWN0OiAoYzogTWFybG93ZUNvbnRyYWN0LCB1cGRhdGU6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD5cbiAgICBzYW1wbGVNYXJsb3dlQ29udHJhY3Q6ICgpID0+IHZvaWRcbiAgICBwbG90TWFybG93ZUNvbnRyYWN0QWxwaGE6ICgpID0+IHZvaWRcbiAgICBkb3dubG9hZFNhbXBsZWRDb250cmFjdEFzQ3N2OiAoKSA9PiB2b2lkXG4gICAgZ2VuZXJhdGVXb2xmTmJVcmk6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGRvd25sb2FkV29sZk5iOiAoKSA9PiB2b2lkXG4gICAgZW1iZWRXb2xmUGxvdDogKGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpID0+IHZvaWRcbiAgICBzY2hub3JyQXBpOiAoKSA9PiBTY2hub3JyQXBpXG4gICAgdHhBcGk6ICgpID0+IFR4QXBpXG59XG5cbmludGVyZmFjZSBOb3RlYm9va1N0YXRlIHtcbiAgICBpc01hcmxvd2VDb250cmFjdEdlbmVyYXRlZDogYm9vbGVhblxuICAgIGlzTWFybG93ZUNvbnRyYWN0U2FtcGxlZDogYm9vbGVhblxuICAgIHNhbXBsaW5nSW5Qcm9ncmVzczogYm9vbGVhblxuICAgIHNhbXBsaW5nUHJvZ3Jlc3M/OiBudW1iZXJcbiAgICBzYW1wbGU/OiBTYW1wbGVkUm93W11cbiAgICBjb250cmFjdD86IE1hcmxvd2VDb250cmFjdFxuICAgIHRlbXBsYXRlPzogc3RyaW5nXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgV2luZG93IHsgXG4gICAgICAgIGRhcmtpZmllcjogYW55XG4gICAgICAgIG1hcmxvd2VXaW5kb3c/OiAoKSA9PiBQcm9taXNlPFdpbmRvdz5cbiAgICAgICAgYXBpOiBDb250cmFjdEFwaVxuICAgICAgICBtb25hY286IGFueVxuICAgICAgICB0aWNrOiBudW1iZXJcbiAgICAgICAgYWN0aXZlVGlja2VyOiBudW1iZXJcbiAgICAgICAgd2ZBcHBJZDogc3RyaW5nXG4gICAgICAgIGNvcnNQcm94eVByZWZpeDogc3RyaW5nXG4gICAgICAgIGlzTWFybG93ZTogYm9vbGVhblxuICAgIH1cbn1cblxuXG5cbmRhcmtpZnkod2luZG93LmRvY3VtZW50KVxuXG5pZiAod2luZG93Lm1hcmxvd2VXaW5kb3cgIT0gdW5kZWZpbmVkICYmICF3aW5kb3cuaXNNYXJsb3dlKSB7XG4gICAgY29uc29sZS5sb2coJ2luaXQgYXBpLi4uJylcbiAgICB3aW5kb3cubWFybG93ZVdpbmRvdygpLnRoZW4obXcgPT4ge1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgd2luZG93LmFwaSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgaXNNYXJsb3dlQ29udHJhY3RHZW5lcmF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzTWFybG93ZUNvbnRyYWN0U2FtcGxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2FtcGxpbmdJblByb2dyZXNzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjaG5vcnJBcGk6IHNjaG5vcnJBcGksXG4gICAgICAgICAgICB0eEFwaTogdHhBcGksXG4gICAgICAgICAgICBpbmplY3RNYXJsb3dlQ29udHJhY3Q6IGFzeW5jIChjOiBNYXJsb3dlQ29udHJhY3QsIHVwZGF0ZVN0YXRlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYXBpLnN0YXRlLmNvbnRyYWN0ID0gY1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWFybG93ZUhvbWUgPSBtdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmgtMTBcIikgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICBtYXJsb3dlSG9tZT8uY2xpY2soKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBkb250U2F2ZSA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubXItbWVkaXVtXCIpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgZG9udFNhdmU/LmNsaWNrKClcblxuICAgICAgICAgICAgICAgIGxldCByYXdcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmFwaS5zdGF0ZS50ZW1wbGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gYXdhaXQgKGF3YWl0IGZldGNoKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBgL21hcmxvd2Utd29sZnJhbS13ZWJkb2MvY29udHJhY3RzLyR7Yy50ZW1wbGF0ZX0ubWFybG93ZWApKS50ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFwaS5zdGF0ZS50ZW1wbGF0ZSA9IHJhd1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gd2luZG93LmFwaS5zdGF0ZS50ZW1wbGF0ZVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGdvVG9FZGl0b3IgPSBtdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXItNCcpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgZ29Ub0VkaXRvcj8uY2xpY2soKVxuXG5cbiAgICAgICAgICAgICAgICBsZXQgbWVudUJhciA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWVudS1iYXJcIikgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICBtZW51QmFyPy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJkaXNwbGF5OiBub25lXCIpXG5cbiAgICAgICAgICAgICAgICBsZXQgbWV0YSA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGV4dC1zZWNvbmRhcnlcIikgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICBtZXRhPy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJkaXNwbGF5OiBub25lXCIpXG5cbiAgICAgICAgICAgICAgICBsZXQgc3RhdGljQW5hbHlzaXMgPSBtdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRleHQtZ3JheS1kYXJrZXN0XCIpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgc3RhdGljQW5hbHlzaXM/LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBcImRpc3BsYXk6IG5vbmVcIilcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgdG9JbmplY3QgPSBwcm9jZXNzVGVtcGxhdGUoYy50ZW1wbGF0ZSwgYy50ZXJtcywgcmF3KVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbXcubW9uYWNvLmVkaXRvci5nZXRNb2RlbHMoKVttdy5tb25hY28uZWRpdG9yLmdldE1vZGVscygpLmxlbmd0aCAtIDJdLmRpc3Bvc2UoKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXdhaXQgbXcubW9uYWNvLmVkaXRvci5nZXRNb2RlbHMoKVttdy5tb25hY28uZWRpdG9yLmdldE1vZGVscygpLmxlbmd0aCAtIDFdLnNldFZhbHVlKHRvSW5qZWN0KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBnb1RvQmxvY2tzID0gbXcuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmdyb3VwJyk/LnF1ZXJ5U2VsZWN0b3IoJy5idG4nKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIGdvVG9CbG9ja3M/LmNsaWNrKClcblxuICAgICAgICAgICAgICAgIGxldCBjYW5jZWwgPSBtdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnVwcGVyY2FzZVwiKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgIGNhbmNlbD8uY2xpY2soKVxuXG4gICAgICAgICAgICAgICAgd2luZG93LmFwaS5zdGF0ZS5pc01hcmxvd2VDb250cmFjdEdlbmVyYXRlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJzdGF0ZVwiKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1wbGVNYXJsb3dlQ29udHJhY3Q6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJzYW1wbGluZy1zdGFydGVkXCIpKVxuICAgICAgICAgICAgICAgIHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxpbmdJblByb2dyZXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxlID0gW11cbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gMTAwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5hcGkuc3RhdGUuY29udHJhY3QhLnRlcm1zLm1pblZhbHVlOyBpIDw9IHdpbmRvdy5hcGkuc3RhdGUuY29udHJhY3QhLnRlcm1zLm1heFZhbHVlOyBpKz1zdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0geyAuLi53aW5kb3cuYXBpLnN0YXRlLmNvbnRyYWN0ISwgdGVybXM6IHsuLi53aW5kb3cuYXBpLnN0YXRlLmNvbnRyYWN0IS50ZXJtc30sIH1cblxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJzYW1wbGluZy1zdGVwXCIpKVxuICAgICAgICAgICAgICAgICAgICBjLnRlcm1zLm1pblZhbHVlID0gaVxuICAgICAgICAgICAgICAgICAgICBjLnRlcm1zLm1heFZhbHVlID0gaVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYXBpLnN0YXRlLnNhbXBsaW5nUHJvZ3Jlc3MgPSAoaSAtIHdpbmRvdy5hcGkuc3RhdGUuY29udHJhY3QhLnRlcm1zLm1pblZhbHVlKSAvICh3aW5kb3cuYXBpLnN0YXRlLmNvbnRyYWN0IS50ZXJtcy5tYXhWYWx1ZSAtIHdpbmRvdy5hcGkuc3RhdGUuY29udHJhY3QhLnRlcm1zLm1pblZhbHVlKVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5hcGkuaW5qZWN0TWFybG93ZUNvbnRyYWN0KGMsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpKVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VuZFRvU2ltdWxhdG9yID0gbXcuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJylbMV0gYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHNlbmRUb1NpbXVsYXRvclsnZGlzYWJsZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBV0FJVFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDEwMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDMwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFRvU2ltdWxhdG9yLmNsaWNrKClcbiAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0U2ltdWxhdGlvbiA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpWzJdIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2ltdWxhdGlvbi5jbGljaygpXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaWNlRGVwb3NpdCA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wbHVzLWJ0bicpIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGFsaWNlRGVwb3NpdD8uY2xpY2soKVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBib2JEZXBvc2l0ID0gbXcuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBsdXMtYnRuJykgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgYm9iRGVwb3NpdD8uY2xpY2soKVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBza2lwVG9FeGVyY2lzZSA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wbHVzLWJ0bicpWzJdIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHNraXBUb0V4ZXJjaXNlPy5jbGljaygpXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm0gPSBtdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGx1cy1idG4nKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtPy5jbGljaygpXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvZyA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ncmlkLWNvbHMtZGVzY3JpcHRpb24tbG9jYXRpb24nKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmFjdEJvYlBheW9mZk9wdCA9IC9UaGUgY29udHJhY3QgcGF5cyDigrMgKFxcZCspIGZyb20gYWNjb3VudCBvZiBCb2IgdG8gQm9iIHdhbGxldC8uZXhlYyhsb2cuaW5uZXJUZXh0KT8uWzFdXG4gICAgICAgICAgICAgICAgICAgIGxldCBleHRyYWN0QWxpY2VQYXlvZmZPcHQgPSAvVGhlIGNvbnRyYWN0IHBheXMg4oKzIChcXGQrKSBmcm9tIGFjY291bnQgb2YgQWxpY2UgdG8gQWxpY2Ugd2FsbGV0Ly5leGVjKGxvZy5pbm5lclRleHQpPy5bMV1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvYlBheW9mZiA9IGV4dHJhY3RCb2JQYXlvZmZPcHQgPT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VJbnQoZXh0cmFjdEJvYlBheW9mZk9wdCkpID8gMCA6IHBhcnNlSW50KGV4dHJhY3RCb2JQYXlvZmZPcHQpXG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGljZVBheW9mZiA9IGV4dHJhY3RBbGljZVBheW9mZk9wdCA9PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZUludChleHRyYWN0QWxpY2VQYXlvZmZPcHQpKSA/IDAgOiBwYXJzZUludChleHRyYWN0QWxpY2VQYXlvZmZPcHQpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh3aW5kb3cuYXBpLnN0YXRlLnNhbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFwaS5zdGF0ZS5zYW1wbGUucHVzaCh7b3JhY2xlVmFsdWU6IGksIGFsaWNlUGF5b3V0OiBhbGljZVBheW9mZiwgYm9iUGF5b3V0OiBib2JQYXlvZmZ9KVxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kU2ltdWxhdGlvbiA9IG13LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpWzBdIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGVuZFNpbXVsYXRpb24uY2xpY2soKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxlKVxuICAgICAgICAgICAgICAgIHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxpbmdJblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aW5kb3cuYXBpLnN0YXRlLmlzTWFybG93ZUNvbnRyYWN0U2FtcGxlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJzdGF0ZVwiKSlcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJzYW1wbGVkXCIpKVxuICAgICAgICAgICAgICAgIHdpbmRvdy5hcGkuaW5qZWN0TWFybG93ZUNvbnRyYWN0KHdpbmRvdy5hcGkuc3RhdGUuY29udHJhY3QhLCBmYWxzZSlcblxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGxvdE1hcmxvd2VDb250cmFjdEFscGhhOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBlbmNvZGVVUklDb21wb25lbnQoJ3Bsb3QgJyArIHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxlLm1hcChyb3cgPT4gYCgke3Jvdy5vcmFjbGVWYWx1ZX0sICR7cm93LmFsaWNlUGF5b3V0fSlgKSlcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly93d3cud29sZnJhbWFscGhhLmNvbS9pbnB1dD9pPScgKyBxdWVyeVxuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb3dubG9hZFNhbXBsZWRDb250cmFjdEFzQ3N2OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNzdkNvbnRlbnQgPSBcImRhdGE6dGV4dC9jc3Y7Y2hhcnNldD11dGYtOCxcXG5vcmFjbGUsYWxpY2UsYm9iXFxuXCIgKyB3aW5kb3cuYXBpLnN0YXRlLnNhbXBsZS5tYXAocm93ID0+IGAke3Jvdy5vcmFjbGVWYWx1ZX0sICR7cm93LmFsaWNlUGF5b3V0fSwgJHtyb3cuYm9iUGF5b3V0fWApLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgbGV0IGVuY29kZWRVcmkgPSBlbmNvZGVVUkkoY3N2Q29udGVudCk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oZW5jb2RlZFVyaSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVXb2xmTmJVcmk6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIGAvbWFybG93ZS13b2xmcmFtLXdlYmRvYy9ub3RlYm9va3Mvd29sZnJhbS1wbG90Lm5iYFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IChhd2FpdCAoYXdhaXQgZmV0Y2godXJsKSkudGV4dCgpKVxuICAgICAgICAgICAgICAgIGxldCByb3dib3ggPSByb3cgPT4gYFJvd0JveFt7XCJ7XCIsUm93Qm94W3tcIiR7cm93Lm9yYWNsZVZhbHVlfVwiLFwiLFwiLFwiIFwiLFwiJHtyb3cuYWxpY2VQYXlvdXR9XCJ9XSxcIn1cIn1dYFxuICAgICAgICAgICAgICAgIGxldCBwb2ludHMgPSB3aW5kb3cuYXBpLnN0YXRlLnNhbXBsZS5tYXAocm93Ym94KS5qb2luKGAsXCIsXCIsXCIgXCIsYCk7XG4gICAgICAgICAgICAgICAgbGV0IG5iID0gdGVtcGxhdGUucmVwbGFjZShgUm93Qm94W3tcIntcIixSb3dCb3hbe1wiMVwiLFwiLFwiLFwiIFwiLFwiMVwifV0sXCJ9XCJ9XSxcIixcIixcIiBcIixSb3dCb3hbe1wie1wiLFJvd0JveFt7XCIyXCIsXCIsXCIsXCIgXCIsXCIyXCJ9XSxcIn1cIn1dYCwgcG9pbnRzKVxuICAgICAgICAgICAgICAgIGxldCBuYkNvbnRlbnQgPSBcImRhdGE6dGV4dC9wbGFpbjtiYXNlNjQsXCIgKyBidG9hKG5iKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUkkobmJDb250ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvd25sb2FkV29sZk5iOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gJ3dvbGZyYW0tcGxvdC5uYidcbiAgICAgICAgICAgICAgICBsaW5rLmhyZWYgPSBhd2FpdCB3aW5kb3cuYXBpLmdlbmVyYXRlV29sZk5iVXJpKClcbiAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWJlZFdvbGZQbG90OiBhc3luYyAoY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPHNwYW4gaWQ9XCJpbWctbG9hZGluZy1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBlbmNvZGVVUklDb21wb25lbnQoJ3Bsb3QgJyArIHdpbmRvdy5hcGkuc3RhdGUuc2FtcGxlLm1hcChyb3cgPT4gYCgke3Jvdy5vcmFjbGVWYWx1ZX0sICR7cm93LmFsaWNlUGF5b3V0fSlgKS5qb2luKFwiLFwiKSlcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwxID0gYGh0dHBzOi8vYXBpLndvbGZyYW1hbHBoYS5jb20vdjIvcXVlcnk/aW5wdXQ9JHtxdWVyeX0mYXBwaWQ9JHt3aW5kb3cud2ZBcHBJZH0mb3V0cHV0PUpTT05gXG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHlVcmwgPSB3aW5kb3cuY29yc1Byb3h5UHJlZml4ICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybDEpXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IChhd2FpdCAoYXdhaXQgZmV0Y2gocHJveHlVcmwpKS5qc29uKCkpXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsMiA9IHJlc3VsdC5xdWVyeXJlc3VsdC5wb2RzWzFdLnN1YnBvZHNbMF0uaW1nLnNyY1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVybDIpXG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IHVybDJcbiAgICAgICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCI1MDBcIilcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJydcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBgaHR0cHM6Ly9hcGkud29sZnJhbWFscGhhLmNvbS92MS9yZXN1bHQ/YXBwaWQ9JHt3aW5kb3cud2ZBcHBJZH0maT0xJTIwYnRjJTIwdG8lMjB1c2QlMjBudW1iZXJgXG4gICAgICAgICAgICBjb25zdCB1cmwgPSB3aW5kb3cuY29yc1Byb3h5UHJlZml4ICsgZW5jb2RlVVJJQ29tcG9uZW50KG9yaWdpbmFsKVxuICAgIFxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gZmV0Y2godXJsKVxuICAgICAgICAgICAgbGV0IHJhdyA9IChhd2FpdCAoYXdhaXQgcmVzcG9uc2UpLnRleHQoKSlcbiAgICAgICAgICAgIGxldCByeCA9IC9cXGQrL2c7XG4gICAgICAgICAgICBsZXQgcmVzID0gcnguZXhlYyhyYXcpXG4gICAgICAgICAgICBpZiAocmVzICE9IG51bGwpIHdpbmRvdy50aWNrID0gcGFyc2VJbnQocmVzWzBdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwidGlja1wiKSlcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHBvbGwoKVxuICAgICAgICBzZXRJbnRlcnZhbChwb2xsLCAxMDAwMClcbiAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2xvY2tcIikpLCA1MDApXG5cbiAgICB9KVxuXG5cbiAgICBcbn1cblxuIiwiaW1wb3J0IHtcbiAgICBlbmFibGUgYXMgZW5hYmxlRGFya01vZGUsXG4gICAgZXhwb3J0R2VuZXJhdGVkQ1NTIGFzIGNvbGxlY3RDU1MsXG4gICAgc2V0RmV0Y2hNZXRob2QgYXMgc2V0RmV0Y2hNZXRob2Rcbn0gZnJvbSAnZGFya3JlYWRlcic7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKGRvYywgc3R5bGVTdHJpbmcpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVTdHJpbmc7XG4gICAgZG9jLmhlYWQuYXBwZW5kKHN0eWxlKTtcbn1cblxuZXhwb3J0IGNvbnN0IGRhcmtpZnkgPSBhc3luYyAoZG9jKSA9PiB7XG4gICAgc2V0RmV0Y2hNZXRob2Qod2luZG93LmZldGNoKVxuXG4gICAgZW5hYmxlRGFya01vZGUoe1xuICAgICAgICBicmlnaHRuZXNzOiAxMDAsXG4gICAgICAgIGNvbnRyYXN0OiA5MCxcbiAgICAgICAgc2VwaWE6IDEwLFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IENTUyA9IGF3YWl0IGNvbGxlY3RDU1MoKTtcbiAgICBhZGRTdHlsZShkb2MsIENTUylcblxufVxuXG5jb25zb2xlLmxvZyh3aW5kb3cubG9jYXRpb24uaHJlZikiLCJleHBvcnQgY29uc3Qgc2lnbiA9IChwazEsIHBrMiwgc2VjcmV0MSwgc2VjcmV0MiwgbXNnKSA9PiB7XG4gICAgY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG4gICAgY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4gICAgY29uc3QgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbiAgICBjb25zdCBjb252ZXJ0ID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKS5jb252ZXJ0XG4gICAgY29uc3QgbXVTaWcgPSByZXF1aXJlKCdiaXAtc2Nobm9ycicpLm11U2lnXG4gICAgY29uc3Qgc2Nobm9yciA9IHJlcXVpcmUoJ2JpcC1zY2hub3JyJylcbiAgICBjb25zdCBtYXRoID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKS5tYXRoXG4gICAgY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xuICAgIGNvbnN0IGVjdXJ2ZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuXG4gICAgY29uc3QgY3VydmUgPSBlY3VydmUuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG4gICAgY29uc3QgcmFuZG9tQnVmZmVyID0gKGxlbikgPT4gQnVmZmVyLmZyb20ocmFuZG9tQnl0ZXMobGVuKSk7XG5cbiAgICBjb25zdCBwdWJsaWNEYXRhID0ge1xuICAgICAgICBwdWJLZXlzOiBbXG4gICAgICAgICAgQnVmZmVyLmZyb20ocGsxLCAnaGV4JyksXG4gICAgICAgICAgQnVmZmVyLmZyb20ocGsyLCAnaGV4JylcbiAgICAgICAgXSxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBwdWJLZXlIYXNoOiBudWxsLFxuICAgICAgICBwdWJLZXlDb21iaW5lZDogbnVsbCxcbiAgICAgICAgcHViS2V5UGFyaXR5OiBudWxsLFxuICAgICAgICBjb21taXRtZW50czogW10sXG4gICAgICAgIG5vbmNlczogW10sXG4gICAgICAgIG5vbmNlQ29tYmluZWQ6IG51bGwsXG4gICAgICAgIHBhcnRpYWxTaWduYXR1cmVzOiBbXSxcbiAgICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgfTtcbiAgICBcbiAgICAgIC8vIGRhdGEgb25seSBrbm93biBieSB0aGUgaW5kaXZpZHVhbCBwYXJ0eSwgdGhlc2UgdmFsdWVzIGFyZSBuZXZlciBzaGFyZWRcbiAgICAgIC8vIGJldHdlZW4gdGhlIHNpZ25lcnMhXG4gICAgICBjb25zdCBzaWduZXJQcml2YXRlRGF0YSA9IFtcbiAgICAgICAgLy8gc2lnbmVyIDFcbiAgICAgICAge1xuICAgICAgICAgIHByaXZhdGVLZXk6IEJpZ0ludGVnZXIuZnJvbUhleChzZWNyZXQxKSxcbiAgICAgICAgICBzZXNzaW9uOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICAvLyBzaWduZXIgMlxuICAgICAgICB7XG4gICAgICAgICAgcHJpdmF0ZUtleTogQmlnSW50ZWdlci5mcm9tSGV4KHNlY3JldDIpLFxuICAgICAgICAgIHNlc3Npb246IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgIFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFN0ZXAgMTogQ29tYmluZSB0aGUgcHVibGljIGtleXNcbiAgICAgIC8vIFRoZSBwdWJsaWMga2V5cyBQX2kgYXJlIGNvbWJpbmVkIGludG8gdGhlIGNvbWJpbmVkIHB1YmxpYyBrZXkgUC5cbiAgICAgIC8vIFRoaXMgY2FuIGJlIGRvbmUgYnkgZXZlcnkgc2lnbmVyIGluZGl2aWR1YWxseSBvciBieSB0aGUgaW5pdGlhbGl6aW5nXG4gICAgICAvLyBwYXJ0eSBhbmQgdGhlbiBiZSBkaXN0cmlidXRlZCB0byBldmVyeSBwYXJ0aWNpcGFudC5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBwdWJsaWNEYXRhLnB1YktleUhhc2ggPSBtdVNpZy5jb21wdXRlRWxsKHB1YmxpY0RhdGEucHViS2V5cyk7XG4gICAgICBjb25zdCBwa0NvbWJpbmVkID0gbXVTaWcucHViS2V5Q29tYmluZShwdWJsaWNEYXRhLnB1YktleXMsIHB1YmxpY0RhdGEucHViS2V5SGFzaCk7XG4gICAgICBwdWJsaWNEYXRhLnB1YktleUNvbWJpbmVkID0gY29udmVydC5pbnRUb0J1ZmZlcihwa0NvbWJpbmVkLmFmZmluZVgpO1xuICAgICAgcHVibGljRGF0YS5wdWJLZXlQYXJpdHkgPSBtYXRoLmlzRXZlbihwa0NvbWJpbmVkKTtcbiAgICBcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTdGVwIDI6IENyZWF0ZSB0aGUgcHJpdmF0ZSBzaWduaW5nIHNlc3Npb25cbiAgICAgIC8vIEVhY2ggc2lnbmluZyBwYXJ0eSBkb2VzIHRoaXMgaW4gcHJpdmF0ZS4gVGhlIHNlc3Npb24gSUQgKm11c3QqIGJlXG4gICAgICAvLyB1bmlxdWUgZm9yIGV2ZXJ5IGNhbGwgdG8gc2Vzc2lvbkluaXRpYWxpemUsIG90aGVyd2lzZSBpdCdzIHRyaXZpYWwgZm9yXG4gICAgICAvLyBhbiBhdHRhY2tlciB0byBleHRyYWN0IHRoZSBzZWNyZXQga2V5IVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHNpZ25lclByaXZhdGVEYXRhLmZvckVhY2goKGRhdGEsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSByYW5kb21CdWZmZXIoMzIpOyAvLyBtdXN0IG5ldmVyIGJlIHJldXNlZCBiZXR3ZWVuIHNlc3Npb25zIVxuICAgICAgICBkYXRhLnNlc3Npb24gPSBtdVNpZy5zZXNzaW9uSW5pdGlhbGl6ZShcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgZGF0YS5wcml2YXRlS2V5LFxuICAgICAgICAgIHB1YmxpY0RhdGEubWVzc2FnZSxcbiAgICAgICAgICBwdWJsaWNEYXRhLnB1YktleUNvbWJpbmVkLFxuICAgICAgICAgIHB1YmxpY0RhdGEucHViS2V5UGFyaXR5LFxuICAgICAgICAgIHB1YmxpY0RhdGEucHViS2V5SGFzaCxcbiAgICAgICAgICBpZHhcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2lnbmVyU2Vzc2lvbiA9IHNpZ25lclByaXZhdGVEYXRhWzBdLnNlc3Npb247XG4gICAgXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU3RlcCAzOiBFeGNoYW5nZSBjb21taXRtZW50cyAoY29tbXVuaWNhdGlvbiByb3VuZCAxKVxuICAgICAgLy8gVGhlIHNpZ25lcnMgbm93IGV4Y2hhbmdlIHRoZSBjb21taXRtZW50cyBIKFJfaSkuIFRoaXMgaXMgc2ltdWxhdGVkIGhlcmVcbiAgICAgIC8vIGJ5IGNvcHlpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBwcml2YXRlIGRhdGEgdG8gcHVibGljIGRhdGEgYXJyYXkuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJsaWNEYXRhLnB1YktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHVibGljRGF0YS5jb21taXRtZW50c1tpXSA9IHNpZ25lclByaXZhdGVEYXRhW2ldLnNlc3Npb24uY29tbWl0bWVudDtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTdGVwIDQ6IEdldCBub25jZXMgKGNvbW11bmljYXRpb24gcm91bmQgMilcbiAgICAgIC8vIE5vdyB0aGF0IGV2ZXJ5Ym9keSBoYXMgY29tbWl0ZWQgdG8gdGhlIHNlc3Npb24sIHRoZSBub25jZXMgKFJfaSkgY2FuIGJlXG4gICAgICAvLyBleGNoYW5nZWQuIEFnYWluLCB0aGlzIGlzIHNpbXVsYXRlZCBieSBjb3B5aW5nLlxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljRGF0YS5wdWJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHB1YmxpY0RhdGEubm9uY2VzW2ldID0gc2lnbmVyUHJpdmF0ZURhdGFbaV0uc2Vzc2lvbi5ub25jZTtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTdGVwIDU6IENvbWJpbmUgbm9uY2VzXG4gICAgICAvLyBUaGUgbm9uY2VzIGNhbiBub3cgYmUgY29tYmluZWQgaW50byBSLiBFYWNoIHBhcnRpY2lwYW50IHNob3VsZCBkbyB0aGlzXG4gICAgICAvLyBhbmQga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBub25jZSB3YXMgbmVnYXRlZCBvciBub3QuIFRoaXMgaXMgbmVlZGVkXG4gICAgICAvLyBmb3IgdGhlIGxhdGVyIHN0ZXBzLlxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIHB1YmxpY0RhdGEubm9uY2VDb21iaW5lZCA9IG11U2lnLnNlc3Npb25Ob25jZUNvbWJpbmUoc2lnbmVyU2Vzc2lvbiwgcHVibGljRGF0YS5ub25jZXMpO1xuICAgICAgc2lnbmVyUHJpdmF0ZURhdGEuZm9yRWFjaChkYXRhID0+IChkYXRhLnNlc3Npb24uY29tYmluZWROb25jZVBhcml0eSA9IHNpZ25lclNlc3Npb24uY29tYmluZWROb25jZVBhcml0eSkpO1xuICAgIFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFN0ZXAgNjogR2VuZXJhdGUgcGFydGlhbCBzaWduYXR1cmVzXG4gICAgICAvLyBFdmVyeSBwYXJ0aWNpcGFudCBjYW4gbm93IGNyZWF0ZSB0aGVpciBwYXJ0aWFsIHNpZ25hdHVyZSBzX2kgb3ZlciB0aGVcbiAgICAgIC8vIGdpdmVuIG1lc3NhZ2UuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgc2lnbmVyUHJpdmF0ZURhdGEuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgICAgZGF0YS5zZXNzaW9uLnBhcnRpYWxTaWduYXR1cmUgPSBtdVNpZy5wYXJ0aWFsU2lnbihkYXRhLnNlc3Npb24sIHB1YmxpY0RhdGEubWVzc2FnZSwgcHVibGljRGF0YS5ub25jZUNvbWJpbmVkLCBwdWJsaWNEYXRhLnB1YktleUNvbWJpbmVkKTtcbiAgICAgIH0pO1xuICAgIFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFN0ZXAgNzogRXhjaGFuZ2UgcGFydGlhbCBzaWduYXR1cmVzIChjb21tdW5pY2F0aW9uIHJvdW5kIDMpXG4gICAgICAvLyBUaGUgcGFydGlhbCBzaWduYXR1cmUgb2YgZWFjaCBzaWduZXIgaXMgZXhjaGFuZ2VkIHdpdGggdGhlIG90aGVyXG4gICAgICAvLyBwYXJ0aWNpcGFudHMuIFNpbXVsYXRlZCBoZXJlIGJ5IGNvcHlpbmcuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJsaWNEYXRhLnB1YktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHVibGljRGF0YS5wYXJ0aWFsU2lnbmF0dXJlc1tpXSA9IHNpZ25lclByaXZhdGVEYXRhW2ldLnNlc3Npb24ucGFydGlhbFNpZ25hdHVyZTtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTdGVwIDg6IFZlcmlmeSBpbmRpdmlkdWFsIHBhcnRpYWwgc2lnbmF0dXJlc1xuICAgICAgLy8gRXZlcnkgcGFydGljaXBhbnQgc2hvdWxkIHZlcmlmeSB0aGUgcGFydGlhbCBzaWduYXR1cmVzIHJlY2VpdmVkIGJ5IHRoZVxuICAgICAgLy8gb3RoZXIgcGFydGljaXBhbnRzLlxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljRGF0YS5wdWJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG11U2lnLnBhcnRpYWxTaWdWZXJpZnkoXG4gICAgICAgICAgc2lnbmVyU2Vzc2lvbixcbiAgICAgICAgICBwdWJsaWNEYXRhLnBhcnRpYWxTaWduYXR1cmVzW2ldLFxuICAgICAgICAgIHB1YmxpY0RhdGEubm9uY2VDb21iaW5lZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHB1YmxpY0RhdGEucHViS2V5c1tpXSxcbiAgICAgICAgICBwdWJsaWNEYXRhLm5vbmNlc1tpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFN0ZXAgOTogQ29tYmluZSBwYXJ0aWFsIHNpZ25hdHVyZXNcbiAgICAgIC8vIEZpbmFsbHksIHRoZSBwYXJ0aWFsIHNpZ25hdHVyZXMgY2FuIGJlIGNvbWJpbmVkIGludG8gdGhlIGZ1bGwgc2lnbmF0dXJlXG4gICAgICAvLyAocywgUikgdGhhdCBjYW4gYmUgdmVyaWZpZWQgYWdhaW5zdCBjb21iaW5lZCBwdWJsaWMga2V5IFAuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgcHVibGljRGF0YS5zaWduYXR1cmUgPSBtdVNpZy5wYXJ0aWFsU2lnQ29tYmluZShwdWJsaWNEYXRhLm5vbmNlQ29tYmluZWQsIHB1YmxpY0RhdGEucGFydGlhbFNpZ25hdHVyZXMpO1xuICAgIFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFN0ZXAgMTA6IFZlcmlmeSBzaWduYXR1cmVcbiAgICAgIC8vIFRoZSByZXN1bHRpbmcgc2lnbmF0dXJlIGNhbiBub3cgYmUgdmVyaWZpZWQgYXMgYSBub3JtYWwgU2Nobm9yclxuICAgICAgLy8gc2lnbmF0dXJlIChzLCBSKSBvdmVyIHRoZSBtZXNzYWdlIG0gYW5kIHB1YmxpYyBrZXkgUC5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBzY2hub3JyLnZlcmlmeShwdWJsaWNEYXRhLnB1YktleUNvbWJpbmVkLCBwdWJsaWNEYXRhLm1lc3NhZ2UsIHB1YmxpY0RhdGEuc2lnbmF0dXJlKTtcblxuICAgICAgcmV0dXJuIHB1YmxpY0RhdGEuc2lnbmF0dXJlLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgfVxuIiwiXG5pbXBvcnQgYWRhcHRvciA9IHJlcXVpcmUoXCJzY2hub3JyLWFkYXB0b3ItcG9pbnRzL3NyYy9hZGFwdG9yLmpzXCIpXG5pbXBvcnQgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbmNvbnN0IHsgbWF0aCwgY29udmVydCB9ID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKTtcbmltcG9ydCBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxuY29uc3QgY3VydmUgPSBlY3VydmUuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuY29uc3QgY29uY2F0ID0gQnVmZmVyLmNvbmNhdDtcbmNvbnN0IEcgPSBjdXJ2ZS5HO1xuY29uc3QgbiA9IGN1cnZlLm47XG5cblxuZXhwb3J0IGludGVyZmFjZSBTY2hub3JyQXBpIHtcbiAgICBnZW5Ob25jZTogKG9yYWNsZVByaXZIZXg6IHN0cmluZywgcXVlc3Rpb25IZXg6IHN0cmluZywgYXV4SGV4OiBzdHJpbmcpID0+IHN0cmluZ1xuICAgIHNpZ25hdHVyZVNWYWx1ZTogKHByaXZIZXg6IHN0cmluZywgbm9uY2U6IHN0cmluZywgbXNnSGV4OiBzdHJpbmcpID0+IHN0cmluZ1xuXG4gICAgYWRhcHRvclB1YmxpYzogKG9yYWNsZVBiSGV4OiBzdHJpbmcsIG1zZ0hleDogc3RyaW5nLCBySGV4OiBzdHJpbmcpID0+IHN0cmluZ1xufVxuXG5leHBvcnQgY29uc3Qgc2Nobm9yckFwaTogKCkgPT4gU2Nobm9yckFwaSA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGFwdG9yUHVibGljOiAob3JhY2xlUGJIZXg6IHN0cmluZywgbXNnSGV4OiBzdHJpbmcsIHJIZXg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAgICAgICBjb25zdCBwdWJJbnQgPSBjb252ZXJ0LmJ1ZmZlclRvSW50KGFkYXB0b3IuY3JlYXRlQWRhcHRvclBvaW50KFtCdWZmZXIuZnJvbShvcmFjbGVQYkhleCwgJ2hleCcpXSwgW0J1ZmZlci5mcm9tKG1zZ0hleCwgJ2hleCcpXSwgW0J1ZmZlci5mcm9tKHJIZXgsICdoZXgnKV0pKVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHB1YkludC50b1N0cmluZygxNilcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTm9uY2U6IChvcmFjbGVQcml2SGV4OiBzdHJpbmcsIHF1ZXN0aW9uSGV4OiBzdHJpbmcsIGF1eEhleDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1eCA9IEJ1ZmZlci5mcm9tKGF1eEhleCwgJ2hleCcpO1xuICAgICAgICAgICAgY29uc3QgcHJpdktleSA9IEJpZ0ludGVnZXIuZnJvbUhleChvcmFjbGVQcml2SGV4KVxuXG4gICAgICAgICAgICBjb25zdCBQID0gRy5tdWx0aXBseShwcml2S2V5KTtcbiAgICAgICAgICAgIGNvbnN0IFB4ID0gY29udmVydC5pbnRUb0J1ZmZlcihQLmFmZmluZVgpO1xuXG4gICAgICAgICAgICBjb25zdCBtID0gQnVmZmVyLmZyb20ocXVlc3Rpb25IZXgsICdoZXgnKVxuXG4gICAgICAgICAgICBjb25zdCBkID0gbWF0aC5nZXRFdmVuS2V5KFAsIHByaXZLZXkpO1xuICAgICAgICAgICAgY29uc3QgdCA9IGNvbnZlcnQuaW50VG9CdWZmZXIoZC54b3IoY29udmVydC5idWZmZXJUb0ludChtYXRoLnRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYXV4KSkpKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmQgPSBtYXRoLnRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCBjb25jYXQoW3QsIFB4LCBtXSkpXG4gICAgICAgICAgICBjb25zdCBrUHJpbWUgPSBjb252ZXJ0LmJ1ZmZlclRvSW50KHJhbmQpLm1vZChuKTtcbiAgICAgICAgICAgIHJldHVybiBrUHJpbWUudG9TdHJpbmcoMTYpXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hdHVyZVNWYWx1ZTogKHByaXZIZXg6IHN0cmluZywgbm9uY2U6IHN0cmluZywgbXNnSGV4OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJpdktleSA9IEJpZ0ludGVnZXIuZnJvbUhleChwcml2SGV4KVxuICAgICAgICAgICAgY29uc3Qga1ByaW1lID0gQmlnSW50ZWdlci5mcm9tSGV4KG5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBCdWZmZXIuZnJvbShtc2dIZXgsICdoZXgnKVxuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFkYXB0b3IuY3JlYXRlQWRhcHRvclNlY3JldChbcHJpdktleV0sIFttXSwgW2tQcmltZV0pXG4gICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJleHBvcnQgY29uc3QgcHJvY2Vzc1RlbXBsYXRlID0gKG5hbWU6IHN0cmluZywgc3Vic3Q6IHtba2V5OiBzdHJpbmddOiBudW1iZXJ9LCB0ZW1wbGF0ZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnZXVyb2NhbGwnOiByZXR1cm4gdGVtcGxhdGVcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiJG5vdGlvbmFsXCIsIHN1YnN0Lm5vdGlvbmFsLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAucmVwbGFjZShcIiRtYXJnaW5cIiwgc3Vic3QubWFyZ2luLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAucmVwbGFjZShcIiRzdHJpa2VcIiwgc3Vic3Quc3RyaWtlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAucmVwbGFjZShcIiRwcmVtaXVtXCIsIHN1YnN0LnByZW1pdW0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiJG1pblZhbHVlXCIsIHN1YnN0Lm1pblZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAucmVwbGFjZShcIiRtYXhWYWx1ZVwiLCBzdWJzdC5tYXhWYWx1ZS50b1N0cmluZygpKVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGVcbn0iLCJpbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gXCJiaXRjb2luanMtbGliXCJcbmltcG9ydCAqIGFzIGVjYyBmcm9tICd0aW55LXNlY3AyNTZrMSc7XG5cbihlY2MgYXMgYW55KS50aGVuKGVjID0+IGJpdGNvaW4uaW5pdEVjY0xpYihlYykpXG5cblxuaW1wb3J0IHtTaWduZXJ9IGZyb20gXCJiaXRjb2luanMtbGliL3NyYy9wc2J0LmRcIlxuXG5jb25zdCBuZXQgPSBiaXRjb2luLm5ldHdvcmtzLnRlc3RuZXRcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVUeE8ge1xuICAgIHR4aWQ6IHN0cmluZyxcbiAgICB2b3V0OiBudW1iZXIsXG4gICAgc2VjcmV0czogQnVmZmVyW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeCB7XG4gICAgdHhpZDogc3RyaW5nLFxuICAgIGhleDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhBcGkge1xuICAgIGdlbk9wZW5pbmdUeChhbGljZUluOiBVVHhPLCBib2JJbjogVVR4TywgYWxpY2VQazogc3RyaW5nLCBib2JQazogc3RyaW5nLCBhbGljZUFtb3VudDogbnVtYmVyLCBib2JBbW91bnQ6IG51bWJlcik6IFR4XG4gICAgZ2VuQ2xvc2luZ1R4KG11bHRpSW46IFVUeE8sIGFsaWNlUGs6IHN0cmluZywgYm9iUGs6IHN0cmluZywgYWxpY2VBbW91bnQ6IG51bWJlciwgYm9iQW1vdW50OiBudW1iZXIpOiBUeFxuICAgIGdlbkFsaWNlQ2V0KG11bHRpSW46IFVUeE8sIGFsaWNlUGs6IHN0cmluZywgYm9iUGs6IHN0cmluZywgb3JhY2xlTXNnSGV4OiBzdHJpbmcsIG9yYWNsZVI6IHN0cmluZywgYWxpY2VBbW91bnQ6IG51bWJlciwgYm9iQW1vdW50OiBudW1iZXIpOiBUeFxuICAgIGdlbkFsaWNlQ2V0UmVkZW1wdGlvbihhbGljZU9yYWNsZUluOiBVVHhPLCBhbGljZVBrOiBzdHJpbmcsIG9yYWNsZVM6IHN0cmluZyk6IFR4XG59XG5cbmNvbnN0IHAycGt0ciA9IChwazogc3RyaW5nKSA9PiBiaXRjb2luLnBheW1lbnRzLnAydHIoe1xuICAgIHB1YmtleTogQnVmZmVyLmZyb20ocGssIFwiaGV4XCIpLFxuICAgIG5ldHdvcms6IG5ldFxuICB9KVxuXG5jb25zdCBzY2hub3JyID0gcmVxdWlyZSgnYmlwLXNjaG5vcnInKTtcbmNvbnN0IG11U2lnID0gc2Nobm9yci5tdVNpZztcbmNvbnN0IGNvbnZlcnQgPSBzY2hub3JyLmNvbnZlcnQ7XG5pbXBvcnQgKiBhcyBtdWx0aXNpZyBmcm9tICcuL211LXNpZydcblxuZnVuY3Rpb24gc2Nobm9yclNpZ25lclNpbmdsZShwaywgc2VjcmV0OiBCdWZmZXIpOiBTaWduZXIge1xuICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleTogQnVmZmVyLmZyb20ocGssIFwiaGV4XCIpLFxuICAgICAgICBuZXR3b3JrOiBuZXQsXG4gICAgICAgIHNpZ24oaGFzaDogQnVmZmVyLCBsb3dSPzogYm9vbGVhbik6IEJ1ZmZlciB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuICAgICAgICBzaWduU2Nobm9ycihoYXNoOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgICAgICAgICAgcmV0dXJuIHNjaG5vcnIuc2lnbihoYXNoLCBzZWNyZXQpXG4gICAgICAgIH0sXG4gICAgICAgIGdldFB1YmxpY0tleSgpOiBCdWZmZXIge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBrLCBcImhleFwiKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzY2hub3JyU2lnbmVyTXVsdGkocGsxLCBwazIsIHNlY3JldDE6IEJ1ZmZlciwgc2VjcmV0MjogQnVmZmVyKTogU2lnbmVyIHtcbiAgICBcbiAgICBjb25zdCBwa0NvbWJpbmVkID0gbXVTaWcucHViS2V5Q29tYmluZShbQnVmZmVyLmZyb20ocGsxLCBcImhleFwiKSwgQnVmZmVyLmZyb20ocGsyLCBcImhleFwiKV0pO1xuICAgIGxldCBwdWJLZXlDb21iaW5lZCA9IGNvbnZlcnQuaW50VG9CdWZmZXIocGtDb21iaW5lZC5hZmZpbmVYKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IHB1YktleUNvbWJpbmVkLFxuICAgICAgICBuZXR3b3JrOiBuZXQsXG4gICAgICAgIHNpZ24oaGFzaDogQnVmZmVyLCBsb3dSPzogYm9vbGVhbik6IEJ1ZmZlciB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuICAgICAgICBzaWduU2Nobm9ycihoYXNoOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgICAgICAgICAgbGV0IG11U2lnbmF0dXJlID0gbXVsdGlzaWcuc2lnbihwazEsIHBrMiwgXG4gICAgICAgICAgICAgICAgc2VjcmV0MS50b1N0cmluZyhcImhleFwiKSxcbiAgICAgICAgICAgICAgICBzZWNyZXQyLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgICAgICAgICAgICAgIGhhc2gudG9TdHJpbmcoXCJoZXhcIikpXG4gICAgICAgICAgICByZXR1cm4gbXVTaWduYXR1cmVcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHVibGljS2V5KCk6IEJ1ZmZlciB7XG4gICAgICAgICAgICByZXR1cm4gcHViS2V5Q29tYmluZWRcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHR4QXBpOiAoKSA9PiBUeEFwaSA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW5PcGVuaW5nVHg6IChhbGljZUluOiBVVHhPLCBib2JJbjogVVR4TywgYWxpY2VQazogc3RyaW5nLCBib2JQazogc3RyaW5nLCBhbGljZUFtb3VudDogbnVtYmVyLCBib2JBbW91bnQ6IG51bWJlcik6IFR4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBzYnQgPSBuZXcgYml0Y29pbi5Qc2J0KHsgbmV0d29yazogbmV0fSlcbiAgICAgICAgICAgIGxldCBhbGljZVAyVFIgPSBwMnBrdHIoYWxpY2VQaylcbiAgICAgICAgICAgIGxldCBib2JQMlRSID0gcDJwa3RyKGFsaWNlUGspXG5cbiAgICAgICAgICAgIHBzYnQuYWRkSW5wdXQoe1xuICAgICAgICAgICAgICAgIGhhc2g6IGFsaWNlSW4udHhpZCxcbiAgICAgICAgICAgICAgICBpbmRleDogYWxpY2VJbi52b3V0LFxuICAgICAgICAgICAgICAgIHdpdG5lc3NVdHhvOiB7IHZhbHVlOiBhbGljZUFtb3VudCwgc2NyaXB0OiBhbGljZVAyVFIub3V0cHV0ISB9LFxuICAgICAgICAgICAgICAgIHRhcEludGVybmFsS2V5OiBCdWZmZXIuZnJvbShhbGljZVBrLCBcImhleFwiKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBzYnQuYWRkSW5wdXQoe1xuICAgICAgICAgICAgICAgIGhhc2g6IGJvYkluLnR4aWQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGJvYkluLnZvdXQsXG4gICAgICAgICAgICAgICAgd2l0bmVzc1V0eG86IHsgdmFsdWU6IGJvYkFtb3VudCwgc2NyaXB0OiBib2JQMlRSLm91dHB1dCEgfSxcbiAgICAgICAgICAgICAgICB0YXBJbnRlcm5hbEtleTogQnVmZmVyLmZyb20oYm9iUGssIFwiaGV4XCIpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwibW9oalNhdkRkUVlIUllYY1MzdVM2dHRhSFA4YW15dlg3OFwiLCAvLyBUT0RPOiBnZW5lcmF0ZSBtdSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFsaWNlQW1vdW50ICsgYm9iQW1vdW50XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBwc2J0LnNpZ25JbnB1dCgwLCBzY2hub3JyU2lnbmVyU2luZ2xlKGFsaWNlUGssIGFsaWNlSW4uc2VjcmV0c1swXSkpXG4gICAgICAgICAgICBwc2J0LnNpZ25JbnB1dCgxLCBzY2hub3JyU2lnbmVyU2luZ2xlKGJvYlBrLCBib2JJbi5zZWNyZXRzWzBdKSlcbiAgICAgICAgICAgIHBzYnQuZmluYWxpemVBbGxJbnB1dHMoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR4aWQ6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkuZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBoZXg6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkudG9IZXgoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNsb3NpbmdUeDogKG11bHRpSW46IFVUeE8sIGFsaWNlUGs6IHN0cmluZywgYm9iUGs6IHN0cmluZywgYWxpY2VBbW91bnQ6IG51bWJlciwgYm9iQW1vdW50OiBudW1iZXIpOiBUeCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwc2J0ID0gbmV3IGJpdGNvaW4uUHNidCh7IG5ldHdvcms6IG5ldH0pXG4gICAgICAgICAgICBjb25zdCBwa0NvbWJpbmVkID0gbXVTaWcucHViS2V5Q29tYmluZShbQnVmZmVyLmZyb20oYWxpY2VQaywgXCJoZXhcIiksIEJ1ZmZlci5mcm9tKGJvYlBrLCBcImhleFwiKV0pO1xuICAgICAgICAgICAgbGV0IHB1YktleUNvbWJpbmVkID0gY29udmVydC5pbnRUb0J1ZmZlcihwa0NvbWJpbmVkLmFmZmluZVgpO1xuICAgICAgICAgICAgbGV0IG11bHRpUDJUUiA9IHAycGt0cihwdWJLZXlDb21iaW5lZClcblxuICAgICAgICAgICAgcHNidC5hZGRJbnB1dCh7XG4gICAgICAgICAgICAgICAgaGFzaDogbXVsdGlJbi50eGlkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBtdWx0aUluLnZvdXQsXG4gICAgICAgICAgICAgICAgd2l0bmVzc1V0eG86IHsgdmFsdWU6IGFsaWNlQW1vdW50ICsgYm9iQW1vdW50LCBzY3JpcHQ6IG11bHRpUDJUUi5vdXRwdXQhIH0sXG4gICAgICAgICAgICAgICAgdGFwSW50ZXJuYWxLZXk6IEJ1ZmZlci5mcm9tKGFsaWNlUGssIFwiaGV4XCIpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwibW9oalNhdkRkUVlIUllYY1MzdVM2dHRhSFA4YW15dlg3OFwiLCAvLyBUT0RPOiBnZW5lcmF0ZSBhbGljZSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFsaWNlQW1vdW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwibW9oalNhdkRkUVlIUllYY1MzdVM2dHRhSFA4YW15dlg3OFwiLCAvLyBUT0RPOiBnZW5lcmF0ZSBib2IgYWRkcmVzc1xuICAgICAgICAgICAgICAgIHZhbHVlOiBib2JBbW91bnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwc2J0LnNpZ25JbnB1dCgwLCBzY2hub3JyU2lnbmVyTXVsdGkoYWxpY2VQaywgYm9iUGssIG11bHRpSW4uc2VjcmV0c1swXSwgbXVsdGlJbi5zZWNyZXRzWzFdKSlcbiAgICAgICAgICAgIHBzYnQuZmluYWxpemVBbGxJbnB1dHMoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR4aWQ6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkuZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBoZXg6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkudG9IZXgoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5BbGljZUNldDogKG11bHRpSW46IFVUeE8sIGFsaWNlUGs6IHN0cmluZywgYm9iUGs6IHN0cmluZywgb3JhY2xlTXNnSGV4OiBzdHJpbmcsIG9yYWNsZVI6IHN0cmluZywgYWxpY2VBbW91bnQ6IG51bWJlciwgYm9iQW1vdW50OiBudW1iZXIpOiBUeCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwc2J0ID0gbmV3IGJpdGNvaW4uUHNidCh7IG5ldHdvcms6IG5ldH0pXG4gICAgICAgICAgICBjb25zdCBwa0NvbWJpbmVkID0gbXVTaWcucHViS2V5Q29tYmluZShbQnVmZmVyLmZyb20oYWxpY2VQaywgXCJoZXhcIiksIEJ1ZmZlci5mcm9tKGJvYlBrLCBcImhleFwiKV0pO1xuICAgICAgICAgICAgbGV0IHB1YktleUNvbWJpbmVkID0gY29udmVydC5pbnRUb0J1ZmZlcihwa0NvbWJpbmVkLmFmZmluZVgpO1xuICAgICAgICAgICAgbGV0IG11bHRpUDJUUiA9IHAycGt0cihwdWJLZXlDb21iaW5lZClcblxuICAgICAgICAgICAgcHNidC5hZGRJbnB1dCh7XG4gICAgICAgICAgICAgICAgaGFzaDogbXVsdGlJbi50eGlkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBtdWx0aUluLnZvdXQsXG4gICAgICAgICAgICAgICAgd2l0bmVzc1V0eG86IHsgdmFsdWU6IGFsaWNlQW1vdW50ICsgYm9iQW1vdW50LCBzY3JpcHQ6IG11bHRpUDJUUi5vdXRwdXQhIH0sXG4gICAgICAgICAgICAgICAgdGFwSW50ZXJuYWxLZXk6IEJ1ZmZlci5mcm9tKGFsaWNlUGssIFwiaGV4XCIpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwibW9oalNhdkRkUVlIUllYY1MzdVM2dHRhSFA4YW15dlg3OFwiLCAvLyBUT0RPOiBnZW5lcmF0ZSBhbGljZSBhZGRyZXNzIGZyb20gb3JhY2xlTXNnSGV4IGFuZCBvcmFjbGVSXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFsaWNlQW1vdW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwibW9oalNhdkRkUVlIUllYY1MzdVM2dHRhSFA4YW15dlg3OFwiLCAvLyBUT0RPOiBnZW5lcmF0ZSBib2IgYWRkcmVzc1xuICAgICAgICAgICAgICAgIHZhbHVlOiBib2JBbW91bnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwc2J0LnNpZ25JbnB1dCgwLCBzY2hub3JyU2lnbmVyTXVsdGkoYWxpY2VQaywgYm9iUGssIG11bHRpSW4uc2VjcmV0c1swXSwgbXVsdGlJbi5zZWNyZXRzWzFdKSlcbiAgICAgICAgICAgIHBzYnQuZmluYWxpemVBbGxJbnB1dHMoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR4aWQ6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkuZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBoZXg6IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCkudG9IZXgoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5BbGljZUNldFJlZGVtcHRpb246IChhbGljZU9yYWNsZUluOiBVVHhPLCBhbGljZVBrOiBzdHJpbmcsIG9yYWNsZVM6IHN0cmluZyk6IFR4ID0+IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eGlkOiBcIjBcIixcbiAgICAgICAgICAgICAgICBoZXg6IFwiMFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwidmFyIG5hdGl2ZSA9IHJlcXVpcmUoJy4vbmF0aXZlJylcblxuZnVuY3Rpb24gZ2V0VHlwZU5hbWUgKGZuKSB7XG4gIHJldHVybiBmbi5uYW1lIHx8IGZuLnRvU3RyaW5nKCkubWF0Y2goL2Z1bmN0aW9uICguKj8pXFxzKlxcKC8pWzFdXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlVHlwZU5hbWUgKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmUuTmlsKHZhbHVlKSA/ICcnIDogZ2V0VHlwZU5hbWUodmFsdWUuY29uc3RydWN0b3IpXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlICh2YWx1ZSkge1xuICBpZiAobmF0aXZlLkZ1bmN0aW9uKHZhbHVlKSkgcmV0dXJuICcnXG4gIGlmIChuYXRpdmUuU3RyaW5nKHZhbHVlKSkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICBpZiAodmFsdWUgJiYgbmF0aXZlLk9iamVjdCh2YWx1ZSkpIHJldHVybiAnJ1xuICByZXR1cm4gdmFsdWVcbn1cblxuZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2UgKGUsIHQpIHtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSwgdClcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZkpTT04gKHR5cGUpIHtcbiAgaWYgKG5hdGl2ZS5GdW5jdGlvbih0eXBlKSkgcmV0dXJuIHR5cGUudG9KU09OID8gdHlwZS50b0pTT04oKSA6IGdldFR5cGVOYW1lKHR5cGUpXG4gIGlmIChuYXRpdmUuQXJyYXkodHlwZSkpIHJldHVybiAnQXJyYXknXG4gIGlmICh0eXBlICYmIG5hdGl2ZS5PYmplY3QodHlwZSkpIHJldHVybiAnT2JqZWN0J1xuXG4gIHJldHVybiB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogJydcbn1cblxuZnVuY3Rpb24gdGZFcnJvclN0cmluZyAodHlwZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgdmFyIHZhbHVlSnNvbiA9IGdldFZhbHVlKHZhbHVlKVxuXG4gIHJldHVybiAnRXhwZWN0ZWQgJyArIHRmSlNPTih0eXBlKSArICcsIGdvdCcgK1xuICAgICh2YWx1ZVR5cGVOYW1lICE9PSAnJyA/ICcgJyArIHZhbHVlVHlwZU5hbWUgOiAnJykgK1xuICAgICh2YWx1ZUpzb24gIT09ICcnID8gJyAnICsgdmFsdWVKc29uIDogJycpXG59XG5cbmZ1bmN0aW9uIFRmVHlwZUVycm9yICh0eXBlLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSkge1xuICB2YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlTmFtZSB8fCBnZXRWYWx1ZVR5cGVOYW1lKHZhbHVlKVxuICB0aGlzLm1lc3NhZ2UgPSB0ZkVycm9yU3RyaW5nKHR5cGUsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRmVHlwZUVycm9yKVxuICB0aGlzLl9fdHlwZSA9IHR5cGVcbiAgdGhpcy5fX3ZhbHVlID0gdmFsdWVcbiAgdGhpcy5fX3ZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lXG59XG5cblRmVHlwZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuVGZUeXBlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGZUeXBlRXJyb3JcblxuZnVuY3Rpb24gdGZQcm9wZXJ0eUVycm9yU3RyaW5nICh0eXBlLCBsYWJlbCwgbmFtZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0gJ1wiIG9mIHR5cGUgJ1xuICBpZiAobGFiZWwgPT09ICdrZXknKSBkZXNjcmlwdGlvbiA9ICdcIiB3aXRoIGtleSB0eXBlICdcblxuICByZXR1cm4gdGZFcnJvclN0cmluZygncHJvcGVydHkgXCInICsgdGZKU09OKG5hbWUpICsgZGVzY3JpcHRpb24gKyB0ZkpTT04odHlwZSksIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKVxufVxuXG5mdW5jdGlvbiBUZlByb3BlcnR5VHlwZUVycm9yICh0eXBlLCBwcm9wZXJ0eSwgbGFiZWwsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZU5hbWUgfHwgZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgICB0aGlzLm1lc3NhZ2UgPSB0ZlByb3BlcnR5RXJyb3JTdHJpbmcodHlwZSwgbGFiZWwsIHByb3BlcnR5LCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVW5leHBlY3RlZCBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIidcbiAgfVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRmVHlwZUVycm9yKVxuICB0aGlzLl9fbGFiZWwgPSBsYWJlbFxuICB0aGlzLl9fcHJvcGVydHkgPSBwcm9wZXJ0eVxuICB0aGlzLl9fdHlwZSA9IHR5cGVcbiAgdGhpcy5fX3ZhbHVlID0gdmFsdWVcbiAgdGhpcy5fX3ZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lXG59XG5cblRmUHJvcGVydHlUeXBlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5UZlByb3BlcnR5VHlwZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRmVHlwZUVycm9yXG5cbmZ1bmN0aW9uIHRmQ3VzdG9tRXJyb3IgKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgcmV0dXJuIG5ldyBUZlR5cGVFcnJvcihleHBlY3RlZCwge30sIGFjdHVhbClcbn1cblxuZnVuY3Rpb24gdGZTdWJFcnJvciAoZSwgcHJvcGVydHksIGxhYmVsKSB7XG4gIC8vIHN1YiBjaGlsZD9cbiAgaWYgKGUgaW5zdGFuY2VvZiBUZlByb3BlcnR5VHlwZUVycm9yKSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eSArICcuJyArIGUuX19wcm9wZXJ0eVxuXG4gICAgZSA9IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKFxuICAgICAgZS5fX3R5cGUsIHByb3BlcnR5LCBlLl9fbGFiZWwsIGUuX192YWx1ZSwgZS5fX3ZhbHVlVHlwZU5hbWVcbiAgICApXG5cbiAgLy8gY2hpbGQ/XG4gIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFRmVHlwZUVycm9yKSB7XG4gICAgZSA9IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKFxuICAgICAgZS5fX3R5cGUsIHByb3BlcnR5LCBsYWJlbCwgZS5fX3ZhbHVlLCBlLl9fdmFsdWVUeXBlTmFtZVxuICAgIClcbiAgfVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKGUpXG4gIHJldHVybiBlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZlR5cGVFcnJvcjogVGZUeXBlRXJyb3IsXG4gIFRmUHJvcGVydHlUeXBlRXJyb3I6IFRmUHJvcGVydHlUeXBlRXJyb3IsXG4gIHRmQ3VzdG9tRXJyb3I6IHRmQ3VzdG9tRXJyb3IsXG4gIHRmU3ViRXJyb3I6IHRmU3ViRXJyb3IsXG4gIHRmSlNPTjogdGZKU09OLFxuICBnZXRWYWx1ZVR5cGVOYW1lOiBnZXRWYWx1ZVR5cGVOYW1lXG59XG4iLCJ2YXIgTkFUSVZFID0gcmVxdWlyZSgnLi9uYXRpdmUnKVxudmFyIEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuZnVuY3Rpb24gX0J1ZmZlciAodmFsdWUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSlcbn1cblxuZnVuY3Rpb24gSGV4ICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAvXihbMC05YS1mXXsyfSkrJC9pLnRlc3QodmFsdWUpXG59XG5cbmZ1bmN0aW9uIF9MZW5ndGhOICh0eXBlLCBsZW5ndGgpIHtcbiAgdmFyIG5hbWUgPSB0eXBlLnRvSlNPTigpXG5cbiAgZnVuY3Rpb24gTGVuZ3RoICh2YWx1ZSkge1xuICAgIGlmICghdHlwZSh2YWx1ZSkpIHJldHVybiBmYWxzZVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCkgcmV0dXJuIHRydWVcblxuICAgIHRocm93IEVSUk9SUy50ZkN1c3RvbUVycm9yKG5hbWUgKyAnKExlbmd0aDogJyArIGxlbmd0aCArICcpJywgbmFtZSArICcoTGVuZ3RoOiAnICsgdmFsdWUubGVuZ3RoICsgJyknKVxuICB9XG4gIExlbmd0aC50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lIH1cblxuICByZXR1cm4gTGVuZ3RoXG59XG5cbnZhciBfQXJyYXlOID0gX0xlbmd0aE4uYmluZChudWxsLCBOQVRJVkUuQXJyYXkpXG52YXIgX0J1ZmZlck4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIF9CdWZmZXIpXG52YXIgX0hleE4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIEhleClcbnZhciBfU3RyaW5nTiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgTkFUSVZFLlN0cmluZylcblxuZnVuY3Rpb24gUmFuZ2UgKGEsIGIsIGYpIHtcbiAgZiA9IGYgfHwgTkFUSVZFLk51bWJlclxuICBmdW5jdGlvbiBfcmFuZ2UgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gZih2YWx1ZSwgc3RyaWN0KSAmJiAodmFsdWUgPiBhKSAmJiAodmFsdWUgPCBiKVxuICB9XG4gIF9yYW5nZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGAke2YudG9KU09OKCl9IGJldHdlZW4gWyR7YX0sICR7Yn1dYFxuICB9XG4gIHJldHVybiBfcmFuZ2Vcbn1cblxudmFyIElOVDUzX01BWCA9IE1hdGgucG93KDIsIDUzKSAtIDFcblxuZnVuY3Rpb24gRmluaXRlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSlcbn1cbmZ1bmN0aW9uIEludDggKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlIDw8IDI0KSA+PiAyNCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDE2ICh2YWx1ZSkgeyByZXR1cm4gKCh2YWx1ZSA8PCAxNikgPj4gMTYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBJbnQzMiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSB8IDApID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBJbnQ1MyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+PSAtSU5UNTNfTUFYICYmXG4gICAgdmFsdWUgPD0gSU5UNTNfTUFYICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlXG59XG5mdW5jdGlvbiBVSW50OCAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAmIDB4ZmYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50MTYgKHZhbHVlKSB7IHJldHVybiAodmFsdWUgJiAweGZmZmYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50MzIgKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPj4+IDApID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50NTMgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPj0gMCAmJlxuICAgIHZhbHVlIDw9IElOVDUzX01BWCAmJlxuICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZVxufVxuXG52YXIgdHlwZXMgPSB7XG4gIEFycmF5TjogX0FycmF5TixcbiAgQnVmZmVyOiBfQnVmZmVyLFxuICBCdWZmZXJOOiBfQnVmZmVyTixcbiAgRmluaXRlOiBGaW5pdGUsXG4gIEhleDogSGV4LFxuICBIZXhOOiBfSGV4TixcbiAgSW50ODogSW50OCxcbiAgSW50MTY6IEludDE2LFxuICBJbnQzMjogSW50MzIsXG4gIEludDUzOiBJbnQ1MyxcbiAgUmFuZ2U6IFJhbmdlLFxuICBTdHJpbmdOOiBfU3RyaW5nTixcbiAgVUludDg6IFVJbnQ4LFxuICBVSW50MTY6IFVJbnQxNixcbiAgVUludDMyOiBVSW50MzIsXG4gIFVJbnQ1MzogVUludDUzXG59XG5cbmZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gIHR5cGVzW3R5cGVOYW1lXS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0uYmluZChudWxsLCB0eXBlTmFtZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlc1xuIiwidmFyIEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbnZhciBOQVRJVkUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG5cbi8vIHNob3J0LWhhbmRcbnZhciB0ZkpTT04gPSBFUlJPUlMudGZKU09OXG52YXIgVGZUeXBlRXJyb3IgPSBFUlJPUlMuVGZUeXBlRXJyb3JcbnZhciBUZlByb3BlcnR5VHlwZUVycm9yID0gRVJST1JTLlRmUHJvcGVydHlUeXBlRXJyb3JcbnZhciB0ZlN1YkVycm9yID0gRVJST1JTLnRmU3ViRXJyb3JcbnZhciBnZXRWYWx1ZVR5cGVOYW1lID0gRVJST1JTLmdldFZhbHVlVHlwZU5hbWVcblxudmFyIFRZUEVTID0ge1xuICBhcnJheU9mOiBmdW5jdGlvbiBhcnJheU9mICh0eXBlLCBvcHRpb25zKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgZnVuY3Rpb24gX2FycmF5T2YgKGFycmF5LCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLkFycmF5KGFycmF5KSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbChhcnJheSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoIDwgb3B0aW9ucy5taW5MZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoID4gb3B0aW9ucy5tYXhMZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoICE9PSBvcHRpb25zLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBhcnJheS5ldmVyeShmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hcnJheU9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHIgPSAnWycgKyB0ZkpTT04odHlwZSkgKyAnXSdcbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ciArPSAneycgKyBvcHRpb25zLmxlbmd0aCArICd9J1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RyICs9ICd7JyArXG4gICAgICAgICAgKG9wdGlvbnMubWluTGVuZ3RoID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5taW5MZW5ndGgpICsgJywnICtcbiAgICAgICAgICAob3B0aW9ucy5tYXhMZW5ndGggPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogb3B0aW9ucy5tYXhMZW5ndGgpICsgJ30nXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnJheU9mXG4gIH0sXG5cbiAgbWF5YmU6IGZ1bmN0aW9uIG1heWJlICh0eXBlKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcblxuICAgIGZ1bmN0aW9uIF9tYXliZSAodmFsdWUsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIE5BVElWRS5OaWwodmFsdWUpIHx8IHR5cGUodmFsdWUsIHN0cmljdCwgbWF5YmUpXG4gICAgfVxuICAgIF9tYXliZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPycgKyB0ZkpTT04odHlwZSkgfVxuXG4gICAgcmV0dXJuIF9tYXliZVxuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gbWFwIChwcm9wZXJ0eVR5cGUsIHByb3BlcnR5S2V5VHlwZSkge1xuICAgIHByb3BlcnR5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlUeXBlKVxuICAgIGlmIChwcm9wZXJ0eUtleVR5cGUpIHByb3BlcnR5S2V5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlLZXlUeXBlKVxuXG4gICAgZnVuY3Rpb24gX21hcCAodmFsdWUsIHN0cmljdCkge1xuICAgICAgaWYgKCFOQVRJVkUuT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJvcGVydHlLZXlUeXBlKSB7XG4gICAgICAgICAgICB0eXBlZm9yY2UocHJvcGVydHlLZXlUeXBlLCBwcm9wZXJ0eU5hbWUsIHN0cmljdClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIHByb3BlcnR5TmFtZSwgJ2tleScpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHR5cGVmb3JjZShwcm9wZXJ0eVR5cGUsIHByb3BlcnR5VmFsdWUsIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5S2V5VHlwZSkge1xuICAgICAgX21hcC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAneycgKyB0ZkpTT04ocHJvcGVydHlLZXlUeXBlKSArICc6ICcgKyB0ZkpTT04ocHJvcGVydHlUeXBlKSArICd9J1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfbWFwLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd7JyArIHRmSlNPTihwcm9wZXJ0eVR5cGUpICsgJ30nIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX21hcFxuICB9LFxuXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0ICh1bmNvbXBpbGVkKSB7XG4gICAgdmFyIHR5cGUgPSB7fVxuXG4gICAgZm9yICh2YXIgdHlwZVByb3BlcnR5TmFtZSBpbiB1bmNvbXBpbGVkKSB7XG4gICAgICB0eXBlW3R5cGVQcm9wZXJ0eU5hbWVdID0gY29tcGlsZSh1bmNvbXBpbGVkW3R5cGVQcm9wZXJ0eU5hbWVdKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3QgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLk9iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWUpKSByZXR1cm4gZmFsc2VcblxuICAgICAgdmFyIHByb3BlcnR5TmFtZVxuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiB0eXBlKSB7XG4gICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IHR5cGVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuXG4gICAgICAgICAgdHlwZWZvcmNlKHByb3BlcnR5VHlwZSwgcHJvcGVydHlWYWx1ZSwgc3RyaWN0KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGZvciAocHJvcGVydHlOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVbcHJvcGVydHlOYW1lXSkgY29udGludWVcblxuICAgICAgICAgIHRocm93IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIF9vYmplY3QudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZKU09OKHR5cGUpIH1cblxuICAgIHJldHVybiBfb2JqZWN0XG4gIH0sXG5cbiAgYW55T2Y6IGZ1bmN0aW9uIGFueU9mICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKGNvbXBpbGUpXG5cbiAgICBmdW5jdGlvbiBfYW55T2YgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB0eXBlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVmb3JjZSh0eXBlLCB2YWx1ZSwgc3RyaWN0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hbnlPZi50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlcy5tYXAodGZKU09OKS5qb2luKCd8JykgfVxuXG4gICAgcmV0dXJuIF9hbnlPZlxuICB9LFxuXG4gIGFsbE9mOiBmdW5jdGlvbiBhbGxPZiAoKSB7XG4gICAgdmFyIHR5cGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChjb21waWxlKVxuXG4gICAgZnVuY3Rpb24gX2FsbE9mICh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX2FsbE9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzLm1hcCh0ZkpTT04pLmpvaW4oJyAmICcpIH1cblxuICAgIHJldHVybiBfYWxsT2ZcbiAgfSxcblxuICBxdWFja3NMaWtlOiBmdW5jdGlvbiBxdWFja3NMaWtlICh0eXBlKSB7XG4gICAgZnVuY3Rpb24gX3F1YWNrc0xpa2UgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgICB9XG4gICAgX3F1YWNrc0xpa2UudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgICByZXR1cm4gX3F1YWNrc0xpa2VcbiAgfSxcblxuICB0dXBsZTogZnVuY3Rpb24gdHVwbGUgKCkge1xuICAgIHZhciB0eXBlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoY29tcGlsZSlcblxuICAgIGZ1bmN0aW9uIF90dXBsZSAodmFsdWVzLCBzdHJpY3QpIHtcbiAgICAgIGlmIChOQVRJVkUuTmlsKHZhbHVlcykpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWVzLmxlbmd0aCkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHN0cmljdCAmJiAodmFsdWVzLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0eXBlZm9yY2UodHlwZSwgdmFsdWVzW2ldLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF90dXBsZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnKCcgKyB0eXBlcy5tYXAodGZKU09OKS5qb2luKCcsICcpICsgJyknIH1cblxuICAgIHJldHVybiBfdHVwbGVcbiAgfSxcblxuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUgKGV4cGVjdGVkKSB7XG4gICAgZnVuY3Rpb24gX3ZhbHVlIChhY3R1YWwpIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkXG4gICAgfVxuICAgIF92YWx1ZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBlY3RlZCB9XG5cbiAgICByZXR1cm4gX3ZhbHVlXG4gIH1cbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlXG5UWVBFUy5vbmVPZiA9IFRZUEVTLmFueU9mXG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHR5cGUpIHtcbiAgaWYgKE5BVElWRS5TdHJpbmcodHlwZSkpIHtcbiAgICBpZiAodHlwZVswXSA9PT0gJz8nKSByZXR1cm4gVFlQRVMubWF5YmUodHlwZS5zbGljZSgxKSlcblxuICAgIHJldHVybiBOQVRJVkVbdHlwZV0gfHwgVFlQRVMucXVhY2tzTGlrZSh0eXBlKVxuICB9IGVsc2UgaWYgKHR5cGUgJiYgTkFUSVZFLk9iamVjdCh0eXBlKSkge1xuICAgIGlmIChOQVRJVkUuQXJyYXkodHlwZSkpIHtcbiAgICAgIGlmICh0eXBlLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgY29tcGlsZSgpIHBhcmFtZXRlciBvZiB0eXBlIEFycmF5IG9mIGxlbmd0aCAxJylcbiAgICAgIHJldHVybiBUWVBFUy5hcnJheU9mKHR5cGVbMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFRZUEVTLm9iamVjdCh0eXBlKVxuICB9IGVsc2UgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICByZXR1cm4gVFlQRVMudmFsdWUodHlwZSlcbn1cblxuZnVuY3Rpb24gdHlwZWZvcmNlICh0eXBlLCB2YWx1ZSwgc3RyaWN0LCBzdXJyb2dhdGUpIHtcbiAgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIGlmICh0eXBlKHZhbHVlLCBzdHJpY3QpKSByZXR1cm4gdHJ1ZVxuXG4gICAgdGhyb3cgbmV3IFRmVHlwZUVycm9yKHN1cnJvZ2F0ZSB8fCB0eXBlLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIEpJVFxuICByZXR1cm4gdHlwZWZvcmNlKGNvbXBpbGUodHlwZSksIHZhbHVlLCBzdHJpY3QpXG59XG5cbi8vIGFzc2lnbiB0eXBlcyB0byB0eXBlZm9yY2UgZnVuY3Rpb25cbmZvciAodmFyIHR5cGVOYW1lIGluIE5BVElWRSkge1xuICB0eXBlZm9yY2VbdHlwZU5hbWVdID0gTkFUSVZFW3R5cGVOYW1lXVxufVxuXG5mb3IgKHR5cGVOYW1lIGluIFRZUEVTKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBUWVBFU1t0eXBlTmFtZV1cbn1cblxudmFyIEVYVFJBID0gcmVxdWlyZSgnLi9leHRyYScpXG5mb3IgKHR5cGVOYW1lIGluIEVYVFJBKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBFWFRSQVt0eXBlTmFtZV1cbn1cblxudHlwZWZvcmNlLmNvbXBpbGUgPSBjb21waWxlXG50eXBlZm9yY2UuVGZUeXBlRXJyb3IgPSBUZlR5cGVFcnJvclxudHlwZWZvcmNlLlRmUHJvcGVydHlUeXBlRXJyb3IgPSBUZlByb3BlcnR5VHlwZUVycm9yXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZWZvcmNlXG4iLCJ2YXIgdHlwZXMgPSB7XG4gIEFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5IH0sXG4gIEJvb2xlYW46IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfSxcbiAgRnVuY3Rpb246IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIH0sXG4gIE5pbDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIH0sXG4gIE51bWJlcjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIH0sXG4gIE9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIH0sXG4gIFN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIH0sXG4gICcnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH1cbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlXG50eXBlcy5OdWxsID0gdHlwZXMuTmlsXG5cbmZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gIHR5cGVzW3R5cGVOYW1lXS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0uYmluZChudWxsLCB0eXBlTmFtZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlc1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTFcblxuZnVuY3Rpb24gY2hlY2tVSW50NTMgKG4pIHtcbiAgaWYgKG4gPCAwIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSIHx8IG4gJSAxICE9PSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChudW1iZXIsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNoZWNrVUludDUzKG51bWJlcilcblxuICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG51bWJlcikpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICAvLyA4IGJpdFxuICBpZiAobnVtYmVyIDwgMHhmZCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bWJlciwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDFcblxuICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChudW1iZXIgPD0gMHhmZmZmKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKG51bWJlciwgb2Zmc2V0ICsgMSlcbiAgICBlbmNvZGUuYnl0ZXMgPSAzXG5cbiAgLy8gMzIgYml0XG4gIH0gZWxzZSBpZiAobnVtYmVyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZlLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyLCBvZmZzZXQgKyAxKVxuICAgIGVuY29kZS5ieXRlcyA9IDVcblxuICAvLyA2NCBiaXRcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyID4+PiAwLCBvZmZzZXQgKyAxKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKChudW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KVxuICAgIGVuY29kZS5ieXRlcyA9IDlcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIGZpcnN0ID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpXG5cbiAgLy8gOCBiaXRcbiAgaWYgKGZpcnN0IDwgMHhmZCkge1xuICAgIGRlY29kZS5ieXRlcyA9IDFcbiAgICByZXR1cm4gZmlyc3RcblxuICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZCkge1xuICAgIGRlY29kZS5ieXRlcyA9IDNcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKVxuXG4gIC8vIDMyIGJpdFxuICB9IGVsc2UgaWYgKGZpcnN0ID09PSAweGZlKSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gNVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpXG5cbiAgLy8gNjQgYml0XG4gIH0gZWxzZSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gOVxuICAgIHZhciBsbyA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSlcbiAgICB2YXIgaGkgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDUpXG4gICAgdmFyIG51bWJlciA9IGhpICogMHgwMTAwMDAwMDAwICsgbG9cbiAgICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgICByZXR1cm4gbnVtYmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG51bWJlcikge1xuICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgcmV0dXJuIChcbiAgICBudW1iZXIgPCAweGZkID8gMVxuICAgICAgOiBudW1iZXIgPD0gMHhmZmZmID8gM1xuICAgICAgICA6IG51bWJlciA8PSAweGZmZmZmZmZmID8gNVxuICAgICAgICAgIDogOVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBlbmNvZGU6IGVuY29kZSwgZGVjb2RlOiBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoOiBlbmNvZGluZ0xlbmd0aCB9XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iLCJpbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcInVpbnQ4YXJyYXktdG9vbHNcIjtcbmltcG9ydCAqIGFzIHZhbGlkYXRlIGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5pbXBvcnQgd2FzbSBmcm9tIFwiLi93YXNtX2xvYWRlci5qc1wiO1xuY29uc3QgV0FTTV9CVUZGRVIgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuY29uc3QgV0FTTV9QUklWQVRFX0tFWV9QVFIgPSB3YXNtLlBSSVZBVEVfSU5QVVQudmFsdWU7XG5jb25zdCBXQVNNX1BVQkxJQ19LRVlfSU5QVVRfUFRSID0gd2FzbS5QVUJMSUNfS0VZX0lOUFVULnZhbHVlO1xuY29uc3QgV0FTTV9QVUJMSUNfS0VZX0lOUFVUX1BUUjIgPSB3YXNtLlBVQkxJQ19LRVlfSU5QVVQyLnZhbHVlO1xuY29uc3QgV0FTTV9YX09OTFlfUFVCTElDX0tFWV9JTlBVVF9QVFIgPSB3YXNtLlhfT05MWV9QVUJMSUNfS0VZX0lOUFVULnZhbHVlO1xuY29uc3QgV0FTTV9YX09OTFlfUFVCTElDX0tFWV9JTlBVVDJfUFRSID0gd2FzbS5YX09OTFlfUFVCTElDX0tFWV9JTlBVVDIudmFsdWU7XG5jb25zdCBXQVNNX1RXRUFLX0lOUFVUX1BUUiA9IHdhc20uVFdFQUtfSU5QVVQudmFsdWU7XG5jb25zdCBXQVNNX0hBU0hfSU5QVVRfUFRSID0gd2FzbS5IQVNIX0lOUFVULnZhbHVlO1xuY29uc3QgV0FTTV9FWFRSQV9EQVRBX0lOUFVUX1BUUiA9IHdhc20uRVhUUkFfREFUQV9JTlBVVC52YWx1ZTtcbmNvbnN0IFdBU01fU0lHTkFUVVJFX0lOUFVUX1BUUiA9IHdhc20uU0lHTkFUVVJFX0lOUFVULnZhbHVlO1xuY29uc3QgUFJJVkFURV9LRVlfSU5QVVQgPSBXQVNNX0JVRkZFUi5zdWJhcnJheShXQVNNX1BSSVZBVEVfS0VZX1BUUiwgV0FTTV9QUklWQVRFX0tFWV9QVFIgKyB2YWxpZGF0ZS5QUklWQVRFX0tFWV9TSVpFKTtcbmNvbnN0IFBVQkxJQ19LRVlfSU5QVVQgPSBXQVNNX0JVRkZFUi5zdWJhcnJheShXQVNNX1BVQkxJQ19LRVlfSU5QVVRfUFRSLCBXQVNNX1BVQkxJQ19LRVlfSU5QVVRfUFRSICsgdmFsaWRhdGUuUFVCTElDX0tFWV9VTkNPTVBSRVNTRURfU0laRSk7XG5jb25zdCBQVUJMSUNfS0VZX0lOUFVUMiA9IFdBU01fQlVGRkVSLnN1YmFycmF5KFdBU01fUFVCTElDX0tFWV9JTlBVVF9QVFIyLCBXQVNNX1BVQkxJQ19LRVlfSU5QVVRfUFRSMiArIHZhbGlkYXRlLlBVQkxJQ19LRVlfVU5DT01QUkVTU0VEX1NJWkUpO1xuY29uc3QgWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQgPSBXQVNNX0JVRkZFUi5zdWJhcnJheShXQVNNX1hfT05MWV9QVUJMSUNfS0VZX0lOUFVUX1BUUiwgV0FTTV9YX09OTFlfUFVCTElDX0tFWV9JTlBVVF9QVFIgKyB2YWxpZGF0ZS5YX09OTFlfUFVCTElDX0tFWV9TSVpFKTtcbmNvbnN0IFhfT05MWV9QVUJMSUNfS0VZX0lOUFVUMiA9IFdBU01fQlVGRkVSLnN1YmFycmF5KFdBU01fWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQyX1BUUiwgV0FTTV9YX09OTFlfUFVCTElDX0tFWV9JTlBVVDJfUFRSICsgdmFsaWRhdGUuWF9PTkxZX1BVQkxJQ19LRVlfU0laRSk7XG5jb25zdCBUV0VBS19JTlBVVCA9IFdBU01fQlVGRkVSLnN1YmFycmF5KFdBU01fVFdFQUtfSU5QVVRfUFRSLCBXQVNNX1RXRUFLX0lOUFVUX1BUUiArIHZhbGlkYXRlLlRXRUFLX1NJWkUpO1xuY29uc3QgSEFTSF9JTlBVVCA9IFdBU01fQlVGRkVSLnN1YmFycmF5KFdBU01fSEFTSF9JTlBVVF9QVFIsIFdBU01fSEFTSF9JTlBVVF9QVFIgKyB2YWxpZGF0ZS5IQVNIX1NJWkUpO1xuY29uc3QgRVhUUkFfREFUQV9JTlBVVCA9IFdBU01fQlVGRkVSLnN1YmFycmF5KFdBU01fRVhUUkFfREFUQV9JTlBVVF9QVFIsIFdBU01fRVhUUkFfREFUQV9JTlBVVF9QVFIgKyB2YWxpZGF0ZS5FWFRSQV9EQVRBX1NJWkUpO1xuY29uc3QgU0lHTkFUVVJFX0lOUFVUID0gV0FTTV9CVUZGRVIuc3ViYXJyYXkoV0FTTV9TSUdOQVRVUkVfSU5QVVRfUFRSLCBXQVNNX1NJR05BVFVSRV9JTlBVVF9QVFIgKyB2YWxpZGF0ZS5TSUdOQVRVUkVfU0laRSk7XG5mdW5jdGlvbiBhc3N1bWVDb21wcmVzc2lvbihjb21wcmVzc2VkLCBwKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcCAhPT0gdW5kZWZpbmVkID8gcC5sZW5ndGggOiB2YWxpZGF0ZS5QVUJMSUNfS0VZX0NPTVBSRVNTRURfU0laRTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzZWRcbiAgICAgICAgPyB2YWxpZGF0ZS5QVUJMSUNfS0VZX0NPTVBSRVNTRURfU0laRVxuICAgICAgICA6IHZhbGlkYXRlLlBVQkxJQ19LRVlfVU5DT01QUkVTU0VEX1NJWkU7XG59XG5mdW5jdGlvbiBfaXNQb2ludChwKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5zZXQocCk7XG4gICAgICAgIHJldHVybiB3YXNtLmlzUG9pbnQocC5sZW5ndGgpID09PSAxO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5maWxsKDApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfX2luaXRpYWxpemVDb250ZXh0KCkge1xuICAgIHdhc20uaW5pdGlhbGl6ZUNvbnRleHQoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BvaW50KHApIHtcbiAgICByZXR1cm4gdmFsaWRhdGUuaXNERVJQb2ludChwKSAmJiBfaXNQb2ludChwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BvaW50Q29tcHJlc3NlZChwKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlLmlzUG9pbnRDb21wcmVzc2VkKHApICYmIF9pc1BvaW50KHApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWE9ubHlQb2ludChwKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlLmlzWE9ubHlQb2ludChwKSAmJiBfaXNQb2ludChwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaXZhdGUoZCkge1xuICAgIHJldHVybiB2YWxpZGF0ZS5pc1ByaXZhdGUoZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRBZGQocEEsIHBCLCBjb21wcmVzc2VkKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQb2ludChwQSk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQb2ludChwQik7XG4gICAgY29uc3Qgb3V0cHV0bGVuID0gYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCwgcEEpO1xuICAgIHRyeSB7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQuc2V0KHBBKTtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVDIuc2V0KHBCKTtcbiAgICAgICAgcmV0dXJuIHdhc20ucG9pbnRBZGQocEEubGVuZ3RoLCBwQi5sZW5ndGgsIG91dHB1dGxlbikgPT09IDFcbiAgICAgICAgICAgID8gUFVCTElDX0tFWV9JTlBVVC5zbGljZSgwLCBvdXRwdXRsZW4pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBQVUJMSUNfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQyLmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50QWRkU2NhbGFyKHAsIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQb2ludChwKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVR3ZWFrKHR3ZWFrKTtcbiAgICBjb25zdCBvdXRwdXRsZW4gPSBhc3N1bWVDb21wcmVzc2lvbihjb21wcmVzc2VkLCBwKTtcbiAgICB0cnkge1xuICAgICAgICBQVUJMSUNfS0VZX0lOUFVULnNldChwKTtcbiAgICAgICAgVFdFQUtfSU5QVVQuc2V0KHR3ZWFrKTtcbiAgICAgICAgcmV0dXJuIHdhc20ucG9pbnRBZGRTY2FsYXIocC5sZW5ndGgsIG91dHB1dGxlbikgPT09IDFcbiAgICAgICAgICAgID8gUFVCTElDX0tFWV9JTlBVVC5zbGljZSgwLCBvdXRwdXRsZW4pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBQVUJMSUNfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFRXRUFLX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50Q29tcHJlc3MocCwgY29tcHJlc3NlZCkge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUG9pbnQocCk7XG4gICAgY29uc3Qgb3V0cHV0bGVuID0gYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCwgcCk7XG4gICAgdHJ5IHtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5zZXQocCk7XG4gICAgICAgIHdhc20ucG9pbnRDb21wcmVzcyhwLmxlbmd0aCwgb3V0cHV0bGVuKTtcbiAgICAgICAgcmV0dXJuIFBVQkxJQ19LRVlfSU5QVVQuc2xpY2UoMCwgb3V0cHV0bGVuKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRGcm9tU2NhbGFyKGQsIGNvbXByZXNzZWQpIHtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVByaXZhdGUoZCk7XG4gICAgY29uc3Qgb3V0cHV0bGVuID0gYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuc2V0KGQpO1xuICAgICAgICByZXR1cm4gd2FzbS5wb2ludEZyb21TY2FsYXIob3V0cHV0bGVuKSA9PT0gMVxuICAgICAgICAgICAgPyBQVUJMSUNfS0VZX0lOUFVULnNsaWNlKDAsIG91dHB1dGxlbilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIFBSSVZBVEVfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24geE9ubHlQb2ludEZyb21TY2FsYXIoZCkge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB0cnkge1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5zZXQoZCk7XG4gICAgICAgIHdhc20ueE9ubHlQb2ludEZyb21TY2FsYXIoKTtcbiAgICAgICAgcmV0dXJuIFhfT05MWV9QVUJMSUNfS0VZX0lOUFVULnNsaWNlKDAsIHZhbGlkYXRlLlhfT05MWV9QVUJMSUNfS0VZX1NJWkUpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24geE9ubHlQb2ludEZyb21Qb2ludChwKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQb2ludChwKTtcbiAgICB0cnkge1xuICAgICAgICBQVUJMSUNfS0VZX0lOUFVULnNldChwKTtcbiAgICAgICAgd2FzbS54T25seVBvaW50RnJvbVBvaW50KHAubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIFhfT05MWV9QVUJMSUNfS0VZX0lOUFVULnNsaWNlKDAsIHZhbGlkYXRlLlhfT05MWV9QVUJMSUNfS0VZX1NJWkUpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5maWxsKDApO1xuICAgICAgICBYX09OTFlfUFVCTElDX0tFWV9JTlBVVC5maWxsKDApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludE11bHRpcGx5KHAsIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQb2ludChwKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVR3ZWFrKHR3ZWFrKTtcbiAgICBjb25zdCBvdXRwdXRsZW4gPSBhc3N1bWVDb21wcmVzc2lvbihjb21wcmVzc2VkLCBwKTtcbiAgICB0cnkge1xuICAgICAgICBQVUJMSUNfS0VZX0lOUFVULnNldChwKTtcbiAgICAgICAgVFdFQUtfSU5QVVQuc2V0KHR3ZWFrKTtcbiAgICAgICAgcmV0dXJuIHdhc20ucG9pbnRNdWx0aXBseShwLmxlbmd0aCwgb3V0cHV0bGVuKSA9PT0gMVxuICAgICAgICAgICAgPyBQVUJMSUNfS0VZX0lOUFVULnNsaWNlKDAsIG91dHB1dGxlbilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgVFdFQUtfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpdmF0ZUFkZChkLCB0d2Vhaykge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVR3ZWFrKHR3ZWFrKTtcbiAgICB0cnkge1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5zZXQoZCk7XG4gICAgICAgIFRXRUFLX0lOUFVULnNldCh0d2Vhayk7XG4gICAgICAgIHJldHVybiB3YXNtLnByaXZhdGVBZGQoKSA9PT0gMVxuICAgICAgICAgICAgPyBQUklWQVRFX0tFWV9JTlBVVC5zbGljZSgwLCB2YWxpZGF0ZS5QUklWQVRFX0tFWV9TSVpFKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgVFdFQUtfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcHJpdmF0ZVN1YihkLCB0d2Vhaykge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVR3ZWFrKHR3ZWFrKTtcbiAgICAvLyBXZSBjYW4gbm90IHBhc3MgemVybyB0d2VhayB0byBXQVNNLCBiZWNhdXNlIFdBU00gdXNlIGBzZWNwMjU2azFfZWNfc2Vja2V5X25lZ2F0ZWAgZm9yIHR3ZWFrIG5lZ2F0ZS5cbiAgICAvLyAoemVybyBpcyBub3QgdmFsaWQgc2Vja2V5KVxuICAgIGlmICh2YWxpZGF0ZS5pc1plcm8odHdlYWspKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuc2V0KGQpO1xuICAgICAgICBUV0VBS19JTlBVVC5zZXQodHdlYWspO1xuICAgICAgICByZXR1cm4gd2FzbS5wcml2YXRlU3ViKCkgPT09IDFcbiAgICAgICAgICAgID8gUFJJVkFURV9LRVlfSU5QVVQuc2xpY2UoMCwgdmFsaWRhdGUuUFJJVkFURV9LRVlfU0laRSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIFBSSVZBVEVfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFRXRUFLX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHByaXZhdGVOZWdhdGUoZCkge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB0cnkge1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5zZXQoZCk7XG4gICAgICAgIHdhc20ucHJpdmF0ZU5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gUFJJVkFURV9LRVlfSU5QVVQuc2xpY2UoMCwgdmFsaWRhdGUuUFJJVkFURV9LRVlfU0laRSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5maWxsKDApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB4T25seVBvaW50QWRkVHdlYWsocCwgdHdlYWspIHtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVhPbmx5UG9pbnQocCk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVUd2Vhayh0d2Vhayk7XG4gICAgdHJ5IHtcbiAgICAgICAgWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQuc2V0KHApO1xuICAgICAgICBUV0VBS19JTlBVVC5zZXQodHdlYWspO1xuICAgICAgICBjb25zdCBwYXJpdHkgPSB3YXNtLnhPbmx5UG9pbnRBZGRUd2VhaygpO1xuICAgICAgICByZXR1cm4gcGFyaXR5ICE9PSAtMVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcGFyaXR5LFxuICAgICAgICAgICAgICAgIHhPbmx5UHVia2V5OiBYX09OTFlfUFVCTElDX0tFWV9JTlBVVC5zbGljZSgwLCB2YWxpZGF0ZS5YX09OTFlfUFVCTElDX0tFWV9TSVpFKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIFhfT05MWV9QVUJMSUNfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFRXRUFLX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHhPbmx5UG9pbnRBZGRUd2Vha0NoZWNrKHBvaW50LCB0d2VhaywgcmVzdWx0VG9DaGVjaywgdHdlYWtQYXJpdHkpIHtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVhPbmx5UG9pbnQocG9pbnQpO1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlWE9ubHlQb2ludChyZXN1bHRUb0NoZWNrKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVR3ZWFrKHR3ZWFrKTtcbiAgICBjb25zdCBoYXNQYXJpdHkgPSB0d2Vha1Bhcml0eSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChoYXNQYXJpdHkpXG4gICAgICAgIHZhbGlkYXRlLnZhbGlkYXRlUGFyaXR5KHR3ZWFrUGFyaXR5KTtcbiAgICB0cnkge1xuICAgICAgICBYX09OTFlfUFVCTElDX0tFWV9JTlBVVC5zZXQocG9pbnQpO1xuICAgICAgICBYX09OTFlfUFVCTElDX0tFWV9JTlBVVDIuc2V0KHJlc3VsdFRvQ2hlY2spO1xuICAgICAgICBUV0VBS19JTlBVVC5zZXQodHdlYWspO1xuICAgICAgICBpZiAoaGFzUGFyaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gd2FzbS54T25seVBvaW50QWRkVHdlYWtDaGVjayh0d2Vha1Bhcml0eSkgPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXNtLnhPbmx5UG9pbnRBZGRUd2VhaygpO1xuICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQuc2xpY2UoMCwgdmFsaWRhdGUuWF9PTkxZX1BVQkxJQ19LRVlfU0laRSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZShuZXdLZXksIHJlc3VsdFRvQ2hlY2spID09PSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBYX09OTFlfUFVCTElDX0tFWV9JTlBVVC5maWxsKDApO1xuICAgICAgICBYX09OTFlfUFVCTElDX0tFWV9JTlBVVDIuZmlsbCgwKTtcbiAgICAgICAgVFdFQUtfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2lnbihoLCBkLCBlKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVIYXNoKGgpO1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZUV4dHJhRGF0YShlKTtcbiAgICB0cnkge1xuICAgICAgICBIQVNIX0lOUFVULnNldChoKTtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuc2V0KGQpO1xuICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgRVhUUkFfREFUQV9JTlBVVC5zZXQoZSk7XG4gICAgICAgIHdhc20uc2lnbihlID09PSB1bmRlZmluZWQgPyAwIDogMSk7XG4gICAgICAgIHJldHVybiBTSUdOQVRVUkVfSU5QVVQuc2xpY2UoMCwgdmFsaWRhdGUuU0lHTkFUVVJFX1NJWkUpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgSEFTSF9JTlBVVC5maWxsKDApO1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5maWxsKDApO1xuICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgRVhUUkFfREFUQV9JTlBVVC5maWxsKDApO1xuICAgICAgICBTSUdOQVRVUkVfSU5QVVQuZmlsbCgwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2lnblJlY292ZXJhYmxlKGgsIGQsIGUpIHtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZUhhc2goaCk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVQcml2YXRlKGQpO1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlRXh0cmFEYXRhKGUpO1xuICAgIHRyeSB7XG4gICAgICAgIEhBU0hfSU5QVVQuc2V0KGgpO1xuICAgICAgICBQUklWQVRFX0tFWV9JTlBVVC5zZXQoZCk7XG4gICAgICAgIGlmIChlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBFWFRSQV9EQVRBX0lOUFVULnNldChlKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlJZCA9IHdhc20uc2lnblJlY292ZXJhYmxlKGUgPT09IHVuZGVmaW5lZCA/IDAgOiAxKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gU0lHTkFUVVJFX0lOUFVULnNsaWNlKDAsIHZhbGlkYXRlLlNJR05BVFVSRV9TSVpFKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIHJlY292ZXJ5SWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBIQVNIX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFBSSVZBVEVfS0VZX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIGlmIChlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBFWFRSQV9EQVRBX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFNJR05BVFVSRV9JTlBVVC5maWxsKDApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzaWduU2Nobm9ycihoLCBkLCBlKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVIYXNoKGgpO1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUHJpdmF0ZShkKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZUV4dHJhRGF0YShlKTtcbiAgICB0cnkge1xuICAgICAgICBIQVNIX0lOUFVULnNldChoKTtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuc2V0KGQpO1xuICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgRVhUUkFfREFUQV9JTlBVVC5zZXQoZSk7XG4gICAgICAgIHdhc20uc2lnblNjaG5vcnIoZSA9PT0gdW5kZWZpbmVkID8gMCA6IDEpO1xuICAgICAgICByZXR1cm4gU0lHTkFUVVJFX0lOUFVULnNsaWNlKDAsIHZhbGlkYXRlLlNJR05BVFVSRV9TSVpFKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIEhBU0hfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgUFJJVkFURV9LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgaWYgKGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIEVYVFJBX0RBVEFfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgU0lHTkFUVVJFX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShoLCBRLCBzaWduYXR1cmUsIHN0cmljdCA9IGZhbHNlKSB7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVIYXNoKGgpO1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlUG9pbnQoUSk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICB0cnkge1xuICAgICAgICBIQVNIX0lOUFVULnNldChoKTtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5zZXQoUSk7XG4gICAgICAgIFNJR05BVFVSRV9JTlBVVC5zZXQoc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHdhc20udmVyaWZ5KFEubGVuZ3RoLCBzdHJpY3QgPT09IHRydWUgPyAxIDogMCkgPT09IDEgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBIQVNIX0lOUFVULmZpbGwoMCk7XG4gICAgICAgIFBVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgU0lHTkFUVVJFX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXIoaCwgc2lnbmF0dXJlLCByZWNvdmVyeUlkLCBjb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZUhhc2goaCk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVNpZ25hdHVyZU5vbnplcm9SUyhzaWduYXR1cmUpO1xuICAgIGlmIChyZWNvdmVyeUlkICYgMikge1xuICAgICAgICB2YWxpZGF0ZS52YWxpZGF0ZVNpZ3JQTWludXNOKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlLnZhbGlkYXRlU2lnbmF0dXJlQ3VzdG9tKCgpID0+IGlzWE9ubHlQb2ludChzaWduYXR1cmUuc3ViYXJyYXkoMCwgMzIpKSk7XG4gICAgY29uc3Qgb3V0cHV0bGVuID0gYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgSEFTSF9JTlBVVC5zZXQoaCk7XG4gICAgICAgIFNJR05BVFVSRV9JTlBVVC5zZXQoc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHdhc20ucmVjb3ZlcihvdXRwdXRsZW4sIHJlY292ZXJ5SWQpID09PSAxXG4gICAgICAgICAgICA/IFBVQkxJQ19LRVlfSU5QVVQuc2xpY2UoMCwgb3V0cHV0bGVuKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgSEFTSF9JTlBVVC5maWxsKDApO1xuICAgICAgICBTSUdOQVRVUkVfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgUFVCTElDX0tFWV9JTlBVVC5maWxsKDApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTY2hub3JyKGgsIFEsIHNpZ25hdHVyZSkge1xuICAgIHZhbGlkYXRlLnZhbGlkYXRlSGFzaChoKTtcbiAgICB2YWxpZGF0ZS52YWxpZGF0ZVhPbmx5UG9pbnQoUSk7XG4gICAgdmFsaWRhdGUudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICB0cnkge1xuICAgICAgICBIQVNIX0lOUFVULnNldChoKTtcbiAgICAgICAgWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQuc2V0KFEpO1xuICAgICAgICBTSUdOQVRVUkVfSU5QVVQuc2V0KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB3YXNtLnZlcmlmeVNjaG5vcnIoKSA9PT0gMSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIEhBU0hfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgWF9PTkxZX1BVQkxJQ19LRVlfSU5QVVQuZmlsbCgwKTtcbiAgICAgICAgU0lHTkFUVVJFX0lOUFVULmZpbGwoMCk7XG4gICAgfVxufVxuIiwiZnVuY3Rpb24gZ2V0NFJhbmRvbUJ5dGVzKCkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNyeXB0byBvYmplY3QgaXMgdW5hdmFpbGFibGUuIFRoaXMgbWF5IG9jY3VyIGlmIHlvdXIgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgV2ViIENyeXB0b2dyYXBoeSBBUEkuXCIpO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyBPbmx5IHRvIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgY29udGV4dCBmb3IgcnVzdC1zZWNwMjU2azFcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUludDMyKCkge1xuICAgIGNvbnN0IGFycmF5ID0gZ2V0NFJhbmRvbUJ5dGVzKCk7XG4gICAgcmV0dXJuICgoYXJyYXlbMF0gPDwgKDMgKiA4KSkgK1xuICAgICAgICAoYXJyYXlbMV0gPDwgKDIgKiA4KSkgK1xuICAgICAgICAoYXJyYXlbMl0gPDwgKDEgKiA4KSkgK1xuICAgICAgICBhcnJheVszXSk7XG59XG4iLCJpbXBvcnQgeyBFUlJPUl9CQURfUFJJVkFURSwgRVJST1JfQkFEX1BPSU5ULCBFUlJPUl9CQURfVFdFQUssIHRocm93RXJyb3IsIEVSUk9SX0JBRF9IQVNILCBFUlJPUl9CQURfRVhUUkFfREFUQSwgRVJST1JfQkFEX1NJR05BVFVSRSwgRVJST1JfQkFEX1BBUklUWSwgRVJST1JfQkFEX1JFQ09WRVJZX0lELCB9IGZyb20gXCIuL3ZhbGlkYXRlX2Vycm9yLmpzXCI7XG5leHBvcnQgY29uc3QgUFJJVkFURV9LRVlfU0laRSA9IDMyO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19LRVlfQ09NUFJFU1NFRF9TSVpFID0gMzM7XG5leHBvcnQgY29uc3QgUFVCTElDX0tFWV9VTkNPTVBSRVNTRURfU0laRSA9IDY1O1xuZXhwb3J0IGNvbnN0IFhfT05MWV9QVUJMSUNfS0VZX1NJWkUgPSAzMjtcbmV4cG9ydCBjb25zdCBUV0VBS19TSVpFID0gMzI7XG5leHBvcnQgY29uc3QgSEFTSF9TSVpFID0gMzI7XG5leHBvcnQgY29uc3QgRVhUUkFfREFUQV9TSVpFID0gMzI7XG5leHBvcnQgY29uc3QgU0lHTkFUVVJFX1NJWkUgPSA2NDtcbmNvbnN0IEJOMzJfWkVSTyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbmNvbnN0IEJOMzJfTiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LFxuICAgIDI1NCwgMTg2LCAxNzQsIDIyMCwgMjMwLCAxNzUsIDcyLCAxNjAsIDU5LCAxOTEsIDIxMCwgOTQsIDE0MCwgMjA4LCA1NCwgNjUsIDY1LFxuXSk7XG4vLyBEaWZmZXJlbmNlIGJldHdlZW4gZmllbGQgYW5kIG9yZGVyXG5jb25zdCBCTjMyX1BfTUlOVVNfTiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCA2OSwgODEsIDM1LCAyNSwgODAsIDE4MywgOTUsXG4gICAgMTk2LCA2NCwgNDUsIDE2MSwgMTE0LCA0NywgMjAxLCAxODYsIDIzOCxcbl0pO1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmZ1bmN0aW9uIGNtcEJOMzIoZGF0YTEsIGRhdGEyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICAgIGlmIChkYXRhMVtpXSAhPT0gZGF0YTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMVtpXSA8IGRhdGEyW2ldID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWmVybyh4KSB7XG4gICAgcmV0dXJuIGNtcEJOMzIoeCwgQk4zMl9aRVJPKSA9PT0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaXZhdGUoeCkge1xuICAgIHJldHVybiAoaXNVaW50OEFycmF5KHgpICYmXG4gICAgICAgIHgubGVuZ3RoID09PSBQUklWQVRFX0tFWV9TSVpFICYmXG4gICAgICAgIGNtcEJOMzIoeCwgQk4zMl9aRVJPKSA+IDAgJiZcbiAgICAgICAgY21wQk4zMih4LCBCTjMyX04pIDwgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQb2ludChwKSB7XG4gICAgcmV0dXJuIChpc1VpbnQ4QXJyYXkocCkgJiZcbiAgICAgICAgKHAubGVuZ3RoID09PSBQVUJMSUNfS0VZX0NPTVBSRVNTRURfU0laRSB8fFxuICAgICAgICAgICAgcC5sZW5ndGggPT09IFBVQkxJQ19LRVlfVU5DT01QUkVTU0VEX1NJWkUgfHxcbiAgICAgICAgICAgIHAubGVuZ3RoID09PSBYX09OTFlfUFVCTElDX0tFWV9TSVpFKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNYT25seVBvaW50KHApIHtcbiAgICByZXR1cm4gaXNVaW50OEFycmF5KHApICYmIHAubGVuZ3RoID09PSBYX09OTFlfUFVCTElDX0tFWV9TSVpFO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzREVSUG9pbnQocCkge1xuICAgIHJldHVybiAoaXNVaW50OEFycmF5KHApICYmXG4gICAgICAgIChwLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9DT01QUkVTU0VEX1NJWkUgfHxcbiAgICAgICAgICAgIHAubGVuZ3RoID09PSBQVUJMSUNfS0VZX1VOQ09NUFJFU1NFRF9TSVpFKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQb2ludENvbXByZXNzZWQocCkge1xuICAgIHJldHVybiBpc1VpbnQ4QXJyYXkocCkgJiYgcC5sZW5ndGggPT09IFBVQkxJQ19LRVlfQ09NUFJFU1NFRF9TSVpFO1xufVxuZnVuY3Rpb24gaXNUd2Vhayh0d2Vhaykge1xuICAgIHJldHVybiAoaXNVaW50OEFycmF5KHR3ZWFrKSAmJlxuICAgICAgICB0d2Vhay5sZW5ndGggPT09IFRXRUFLX1NJWkUgJiZcbiAgICAgICAgY21wQk4zMih0d2VhaywgQk4zMl9OKSA8IDApO1xufVxuZnVuY3Rpb24gaXNIYXNoKGgpIHtcbiAgICByZXR1cm4gaXNVaW50OEFycmF5KGgpICYmIGgubGVuZ3RoID09PSBIQVNIX1NJWkU7XG59XG5mdW5jdGlvbiBpc0V4dHJhRGF0YShlKSB7XG4gICAgcmV0dXJuIGUgPT09IHVuZGVmaW5lZCB8fCAoaXNVaW50OEFycmF5KGUpICYmIGUubGVuZ3RoID09PSBFWFRSQV9EQVRBX1NJWkUpO1xufVxuZnVuY3Rpb24gaXNTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIChpc1VpbnQ4QXJyYXkoc2lnbmF0dXJlKSAmJlxuICAgICAgICBzaWduYXR1cmUubGVuZ3RoID09PSA2NCAmJlxuICAgICAgICBjbXBCTjMyKHNpZ25hdHVyZS5zdWJhcnJheSgwLCAzMiksIEJOMzJfTikgPCAwICYmXG4gICAgICAgIGNtcEJOMzIoc2lnbmF0dXJlLnN1YmFycmF5KDMyLCA2NCksIEJOMzJfTikgPCAwKTtcbn1cbmZ1bmN0aW9uIGlzU2lnckxlc3NUaGFuUE1pbnVzTihzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gKGlzVWludDhBcnJheShzaWduYXR1cmUpICYmXG4gICAgICAgIHNpZ25hdHVyZS5sZW5ndGggPT09IDY0ICYmXG4gICAgICAgIGNtcEJOMzIoc2lnbmF0dXJlLnN1YmFycmF5KDAsIDMyKSwgQk4zMl9QX01JTlVTX04pIDwgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQYXJpdHkocCkge1xuICAgIGlmIChwICE9PSAwICYmIHAgIT09IDEpXG4gICAgICAgIHRocm93RXJyb3IoRVJST1JfQkFEX1BBUklUWSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlKGQpIHtcbiAgICBpZiAoIWlzUHJpdmF0ZShkKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfUFJJVkFURSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQb2ludChwKSB7XG4gICAgaWYgKCFpc1BvaW50KHApKVxuICAgICAgICB0aHJvd0Vycm9yKEVSUk9SX0JBRF9QT0lOVCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVYT25seVBvaW50KHApIHtcbiAgICBpZiAoIWlzWE9ubHlQb2ludChwKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfUE9JTlQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVHdlYWsodHdlYWspIHtcbiAgICBpZiAoIWlzVHdlYWsodHdlYWspKVxuICAgICAgICB0aHJvd0Vycm9yKEVSUk9SX0JBRF9UV0VBSyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVIYXNoKGgpIHtcbiAgICBpZiAoIWlzSGFzaChoKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfSEFTSCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFeHRyYURhdGEoZSkge1xuICAgIGlmICghaXNFeHRyYURhdGEoZSkpXG4gICAgICAgIHRocm93RXJyb3IoRVJST1JfQkFEX0VYVFJBX0RBVEEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmICghaXNTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfU0lHTkFUVVJFKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNpZ25hdHVyZUN1c3RvbSh2YWxpZGF0b3JGbikge1xuICAgIGlmICghdmFsaWRhdG9yRm4oKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfU0lHTkFUVVJFKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNpZ25hdHVyZU5vbnplcm9SUyhzaWduYXR1cmUpIHtcbiAgICBpZiAoaXNaZXJvKHNpZ25hdHVyZS5zdWJhcnJheSgwLCAzMikpKVxuICAgICAgICB0aHJvd0Vycm9yKEVSUk9SX0JBRF9TSUdOQVRVUkUpO1xuICAgIGlmIChpc1plcm8oc2lnbmF0dXJlLnN1YmFycmF5KDMyLCA2NCkpKVxuICAgICAgICB0aHJvd0Vycm9yKEVSUk9SX0JBRF9TSUdOQVRVUkUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2lnclBNaW51c04oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFpc1NpZ3JMZXNzVGhhblBNaW51c04oc2lnbmF0dXJlKSlcbiAgICAgICAgdGhyb3dFcnJvcihFUlJPUl9CQURfUkVDT1ZFUllfSUQpO1xufVxuIiwiZXhwb3J0IGNvbnN0IEVSUk9SX0JBRF9QUklWQVRFID0gMDtcbmV4cG9ydCBjb25zdCBFUlJPUl9CQURfUE9JTlQgPSAxO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0JBRF9UV0VBSyA9IDI7XG5leHBvcnQgY29uc3QgRVJST1JfQkFEX0hBU0ggPSAzO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0JBRF9TSUdOQVRVUkUgPSA0O1xuZXhwb3J0IGNvbnN0IEVSUk9SX0JBRF9FWFRSQV9EQVRBID0gNTtcbmV4cG9ydCBjb25zdCBFUlJPUl9CQURfUEFSSVRZID0gNjtcbmV4cG9ydCBjb25zdCBFUlJPUl9CQURfUkVDT1ZFUllfSUQgPSA3O1xuY29uc3QgRVJST1JTX01FU1NBR0VTID0ge1xuICAgIFtFUlJPUl9CQURfUFJJVkFURS50b1N0cmluZygpXTogXCJFeHBlY3RlZCBQcml2YXRlXCIsXG4gICAgW0VSUk9SX0JBRF9QT0lOVC50b1N0cmluZygpXTogXCJFeHBlY3RlZCBQb2ludFwiLFxuICAgIFtFUlJPUl9CQURfVFdFQUsudG9TdHJpbmcoKV06IFwiRXhwZWN0ZWQgVHdlYWtcIixcbiAgICBbRVJST1JfQkFEX0hBU0gudG9TdHJpbmcoKV06IFwiRXhwZWN0ZWQgSGFzaFwiLFxuICAgIFtFUlJPUl9CQURfU0lHTkFUVVJFLnRvU3RyaW5nKCldOiBcIkV4cGVjdGVkIFNpZ25hdHVyZVwiLFxuICAgIFtFUlJPUl9CQURfRVhUUkFfREFUQS50b1N0cmluZygpXTogXCJFeHBlY3RlZCBFeHRyYSBEYXRhICgzMiBieXRlcylcIixcbiAgICBbRVJST1JfQkFEX1BBUklUWS50b1N0cmluZygpXTogXCJFeHBlY3RlZCBQYXJpdHkgKDEgfCAwKVwiLFxuICAgIFtFUlJPUl9CQURfUkVDT1ZFUllfSUQudG9TdHJpbmcoKV06IFwiQmFkIFJlY292ZXJ5IElkXCIsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93RXJyb3IoZXJyY29kZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBFUlJPUlNfTUVTU0FHRVNbZXJyY29kZS50b1N0cmluZygpXSB8fCBgVW5rbm93IGVycm9yIGNvZGU6ICR7ZXJyY29kZX1gO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG59XG4iLCIvLyBTdXBwcmVzcyBUUzI3OTI6IENhbm5vdCBmaW5kIG1vZHVsZSAnLi9zZWNwMjU2azEud2FzbScuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyB3YXNtIGZyb20gXCIuL3NlY3AyNTZrMS53YXNtXCI7XG5leHBvcnQgZGVmYXVsdCB3YXNtO1xuIiwiY29uc3QgSEVYX1NUUklOR1MgPSBcIjAxMjM0NTY3ODlhYmNkZWZBQkNERUZcIjtcbmNvbnN0IEhFWF9DT0RFUyA9IEhFWF9TVFJJTkdTLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XG5jb25zdCBIRVhfQ09ERVBPSU5UUyA9IEFycmF5KDI1NilcbiAgICAuZmlsbCh0cnVlKVxuICAgIC5tYXAoKF8sIGkpID0+IHtcbiAgICBjb25zdCBzID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoaSk7XG4gICAgY29uc3QgaW5kZXggPSBIRVhfU1RSSU5HUy5pbmRleE9mKHMpO1xuICAgIC8vIEFCQ0RFRiB3aWxsIHVzZSAxMCAtIDE1XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4IDwgMTYgPyBpbmRleCA6IGluZGV4IC0gNjtcbn0pO1xuY29uc3QgRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgREVDT0RFUiA9IG5ldyBUZXh0RGVjb2RlcihcImFzY2lpXCIpO1xuLy8gVGhlcmUgYXJlIHR3byBpbXBsZW1lbnRhdGlvbnMuXG4vLyBPbmUgb3B0aW1pemVzIGZvciBsZW5ndGggb2YgdGhlIGJ5dGVzLCBhbmQgdXNlcyBUZXh0RGVjb2Rlci5cbi8vIE9uZSBvcHRpbWl6ZXMgZm9yIGl0ZXJhdGlvbiBjb3VudCwgYW5kIGFwcGVuZHMgc3RyaW5ncy5cbi8vIFRoaXMgcmVtb3ZlcyB0aGUgb3ZlcmhlYWQgb2YgVGV4dERlY29kZXIuXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYnl0ZXMpIHtcbiAgICBjb25zdCBiID0gYnl0ZXMgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICByZXR1cm4gYi5sZW5ndGggPiA1MTIgPyBfdG9IZXhMZW5ndGhQZXJmKGIpIDogX3RvSGV4SXRlclBlcmYoYik7XG59XG5mdW5jdGlvbiBfdG9IZXhJdGVyUGVyZihieXRlcykge1xuICAgIGxldCBzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHMgKz0gSEVYX1NUUklOR1NbSEVYX0NPREVQT0lOVFNbSEVYX0NPREVTW2J5dGVzW2ldID4+IDRdXV07XG4gICAgICAgIHMgKz0gSEVYX1NUUklOR1NbSEVYX0NPREVQT0lOVFNbSEVYX0NPREVTW2J5dGVzW2ldICYgMTVdXV07XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gX3RvSGV4TGVuZ3RoUGVyZihieXRlcykge1xuICAgIGNvbnN0IGhleEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBoZXhCeXRlc1tpICogMl0gPSBIRVhfQ09ERVNbYnl0ZXNbaV0gPj4gNF07XG4gICAgICAgIGhleEJ5dGVzW2kgKiAyICsgMV0gPSBIRVhfQ09ERVNbYnl0ZXNbaV0gJiAxNV07XG4gICAgfVxuICAgIHJldHVybiBERUNPREVSLmRlY29kZShoZXhCeXRlcyk7XG59XG4vLyBNaW1pY3MgQnVmZmVyLmZyb20oeCwgJ2hleCcpIGxvZ2ljXG4vLyBTdG9wcyBvbiBmaXJzdCBub24taGV4IHN0cmluZyBhbmQgcmV0dXJuc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE4LjEvc3JjL3N0cmluZ19ieXRlcy5jYyNMMjQ2LUwyNjFcbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleFN0cmluZykge1xuICAgIGNvbnN0IGhleEJ5dGVzID0gRU5DT0RFUi5lbmNvZGUoaGV4U3RyaW5nIHx8IFwiXCIpO1xuICAgIGNvbnN0IHJlc3VsdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5mbG9vcihoZXhCeXRlcy5sZW5ndGggLyAyKSk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdEJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBIRVhfQ09ERVBPSU5UU1toZXhCeXRlc1tpICogMl1dO1xuICAgICAgICBjb25zdCBiID0gSEVYX0NPREVQT0lOVFNbaGV4Qnl0ZXNbaSAqIDIgKyAxXV07XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRCeXRlc1tpXSA9IChhIDw8IDQpIHwgYjtcbiAgICB9XG4gICAgcmV0dXJuIGkgPT09IHJlc3VsdEJ5dGVzLmxlbmd0aCA/IHJlc3VsdEJ5dGVzIDogcmVzdWx0Qnl0ZXMuc2xpY2UoMCwgaSk7XG59XG4vLyBTYW1lIGJlaGF2aW9yIGFzIEJ1ZmZlci5jb21wYXJlKClcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKHYxLCB2Mikge1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbkxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh2MVtpXSAhPT0gdjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB2MVtpXSA8IHYyW2ldID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2MS5sZW5ndGggPT09IHYyLmxlbmd0aCA/IDAgOiB2MS5sZW5ndGggPiB2Mi5sZW5ndGggPyAxIDogLTE7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwidmFyIHdlYnBhY2tRdWV1ZXMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIHF1ZXVlc1wiKSA6IFwiX193ZWJwYWNrX3F1ZXVlc19fXCI7XG52YXIgd2VicGFja0V4cG9ydHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIGV4cG9ydHNcIikgOiBcIl9fd2VicGFja19leHBvcnRzX19cIjtcbnZhciB3ZWJwYWNrRXJyb3IgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIGVycm9yXCIpIDogXCJfX3dlYnBhY2tfZXJyb3JfX1wiO1xudmFyIHJlc29sdmVRdWV1ZSA9IChxdWV1ZSkgPT4ge1xuXHRpZihxdWV1ZSAmJiBxdWV1ZS5kIDwgMSkge1xuXHRcdHF1ZXVlLmQgPSAxO1xuXHRcdHF1ZXVlLmZvckVhY2goKGZuKSA9PiAoZm4uci0tKSk7XG5cdFx0cXVldWUuZm9yRWFjaCgoZm4pID0+IChmbi5yLS0gPyBmbi5yKysgOiBmbigpKSk7XG5cdH1cbn1cbnZhciB3cmFwRGVwcyA9IChkZXBzKSA9PiAoZGVwcy5tYXAoKGRlcCkgPT4ge1xuXHRpZihkZXAgIT09IG51bGwgJiYgdHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmKGRlcFt3ZWJwYWNrUXVldWVzXSkgcmV0dXJuIGRlcDtcblx0XHRpZihkZXAudGhlbikge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRxdWV1ZS5kID0gMDtcblx0XHRcdGRlcC50aGVuKChyKSA9PiB7XG5cdFx0XHRcdG9ialt3ZWJwYWNrRXhwb3J0c10gPSByO1xuXHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuXHRcdFx0fSwgKGUpID0+IHtcblx0XHRcdFx0b2JqW3dlYnBhY2tFcnJvcl0gPSBlO1xuXHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuXHRcdFx0fSk7XG5cdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRvYmpbd2VicGFja1F1ZXVlc10gPSAoZm4pID0+IChmbihxdWV1ZSkpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdH1cblx0dmFyIHJldCA9IHt9O1xuXHRyZXRbd2VicGFja1F1ZXVlc10gPSB4ID0+IHt9O1xuXHRyZXRbd2VicGFja0V4cG9ydHNdID0gZGVwO1xuXHRyZXR1cm4gcmV0O1xufSkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5hID0gKG1vZHVsZSwgYm9keSwgaGFzQXdhaXQpID0+IHtcblx0dmFyIHF1ZXVlO1xuXHRoYXNBd2FpdCAmJiAoKHF1ZXVlID0gW10pLmQgPSAtMSk7XG5cdHZhciBkZXBRdWV1ZXMgPSBuZXcgU2V0KCk7XG5cdHZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG5cdHZhciBjdXJyZW50RGVwcztcblx0dmFyIG91dGVyUmVzb2x2ZTtcblx0dmFyIHJlamVjdDtcblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqKSA9PiB7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHRcdG91dGVyUmVzb2x2ZSA9IHJlc29sdmU7XG5cdH0pO1xuXHRwcm9taXNlW3dlYnBhY2tFeHBvcnRzXSA9IGV4cG9ydHM7XG5cdHByb21pc2Vbd2VicGFja1F1ZXVlc10gPSAoZm4pID0+IChxdWV1ZSAmJiBmbihxdWV1ZSksIGRlcFF1ZXVlcy5mb3JFYWNoKGZuKSwgcHJvbWlzZVtcImNhdGNoXCJdKHggPT4ge30pKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBwcm9taXNlO1xuXHRib2R5KChkZXBzKSA9PiB7XG5cdFx0Y3VycmVudERlcHMgPSB3cmFwRGVwcyhkZXBzKTtcblx0XHR2YXIgZm47XG5cdFx0dmFyIGdldFJlc3VsdCA9ICgpID0+IChjdXJyZW50RGVwcy5tYXAoKGQpID0+IHtcblx0XHRcdGlmKGRbd2VicGFja0Vycm9yXSkgdGhyb3cgZFt3ZWJwYWNrRXJyb3JdO1xuXHRcdFx0cmV0dXJuIGRbd2VicGFja0V4cG9ydHNdO1xuXHRcdH0pKVxuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGZuID0gKCkgPT4gKHJlc29sdmUoZ2V0UmVzdWx0KSk7XG5cdFx0XHRmbi5yID0gMDtcblx0XHRcdHZhciBmblF1ZXVlID0gKHEpID0+IChxICE9PSBxdWV1ZSAmJiAhZGVwUXVldWVzLmhhcyhxKSAmJiAoZGVwUXVldWVzLmFkZChxKSwgcSAmJiAhcS5kICYmIChmbi5yKyssIHEucHVzaChmbikpKSk7XG5cdFx0XHRjdXJyZW50RGVwcy5tYXAoKGRlcCkgPT4gKGRlcFt3ZWJwYWNrUXVldWVzXShmblF1ZXVlKSkpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBmbi5yID8gcHJvbWlzZSA6IGdldFJlc3VsdCgpO1xuXHR9LCAoZXJyKSA9PiAoKGVyciA/IHJlamVjdChwcm9taXNlW3dlYnBhY2tFcnJvcl0gPSBlcnIpIDogb3V0ZXJSZXNvbHZlKGV4cG9ydHMpKSwgcmVzb2x2ZVF1ZXVlKHF1ZXVlKSkpO1xuXHRxdWV1ZSAmJiBxdWV1ZS5kIDwgMCAmJiAocXVldWUuZCA9IDApO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnYgPSAoZXhwb3J0cywgd2FzbU1vZHVsZUlkLCB3YXNtTW9kdWxlSGFzaCwgaW1wb3J0c09iaikgPT4ge1xuXHR2YXIgcmVxID0gZmV0Y2goX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIHdhc21Nb2R1bGVIYXNoICsgXCIubW9kdWxlLndhc21cIik7XG5cdGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVxLCBpbXBvcnRzT2JqKVxuXHRcdFx0LnRoZW4oKHJlcykgPT4gKE9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVzLmluc3RhbmNlLmV4cG9ydHMpKSk7XG5cdH1cblx0cmV0dXJuIHJlcVxuXHRcdC50aGVuKCh4KSA9PiAoeC5hcnJheUJ1ZmZlcigpKSlcblx0XHQudGhlbigoYnl0ZXMpID0+IChXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0c09iaikpKVxuXHRcdC50aGVuKChyZXMpID0+IChPYmplY3QuYXNzaWduKGV4cG9ydHMsIHJlcy5pbnN0YW5jZS5leHBvcnRzKSkpO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICFzY3JpcHRVcmwpIHNjcmlwdFVybCA9IHNjcmlwdHNbaS0tXS5zcmM7XG5cdFx0fVxuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2FwcC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==